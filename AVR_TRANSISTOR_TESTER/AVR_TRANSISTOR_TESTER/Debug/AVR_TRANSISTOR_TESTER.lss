
AVR_TRANSISTOR_TESTER.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00005530  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000520a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000a0  00800100  00800100  0000529e  2**0
                  ALLOC
  3 .eeprom       00000292  00810000  00810000  0000529e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .comment      00000030  00000000  00000000  00005530  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00005560  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 000003d8  00000000  00000000  000055a0  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000851e  00000000  00000000  00005978  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001728  00000000  00000000  0000de96  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00001feb  00000000  00000000  0000f5be  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000fa0  00000000  00000000  000115ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00000f9f  00000000  00000000  0001254c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000074ca  00000000  00000000  000134eb  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000348  00000000  00000000  0001a9b5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 57 00 	jmp	0xae	; 0xae <__ctors_end>
       4:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
       8:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
       c:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      10:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      14:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      18:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      1c:	0c 94 49 17 	jmp	0x2e92	; 0x2e92 <__vector_7>
      20:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      24:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      28:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      2c:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      30:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      34:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      38:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      3c:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      40:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      44:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      48:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      4c:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      50:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      54:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      58:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      5c:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      60:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      64:	0c 94 69 00 	jmp	0xd2	; 0xd2 <__bad_interrupt>
      68:	e0 16       	cp	r14, r16
      6a:	fb 16       	cp	r15, r27
      6c:	fb 16       	cp	r15, r27
      6e:	fb 16       	cp	r15, r27
      70:	fb 16       	cp	r15, r27
      72:	fb 16       	cp	r15, r27
      74:	fb 16       	cp	r15, r27
      76:	fb 16       	cp	r15, r27
      78:	fb 16       	cp	r15, r27
      7a:	f5 16       	cp	r15, r21
      7c:	f8 16       	cp	r15, r24
      7e:	fb 16       	cp	r15, r27
      80:	fb 16       	cp	r15, r27
      82:	fb 16       	cp	r15, r27
      84:	fb 16       	cp	r15, r27
      86:	fb 16       	cp	r15, r27
      88:	fb 16       	cp	r15, r27
      8a:	fb 16       	cp	r15, r27
      8c:	fb 16       	cp	r15, r27
      8e:	e3 16       	cp	r14, r19
      90:	e6 16       	cp	r14, r22
      92:	e9 16       	cp	r14, r25
      94:	ec 16       	cp	r14, r28
      96:	f2 16       	cp	r15, r18
      98:	ef 16       	cp	r14, r31
      9a:	c0 27       	eor	r28, r16
      9c:	c4 27       	eor	r28, r20
      9e:	c8 27       	eor	r28, r24
      a0:	cb 27       	eor	r28, r27
      a2:	ce 27       	eor	r28, r30
      a4:	ec 27       	eor	r30, r28
      a6:	ec 27       	eor	r30, r28
      a8:	e6 27       	eor	r30, r22
      aa:	ec 27       	eor	r30, r28
      ac:	e9 27       	eor	r30, r25

000000ae <__ctors_end>:
      ae:	11 24       	eor	r1, r1
      b0:	1f be       	out	0x3f, r1	; 63
      b2:	cf ef       	ldi	r28, 0xFF	; 255
      b4:	d8 e0       	ldi	r29, 0x08	; 8
      b6:	de bf       	out	0x3e, r29	; 62
      b8:	cd bf       	out	0x3d, r28	; 61

000000ba <__do_clear_bss>:
      ba:	21 e0       	ldi	r18, 0x01	; 1
      bc:	a0 e0       	ldi	r26, 0x00	; 0
      be:	b1 e0       	ldi	r27, 0x01	; 1
      c0:	01 c0       	rjmp	.+2      	; 0xc4 <.do_clear_bss_start>

000000c2 <.do_clear_bss_loop>:
      c2:	1d 92       	st	X+, r1

000000c4 <.do_clear_bss_start>:
      c4:	a0 3a       	cpi	r26, 0xA0	; 160
      c6:	b2 07       	cpc	r27, r18
      c8:	e1 f7       	brne	.-8      	; 0xc2 <.do_clear_bss_loop>
      ca:	0e 94 84 15 	call	0x2b08	; 0x2b08 <main>
      ce:	0c 94 03 29 	jmp	0x5206	; 0x5206 <_exit>

000000d2 <__bad_interrupt>:
      d2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000d6 <wait5s>:
/*
 *  20탎 and up (clock rate independent)
 */

wait5s:
 rcall wait1s		;1s	12+x return addresses
      d6:	03 d0       	rcall	.+6      	; 0xde <wait1000ms>

000000d8 <wait4s>:
;proceed with wait4s	;+4s

wait4s:
 rcall wait1s		;1s	12+x return addresses
      d8:	02 d0       	rcall	.+4      	; 0xde <wait1000ms>

000000da <wait3s>:
;proceed with wait3s	;+3s

wait3s:
 rcall wait1s		;1s	12+x return addresses
      da:	01 d0       	rcall	.+2      	; 0xde <wait1000ms>

000000dc <wait2s>:
;proceed with wait2s	;+2s

wait2s:
 rcall wait1s		;1s     12+x return addresses
      dc:	00 d0       	rcall	.+0      	; 0xde <wait1000ms>

000000de <wait1000ms>:
;proceed with wait1s	;+1s

wait1s:
wait1000ms:	
 rcall wait500ms	;500ms	11+x return addresses
      de:	00 d0       	rcall	.+0      	; 0xe0 <wait500ms>

000000e0 <wait500ms>:
;proceed with wait500ms	;+500ms	

wait500ms:
 rcall wait100ms	;100ms	10+x return addresses
      e0:	03 d0       	rcall	.+6      	; 0xe8 <wait100ms>

000000e2 <wait400ms>:
;proceed with wait400ms	;+400ms

wait400ms:
 rcall wait100ms	;100ms	10+x return addresses
      e2:	02 d0       	rcall	.+4      	; 0xe8 <wait100ms>

000000e4 <wait300ms>:
;proceed with wait300ms	;+300ms

wait300ms:
 rcall wait100ms        ;100ms	10+x return addresses
      e4:	01 d0       	rcall	.+2      	; 0xe8 <wait100ms>

000000e6 <wait200ms>:
;proceed with wait200ms	;+200ms

wait200ms:
 rcall wait100ms	;100ms	10+x return addresses
      e6:	00 d0       	rcall	.+0      	; 0xe8 <wait100ms>

000000e8 <wait100ms>:
;proceed with wait100ms ;+100ms

wait100ms:
 wdr			;reset watchdog every 100ms!
      e8:	a8 95       	wdr
 rcall wait50ms	    	;50ms	9+x return addresses
      ea:	00 d0       	rcall	.+0      	; 0xec <wait50ms>

000000ec <wait50ms>:
;proceed with wait50ms 	;+50ms

wait50ms:
 rcall wait10ms	    	;10ms	8+x return addresses 
      ec:	03 d0       	rcall	.+6      	; 0xf4 <wait10ms>

000000ee <wait40ms>:
;proceed with wait40ms	;+40ms

wait40ms:
 rcall wait10ms	    	;10ms	8+x return addresses
      ee:	02 d0       	rcall	.+4      	; 0xf4 <wait10ms>

000000f0 <wait30ms>:
;proceed with wait30us 	;+30ms

wait30ms:
 rcall wait10ms	    	;10ms	8+x return addresses
      f0:	01 d0       	rcall	.+2      	; 0xf4 <wait10ms>

000000f2 <wait20ms>:
;proceed with wait20us 	;+20ms

wait20ms:
 rcall wait10ms	    	;10ms	8+x return addresses
      f2:	00 d0       	rcall	.+0      	; 0xf4 <wait10ms>

000000f4 <wait10ms>:
;proceed with wait10ms	;+10ms

wait10ms:
 rcall wait5ms	   	;5ms	7+x return addresses
      f4:	00 d0       	rcall	.+0      	; 0xf6 <wait5ms>

000000f6 <wait5ms>:
;proceed with wait5ms	;+5ms

wait5ms:
 rcall wait1ms	   	;1ms	6+x return addresses
      f6:	03 d0       	rcall	.+6      	; 0xfe <wait1ms>

000000f8 <wait4ms>:
;proceed with wait4ms	;+4ms

wait4ms:
 rcall wait1ms	   	;1ms	6+x return addresses
      f8:	02 d0       	rcall	.+4      	; 0xfe <wait1ms>

000000fa <wait3ms>:
;proceed with wait3ms	;+3ms	

wait3ms:
 rcall wait1ms	   	;1ms	6+x return addresses
      fa:	01 d0       	rcall	.+2      	; 0xfe <wait1ms>

000000fc <wait2ms>:
;proceed with wait2ms	;+2ms

wait2ms:
 rcall wait1ms	   	;1ms	6+x return addresses
      fc:	00 d0       	rcall	.+0      	; 0xfe <wait1ms>

000000fe <wait1ms>:
;proceed with wait1ms	;+1ms

wait1ms:
 rcall wait500us    	;500탎	5+x return addresses
      fe:	00 d0       	rcall	.+0      	; 0x100 <wait500us>

00000100 <wait500us>:
;laeuft in wait500us	;+500탎

wait500us:
 rcall wait100us    	;100탎	4+x return addresses
     100:	03 d0       	rcall	.+6      	; 0x108 <wait100us>

00000102 <wait400us>:
;proceed with wait400us	;+400탎

wait400us:
 rcall wait100us    	;100탎	4+x return addresses
     102:	02 d0       	rcall	.+4      	; 0x108 <wait100us>

00000104 <wait300us>:
;proceed with wait300us	;+300탎

wait300us:
 rcall wait100us    	;100탎	4+x return addresses
     104:	01 d0       	rcall	.+2      	; 0x108 <wait100us>

00000106 <wait200us>:
;proceed with wait200us	;+200탎

wait200us:
 rcall wait100us    	;100탎	4+x return addresses
     106:	00 d0       	rcall	.+0      	; 0x108 <wait100us>

00000108 <wait100us>:
;proceed with wait100us	;+100탎	

wait100us:
 rcall wait50us	    	;50탎	3+x return addresses
     108:	00 d0       	rcall	.+0      	; 0x10a <wait50us>

0000010a <wait50us>:
;proceed with wait50us	;+50탎	

wait50us:
 rcall wait10us     	;10탎	2+x return addresses
     10a:	03 d0       	rcall	.+6      	; 0x112 <wait10us>

0000010c <wait40us>:
;proceed with wait40us	;+40탎

wait40us:
 rcall wait10us     	;10탎	2+x return addresses
     10c:	02 d0       	rcall	.+4      	; 0x112 <wait10us>

0000010e <wait30us>:
;proceed with wait30us	;+30탎

wait30us:
 rcall wait10us     	;10탎	2+x return addresses
     10e:	01 d0       	rcall	.+2      	; 0x112 <wait10us>

00000110 <wait20us>:
;proceed with wait20us	;+20탎

wait20us:
 rcall wait10us		;10탎	2+x return addresses
     110:	00 d0       	rcall	.+0      	; 0x112 <wait10us>

00000112 <wait10us>:
wait500ns:
 nop			;500ns
#endif


 ret
     112:	08 95       	ret

00000114 <ReadU>:
 *           may also include setting of voltage reference
 *
 */

uint16_t ReadU(uint8_t Probe)
{
     114:	5f 92       	push	r5
     116:	6f 92       	push	r6
     118:	7f 92       	push	r7
     11a:	8f 92       	push	r8
     11c:	9f 92       	push	r9
     11e:	af 92       	push	r10
     120:	bf 92       	push	r11
     122:	cf 92       	push	r12
     124:	df 92       	push	r13
     126:	ef 92       	push	r14
     128:	ff 92       	push	r15
     12a:	0f 93       	push	r16
     12c:	1f 93       	push	r17
     12e:	cf 93       	push	r28
     130:	df 93       	push	r29
  uint16_t          U;             /* return value (mV) */
  uint8_t           Counter;       /* loop counter */
  uint32_t          Value;         /* ADC value */

  Probe |= (1 << REFS0);           /* use external buffer cap anyway */
     132:	80 64       	ori	r24, 0x40	; 64
     134:	b8 2e       	mov	r11, r24
                                   /* and AVcc as default */

sample:

  ADMUX = Probe;                   /* set input channel and U reference */
     136:	0f 2e       	mov	r0, r31
     138:	fc e7       	ldi	r31, 0x7C	; 124
     13a:	cf 2e       	mov	r12, r31
     13c:	d1 2c       	mov	r13, r1
     13e:	f0 2d       	mov	r31, r0

  /* if voltage reference has changed run a dummy conversion */
  /* (recommended by datasheet) */
  Counter = Probe & (1 << REFS1);    /* get REFS1 bit flag */
  if (Counter != Config.RefFlag)
     140:	0e e8       	ldi	r16, 0x8E	; 142
     142:	11 e0       	ldi	r17, 0x01	; 1
  {
    wait100us();                     /* time for voltage stabilization */

    ADCSRA |= (1 << ADSC);           /* start conversion */
     144:	ca e7       	ldi	r28, 0x7A	; 122
     146:	d0 e0       	ldi	r29, 0x00	; 0
   *  sample ADC readings
   */

  Value = 0UL;                     /* reset sampling variable */
  Counter = 0;                     /* reset counter */
  while (Counter < Config.Samples) /* take samples */
     148:	61 2c       	mov	r6, r1
     14a:	71 2c       	mov	r7, r1
     14c:	81 2c       	mov	r8, r1
     14e:	91 2c       	mov	r9, r1
     150:	a1 2c       	mov	r10, r1
  {
    ADCSRA |= (1 << ADSC);         /* start conversion */
    while (ADCSRA & (1 << ADSC));  /* wait until conversion is done */

    Value += ADCW;                 /* add ADC reading */
     152:	0f 2e       	mov	r0, r31
     154:	f8 e7       	ldi	r31, 0x78	; 120
     156:	ef 2e       	mov	r14, r31
     158:	f1 2c       	mov	r15, r1
     15a:	f0 2d       	mov	r31, r0
  Probe |= (1 << REFS0);           /* use external buffer cap anyway */
                                   /* and AVcc as default */

sample:

  ADMUX = Probe;                   /* set input channel and U reference */
     15c:	d6 01       	movw	r26, r12
     15e:	bc 92       	st	X, r11

  /* if voltage reference has changed run a dummy conversion */
  /* (recommended by datasheet) */
  Counter = Probe & (1 << REFS1);    /* get REFS1 bit flag */
     160:	bb 2d       	mov	r27, r11
     162:	b0 78       	andi	r27, 0x80	; 128
     164:	5b 2e       	mov	r5, r27
  if (Counter != Config.RefFlag)
     166:	f8 01       	movw	r30, r16
     168:	84 81       	ldd	r24, Z+4	; 0x04
     16a:	8b 17       	cp	r24, r27
     16c:	59 f0       	breq	.+22     	; 0x184 <ReadU+0x70>
  {
    wait100us();                     /* time for voltage stabilization */
     16e:	0e 94 84 00 	call	0x108	; 0x108 <wait100us>

    ADCSRA |= (1 << ADSC);           /* start conversion */
     172:	88 81       	ld	r24, Y
     174:	80 64       	ori	r24, 0x40	; 64
     176:	88 83       	st	Y, r24
    while (ADCSRA & (1 << ADSC));    /* wait until conversion is done */
     178:	88 81       	ld	r24, Y
     17a:	86 fd       	sbrc	r24, 6
     17c:	fd cf       	rjmp	.-6      	; 0x178 <ReadU+0x64>

    Config.RefFlag = Counter;        /* update flag */
     17e:	d8 01       	movw	r26, r16
     180:	14 96       	adiw	r26, 0x04	; 4
     182:	5c 92       	st	X, r5
   *  sample ADC readings
   */

  Value = 0UL;                     /* reset sampling variable */
  Counter = 0;                     /* reset counter */
  while (Counter < Config.Samples) /* take samples */
     184:	d8 01       	movw	r26, r16
     186:	12 96       	adiw	r26, 0x02	; 2
     188:	ec 91       	ld	r30, X
     18a:	ee 23       	and	r30, r30
     18c:	51 f1       	breq	.+84     	; 0x1e2 <ReadU+0xce>
     18e:	46 2d       	mov	r20, r6
     190:	57 2d       	mov	r21, r7
     192:	68 2d       	mov	r22, r8
     194:	79 2d       	mov	r23, r9
     196:	3a 2d       	mov	r19, r10
  {
    ADCSRA |= (1 << ADSC);         /* start conversion */
     198:	98 81       	ld	r25, Y
     19a:	90 64       	ori	r25, 0x40	; 64
     19c:	98 83       	st	Y, r25
    while (ADCSRA & (1 << ADSC));  /* wait until conversion is done */
     19e:	98 81       	ld	r25, Y
     1a0:	96 fd       	sbrc	r25, 6
     1a2:	fd cf       	rjmp	.-6      	; 0x19e <ReadU+0x8a>

    Value += ADCW;                 /* add ADC reading */
     1a4:	f7 01       	movw	r30, r14
     1a6:	80 81       	ld	r24, Z
     1a8:	91 81       	ldd	r25, Z+1	; 0x01
     1aa:	48 0f       	add	r20, r24
     1ac:	59 1f       	adc	r21, r25
     1ae:	61 1d       	adc	r22, r1
     1b0:	71 1d       	adc	r23, r1

    /* auto-switch voltage reference for low readings */
    if ((Counter == 4) &&
     1b2:	34 30       	cpi	r19, 0x04	; 4
     1b4:	79 f4       	brne	.+30     	; 0x1d4 <ReadU+0xc0>
     1b6:	41 15       	cp	r20, r1
     1b8:	f4 e0       	ldi	r31, 0x04	; 4
     1ba:	5f 07       	cpc	r21, r31
     1bc:	58 f4       	brcc	.+22     	; 0x1d4 <ReadU+0xc0>
        ((uint16_t)Value < 1024) &&
     1be:	bb 20       	and	r11, r11
     1c0:	4c f0       	brlt	.+18     	; 0x1d4 <ReadU+0xc0>
        !(Probe & (1 << REFS1)) &&
     1c2:	d8 01       	movw	r26, r16
     1c4:	13 96       	adiw	r26, 0x03	; 3
     1c6:	8c 91       	ld	r24, X
     1c8:	81 30       	cpi	r24, 0x01	; 1
     1ca:	21 f4       	brne	.+8      	; 0x1d4 <ReadU+0xc0>
        (Config.AutoScale == 1))
    {
      Probe |= (1 << REFS1);       /* select internal bandgap reference */
     1cc:	bb 2d       	mov	r27, r11
     1ce:	b0 68       	ori	r27, 0x80	; 128
     1d0:	bb 2e       	mov	r11, r27
      goto sample;                 /* re-run sampling */
     1d2:	c4 cf       	rjmp	.-120    	; 0x15c <ReadU+0x48>
    }

    Counter++;                     /* one less to do */
     1d4:	3f 5f       	subi	r19, 0xFF	; 255
   *  sample ADC readings
   */

  Value = 0UL;                     /* reset sampling variable */
  Counter = 0;                     /* reset counter */
  while (Counter < Config.Samples) /* take samples */
     1d6:	d8 01       	movw	r26, r16
     1d8:	12 96       	adiw	r26, 0x02	; 2
     1da:	ec 91       	ld	r30, X
     1dc:	3e 17       	cp	r19, r30
     1de:	e0 f2       	brcs	.-72     	; 0x198 <ReadU+0x84>
     1e0:	03 c0       	rjmp	.+6      	; 0x1e8 <ReadU+0xd4>
     1e2:	40 e0       	ldi	r20, 0x00	; 0
     1e4:	50 e0       	ldi	r21, 0x00	; 0
     1e6:	ba 01       	movw	r22, r20
   *  convert ADC reading to voltage
   *  - single sample: U = ADC reading * U_ref / 1024
   */

  /* get voltage of reference used */
  if (Probe & (1 << REFS1)) U = Config.Bandgap;   /* bandgap reference */
     1e8:	bb 20       	and	r11, r11
     1ea:	2c f4       	brge	.+10     	; 0x1f6 <ReadU+0xe2>
     1ec:	a0 91 93 01 	lds	r26, 0x0193
     1f0:	b0 91 94 01 	lds	r27, 0x0194
     1f4:	04 c0       	rjmp	.+8      	; 0x1fe <ReadU+0xea>
  else U = Config.Vcc;                            /* Vcc reference */   
     1f6:	a0 91 95 01 	lds	r26, 0x0195
     1fa:	b0 91 96 01 	lds	r27, 0x0196

  /* convert to voltage; */
  Value *= U;                      /* ADC readings * U_ref */
     1fe:	9a 01       	movw	r18, r20
     200:	ab 01       	movw	r20, r22
     202:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
//  Value += 511 * Config.Samples;   /* automagic rounding */
  Value /= 1024;                   /* / 1024 for 10bit ADC */
     206:	05 2e       	mov	r0, r21
     208:	5a e0       	ldi	r21, 0x0A	; 10
     20a:	96 95       	lsr	r25
     20c:	87 95       	ror	r24
     20e:	77 95       	ror	r23
     210:	67 95       	ror	r22
     212:	5a 95       	dec	r21
     214:	d1 f7       	brne	.-12     	; 0x20a <ReadU+0xf6>
     216:	50 2d       	mov	r21, r0

  /* de-sample to get average voltage */
  Value /= Config.Samples;
     218:	2e 2f       	mov	r18, r30
     21a:	30 e0       	ldi	r19, 0x00	; 0
     21c:	40 e0       	ldi	r20, 0x00	; 0
     21e:	50 e0       	ldi	r21, 0x00	; 0
     220:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
  U = (uint16_t)Value;

  return U; 
}
     224:	c9 01       	movw	r24, r18
     226:	df 91       	pop	r29
     228:	cf 91       	pop	r28
     22a:	1f 91       	pop	r17
     22c:	0f 91       	pop	r16
     22e:	ff 90       	pop	r15
     230:	ef 90       	pop	r14
     232:	df 90       	pop	r13
     234:	cf 90       	pop	r12
     236:	bf 90       	pop	r11
     238:	af 90       	pop	r10
     23a:	9f 90       	pop	r9
     23c:	8f 90       	pop	r8
     23e:	7f 90       	pop	r7
     240:	6f 90       	pop	r6
     242:	5f 90       	pop	r5
     244:	08 95       	ret

00000246 <ReadU_5ms>:
 *  wait 5ms and then read ADC
 *  - same as ReadU()
 */

uint16_t ReadU_5ms(uint8_t Probe)
{
     246:	cf 93       	push	r28
     248:	c8 2f       	mov	r28, r24
   wait5ms();       /* wait 5ms */
     24a:	0e 94 7b 00 	call	0xf6	; 0xf6 <wait5ms>

   return (ReadU(Probe));
     24e:	8c 2f       	mov	r24, r28
     250:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
}
     254:	cf 91       	pop	r28
     256:	08 95       	ret

00000258 <ReadU_20ms>:
 *  wait 20ms and then read ADC
 *  - same as ReadU()
 */

uint16_t ReadU_20ms(uint8_t Probe)
{
     258:	cf 93       	push	r28
     25a:	c8 2f       	mov	r28, r24
  wait20ms();       /* wait 20ms */
     25c:	0e 94 79 00 	call	0xf2	; 0xf2 <wait20ms>

  return (ReadU(Probe));
     260:	8c 2f       	mov	r24, r28
     262:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
}
     266:	cf 91       	pop	r28
     268:	08 95       	ret

0000026a <CheckSum>:

uint8_t CheckSum(void)
{
  uint8_t           Checksum;

  Checksum = (uint8_t)Config.RiL;
     26a:	ee e8       	ldi	r30, 0x8E	; 142
     26c:	f1 e0       	ldi	r31, 0x01	; 1
     26e:	91 85       	ldd	r25, Z+9	; 0x09
     270:	83 85       	ldd	r24, Z+11	; 0x0b
     272:	89 0f       	add	r24, r25
     274:	97 85       	ldd	r25, Z+15	; 0x0f
     276:	89 0f       	add	r24, r25
  Checksum += (uint8_t)Config.RiH;
  Checksum += (uint8_t)Config.RZero;
  Checksum += Config.CapZero;
     278:	95 85       	ldd	r25, Z+13	; 0x0d
     27a:	89 0f       	add	r24, r25
  Checksum += (uint8_t)Config.RefOffset;
     27c:	90 89       	ldd	r25, Z+16	; 0x10
     27e:	89 0f       	add	r24, r25
  Checksum += (uint8_t)Config.CompOffset;
     280:	91 89       	ldd	r25, Z+17	; 0x11

  return Checksum;
}
     282:	89 0f       	add	r24, r25
     284:	08 95       	ret

00000286 <SafeAdjust>:
/*
 *  save adjustment values
 */

void SafeAdjust(void)
{
     286:	cf 93       	push	r28
     288:	df 93       	push	r29
  /*
   *  update values stored in EEPROM
   */

  /* Ri of MCU in low mode */
  eeprom_write_word((uint16_t *)&NV_RiL, Config.RiL);
     28a:	ce e8       	ldi	r28, 0x8E	; 142
     28c:	d1 e0       	ldi	r29, 0x01	; 1
     28e:	69 85       	ldd	r22, Y+9	; 0x09
     290:	7a 85       	ldd	r23, Y+10	; 0x0a
     292:	80 e9       	ldi	r24, 0x90	; 144
     294:	92 e0       	ldi	r25, 0x02	; 2
     296:	0e 94 ee 28 	call	0x51dc	; 0x51dc <eeprom_write_word>

  /* Ri of MCU in low mode */
  eeprom_write_word((uint16_t *)&NV_RiH, Config.RiH);
     29a:	6b 85       	ldd	r22, Y+11	; 0x0b
     29c:	7c 85       	ldd	r23, Y+12	; 0x0c
     29e:	8e e8       	ldi	r24, 0x8E	; 142
     2a0:	92 e0       	ldi	r25, 0x02	; 2
     2a2:	0e 94 ee 28 	call	0x51dc	; 0x51dc <eeprom_write_word>

  /* resistance of probe leads */
  eeprom_write_word((uint16_t *)&NV_RZero, Config.RZero);
     2a6:	6d 85       	ldd	r22, Y+13	; 0x0d
     2a8:	7e 85       	ldd	r23, Y+14	; 0x0e
     2aa:	8c e8       	ldi	r24, 0x8C	; 140
     2ac:	92 e0       	ldi	r25, 0x02	; 2
     2ae:	0e 94 ee 28 	call	0x51dc	; 0x51dc <eeprom_write_word>

  /* capacitance offset: PCB + wiring + probe leads */
  eeprom_write_byte((uint8_t *)&NV_CapZero, Config.CapZero);
     2b2:	6f 85       	ldd	r22, Y+15	; 0x0f
     2b4:	8b e8       	ldi	r24, 0x8B	; 139
     2b6:	92 e0       	ldi	r25, 0x02	; 2
     2b8:	0e 94 e0 28 	call	0x51c0	; 0x51c0 <eeprom_write_byte>

  /* voltage offset of bandgap reference */
  eeprom_write_byte((uint8_t *)&NV_RefOffset, (uint8_t)Config.RefOffset);
     2bc:	68 89       	ldd	r22, Y+16	; 0x10
     2be:	8a e8       	ldi	r24, 0x8A	; 138
     2c0:	92 e0       	ldi	r25, 0x02	; 2
     2c2:	0e 94 e0 28 	call	0x51c0	; 0x51c0 <eeprom_write_byte>

  /* voltage offset of analog comparator */
  eeprom_write_byte((uint8_t *)&NV_CompOffset, (uint8_t)Config.CompOffset);
     2c6:	69 89       	ldd	r22, Y+17	; 0x11
     2c8:	89 e8       	ldi	r24, 0x89	; 137
     2ca:	92 e0       	ldi	r25, 0x02	; 2
     2cc:	0e 94 e0 28 	call	0x51c0	; 0x51c0 <eeprom_write_byte>

  /* checksum */
  Checksum = CheckSum();
     2d0:	0e 94 35 01 	call	0x26a	; 0x26a <CheckSum>
  eeprom_write_byte((uint8_t *)&NV_Checksum, Checksum);
     2d4:	68 2f       	mov	r22, r24
     2d6:	88 e8       	ldi	r24, 0x88	; 136
     2d8:	92 e0       	ldi	r25, 0x02	; 2
     2da:	0e 94 e0 28 	call	0x51c0	; 0x51c0 <eeprom_write_byte>
}
     2de:	df 91       	pop	r29
     2e0:	cf 91       	pop	r28
     2e2:	08 95       	ret

000002e4 <LoadAdjust>:
/*
 *  load adjustment values
 */

void LoadAdjust(void)
{
     2e4:	cf 93       	push	r28
     2e6:	df 93       	push	r29
  /*
   *  read stored values from EEPROM
   */

  /* Ri of MCU in low mode */ 
  Config.RiL = eeprom_read_word(&NV_RiL);
     2e8:	80 e9       	ldi	r24, 0x90	; 144
     2ea:	92 e0       	ldi	r25, 0x02	; 2
     2ec:	0e 94 da 28 	call	0x51b4	; 0x51b4 <eeprom_read_word>
     2f0:	ce e8       	ldi	r28, 0x8E	; 142
     2f2:	d1 e0       	ldi	r29, 0x01	; 1
     2f4:	9a 87       	std	Y+10, r25	; 0x0a
     2f6:	89 87       	std	Y+9, r24	; 0x09

  /* Ri of MCU in low mode */
  Config.RiH = eeprom_read_word(&NV_RiH);
     2f8:	8e e8       	ldi	r24, 0x8E	; 142
     2fa:	92 e0       	ldi	r25, 0x02	; 2
     2fc:	0e 94 da 28 	call	0x51b4	; 0x51b4 <eeprom_read_word>
     300:	9c 87       	std	Y+12, r25	; 0x0c
     302:	8b 87       	std	Y+11, r24	; 0x0b

  /* resitance of probe leads */
  Config.RZero = eeprom_read_word(&NV_RZero);
     304:	8c e8       	ldi	r24, 0x8C	; 140
     306:	92 e0       	ldi	r25, 0x02	; 2
     308:	0e 94 da 28 	call	0x51b4	; 0x51b4 <eeprom_read_word>
     30c:	9e 87       	std	Y+14, r25	; 0x0e
     30e:	8d 87       	std	Y+13, r24	; 0x0d

  /* capacitance offset: PCB + wiring + probe leads */
  Config.CapZero = eeprom_read_byte(&NV_CapZero);
     310:	8b e8       	ldi	r24, 0x8B	; 139
     312:	92 e0       	ldi	r25, 0x02	; 2
     314:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <eeprom_read_byte>
     318:	8f 87       	std	Y+15, r24	; 0x0f

  /* voltage offset of bandgap reference */
  Config.RefOffset = (int8_t)eeprom_read_byte((uint8_t *)&NV_RefOffset);
     31a:	8a e8       	ldi	r24, 0x8A	; 138
     31c:	92 e0       	ldi	r25, 0x02	; 2
     31e:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <eeprom_read_byte>
     322:	88 8b       	std	Y+16, r24	; 0x10

  /* voltage offset of analog comparator */
  Config.CompOffset = (int8_t)eeprom_read_byte((uint8_t *)&NV_CompOffset);
     324:	89 e8       	ldi	r24, 0x89	; 137
     326:	92 e0       	ldi	r25, 0x02	; 2
     328:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <eeprom_read_byte>
     32c:	89 8b       	std	Y+17, r24	; 0x11

  /* checksum */
  Checksum = eeprom_read_byte(&NV_Checksum);
     32e:	88 e8       	ldi	r24, 0x88	; 136
     330:	92 e0       	ldi	r25, 0x02	; 2
     332:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <eeprom_read_byte>
     336:	c8 2f       	mov	r28, r24

  /*
   *  check checksum
   */

  Test = CheckSum();
     338:	0e 94 35 01 	call	0x26a	; 0x26a <CheckSum>

  if (Test != Checksum)
     33c:	8c 17       	cp	r24, r28
     33e:	09 f1       	breq	.+66     	; 0x382 <LoadAdjust+0x9e>
  {
    /* tell user */
    LCD_Clear();
     340:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>
    LCD_EEString2(Checksum_str);        /* display: Checksum */
     344:	85 e2       	ldi	r24, 0x25	; 37
     346:	91 e0       	ldi	r25, 0x01	; 1
     348:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
    LCD_EEString(Error_str);            /* display: error! */
     34c:	81 e0       	ldi	r24, 0x01	; 1
     34e:	92 e0       	ldi	r25, 0x02	; 2
     350:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
    MilliSleep(2000);                   /* give user some time to read */
     354:	80 ed       	ldi	r24, 0xD0	; 208
     356:	97 e0       	ldi	r25, 0x07	; 7
     358:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>

    /* set default values */
    Config.RiL = R_MCU_LOW;
     35c:	ee e8       	ldi	r30, 0x8E	; 142
     35e:	f1 e0       	ldi	r31, 0x01	; 1
     360:	88 ec       	ldi	r24, 0xC8	; 200
     362:	90 e0       	ldi	r25, 0x00	; 0
     364:	92 87       	std	Z+10, r25	; 0x0a
     366:	81 87       	std	Z+9, r24	; 0x09
    Config.RiH = R_MCU_HIGH;
     368:	8c ed       	ldi	r24, 0xDC	; 220
     36a:	90 e0       	ldi	r25, 0x00	; 0
     36c:	94 87       	std	Z+12, r25	; 0x0c
     36e:	83 87       	std	Z+11, r24	; 0x0b
    Config.RZero = R_ZERO;
     370:	84 e1       	ldi	r24, 0x14	; 20
     372:	90 e0       	ldi	r25, 0x00	; 0
     374:	96 87       	std	Z+14, r25	; 0x0e
     376:	85 87       	std	Z+13, r24	; 0x0d
    Config.CapZero = C_ZERO;
     378:	8b e2       	ldi	r24, 0x2B	; 43
     37a:	87 87       	std	Z+15, r24	; 0x0f
    Config.RefOffset = UREF_OFFSET;
     37c:	10 8a       	std	Z+16, r1	; 0x10
    Config.CompOffset = COMPARATOR_OFFSET;
     37e:	8f e0       	ldi	r24, 0x0F	; 15
     380:	81 8b       	std	Z+17, r24	; 0x11
  }
}
     382:	df 91       	pop	r29
     384:	cf 91       	pop	r28
     386:	08 95       	ret

00000388 <ShowAdjust>:
/*
 *  show adjustment values and offsets
 */

void ShowAdjust(void)
{
     388:	cf 93       	push	r28
     38a:	df 93       	push	r29
  /* display RiL and RiH */
  LCD_Clear();
     38c:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>
  LCD_EEString2(RiLow_str);             /* display: Ri- */
     390:	83 e5       	ldi	r24, 0x53	; 83
     392:	91 e0       	ldi	r25, 0x01	; 1
     394:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
  DisplayValue(Config.RiL, -1, LCD_CHAR_OMEGA);
     398:	ce e8       	ldi	r28, 0x8E	; 142
     39a:	d1 e0       	ldi	r29, 0x01	; 1
     39c:	69 85       	ldd	r22, Y+9	; 0x09
     39e:	7a 85       	ldd	r23, Y+10	; 0x0a
     3a0:	80 e0       	ldi	r24, 0x00	; 0
     3a2:	90 e0       	ldi	r25, 0x00	; 0
     3a4:	24 ef       	ldi	r18, 0xF4	; 244
     3a6:	4f ef       	ldi	r20, 0xFF	; 255
     3a8:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>

  LCD_Line2();
     3ac:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>
  LCD_EEString2(RiHigh_str);            /* display: Ri+ */
     3b0:	8f e4       	ldi	r24, 0x4F	; 79
     3b2:	91 e0       	ldi	r25, 0x01	; 1
     3b4:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
  DisplayValue(Config.RiH, -1, LCD_CHAR_OMEGA);
     3b8:	6b 85       	ldd	r22, Y+11	; 0x0b
     3ba:	7c 85       	ldd	r23, Y+12	; 0x0c
     3bc:	80 e0       	ldi	r24, 0x00	; 0
     3be:	90 e0       	ldi	r25, 0x00	; 0
     3c0:	24 ef       	ldi	r18, 0xF4	; 244
     3c2:	4f ef       	ldi	r20, 0xFF	; 255
     3c4:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>

  WaitKey();                  /* let the user read */
     3c8:	0e 94 cb 26 	call	0x4d96	; 0x4d96 <WaitKey>

  /* display C-Zero */
  LCD_Clear();
     3cc:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>
  LCD_EEString2(CapOffset_str);              /* display: C0 */
     3d0:	89 e3       	ldi	r24, 0x39	; 57
     3d2:	91 e0       	ldi	r25, 0x01	; 1
     3d4:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
  DisplayValue(Config.CapZero, -12, 'F');    /* display C0 offset */
     3d8:	6f 85       	ldd	r22, Y+15	; 0x0f
     3da:	70 e0       	ldi	r23, 0x00	; 0
     3dc:	80 e0       	ldi	r24, 0x00	; 0
     3de:	90 e0       	ldi	r25, 0x00	; 0
     3e0:	26 e4       	ldi	r18, 0x46	; 70
     3e2:	44 ef       	ldi	r20, 0xF4	; 244
     3e4:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>

  /* display R-Zero */
  LCD_Line2();
     3e8:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>
  LCD_EEString2(ROffset_str);                      /* display: R0 */
     3ec:	86 e3       	ldi	r24, 0x36	; 54
     3ee:	91 e0       	ldi	r25, 0x01	; 1
     3f0:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
  DisplayValue(Config.RZero, -2, LCD_CHAR_OMEGA);  /* display R0 */
     3f4:	6d 85       	ldd	r22, Y+13	; 0x0d
     3f6:	7e 85       	ldd	r23, Y+14	; 0x0e
     3f8:	80 e0       	ldi	r24, 0x00	; 0
     3fa:	90 e0       	ldi	r25, 0x00	; 0
     3fc:	24 ef       	ldi	r18, 0xF4	; 244
     3fe:	4e ef       	ldi	r20, 0xFE	; 254
     400:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>

  WaitKey();                  /* let the user read */
     404:	0e 94 cb 26 	call	0x4d96	; 0x4d96 <WaitKey>

  /* display internal bandgap reference */
  LCD_Clear();
     408:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>
  LCD_EEString2(URef_str);                   /* display: Vref */
     40c:	8f e5       	ldi	r24, 0x5F	; 95
     40e:	91 e0       	ldi	r25, 0x01	; 1
     410:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
  DisplayValue(Config.Bandgap, -3, 'V');     /* display bandgap ref */
     414:	6d 81       	ldd	r22, Y+5	; 0x05
     416:	7e 81       	ldd	r23, Y+6	; 0x06
     418:	80 e0       	ldi	r24, 0x00	; 0
     41a:	90 e0       	ldi	r25, 0x00	; 0
     41c:	26 e5       	ldi	r18, 0x56	; 86
     41e:	4d ef       	ldi	r20, 0xFD	; 253
     420:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>

  /* display Vcc */
  LCD_Line2();
     424:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>
  LCD_EEString2(Vcc_str);                    /* display: Vcc */
     428:	82 e3       	ldi	r24, 0x32	; 50
     42a:	91 e0       	ldi	r25, 0x01	; 1
     42c:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
  DisplayValue(Config.Vcc, -3, 'V');         /* display Vcc */
     430:	6f 81       	ldd	r22, Y+7	; 0x07
     432:	78 85       	ldd	r23, Y+8	; 0x08
     434:	80 e0       	ldi	r24, 0x00	; 0
     436:	90 e0       	ldi	r25, 0x00	; 0
     438:	26 e5       	ldi	r18, 0x56	; 86
     43a:	4d ef       	ldi	r20, 0xFD	; 253
     43c:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>

  WaitKey();                  /* let the user read */
     440:	0e 94 cb 26 	call	0x4d96	; 0x4d96 <WaitKey>

  /* display offset of analog comparator */
  LCD_Clear();
     444:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>
  LCD_EEString2(CompOffset_str);             /* display: AComp */
     448:	8c e2       	ldi	r24, 0x2C	; 44
     44a:	91 e0       	ldi	r25, 0x01	; 1
     44c:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
  DisplaySignedValue(Config.CompOffset, -3, 'V');
     450:	69 89       	ldd	r22, Y+17	; 0x11
     452:	06 2e       	mov	r0, r22
     454:	00 0c       	add	r0, r0
     456:	77 0b       	sbc	r23, r23
     458:	88 0b       	sbc	r24, r24
     45a:	99 0b       	sbc	r25, r25
     45c:	26 e5       	ldi	r18, 0x56	; 86
     45e:	4d ef       	ldi	r20, 0xFD	; 253
     460:	0e 94 2e 26 	call	0x4c5c	; 0x4c5c <DisplaySignedValue>

  WaitKey();                  /* let the user read */
     464:	0e 94 cb 26 	call	0x4d96	; 0x4d96 <WaitKey>
}
     468:	df 91       	pop	r29
     46a:	cf 91       	pop	r28
     46c:	08 95       	ret

0000046e <SelfAdjust>:
 *  - 0 on error
 *  - 1 on success
 */

uint8_t SelfAdjust(void)
{
     46e:	2f 92       	push	r2
     470:	3f 92       	push	r3
     472:	4f 92       	push	r4
     474:	5f 92       	push	r5
     476:	6f 92       	push	r6
     478:	7f 92       	push	r7
     47a:	8f 92       	push	r8
     47c:	9f 92       	push	r9
     47e:	af 92       	push	r10
     480:	bf 92       	push	r11
     482:	cf 92       	push	r12
     484:	df 92       	push	r13
     486:	ef 92       	push	r14
     488:	ff 92       	push	r15
     48a:	0f 93       	push	r16
     48c:	1f 93       	push	r17
     48e:	cf 93       	push	r28
     490:	df 93       	push	r29
     492:	cd b7       	in	r28, 0x3d	; 61
     494:	de b7       	in	r29, 0x3e	; 62
     496:	2c 97       	sbiw	r28, 0x0c	; 12
     498:	0f b6       	in	r0, 0x3f	; 63
     49a:	f8 94       	cli
     49c:	de bf       	out	0x3e, r29	; 62
     49e:	0f be       	out	0x3f, r0	; 63
     4a0:	cd bf       	out	0x3d, r28	; 61
  /*
   *  measurements
   */

  /* make sure all probes are shorted */
  Counter = ShortCircuit(1);
     4a2:	81 e0       	ldi	r24, 0x01	; 1
     4a4:	0e 94 d1 26 	call	0x4da2	; 0x4da2 <ShortCircuit>
  if (Counter == 0) Test = 10;      /* skip adjustment on error */
     4a8:	88 23       	and	r24, r24
     4aa:	09 f4       	brne	.+2      	; 0x4ae <SelfAdjust+0x40>
     4ac:	bd c1       	rjmp	.+890    	; 0x828 <SelfAdjust+0x3ba>
     4ae:	41 2c       	mov	r4, r1
     4b0:	51 2c       	mov	r5, r1
     4b2:	1a 82       	std	Y+2, r1	; 0x02
     4b4:	1c 82       	std	Y+4, r1	; 0x04
     4b6:	1b 82       	std	Y+3, r1	; 0x03
     4b8:	19 82       	std	Y+1, r1	; 0x01
     4ba:	21 2c       	mov	r2, r1
     4bc:	31 2c       	mov	r3, r1
     4be:	b1 2c       	mov	r11, r1
     4c0:	1a 86       	std	Y+10, r1	; 0x0a
     4c2:	19 86       	std	Y+9, r1	; 0x09
     4c4:	18 86       	std	Y+8, r1	; 0x08
     4c6:	c1 2c       	mov	r12, r1
     4c8:	d1 2c       	mov	r13, r1
     4ca:	e1 2c       	mov	r14, r1
     4cc:	f1 2c       	mov	r15, r1
     4ce:	61 2c       	mov	r6, r1
     4d0:	71 2c       	mov	r7, r1
     4d2:	aa 24       	eor	r10, r10
     4d4:	a3 94       	inc	r10
 *  - 0 on error
 *  - 1 on success
 */

uint8_t SelfAdjust(void)
{
     4d6:	01 e0       	ldi	r16, 0x01	; 1
          Val1 = ReadU_5ms(TP1);
          U_RiL += Val1;

          /* TP2: Gnd -- Ri -- probe -- Rl -- Ri -- Vcc */
          ADC_DDR = 1 << TP2;
          R_PORT =  1 << (TP2 * 2);
     4d8:	68 94       	set
     4da:	88 24       	eor	r8, r8
     4dc:	82 f8       	bld	r8, 2
        case 3:     /* internal resistance of MCU in pull-down mode */
          LCD_EEString(RiLow_str);      /* display: Ri- */

          /* TP1:  Gnd -- Ri -- probe -- Rl -- Ri -- Vcc */
          ADC_PORT = 0;
          ADC_DDR = 1 << TP1;
     4de:	10 2f       	mov	r17, r16
          R_DDR = 1 << (TP1 * 2);
          Val1 = ReadU_5ms(TP1);
          U_RiL += Val1;

          /* TP2: Gnd -- Ri -- probe -- Rl -- Ri -- Vcc */
          ADC_DDR = 1 << TP2;
     4e0:	68 94       	set
     4e2:	99 24       	eor	r9, r9
     4e4:	91 f8       	bld	r9, 1

          break;

        case 2:     /* un-short probes */
          ShortCircuit(0);              /* make sure probes are not shorted */
          Counter = 100;                /* skip test */
     4e6:	24 e6       	ldi	r18, 0x64	; 100
     4e8:	2f 83       	std	Y+7, r18	; 0x07
     4ea:	5e 82       	std	Y+6, r5	; 0x06
     4ec:	4d 82       	std	Y+5, r4	; 0x05
     4ee:	4b 2c       	mov	r4, r11
     4f0:	59 2c       	mov	r5, r9
     4f2:	7b c1       	rjmp	.+758    	; 0x7ea <SelfAdjust+0x37c>

    /* repeat each measurement 5 times */
    while (Counter <= 5)
    {
      /* display test number */
      LCD_Clear();
     4f4:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>
      LCD_Data('A');                    /* display: a */
     4f8:	81 e4       	ldi	r24, 0x41	; 65
     4fa:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
      LCD_Data('0' + Test);             /* display number */
     4fe:	89 2d       	mov	r24, r9
     500:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
      LCD_Space();
     504:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>

      /*
       *  tests
       */

      switch (Test)
     508:	3c 85       	ldd	r19, Y+12	; 0x0c
     50a:	33 30       	cpi	r19, 0x03	; 3
     50c:	09 f4       	brne	.+2      	; 0x510 <SelfAdjust+0xa2>
     50e:	4f c0       	rjmp	.+158    	; 0x5ae <SelfAdjust+0x140>
     510:	30 f4       	brcc	.+12     	; 0x51e <SelfAdjust+0xb0>
     512:	31 30       	cpi	r19, 0x01	; 1
     514:	61 f0       	breq	.+24     	; 0x52e <SelfAdjust+0xc0>
     516:	32 30       	cpi	r19, 0x02	; 2
     518:	09 f4       	brne	.+2      	; 0x51c <SelfAdjust+0xae>
     51a:	42 c0       	rjmp	.+132    	; 0x5a0 <SelfAdjust+0x132>
     51c:	1b c1       	rjmp	.+566    	; 0x754 <SelfAdjust+0x2e6>
     51e:	8c 85       	ldd	r24, Y+12	; 0x0c
     520:	84 30       	cpi	r24, 0x04	; 4
     522:	09 f4       	brne	.+2      	; 0x526 <SelfAdjust+0xb8>
     524:	71 c0       	rjmp	.+226    	; 0x608 <SelfAdjust+0x19a>
     526:	85 30       	cpi	r24, 0x05	; 5
     528:	09 f4       	brne	.+2      	; 0x52c <SelfAdjust+0xbe>
     52a:	aa c0       	rjmp	.+340    	; 0x680 <SelfAdjust+0x212>
     52c:	13 c1       	rjmp	.+550    	; 0x754 <SelfAdjust+0x2e6>
      {
        case 1:     /* resistance of probe leads (probes shorted) */
          LCD_EEString2(ROffset_str);   /* display: R0 */
     52e:	86 e3       	ldi	r24, 0x36	; 54
     530:	91 e0       	ldi	r25, 0x01	; 1
     532:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
          LCD_EEString(ProbeComb_str);  /* display: 12 13 23 */          
     536:	8c e3       	ldi	r24, 0x3C	; 60
     538:	91 e0       	ldi	r25, 0x01	; 1
     53a:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
          /*
           *  The resistance is for two probes in series and we expect it to be
           *  smaller than 1.00 Ohms, i.e. 0.50 Ohms for a single probe
           */

          UpdateProbes(TP2, TP1, 0);
     53e:	40 e0       	ldi	r20, 0x00	; 0
     540:	60 e0       	ldi	r22, 0x00	; 0
     542:	81 2f       	mov	r24, r17
     544:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <UpdateProbes>
          Val1 = SmallResistor(0);
     548:	80 e0       	ldi	r24, 0x00	; 0
     54a:	0e 94 55 1a 	call	0x34aa	; 0x34aa <SmallResistor>
     54e:	3c 01       	movw	r6, r24
          if (Val1 < 100)                    /* within limit */
     550:	94 e6       	ldi	r25, 0x64	; 100
     552:	69 16       	cp	r6, r25
     554:	71 04       	cpc	r7, r1
     556:	18 f4       	brcc	.+6      	; 0x55e <SelfAdjust+0xf0>
          {
            RSum += Val1;
     558:	26 0c       	add	r2, r6
     55a:	37 1c       	adc	r3, r7
            RCounter++;
     55c:	43 94       	inc	r4
          }

          UpdateProbes(TP3, TP1, 0);
     55e:	40 e0       	ldi	r20, 0x00	; 0
     560:	60 e0       	ldi	r22, 0x00	; 0
     562:	85 2d       	mov	r24, r5
     564:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <UpdateProbes>
          Val2 = SmallResistor(0);
     568:	80 e0       	ldi	r24, 0x00	; 0
     56a:	0e 94 55 1a 	call	0x34aa	; 0x34aa <SmallResistor>
     56e:	7c 01       	movw	r14, r24
          if (Val2 < 100)                    /* whithin limit */
     570:	84 36       	cpi	r24, 0x64	; 100
     572:	91 05       	cpc	r25, r1
     574:	18 f4       	brcc	.+6      	; 0x57c <SelfAdjust+0x10e>
          {
            RSum += Val2;
     576:	28 0e       	add	r2, r24
     578:	39 1e       	adc	r3, r25
            RCounter++;
     57a:	43 94       	inc	r4
          }

          UpdateProbes(TP3, TP2, 0);
     57c:	40 e0       	ldi	r20, 0x00	; 0
     57e:	61 2f       	mov	r22, r17
     580:	85 2d       	mov	r24, r5
     582:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <UpdateProbes>
          Val3 = SmallResistor(0);
     586:	80 e0       	ldi	r24, 0x00	; 0
     588:	0e 94 55 1a 	call	0x34aa	; 0x34aa <SmallResistor>
     58c:	6c 01       	movw	r12, r24
          if (Val3 < 100)                    /* within limit */
     58e:	84 36       	cpi	r24, 0x64	; 100
     590:	91 05       	cpc	r25, r1
     592:	08 f0       	brcs	.+2      	; 0x596 <SelfAdjust+0x128>
     594:	e1 c0       	rjmp	.+450    	; 0x758 <SelfAdjust+0x2ea>
          {
            RSum += Val3;
     596:	28 0e       	add	r2, r24
     598:	39 1e       	adc	r3, r25
            RCounter++;
     59a:	43 94       	inc	r4
      LCD_Clear();
      LCD_Data('A');                    /* display: a */
      LCD_Data('0' + Test);             /* display number */
      LCD_Space();

      DisplayFlag = 1;        /* display values by default */
     59c:	81 2f       	mov	r24, r17
     59e:	e1 c0       	rjmp	.+450    	; 0x762 <SelfAdjust+0x2f4>
          }

          break;

        case 2:     /* un-short probes */
          ShortCircuit(0);              /* make sure probes are not shorted */
     5a0:	80 e0       	ldi	r24, 0x00	; 0
     5a2:	0e 94 d1 26 	call	0x4da2	; 0x4da2 <ShortCircuit>
          Counter = 100;                /* skip test */
          DisplayFlag = 0;              /* reset display flag */
     5a6:	80 e0       	ldi	r24, 0x00	; 0

          break;

        case 2:     /* un-short probes */
          ShortCircuit(0);              /* make sure probes are not shorted */
          Counter = 100;                /* skip test */
     5a8:	2f 81       	ldd	r18, Y+7	; 0x07
     5aa:	2b 87       	std	Y+11, r18	; 0x0b
          DisplayFlag = 0;              /* reset display flag */
          break;
     5ac:	da c0       	rjmp	.+436    	; 0x762 <SelfAdjust+0x2f4>

        case 3:     /* internal resistance of MCU in pull-down mode */
          LCD_EEString(RiLow_str);      /* display: Ri- */
     5ae:	83 e5       	ldi	r24, 0x53	; 83
     5b0:	91 e0       	ldi	r25, 0x01	; 1
     5b2:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>

          /* TP1:  Gnd -- Ri -- probe -- Rl -- Ri -- Vcc */
          ADC_PORT = 0;
     5b6:	18 b8       	out	0x08, r1	; 8
          ADC_DDR = 1 << TP1;
     5b8:	07 b9       	out	0x07, r16	; 7
          R_PORT = 1 << (TP1 * 2);
     5ba:	05 b9       	out	0x05, r16	; 5
          R_DDR = 1 << (TP1 * 2);
     5bc:	04 b9       	out	0x04, r16	; 4
          Val1 = ReadU_5ms(TP1);
     5be:	80 e0       	ldi	r24, 0x00	; 0
     5c0:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
     5c4:	3c 01       	movw	r6, r24
          U_RiL += Val1;

          /* TP2: Gnd -- Ri -- probe -- Rl -- Ri -- Vcc */
          ADC_DDR = 1 << TP2;
     5c6:	32 e0       	ldi	r19, 0x02	; 2
     5c8:	37 b9       	out	0x07, r19	; 7
          R_PORT =  1 << (TP2 * 2);
     5ca:	85 b8       	out	0x05, r8	; 5
          R_DDR = 1 << (TP2 * 2);
     5cc:	84 b8       	out	0x04, r8	; 4
          Val2 = ReadU_5ms(TP2);
     5ce:	81 2f       	mov	r24, r17
     5d0:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
     5d4:	7c 01       	movw	r14, r24
     5d6:	53 01       	movw	r10, r6
     5d8:	a8 0e       	add	r10, r24
     5da:	b9 1e       	adc	r11, r25
          U_RiL += Val2;
     5dc:	8b 81       	ldd	r24, Y+3	; 0x03
     5de:	9c 81       	ldd	r25, Y+4	; 0x04
     5e0:	a8 0e       	add	r10, r24
     5e2:	b9 1e       	adc	r11, r25

          /* TP3: Gnd -- Ri -- probe -- Rl -- Ri -- Vcc */
          ADC_DDR = 1 << TP3;
     5e4:	87 b8       	out	0x07, r8	; 7
          R_PORT =  1 << (TP3 * 2);
     5e6:	90 e1       	ldi	r25, 0x10	; 16
     5e8:	95 b9       	out	0x05, r25	; 5
          R_DDR = 1 << (TP3 * 2);
     5ea:	94 b9       	out	0x04, r25	; 4
          Val3 = ReadU_5ms(TP3);
     5ec:	85 2d       	mov	r24, r5
     5ee:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
     5f2:	6c 01       	movw	r12, r24
          U_RiL += Val3;
     5f4:	f5 01       	movw	r30, r10
     5f6:	e8 0f       	add	r30, r24
     5f8:	f9 1f       	adc	r31, r25
     5fa:	fc 83       	std	Y+4, r31	; 0x04
     5fc:	eb 83       	std	Y+3, r30	; 0x03

          RiL_Counter += 3;
     5fe:	f9 81       	ldd	r31, Y+1	; 0x01
     600:	fd 5f       	subi	r31, 0xFD	; 253
     602:	f9 83       	std	Y+1, r31	; 0x01
      LCD_Clear();
      LCD_Data('A');                    /* display: a */
      LCD_Data('0' + Test);             /* display number */
      LCD_Space();

      DisplayFlag = 1;        /* display values by default */
     604:	81 2f       	mov	r24, r17
          R_DDR = 1 << (TP3 * 2);
          Val3 = ReadU_5ms(TP3);
          U_RiL += Val3;

          RiL_Counter += 3;
          break;
     606:	ad c0       	rjmp	.+346    	; 0x762 <SelfAdjust+0x2f4>

        case 4:     /* internal resistance of MCU in pull-up mode */
          LCD_EEString(RiHigh_str);     /* display: Ri+ */
     608:	8f e4       	ldi	r24, 0x4F	; 79
     60a:	91 e0       	ldi	r25, 0x01	; 1
     60c:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>

          /* TP1: Gnd -- Ri -- Rl -- probe -- Ri -- Vcc */
          R_PORT = 0;
     610:	15 b8       	out	0x05, r1	; 5
          ADC_PORT = 1 << TP1;
     612:	08 b9       	out	0x08, r16	; 8
          ADC_DDR = 1 << TP1;
     614:	07 b9       	out	0x07, r16	; 7
          R_DDR = 1 << (TP1 * 2);
     616:	04 b9       	out	0x04, r16	; 4
          Val1 = Config.Vcc - ReadU_5ms(TP1);
     618:	60 90 95 01 	lds	r6, 0x0195
     61c:	70 90 96 01 	lds	r7, 0x0196
     620:	80 e0       	ldi	r24, 0x00	; 0
     622:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
     626:	68 1a       	sub	r6, r24
     628:	79 0a       	sbc	r7, r25
          U_RiH += Val1;

          /* TP2: Gnd -- Ri -- Rl -- probe -- Ri -- Vcc */
          ADC_PORT = 1 << TP2;
     62a:	22 e0       	ldi	r18, 0x02	; 2
     62c:	28 b9       	out	0x08, r18	; 8
          ADC_DDR = 1 << TP2;
     62e:	27 b9       	out	0x07, r18	; 7
          R_DDR = 1 << (TP2 * 2);
     630:	84 b8       	out	0x04, r8	; 4
          Val2 = Config.Vcc - ReadU_5ms(TP2);
     632:	e0 90 95 01 	lds	r14, 0x0195
     636:	f0 90 96 01 	lds	r15, 0x0196
     63a:	81 2f       	mov	r24, r17
     63c:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
     640:	e8 1a       	sub	r14, r24
     642:	f9 0a       	sbc	r15, r25
     644:	53 01       	movw	r10, r6
     646:	ae 0c       	add	r10, r14
     648:	bf 1c       	adc	r11, r15
          U_RiH += Val2;
     64a:	8d 81       	ldd	r24, Y+5	; 0x05
     64c:	9e 81       	ldd	r25, Y+6	; 0x06
     64e:	a8 0e       	add	r10, r24
     650:	b9 1e       	adc	r11, r25

          /* TP3: Gnd -- Ri -- Rl -- probe -- Ri -- Vcc */
          ADC_PORT = 1 << TP3;
     652:	88 b8       	out	0x08, r8	; 8
          ADC_DDR = 1 << TP3;
     654:	87 b8       	out	0x07, r8	; 7
          R_DDR = 1 << (TP3 * 2);
     656:	90 e1       	ldi	r25, 0x10	; 16
     658:	94 b9       	out	0x04, r25	; 4
          Val3 = Config.Vcc - ReadU_5ms(TP3);
     65a:	c0 90 95 01 	lds	r12, 0x0195
     65e:	d0 90 96 01 	lds	r13, 0x0196
     662:	85 2d       	mov	r24, r5
     664:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
     668:	c8 1a       	sub	r12, r24
     66a:	d9 0a       	sbc	r13, r25
          U_RiH += Val3;
     66c:	f5 01       	movw	r30, r10
     66e:	ec 0d       	add	r30, r12
     670:	fd 1d       	adc	r31, r13
     672:	fe 83       	std	Y+6, r31	; 0x06
     674:	ed 83       	std	Y+5, r30	; 0x05

          RiH_Counter += 3;
     676:	fa 81       	ldd	r31, Y+2	; 0x02
     678:	fd 5f       	subi	r31, 0xFD	; 253
     67a:	fa 83       	std	Y+2, r31	; 0x02
      LCD_Clear();
      LCD_Data('A');                    /* display: a */
      LCD_Data('0' + Test);             /* display number */
      LCD_Space();

      DisplayFlag = 1;        /* display values by default */
     67c:	81 2f       	mov	r24, r17
          R_DDR = 1 << (TP3 * 2);
          Val3 = Config.Vcc - ReadU_5ms(TP3);
          U_RiH += Val3;

          RiH_Counter += 3;
          break;
     67e:	71 c0       	rjmp	.+226    	; 0x762 <SelfAdjust+0x2f4>

        case 5:     /* capacitance offset (PCB and probe leads) */
          LCD_EEString2(CapOffset_str);   /* display: C0 */
     680:	89 e3       	ldi	r24, 0x39	; 57
     682:	91 e0       	ldi	r25, 0x01	; 1
     684:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
          LCD_EEString(ProbeComb_str);    /* display: 12 13 23 */
     688:	8c e3       	ldi	r24, 0x3C	; 60
     68a:	91 e0       	ldi	r25, 0x01	; 1
     68c:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
          /*
           *  The capacitance is for two probes and we expect it to be
           *  less than 100pF.
           */

          MeasureCap(TP2, TP1, 0);
     690:	40 e0       	ldi	r20, 0x00	; 0
     692:	60 e0       	ldi	r22, 0x00	; 0
     694:	81 2f       	mov	r24, r17
     696:	0e 94 be 09 	call	0x137c	; 0x137c <MeasureCap>
          Val1 = (uint16_t)Caps[0].Raw;
     69a:	80 91 30 01 	lds	r24, 0x0130
     69e:	90 91 31 01 	lds	r25, 0x0131
     6a2:	a0 91 32 01 	lds	r26, 0x0132
     6a6:	b0 91 33 01 	lds	r27, 0x0133
     6aa:	3c 01       	movw	r6, r24
          /* limit offset to 100pF */
          if ((Caps[0].Scale == -12) && (Caps[0].Raw <= 100))
     6ac:	20 91 2b 01 	lds	r18, 0x012B
     6b0:	24 3f       	cpi	r18, 0xF4	; 244
     6b2:	71 f4       	brne	.+28     	; 0x6d0 <SelfAdjust+0x262>
     6b4:	85 36       	cpi	r24, 0x65	; 101
     6b6:	91 05       	cpc	r25, r1
     6b8:	a1 05       	cpc	r26, r1
     6ba:	b1 05       	cpc	r27, r1
     6bc:	48 f4       	brcc	.+18     	; 0x6d0 <SelfAdjust+0x262>
          {
            CapSum += Val1;
     6be:	29 85       	ldd	r18, Y+9	; 0x09
     6c0:	3a 85       	ldd	r19, Y+10	; 0x0a
     6c2:	28 0f       	add	r18, r24
     6c4:	39 1f       	adc	r19, r25
     6c6:	3a 87       	std	Y+10, r19	; 0x0a
     6c8:	29 87       	std	Y+9, r18	; 0x09
            CapCounter++;            
     6ca:	38 85       	ldd	r19, Y+8	; 0x08
     6cc:	3f 5f       	subi	r19, 0xFF	; 255
     6ce:	38 87       	std	Y+8, r19	; 0x08
          }

          MeasureCap(TP3, TP1, 1);
     6d0:	41 2f       	mov	r20, r17
     6d2:	60 e0       	ldi	r22, 0x00	; 0
     6d4:	85 2d       	mov	r24, r5
     6d6:	0e 94 be 09 	call	0x137c	; 0x137c <MeasureCap>
          Val2 = (uint16_t)Caps[1].Raw;
     6da:	80 91 3b 01 	lds	r24, 0x013B
     6de:	90 91 3c 01 	lds	r25, 0x013C
     6e2:	a0 91 3d 01 	lds	r26, 0x013D
     6e6:	b0 91 3e 01 	lds	r27, 0x013E
     6ea:	7c 01       	movw	r14, r24
          /* limit offset to 100pF */
          if ((Caps[1].Scale == -12) && (Caps[1].Raw <= 100))
     6ec:	20 91 36 01 	lds	r18, 0x0136
     6f0:	24 3f       	cpi	r18, 0xF4	; 244
     6f2:	71 f4       	brne	.+28     	; 0x710 <SelfAdjust+0x2a2>
     6f4:	85 36       	cpi	r24, 0x65	; 101
     6f6:	91 05       	cpc	r25, r1
     6f8:	a1 05       	cpc	r26, r1
     6fa:	b1 05       	cpc	r27, r1
     6fc:	48 f4       	brcc	.+18     	; 0x710 <SelfAdjust+0x2a2>
          {
            CapSum += Val2;
     6fe:	e9 85       	ldd	r30, Y+9	; 0x09
     700:	fa 85       	ldd	r31, Y+10	; 0x0a
     702:	e8 0f       	add	r30, r24
     704:	f9 1f       	adc	r31, r25
     706:	fa 87       	std	Y+10, r31	; 0x0a
     708:	e9 87       	std	Y+9, r30	; 0x09
            CapCounter++;            
     70a:	f8 85       	ldd	r31, Y+8	; 0x08
     70c:	ff 5f       	subi	r31, 0xFF	; 255
     70e:	f8 87       	std	Y+8, r31	; 0x08
          }

          MeasureCap(TP3, TP2, 2);
     710:	45 2d       	mov	r20, r5
     712:	61 2f       	mov	r22, r17
     714:	85 2d       	mov	r24, r5
     716:	0e 94 be 09 	call	0x137c	; 0x137c <MeasureCap>
          Val3 = (uint16_t)Caps[2].Raw;
     71a:	80 91 46 01 	lds	r24, 0x0146
     71e:	90 91 47 01 	lds	r25, 0x0147
     722:	a0 91 48 01 	lds	r26, 0x0148
     726:	b0 91 49 01 	lds	r27, 0x0149
     72a:	6c 01       	movw	r12, r24
          /* limit offset to 100pF */
          if ((Caps[2].Scale == -12) && (Caps[2].Raw <= 100))
     72c:	20 91 41 01 	lds	r18, 0x0141
     730:	24 3f       	cpi	r18, 0xF4	; 244
     732:	a1 f4       	brne	.+40     	; 0x75c <SelfAdjust+0x2ee>
     734:	85 36       	cpi	r24, 0x65	; 101
     736:	91 05       	cpc	r25, r1
     738:	a1 05       	cpc	r26, r1
     73a:	b1 05       	cpc	r27, r1
     73c:	88 f4       	brcc	.+34     	; 0x760 <SelfAdjust+0x2f2>
          {
            CapSum += Val3;
     73e:	29 85       	ldd	r18, Y+9	; 0x09
     740:	3a 85       	ldd	r19, Y+10	; 0x0a
     742:	28 0f       	add	r18, r24
     744:	39 1f       	adc	r19, r25
     746:	3a 87       	std	Y+10, r19	; 0x0a
     748:	29 87       	std	Y+9, r18	; 0x09
            CapCounter++;            
     74a:	38 85       	ldd	r19, Y+8	; 0x08
     74c:	3f 5f       	subi	r19, 0xFF	; 255
     74e:	38 87       	std	Y+8, r19	; 0x08
      LCD_Clear();
      LCD_Data('A');                    /* display: a */
      LCD_Data('0' + Test);             /* display number */
      LCD_Space();

      DisplayFlag = 1;        /* display values by default */
     750:	81 2f       	mov	r24, r17
     752:	07 c0       	rjmp	.+14     	; 0x762 <SelfAdjust+0x2f4>
     754:	81 2f       	mov	r24, r17
     756:	05 c0       	rjmp	.+10     	; 0x762 <SelfAdjust+0x2f4>
     758:	81 2f       	mov	r24, r17
     75a:	03 c0       	rjmp	.+6      	; 0x762 <SelfAdjust+0x2f4>
     75c:	81 2f       	mov	r24, r17
     75e:	01 c0       	rjmp	.+2      	; 0x762 <SelfAdjust+0x2f4>
     760:	81 2f       	mov	r24, r17

          break;
      }

      /* reset ports to defaults */
      ADC_DDR = 0;                      /* input mode */
     762:	17 b8       	out	0x07, r1	; 7
      ADC_PORT = 0;                     /* all pins low */
     764:	18 b8       	out	0x08, r1	; 8
      R_DDR = 0;                        /* input mode */
     766:	14 b8       	out	0x04, r1	; 4
      R_PORT = 0;                       /* all pins low */
     768:	15 b8       	out	0x05, r1	; 5

      /* display values */
      if (DisplayFlag)
     76a:	88 23       	and	r24, r24
     76c:	09 f1       	breq	.+66     	; 0x7b0 <SelfAdjust+0x342>
      {
        LCD_Line2();                    /* move to line #2 */
     76e:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>
        DisplayValue(Val1, 0 , 0);      /* display TP1 */
     772:	c3 01       	movw	r24, r6
     774:	a0 e0       	ldi	r26, 0x00	; 0
     776:	b0 e0       	ldi	r27, 0x00	; 0
     778:	20 e0       	ldi	r18, 0x00	; 0
     77a:	40 e0       	ldi	r20, 0x00	; 0
     77c:	bc 01       	movw	r22, r24
     77e:	cd 01       	movw	r24, r26
     780:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
        LCD_Space();
     784:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>
        DisplayValue(Val2, 0 , 0);      /* display TP2 */
     788:	c7 01       	movw	r24, r14
     78a:	a0 e0       	ldi	r26, 0x00	; 0
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	20 e0       	ldi	r18, 0x00	; 0
     790:	40 e0       	ldi	r20, 0x00	; 0
     792:	bc 01       	movw	r22, r24
     794:	cd 01       	movw	r24, r26
     796:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
        LCD_Space();
     79a:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>
        DisplayValue(Val3, 0 , 0);      /* display TP3 */
     79e:	c6 01       	movw	r24, r12
     7a0:	a0 e0       	ldi	r26, 0x00	; 0
     7a2:	b0 e0       	ldi	r27, 0x00	; 0
     7a4:	20 e0       	ldi	r18, 0x00	; 0
     7a6:	40 e0       	ldi	r20, 0x00	; 0
     7a8:	bc 01       	movw	r22, r24
     7aa:	cd 01       	movw	r24, r26
     7ac:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
      }

      /* wait and check test push button */
      if (Counter < 100)                     /* when we don't skip this test */
     7b0:	8b 85       	ldd	r24, Y+11	; 0x0b
     7b2:	84 36       	cpi	r24, 0x64	; 100
     7b4:	78 f4       	brcc	.+30     	; 0x7d4 <SelfAdjust+0x366>
      {
        DisplayFlag = TestKey(1000, 0);      /* catch key press or timeout */
     7b6:	60 e0       	ldi	r22, 0x00	; 0
     7b8:	88 ee       	ldi	r24, 0xE8	; 232
     7ba:	93 e0       	ldi	r25, 0x03	; 3
     7bc:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <TestKey>

        /* short press -> next test / long press -> end selftest */
        if (DisplayFlag > 0)
     7c0:	88 23       	and	r24, r24
     7c2:	41 f0       	breq	.+16     	; 0x7d4 <SelfAdjust+0x366>
     7c4:	ac 84       	ldd	r10, Y+12	; 0x0c
        {
          Counter = 100;                       /* skip current test anyway */
          if (DisplayFlag == 2) Test = 100;    /* also skip selftest */
     7c6:	82 30       	cpi	r24, 0x02	; 2
     7c8:	61 f4       	brne	.+24     	; 0x7e2 <SelfAdjust+0x374>
     7ca:	0f 2e       	mov	r0, r31
     7cc:	f4 e6       	ldi	r31, 0x64	; 100
     7ce:	af 2e       	mov	r10, r31
     7d0:	f0 2d       	mov	r31, r0
     7d2:	07 c0       	rjmp	.+14     	; 0x7e2 <SelfAdjust+0x374>
        } 
      }
 
      Counter++;                        /* next run */
     7d4:	9b 85       	ldd	r25, Y+11	; 0x0b
     7d6:	9f 5f       	subi	r25, 0xFF	; 255
     7d8:	9b 87       	std	Y+11, r25	; 0x0b
  while (Test <= 5)      /* loop through tests */
  {
    Counter = 1;

    /* repeat each measurement 5 times */
    while (Counter <= 5)
     7da:	96 30       	cpi	r25, 0x06	; 6
     7dc:	08 f4       	brcc	.+2      	; 0x7e0 <SelfAdjust+0x372>
     7de:	8a ce       	rjmp	.-748    	; 0x4f4 <SelfAdjust+0x86>
     7e0:	ac 84       	ldd	r10, Y+12	; 0x0c
      }
 
      Counter++;                        /* next run */
    }

    Test++;                             /* next one */
     7e2:	a3 94       	inc	r10

  /* make sure all probes are shorted */
  Counter = ShortCircuit(1);
  if (Counter == 0) Test = 10;      /* skip adjustment on error */

  while (Test <= 5)      /* loop through tests */
     7e4:	e5 e0       	ldi	r30, 0x05	; 5
     7e6:	ea 15       	cp	r30, r10
     7e8:	40 f0       	brcs	.+16     	; 0x7fa <SelfAdjust+0x38c>
    while (Counter <= 5)
    {
      /* display test number */
      LCD_Clear();
      LCD_Data('A');                    /* display: a */
      LCD_Data('0' + Test);             /* display number */
     7ea:	0f 2e       	mov	r0, r31
     7ec:	f0 e3       	ldi	r31, 0x30	; 48
     7ee:	9f 2e       	mov	r9, r31
     7f0:	f0 2d       	mov	r31, r0
     7f2:	9a 0c       	add	r9, r10
     7f4:	ac 86       	std	Y+12, r10	; 0x0c
     7f6:	0b 87       	std	Y+11, r16	; 0x0b
     7f8:	7d ce       	rjmp	.-774    	; 0x4f4 <SelfAdjust+0x86>
     7fa:	b4 2c       	mov	r11, r4
     7fc:	4d 80       	ldd	r4, Y+5	; 0x05
     7fe:	5e 80       	ldd	r5, Y+6	; 0x06
  /*
   *  calculate values and offsets
   */

  /* capacitance auto-zero: calculate average value for all probe pairs */
  if (CapCounter == 15)
     800:	f8 85       	ldd	r31, Y+8	; 0x08
     802:	ff 30       	cpi	r31, 0x0F	; 15
     804:	e1 f4       	brne	.+56     	; 0x83e <SelfAdjust+0x3d0>
  {
    /* calculate average offset (pF) */
    Config.CapZero = CapSum / CapCounter;
     806:	29 85       	ldd	r18, Y+9	; 0x09
     808:	3a 85       	ldd	r19, Y+10	; 0x0a
     80a:	a9 e8       	ldi	r26, 0x89	; 137
     80c:	b8 e8       	ldi	r27, 0x88	; 136
     80e:	0e 94 87 28 	call	0x510e	; 0x510e <__umulhisi3>
     812:	96 95       	lsr	r25
     814:	87 95       	ror	r24
     816:	96 95       	lsr	r25
     818:	87 95       	ror	r24
     81a:	96 95       	lsr	r25
     81c:	87 95       	ror	r24
     81e:	80 93 9d 01 	sts	0x019D, r24
    Flag++;
     822:	aa 24       	eor	r10, r10
     824:	a3 94       	inc	r10
     826:	0c c0       	rjmp	.+24     	; 0x840 <SelfAdjust+0x3d2>
     828:	41 2c       	mov	r4, r1
     82a:	51 2c       	mov	r5, r1
     82c:	1a 82       	std	Y+2, r1	; 0x02
     82e:	1c 82       	std	Y+4, r1	; 0x04
     830:	1b 82       	std	Y+3, r1	; 0x03
     832:	19 82       	std	Y+1, r1	; 0x01
     834:	21 2c       	mov	r2, r1
     836:	31 2c       	mov	r3, r1
     838:	b1 2c       	mov	r11, r1
 *  - 1 on success
 */

uint8_t SelfAdjust(void)
{
  uint8_t           Flag = 0;           /* return value */
     83a:	a1 2c       	mov	r10, r1
     83c:	01 c0       	rjmp	.+2      	; 0x840 <SelfAdjust+0x3d2>
     83e:	a1 2c       	mov	r10, r1
    Config.CapZero = CapSum / CapCounter;
    Flag++;
  }

  /* resistance auto-zero: calculate average value for all probes pairs */
  if (RCounter == 15)
     840:	2f e0       	ldi	r18, 0x0F	; 15
     842:	b2 12       	cpse	r11, r18
     844:	10 c0       	rjmp	.+32     	; 0x866 <SelfAdjust+0x3f8>
  { 
    /* calculate average offset (0.01 Ohms) */
    Config.RZero = RSum / RCounter;
     846:	91 01       	movw	r18, r2
     848:	a9 e8       	ldi	r26, 0x89	; 137
     84a:	b8 e8       	ldi	r27, 0x88	; 136
     84c:	0e 94 87 28 	call	0x510e	; 0x510e <__umulhisi3>
     850:	96 95       	lsr	r25
     852:	87 95       	ror	r24
     854:	96 95       	lsr	r25
     856:	87 95       	ror	r24
     858:	96 95       	lsr	r25
     85a:	87 95       	ror	r24
     85c:	90 93 9c 01 	sts	0x019C, r25
     860:	80 93 9b 01 	sts	0x019B, r24
    Flag++;
     864:	a3 94       	inc	r10
  }

  /* RiL & RiH */
  if ((RiL_Counter == 15) && (RiH_Counter == 15))
     866:	39 81       	ldd	r19, Y+1	; 0x01
     868:	3f 30       	cpi	r19, 0x0F	; 15
     86a:	09 f0       	breq	.+2      	; 0x86e <SelfAdjust+0x400>
     86c:	69 c0       	rjmp	.+210    	; 0x940 <__stack+0x41>
     86e:	8a 81       	ldd	r24, Y+2	; 0x02
     870:	8f 30       	cpi	r24, 0x0F	; 15
     872:	09 f0       	breq	.+2      	; 0x876 <SelfAdjust+0x408>
     874:	65 c0       	rjmp	.+202    	; 0x940 <__stack+0x41>
     *  Ri = Rl * (U_Ri / U_Rl)
     *  - scale up by 100, round up/down and scale down by 10
     */

    /* use values multiplied by 3 to increase accuracy */    
    U_RiL /= 5;                         /* average sum of 3 U_RiL */
     876:	2b 81       	ldd	r18, Y+3	; 0x03
     878:	3c 81       	ldd	r19, Y+4	; 0x04
     87a:	ad ec       	ldi	r26, 0xCD	; 205
     87c:	bc ec       	ldi	r27, 0xCC	; 204
     87e:	0e 94 87 28 	call	0x510e	; 0x510e <__umulhisi3>
     882:	ac 01       	movw	r20, r24
     884:	56 95       	lsr	r21
     886:	47 95       	ror	r20
     888:	56 95       	lsr	r21
     88a:	47 95       	ror	r20
    U_RiH /= 5;                         /* average sum of 3 U_RiH */
     88c:	92 01       	movw	r18, r4
     88e:	0e 94 87 28 	call	0x510e	; 0x510e <__umulhisi3>
     892:	8c 01       	movw	r16, r24
     894:	16 95       	lsr	r17
     896:	07 95       	ror	r16
     898:	16 95       	lsr	r17
     89a:	07 95       	ror	r16
    Val1 = (Config.Vcc * 3) - U_RiL - U_RiH;  /* U_Rl * 3 */
     89c:	20 91 95 01 	lds	r18, 0x0195
     8a0:	30 91 96 01 	lds	r19, 0x0196
     8a4:	69 01       	movw	r12, r18
     8a6:	cc 0c       	add	r12, r12
     8a8:	dd 1c       	adc	r13, r13
     8aa:	c2 0e       	add	r12, r18
     8ac:	d3 1e       	adc	r13, r19
     8ae:	c4 1a       	sub	r12, r20
     8b0:	d5 0a       	sbc	r13, r21
     8b2:	c0 1a       	sub	r12, r16
     8b4:	d1 0a       	sbc	r13, r17

    /* RiL */
    Val0 = ((uint32_t)R_LOW * 100 * U_RiL) / Val1;     /* Rl * U_Ri / U_Rl in 0.01 Ohm */
     8b6:	e1 2c       	mov	r14, r1
     8b8:	f1 2c       	mov	r15, r1
     8ba:	da 01       	movw	r26, r20
     8bc:	20 ea       	ldi	r18, 0xA0	; 160
     8be:	39 e0       	ldi	r19, 0x09	; 9
     8c0:	41 e0       	ldi	r20, 0x01	; 1
     8c2:	50 e0       	ldi	r21, 0x00	; 0
     8c4:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
     8c8:	a7 01       	movw	r20, r14
     8ca:	96 01       	movw	r18, r12
     8cc:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    Val0 += 5;                                         /* for automagic rounding */
     8d0:	ca 01       	movw	r24, r20
     8d2:	b9 01       	movw	r22, r18
     8d4:	6b 5f       	subi	r22, 0xFB	; 251
     8d6:	7f 4f       	sbci	r23, 0xFF	; 255
     8d8:	8f 4f       	sbci	r24, 0xFF	; 255
     8da:	9f 4f       	sbci	r25, 0xFF	; 255
    Val0 /= 10;                                        /* scale down to 0.1 Ohm */
     8dc:	2a e0       	ldi	r18, 0x0A	; 10
     8de:	30 e0       	ldi	r19, 0x00	; 0
     8e0:	40 e0       	ldi	r20, 0x00	; 0
     8e2:	50 e0       	ldi	r21, 0x00	; 0
     8e4:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    if (Val0 < 250UL)         /* < 25 Ohms */
     8e8:	2a 3f       	cpi	r18, 0xFA	; 250
     8ea:	31 05       	cpc	r19, r1
     8ec:	41 05       	cpc	r20, r1
     8ee:	51 05       	cpc	r21, r1
     8f0:	28 f4       	brcc	.+10     	; 0x8fc <SelfAdjust+0x48e>
    {
      Config.RiL = (uint16_t)Val0;
     8f2:	30 93 98 01 	sts	0x0198, r19
     8f6:	20 93 97 01 	sts	0x0197, r18
      Flag++;
     8fa:	a3 94       	inc	r10
    }

    /* RiH */
    Val0 = ((uint32_t)R_LOW * 100 * U_RiH) / Val1;     /* Rl * U_Ri / U_Rl in 0.01 Ohm */
     8fc:	d8 01       	movw	r26, r16
     8fe:	20 ea       	ldi	r18, 0xA0	; 160
     900:	39 e0       	ldi	r19, 0x09	; 9
     902:	41 e0       	ldi	r20, 0x01	; 1
     904:	50 e0       	ldi	r21, 0x00	; 0
     906:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
     90a:	a7 01       	movw	r20, r14
     90c:	96 01       	movw	r18, r12
     90e:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    Val0 += 5;                                         /* for automagic rounding */
     912:	ca 01       	movw	r24, r20
     914:	b9 01       	movw	r22, r18
     916:	6b 5f       	subi	r22, 0xFB	; 251
     918:	7f 4f       	sbci	r23, 0xFF	; 255
     91a:	8f 4f       	sbci	r24, 0xFF	; 255
     91c:	9f 4f       	sbci	r25, 0xFF	; 255
    Val0 /= 10;                                        /* scale down to 0.1 Ohm */
     91e:	2a e0       	ldi	r18, 0x0A	; 10
     920:	30 e0       	ldi	r19, 0x00	; 0
     922:	40 e0       	ldi	r20, 0x00	; 0
     924:	50 e0       	ldi	r21, 0x00	; 0
     926:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    if (Val0 < 280UL)         /* < 29 Ohms */
     92a:	28 31       	cpi	r18, 0x18	; 24
     92c:	91 e0       	ldi	r25, 0x01	; 1
     92e:	39 07       	cpc	r19, r25
     930:	41 05       	cpc	r20, r1
     932:	51 05       	cpc	r21, r1
     934:	28 f4       	brcc	.+10     	; 0x940 <__stack+0x41>
    {
      Config.RiH = (uint16_t)Val0;
     936:	30 93 9a 01 	sts	0x019A, r19
     93a:	20 93 99 01 	sts	0x0199, r18
      Flag++;
     93e:	a3 94       	inc	r10
    }
  }

  /* show values and offsets */
  ShowAdjust();
     940:	0e 94 c4 01 	call	0x388	; 0x388 <ShowAdjust>

  if (Flag == 4) Flag = 1;         /* all adjustments done -> success */
     944:	81 e0       	ldi	r24, 0x01	; 1
     946:	e4 e0       	ldi	r30, 0x04	; 4
     948:	ae 12       	cpse	r10, r30
     94a:	80 e0       	ldi	r24, 0x00	; 0
  else Flag = 0;                   /* signal error */

  return Flag;
}
     94c:	2c 96       	adiw	r28, 0x0c	; 12
     94e:	0f b6       	in	r0, 0x3f	; 63
     950:	f8 94       	cli
     952:	de bf       	out	0x3e, r29	; 62
     954:	0f be       	out	0x3f, r0	; 63
     956:	cd bf       	out	0x3d, r28	; 61
     958:	df 91       	pop	r29
     95a:	cf 91       	pop	r28
     95c:	1f 91       	pop	r17
     95e:	0f 91       	pop	r16
     960:	ff 90       	pop	r15
     962:	ef 90       	pop	r14
     964:	df 90       	pop	r13
     966:	cf 90       	pop	r12
     968:	bf 90       	pop	r11
     96a:	af 90       	pop	r10
     96c:	9f 90       	pop	r9
     96e:	8f 90       	pop	r8
     970:	7f 90       	pop	r7
     972:	6f 90       	pop	r6
     974:	5f 90       	pop	r5
     976:	4f 90       	pop	r4
     978:	3f 90       	pop	r3
     97a:	2f 90       	pop	r2
     97c:	08 95       	ret

0000097e <SelfTest>:
 *  - 0 on error
 *  - 1 on success
 */

uint8_t SelfTest(void)
{
     97e:	2f 92       	push	r2
     980:	3f 92       	push	r3
     982:	4f 92       	push	r4
     984:	5f 92       	push	r5
     986:	6f 92       	push	r6
     988:	7f 92       	push	r7
     98a:	8f 92       	push	r8
     98c:	9f 92       	push	r9
     98e:	af 92       	push	r10
     990:	bf 92       	push	r11
     992:	cf 92       	push	r12
     994:	df 92       	push	r13
     996:	ef 92       	push	r14
     998:	ff 92       	push	r15
     99a:	0f 93       	push	r16
     99c:	1f 93       	push	r17
     99e:	cf 93       	push	r28
     9a0:	df 93       	push	r29
     9a2:	00 d0       	rcall	.+0      	; 0x9a4 <SelfTest+0x26>
     9a4:	1f 92       	push	r1
     9a6:	cd b7       	in	r28, 0x3d	; 61
     9a8:	de b7       	in	r29, 0x3e	; 62
  uint8_t           DisplayFlag;        /* display flag */
  uint16_t          Val0;               /* voltage/value */
  int16_t           Val1 = 0, Val2 = 0, Val3 = 0;   /* voltages/values */

  /* make sure all probes are shorted */
  Counter = ShortCircuit(1);
     9aa:	81 e0       	ldi	r24, 0x01	; 1
     9ac:	0e 94 d1 26 	call	0x4da2	; 0x4da2 <ShortCircuit>
  if (Counter == 0) Test = 10;     /* skip selftest */
     9b0:	88 23       	and	r24, r24
     9b2:	09 f4       	brne	.+2      	; 0x9b6 <SelfTest+0x38>
     9b4:	51 c1       	rjmp	.+674    	; 0xc58 <SelfTest+0x2da>
     9b6:	00 e0       	ldi	r16, 0x00	; 0
     9b8:	10 e0       	ldi	r17, 0x00	; 0
     9ba:	21 2c       	mov	r2, r1
     9bc:	31 2c       	mov	r3, r1
     9be:	81 2c       	mov	r8, r1
     9c0:	91 2c       	mov	r9, r1
     9c2:	ff 24       	eor	r15, r15
     9c4:	f3 94       	inc	r15
          LCD_EEString(ProbeComb_str);    /* display: 12 13 23 */

          /* set up a voltage divider with the Rh's */

          /* TP1: Gnd -- Rh -- probe-2 -- probe-1 -- Rh -- Vcc */
          R_PORT = 2 << (TP1 * 2);
     9c6:	68 94       	set
     9c8:	77 24       	eor	r7, r7
     9ca:	71 f8       	bld	r7, 1
          R_DDR = (2 << (TP1 * 2)) | (2 << (TP2 * 2));
          Val1 = ReadU_20ms(TP3);
          Val1 -= (Config.Vcc / 2);
     9cc:	0f 2e       	mov	r0, r31
     9ce:	fe e8       	ldi	r31, 0x8E	; 142
     9d0:	4f 2e       	mov	r4, r31
     9d2:	f1 e0       	ldi	r31, 0x01	; 1
     9d4:	5f 2e       	mov	r5, r31
     9d6:	f0 2d       	mov	r31, r0
          R_DDR = (2 << (TP1 * 2)) | (2 << (TP3 * 2));
          Val2 = ReadU_20ms(TP2);
          Val2 -= (Config.Vcc / 2);

          /* TP1: Gnd -- Rh -- probe-3 -- probe-2 -- Rh -- Vcc */
          R_PORT = 2 << (TP2 * 2);
     9d8:	68 94       	set
     9da:	66 24       	eor	r6, r6
     9dc:	63 f8       	bld	r6, 3
          LCD_EEString(ProbeComb_str);    /* display: 12 13 23 */

          /* set up a voltage divider with the Rh's */

          /* TP1: Gnd -- Rh -- probe-2 -- probe-1 -- Rh -- Vcc */
          R_PORT = 2 << (TP1 * 2);
     9de:	b7 2c       	mov	r11, r7

          break;

        case 4:     /* un-short probes */
          ShortCircuit(0);         /* make sure probes are not shorted */
          Counter = 100;           /* skip test */
     9e0:	84 e6       	ldi	r24, 0x64	; 100
     9e2:	89 83       	std	Y+1, r24	; 0x01
     9e4:	22 c1       	rjmp	.+580    	; 0xc2a <SelfTest+0x2ac>

    /* repeat each test 5 times */
    while (Counter <= 5)
    {
      /* display test number */
      LCD_Clear();
     9e6:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>
      LCD_Data('T');                    /* display: T */
     9ea:	84 e5       	ldi	r24, 0x54	; 84
     9ec:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
      LCD_Data('0' + Test);             /* display test number */
     9f0:	8d 2d       	mov	r24, r13
     9f2:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
      LCD_Space();
     9f6:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>

      /*
       *  tests
       */

      switch (Test)
     9fa:	ea 81       	ldd	r30, Y+2	; 0x02
     9fc:	e3 30       	cpi	r30, 0x03	; 3
     9fe:	09 f4       	brne	.+2      	; 0xa02 <SelfTest+0x84>
     a00:	71 c0       	rjmp	.+226    	; 0xae4 <SelfTest+0x166>
     a02:	28 f4       	brcc	.+10     	; 0xa0e <SelfTest+0x90>
     a04:	e1 30       	cpi	r30, 0x01	; 1
     a06:	69 f0       	breq	.+26     	; 0xa22 <SelfTest+0xa4>
     a08:	e2 30       	cpi	r30, 0x02	; 2
     a0a:	01 f1       	breq	.+64     	; 0xa4c <SelfTest+0xce>
     a0c:	ce c0       	rjmp	.+412    	; 0xbaa <SelfTest+0x22c>
     a0e:	fa 81       	ldd	r31, Y+2	; 0x02
     a10:	f5 30       	cpi	r31, 0x05	; 5
     a12:	09 f4       	brne	.+2      	; 0xa16 <SelfTest+0x98>
     a14:	9e c0       	rjmp	.+316    	; 0xb52 <SelfTest+0x1d4>
     a16:	08 f4       	brcc	.+2      	; 0xa1a <SelfTest+0x9c>
     a18:	96 c0       	rjmp	.+300    	; 0xb46 <SelfTest+0x1c8>
     a1a:	f6 30       	cpi	r31, 0x06	; 6
     a1c:	09 f4       	brne	.+2      	; 0xa20 <SelfTest+0xa2>
     a1e:	ae c0       	rjmp	.+348    	; 0xb7c <SelfTest+0x1fe>
     a20:	c4 c0       	rjmp	.+392    	; 0xbaa <SelfTest+0x22c>
      {
        case 1:     /* reference voltage */
          Val0 = ReadU(0x0e);           /* dummy read for bandgap stabilization */
     a22:	8e e0       	ldi	r24, 0x0E	; 14
     a24:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
          Val0 = ReadU(0x0e);           /* read bandgap reference voltage */ 
     a28:	8e e0       	ldi	r24, 0x0E	; 14
     a2a:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
     a2e:	7c 01       	movw	r14, r24
          LCD_EEString(URef_str);       /* display: Vref */
     a30:	8f e5       	ldi	r24, 0x5F	; 95
     a32:	91 e0       	ldi	r25, 0x01	; 1
     a34:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>

          LCD_Line2();
     a38:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>
          DisplayValue(Val0, -3, 'V');       /* display voltage in mV */
     a3c:	b7 01       	movw	r22, r14
     a3e:	80 e0       	ldi	r24, 0x00	; 0
     a40:	90 e0       	ldi	r25, 0x00	; 0
     a42:	26 e5       	ldi	r18, 0x56	; 86
     a44:	4d ef       	ldi	r20, 0xFD	; 253
     a46:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>

          DisplayFlag = 0;                   /* reset flag */
          break;
     a4a:	00 c1       	rjmp	.+512    	; 0xc4c <SelfTest+0x2ce>

        case 2:     /* compare Rl resistors (probes still shorted) */
          LCD_EEString2(Rl_str);          /* display: +Rl- */
     a4c:	8a e4       	ldi	r24, 0x4A	; 74
     a4e:	91 e0       	ldi	r25, 0x01	; 1
     a50:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
          LCD_EEString(ProbeComb_str);    /* display: 12 13 23 */
     a54:	8c e3       	ldi	r24, 0x3C	; 60
     a56:	91 e0       	ldi	r25, 0x01	; 1
     a58:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>

          /* set up a voltage divider with the Rl's */
          /* substract theoretical voltage of voltage divider */

          /* TP1: Gnd -- Rl -- probe-2 -- probe-1 -- Rl -- Vcc */
          R_PORT = 1 << (TP1 * 2);
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	85 b9       	out	0x05, r24	; 5
          R_DDR = (1 << (TP1 * 2)) | (1 << (TP2 * 2));
     a60:	85 e0       	ldi	r24, 0x05	; 5
     a62:	84 b9       	out	0x04, r24	; 4
          Val1 = ReadU_20ms(TP3);
     a64:	8b 2d       	mov	r24, r11
     a66:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>
     a6a:	4c 01       	movw	r8, r24
          Val1 -= ((int32_t)Config.Vcc * (R_MCU_LOW + R_LOW)) / (R_MCU_LOW + R_LOW + R_LOW + R_MCU_HIGH);
     a6c:	f2 01       	movw	r30, r4
     a6e:	27 81       	ldd	r18, Z+7	; 0x07
     a70:	30 85       	ldd	r19, Z+8	; 0x08
     a72:	a0 e7       	ldi	r26, 0x70	; 112
     a74:	b3 e0       	ldi	r27, 0x03	; 3
     a76:	0e 94 87 28 	call	0x510e	; 0x510e <__umulhisi3>
     a7a:	24 ef       	ldi	r18, 0xF4	; 244
     a7c:	36 e0       	ldi	r19, 0x06	; 6
     a7e:	40 e0       	ldi	r20, 0x00	; 0
     a80:	50 e0       	ldi	r21, 0x00	; 0
     a82:	0e 94 62 28 	call	0x50c4	; 0x50c4 <__divmodsi4>
     a86:	82 1a       	sub	r8, r18
     a88:	93 0a       	sbc	r9, r19

          /* TP1: Gnd -- Rl -- probe-3 -- probe-1 -- Rl -- Vcc */
          R_DDR = (1 << (TP1 * 2)) | (1 << (TP3 * 2));
     a8a:	f1 e1       	ldi	r31, 0x11	; 17
     a8c:	f4 b9       	out	0x04, r31	; 4
          Val2 = ReadU_20ms(TP2);
     a8e:	81 e0       	ldi	r24, 0x01	; 1
     a90:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>
     a94:	1c 01       	movw	r2, r24
          Val2 -= ((int32_t)Config.Vcc * (R_MCU_LOW + R_LOW)) / (R_MCU_LOW + R_LOW + R_LOW + R_MCU_HIGH);
     a96:	f2 01       	movw	r30, r4
     a98:	27 81       	ldd	r18, Z+7	; 0x07
     a9a:	30 85       	ldd	r19, Z+8	; 0x08
     a9c:	a0 e7       	ldi	r26, 0x70	; 112
     a9e:	b3 e0       	ldi	r27, 0x03	; 3
     aa0:	0e 94 87 28 	call	0x510e	; 0x510e <__umulhisi3>
     aa4:	24 ef       	ldi	r18, 0xF4	; 244
     aa6:	36 e0       	ldi	r19, 0x06	; 6
     aa8:	40 e0       	ldi	r20, 0x00	; 0
     aaa:	50 e0       	ldi	r21, 0x00	; 0
     aac:	0e 94 62 28 	call	0x50c4	; 0x50c4 <__divmodsi4>
     ab0:	22 1a       	sub	r2, r18
     ab2:	33 0a       	sbc	r3, r19

          /* TP1: Gnd -- Rl -- probe-3 -- probe-2 -- Rl -- Vcc */
          R_PORT = 1 << (TP2 * 2);
     ab4:	f4 e0       	ldi	r31, 0x04	; 4
     ab6:	f5 b9       	out	0x05, r31	; 5
          R_DDR = (1 << (TP2 * 2)) | (1 << (TP3 * 2));
     ab8:	84 e1       	ldi	r24, 0x14	; 20
     aba:	84 b9       	out	0x04, r24	; 4
          Val3 = ReadU_20ms(TP2);
     abc:	81 e0       	ldi	r24, 0x01	; 1
     abe:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>
     ac2:	8c 01       	movw	r16, r24
          Val3 -= ((int32_t)Config.Vcc * (R_MCU_LOW + R_LOW)) / (R_MCU_LOW + R_LOW + R_LOW + R_MCU_HIGH);
     ac4:	f2 01       	movw	r30, r4
     ac6:	27 81       	ldd	r18, Z+7	; 0x07
     ac8:	30 85       	ldd	r19, Z+8	; 0x08
     aca:	a0 e7       	ldi	r26, 0x70	; 112
     acc:	b3 e0       	ldi	r27, 0x03	; 3
     ace:	0e 94 87 28 	call	0x510e	; 0x510e <__umulhisi3>
     ad2:	24 ef       	ldi	r18, 0xF4	; 244
     ad4:	36 e0       	ldi	r19, 0x06	; 6
     ad6:	40 e0       	ldi	r20, 0x00	; 0
     ad8:	50 e0       	ldi	r21, 0x00	; 0
     ada:	0e 94 62 28 	call	0x50c4	; 0x50c4 <__divmodsi4>
     ade:	02 1b       	sub	r16, r18
     ae0:	13 0b       	sbc	r17, r19

          break;
     ae2:	b7 c0       	rjmp	.+366    	; 0xc52 <SelfTest+0x2d4>

        case 3:     /* compare Rh resistors (probes still shorted) */
          LCD_EEString2(Rh_str);          /* display: +Rh- */
     ae4:	85 e4       	ldi	r24, 0x45	; 69
     ae6:	91 e0       	ldi	r25, 0x01	; 1
     ae8:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
          LCD_EEString(ProbeComb_str);    /* display: 12 13 23 */
     aec:	8c e3       	ldi	r24, 0x3C	; 60
     aee:	91 e0       	ldi	r25, 0x01	; 1
     af0:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>

          /* set up a voltage divider with the Rh's */

          /* TP1: Gnd -- Rh -- probe-2 -- probe-1 -- Rh -- Vcc */
          R_PORT = 2 << (TP1 * 2);
     af4:	75 b8       	out	0x05, r7	; 5
          R_DDR = (2 << (TP1 * 2)) | (2 << (TP2 * 2));
     af6:	fa e0       	ldi	r31, 0x0A	; 10
     af8:	f4 b9       	out	0x04, r31	; 4
          Val1 = ReadU_20ms(TP3);
     afa:	8b 2d       	mov	r24, r11
     afc:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>
          Val1 -= (Config.Vcc / 2);
     b00:	f2 01       	movw	r30, r4
     b02:	27 81       	ldd	r18, Z+7	; 0x07
     b04:	30 85       	ldd	r19, Z+8	; 0x08
     b06:	36 95       	lsr	r19
     b08:	27 95       	ror	r18
     b0a:	4c 01       	movw	r8, r24
     b0c:	82 1a       	sub	r8, r18
     b0e:	93 0a       	sbc	r9, r19

          /* TP1: Gnd -- Rh -- probe-3 -- probe-1 -- Rh -- Vcc */
          R_DDR = (2 << (TP1 * 2)) | (2 << (TP3 * 2));
     b10:	f2 e2       	ldi	r31, 0x22	; 34
     b12:	f4 b9       	out	0x04, r31	; 4
          Val2 = ReadU_20ms(TP2);
     b14:	81 e0       	ldi	r24, 0x01	; 1
     b16:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>
          Val2 -= (Config.Vcc / 2);
     b1a:	f2 01       	movw	r30, r4
     b1c:	27 81       	ldd	r18, Z+7	; 0x07
     b1e:	30 85       	ldd	r19, Z+8	; 0x08
     b20:	36 95       	lsr	r19
     b22:	27 95       	ror	r18
     b24:	1c 01       	movw	r2, r24
     b26:	22 1a       	sub	r2, r18
     b28:	33 0a       	sbc	r3, r19

          /* TP1: Gnd -- Rh -- probe-3 -- probe-2 -- Rh -- Vcc */
          R_PORT = 2 << (TP2 * 2);
     b2a:	65 b8       	out	0x05, r6	; 5
          R_DDR = (2 << (TP2 * 2)) | (2 << (TP3 * 2));
     b2c:	a4 b8       	out	0x04, r10	; 4
          Val3 = ReadU_20ms(TP1);
     b2e:	80 e0       	ldi	r24, 0x00	; 0
     b30:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>
          Val3 -= (Config.Vcc / 2);
     b34:	f2 01       	movw	r30, r4
     b36:	27 81       	ldd	r18, Z+7	; 0x07
     b38:	30 85       	ldd	r19, Z+8	; 0x08
     b3a:	36 95       	lsr	r19
     b3c:	27 95       	ror	r18
     b3e:	8c 01       	movw	r16, r24
     b40:	02 1b       	sub	r16, r18
     b42:	13 0b       	sbc	r17, r19

          break;
     b44:	86 c0       	rjmp	.+268    	; 0xc52 <SelfTest+0x2d4>

        case 4:     /* un-short probes */
          ShortCircuit(0);         /* make sure probes are not shorted */
     b46:	80 e0       	ldi	r24, 0x00	; 0
     b48:	0e 94 d1 26 	call	0x4da2	; 0x4da2 <ShortCircuit>
          Counter = 100;           /* skip test */
     b4c:	f9 81       	ldd	r31, Y+1	; 0x01
     b4e:	fb 83       	std	Y+3, r31	; 0x03
          DisplayFlag = 0;         /* reset flag */
          break;
     b50:	7d c0       	rjmp	.+250    	; 0xc4c <SelfTest+0x2ce>

        case 5:     /* Rh resistors pulled down */
          LCD_EEString(RhLow_str);      /* display: Rh- */
     b52:	8b e5       	ldi	r24, 0x5B	; 91
     b54:	91 e0       	ldi	r25, 0x01	; 1
     b56:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>

          /* TP1: Gnd -- Rh -- probe */
          R_PORT = 0;
     b5a:	15 b8       	out	0x05, r1	; 5
          R_DDR = 2 << (TP1 * 2);
     b5c:	74 b8       	out	0x04, r7	; 4
          Val1 = ReadU_20ms(TP1);
     b5e:	80 e0       	ldi	r24, 0x00	; 0
     b60:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>
     b64:	4c 01       	movw	r8, r24

          /* TP1: Gnd -- Rh -- probe */
          R_DDR = 2 << (TP2 * 2);
     b66:	64 b8       	out	0x04, r6	; 4
          Val2 = ReadU_20ms(TP2);
     b68:	81 e0       	ldi	r24, 0x01	; 1
     b6a:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>
     b6e:	1c 01       	movw	r2, r24

          /* TP1: Gnd -- Rh -- probe */
          R_DDR = 2 << (TP3 * 2);
     b70:	c4 b8       	out	0x04, r12	; 4
          Val3 = ReadU_20ms(TP3);
     b72:	8b 2d       	mov	r24, r11
     b74:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>
     b78:	8c 01       	movw	r16, r24

          break;
     b7a:	6b c0       	rjmp	.+214    	; 0xc52 <SelfTest+0x2d4>

        case 6:     /* Rh resistors pulled up */
          LCD_EEString(RhHigh_str);     /* display: Rh+ */
     b7c:	87 e5       	ldi	r24, 0x57	; 87
     b7e:	91 e0       	ldi	r25, 0x01	; 1
     b80:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>

          /* TP1: probe -- Rh -- Vcc */
          R_DDR = 2 << (TP1 * 2);
     b84:	74 b8       	out	0x04, r7	; 4
          R_PORT = 2 << (TP1 * 2);
     b86:	75 b8       	out	0x05, r7	; 5
          Val1 = ReadU_20ms(TP1);
     b88:	80 e0       	ldi	r24, 0x00	; 0
     b8a:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>
     b8e:	4c 01       	movw	r8, r24

          /* TP1: probe -- Rh -- Vcc */
          R_DDR = 2 << (TP2 * 2);
     b90:	64 b8       	out	0x04, r6	; 4
          R_PORT = 2 << (TP2 * 2);
     b92:	65 b8       	out	0x05, r6	; 5
          Val2 = ReadU_20ms(TP2);
     b94:	81 e0       	ldi	r24, 0x01	; 1
     b96:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>
     b9a:	1c 01       	movw	r2, r24

          /* TP1: probe -- Rh -- Vcc */
          R_DDR = 2 << (TP3 * 2);
     b9c:	c4 b8       	out	0x04, r12	; 4
          R_PORT = 2 << (TP3 * 2);
     b9e:	c5 b8       	out	0x05, r12	; 5
          Val3 = ReadU_20ms(TP3);
     ba0:	8b 2d       	mov	r24, r11
     ba2:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>
     ba6:	8c 01       	movw	r16, r24

          break;
     ba8:	54 c0       	rjmp	.+168    	; 0xc52 <SelfTest+0x2d4>
      }

      /* reset ports to defaults */
      R_DDR = 0;                             /* input mode */
     baa:	14 b8       	out	0x04, r1	; 4
      R_PORT = 0;                            /* all pins low */
     bac:	15 b8       	out	0x05, r1	; 5

      /* display voltages/values of all probes */
      if (DisplayFlag)
      {
        LCD_Line2();                         /* move to line #2 */
     bae:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>
        DisplaySignedValue(Val1, 0 , 0);     /* display TP1 */
     bb2:	20 e0       	ldi	r18, 0x00	; 0
     bb4:	40 e0       	ldi	r20, 0x00	; 0
     bb6:	b4 01       	movw	r22, r8
     bb8:	09 2c       	mov	r0, r9
     bba:	00 0c       	add	r0, r0
     bbc:	88 0b       	sbc	r24, r24
     bbe:	99 0b       	sbc	r25, r25
     bc0:	0e 94 2e 26 	call	0x4c5c	; 0x4c5c <DisplaySignedValue>
        LCD_Space();
     bc4:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>
        DisplaySignedValue(Val2, 0 , 0);     /* display TP2 */
     bc8:	20 e0       	ldi	r18, 0x00	; 0
     bca:	40 e0       	ldi	r20, 0x00	; 0
     bcc:	b1 01       	movw	r22, r2
     bce:	03 2c       	mov	r0, r3
     bd0:	00 0c       	add	r0, r0
     bd2:	88 0b       	sbc	r24, r24
     bd4:	99 0b       	sbc	r25, r25
     bd6:	0e 94 2e 26 	call	0x4c5c	; 0x4c5c <DisplaySignedValue>
        LCD_Space();
     bda:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>
        DisplaySignedValue(Val3, 0 , 0);     /* display TP3 */
     bde:	20 e0       	ldi	r18, 0x00	; 0
     be0:	40 e0       	ldi	r20, 0x00	; 0
     be2:	b8 01       	movw	r22, r16
     be4:	01 2e       	mov	r0, r17
     be6:	00 0c       	add	r0, r0
     be8:	88 0b       	sbc	r24, r24
     bea:	99 0b       	sbc	r25, r25
     bec:	0e 94 2e 26 	call	0x4c5c	; 0x4c5c <DisplaySignedValue>
      }

      /* wait and check test push button */
      if (Counter < 100)                     /* when we don't skip this test */
     bf0:	8b 81       	ldd	r24, Y+3	; 0x03
     bf2:	84 36       	cpi	r24, 0x64	; 100
     bf4:	78 f4       	brcc	.+30     	; 0xc14 <SelfTest+0x296>
      {
        DisplayFlag = TestKey(1000, 0);      /* catch key press or timeout */
     bf6:	60 e0       	ldi	r22, 0x00	; 0
     bf8:	88 ee       	ldi	r24, 0xE8	; 232
     bfa:	93 e0       	ldi	r25, 0x03	; 3
     bfc:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <TestKey>

        /* short press -> next test / long press -> end selftest */
        if (DisplayFlag > 0)
     c00:	88 23       	and	r24, r24
     c02:	41 f0       	breq	.+16     	; 0xc14 <SelfTest+0x296>
     c04:	fa 80       	ldd	r15, Y+2	; 0x02
        {
          Counter = 100;                       /* skip current test anyway */
          if (DisplayFlag == 2) Test = 100;    /* also skip selftest */
     c06:	82 30       	cpi	r24, 0x02	; 2
     c08:	61 f4       	brne	.+24     	; 0xc22 <SelfTest+0x2a4>
     c0a:	0f 2e       	mov	r0, r31
     c0c:	f4 e6       	ldi	r31, 0x64	; 100
     c0e:	ff 2e       	mov	r15, r31
     c10:	f0 2d       	mov	r31, r0
     c12:	07 c0       	rjmp	.+14     	; 0xc22 <SelfTest+0x2a4>
        } 
      }
 
      Counter++;                        /* next run */
     c14:	eb 81       	ldd	r30, Y+3	; 0x03
     c16:	ef 5f       	subi	r30, 0xFF	; 255
     c18:	eb 83       	std	Y+3, r30	; 0x03
  while (Test <= 6)
  {
    Counter = 1;

    /* repeat each test 5 times */
    while (Counter <= 5)
     c1a:	e6 30       	cpi	r30, 0x06	; 6
     c1c:	08 f4       	brcc	.+2      	; 0xc20 <SelfTest+0x2a2>
     c1e:	e3 ce       	rjmp	.-570    	; 0x9e6 <SelfTest+0x68>
     c20:	fa 80       	ldd	r15, Y+2	; 0x02
      }
 
      Counter++;                        /* next run */
    }

    Test++;                             /* next one */
     c22:	f3 94       	inc	r15
  /* make sure all probes are shorted */
  Counter = ShortCircuit(1);
  if (Counter == 0) Test = 10;     /* skip selftest */

  /* loop through all tests */
  while (Test <= 6)
     c24:	f6 e0       	ldi	r31, 0x06	; 6
     c26:	ff 15       	cp	r31, r15
     c28:	b8 f0       	brcs	.+46     	; 0xc58 <SelfTest+0x2da>
 *  - 0 on error
 *  - 1 on success
 */

uint8_t SelfTest(void)
{
     c2a:	ee 24       	eor	r14, r14
     c2c:	e3 94       	inc	r14
    while (Counter <= 5)
    {
      /* display test number */
      LCD_Clear();
      LCD_Data('T');                    /* display: T */
      LCD_Data('0' + Test);             /* display test number */
     c2e:	0f 2e       	mov	r0, r31
     c30:	f0 e3       	ldi	r31, 0x30	; 48
     c32:	df 2e       	mov	r13, r31
     c34:	f0 2d       	mov	r31, r0
     c36:	df 0c       	add	r13, r15
          Val2 = ReadU_20ms(TP2);
          Val2 -= (Config.Vcc / 2);

          /* TP1: Gnd -- Rh -- probe-3 -- probe-2 -- Rh -- Vcc */
          R_PORT = 2 << (TP2 * 2);
          R_DDR = (2 << (TP2 * 2)) | (2 << (TP3 * 2));
     c38:	0f 2e       	mov	r0, r31
     c3a:	f8 e2       	ldi	r31, 0x28	; 40
     c3c:	af 2e       	mov	r10, r31
     c3e:	f0 2d       	mov	r31, r0
          /* TP1: Gnd -- Rh -- probe */
          R_DDR = 2 << (TP2 * 2);
          Val2 = ReadU_20ms(TP2);

          /* TP1: Gnd -- Rh -- probe */
          R_DDR = 2 << (TP3 * 2);
     c40:	68 94       	set
     c42:	cc 24       	eor	r12, r12
     c44:	c5 f8       	bld	r12, 5
     c46:	fa 82       	std	Y+2, r15	; 0x02
     c48:	eb 82       	std	Y+3, r14	; 0x03
     c4a:	cd ce       	rjmp	.-614    	; 0x9e6 <SelfTest+0x68>

          break;
      }

      /* reset ports to defaults */
      R_DDR = 0;                             /* input mode */
     c4c:	14 b8       	out	0x04, r1	; 4
      R_PORT = 0;                            /* all pins low */
     c4e:	15 b8       	out	0x05, r1	; 5
     c50:	cf cf       	rjmp	.-98     	; 0xbf0 <SelfTest+0x272>

          break;
      }

      /* reset ports to defaults */
      R_DDR = 0;                             /* input mode */
     c52:	14 b8       	out	0x04, r1	; 4
      R_PORT = 0;                            /* all pins low */
     c54:	15 b8       	out	0x05, r1	; 5
     c56:	ab cf       	rjmp	.-170    	; 0xbae <SelfTest+0x230>
    Test++;                             /* next one */
  }

  Flag = 1;         /* signal success */
  return Flag;
} 
     c58:	81 e0       	ldi	r24, 0x01	; 1
     c5a:	0f 90       	pop	r0
     c5c:	0f 90       	pop	r0
     c5e:	0f 90       	pop	r0
     c60:	df 91       	pop	r29
     c62:	cf 91       	pop	r28
     c64:	1f 91       	pop	r17
     c66:	0f 91       	pop	r16
     c68:	ff 90       	pop	r15
     c6a:	ef 90       	pop	r14
     c6c:	df 90       	pop	r13
     c6e:	cf 90       	pop	r12
     c70:	bf 90       	pop	r11
     c72:	af 90       	pop	r10
     c74:	9f 90       	pop	r9
     c76:	8f 90       	pop	r8
     c78:	7f 90       	pop	r7
     c7a:	6f 90       	pop	r6
     c7c:	5f 90       	pop	r5
     c7e:	4f 90       	pop	r4
     c80:	3f 90       	pop	r3
     c82:	2f 90       	pop	r2
     c84:	08 95       	ret

00000c86 <MeasureESR>:
 *  returns:
 *  - ESR in 0.01 Ohm
 */

uint16_t MeasureESR(Capacitor_Type *Cap)
{
     c86:	ef 92       	push	r14
     c88:	0f 93       	push	r16
     c8a:	1f 93       	push	r17
     c8c:	cf 93       	push	r28
     c8e:	df 93       	push	r29
  uint32_t          Value;

  #define LOOP_RUNS      255

  /* check for a capacitor >= 0.18킚 */
  if ((Cap == NULL) ||
     c90:	00 97       	sbiw	r24, 0x00	; 0
     c92:	e9 f0       	breq	.+58     	; 0xcce <MeasureESR+0x48>
     c94:	ec 01       	movw	r28, r24
      (CmpValue(Cap->Value, Cap->Scale, 180, -9) < 0)) return ESR;
     c96:	6b 81       	ldd	r22, Y+3	; 0x03
     c98:	7c 81       	ldd	r23, Y+4	; 0x04
     c9a:	8d 81       	ldd	r24, Y+5	; 0x05
     c9c:	9e 81       	ldd	r25, Y+6	; 0x06
     c9e:	0f 2e       	mov	r0, r31
     ca0:	f7 ef       	ldi	r31, 0xF7	; 247
     ca2:	ef 2e       	mov	r14, r31
     ca4:	f0 2d       	mov	r31, r0
     ca6:	04 eb       	ldi	r16, 0xB4	; 180
     ca8:	10 e0       	ldi	r17, 0x00	; 0
     caa:	20 e0       	ldi	r18, 0x00	; 0
     cac:	30 e0       	ldi	r19, 0x00	; 0
     cae:	4a 81       	ldd	r20, Y+2	; 0x02
     cb0:	0e 94 a6 24 	call	0x494c	; 0x494c <CmpValue>
  uint32_t          Value;

  #define LOOP_RUNS      255

  /* check for a capacitor >= 0.18킚 */
  if ((Cap == NULL) ||
     cb4:	88 23       	and	r24, r24
     cb6:	5c f0       	brlt	.+22     	; 0xcce <MeasureESR+0x48>

  /*
   *  init stuff
   */

  DischargeProbes();                    /* try to discharge probes */
     cb8:	0e 94 64 18 	call	0x30c8	; 0x30c8 <DischargeProbes>
  if (Check.Found == COMP_ERROR) return ESR;   /* skip on error */
     cbc:	80 91 01 01 	lds	r24, 0x0101
     cc0:	81 30       	cpi	r24, 0x01	; 1
     cc2:	29 f0       	breq	.+10     	; 0xcce <MeasureESR+0x48>

  Probe1 = Cap->A;       /* probe facing Gnd */
  Probe2 = Cap->B;       /* probe facing Vcc */

  UpdateProbes(Probe1, Probe2, 0);      /* update probes */
     cc4:	40 e0       	ldi	r20, 0x00	; 0
     cc6:	69 81       	ldd	r22, Y+1	; 0x01
     cc8:	88 81       	ld	r24, Y
     cca:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <UpdateProbes>
  Config.RefFlag = (1 << REFS1);        /* set REFS1 bit flag */

  return ESR;

  #undef LOOP_RUNS 
}
     cce:	80 e0       	ldi	r24, 0x00	; 0
     cd0:	90 e0       	ldi	r25, 0x00	; 0
     cd2:	df 91       	pop	r29
     cd4:	cf 91       	pop	r28
     cd6:	1f 91       	pop	r17
     cd8:	0f 91       	pop	r16
     cda:	ef 90       	pop	r14
     cdc:	08 95       	ret

00000cde <LargeCap>:
 *  - 1 if capacitance is too high
 *  - 0 on any problem
 */

uint8_t LargeCap(Capacitor_Type *Cap)
{
     cde:	2f 92       	push	r2
     ce0:	3f 92       	push	r3
     ce2:	4f 92       	push	r4
     ce4:	5f 92       	push	r5
     ce6:	6f 92       	push	r6
     ce8:	7f 92       	push	r7
     cea:	8f 92       	push	r8
     cec:	9f 92       	push	r9
     cee:	af 92       	push	r10
     cf0:	bf 92       	push	r11
     cf2:	cf 92       	push	r12
     cf4:	df 92       	push	r13
     cf6:	ef 92       	push	r14
     cf8:	ff 92       	push	r15
     cfa:	0f 93       	push	r16
     cfc:	1f 93       	push	r17
     cfe:	cf 93       	push	r28
     d00:	df 93       	push	r29
     d02:	00 d0       	rcall	.+0      	; 0xd04 <LargeCap+0x26>
     d04:	00 d0       	rcall	.+0      	; 0xd06 <LargeCap+0x28>
     d06:	1f 92       	push	r1
     d08:	cd b7       	in	r28, 0x3d	; 61
     d0a:	de b7       	in	r29, 0x3e	; 62
     d0c:	9b 83       	std	Y+3, r25	; 0x03
     d0e:	8a 83       	std	Y+2, r24	; 0x02
  uint16_t          U_Drop = 0;    /* voltage drop */
  uint32_t          Raw;           /* raw capacitance value */
  uint32_t          Value;         /* corrected capacitance value */

  /* setup mode */
  Mode = FLAG_10MS | FLAG_PULLUP;       /* start with large caps */
     d10:	0f 2e       	mov	r0, r31
     d12:	f1 e1       	ldi	r31, 0x11	; 17
     d14:	cf 2e       	mov	r12, r31
     d16:	f0 2d       	mov	r31, r0
 *  - 0 on any problem
 */

uint8_t LargeCap(Capacitor_Type *Cap)
{
  uint8_t           Flag = 3;      /* return value */
     d18:	23 e0       	ldi	r18, 0x03	; 3
     d1a:	29 83       	std	Y+1, r18	; 0x01

large_cap:

  /* prepare probes */
  DischargeProbes();                    /* try to discharge probes */
  if (Check.Found == COMP_ERROR) return 0;     /* skip on error */
     d1c:	0f 2e       	mov	r0, r31
     d1e:	f0 e0       	ldi	r31, 0x00	; 0
     d20:	8f 2e       	mov	r8, r31
     d22:	f1 e0       	ldi	r31, 0x01	; 1
     d24:	9f 2e       	mov	r9, r31
     d26:	f0 2d       	mov	r31, r0

  /* setup probes: Gnd -- probe 1 / probe 2 -- Rl -- Vcc */
  ADC_PORT = 0;                    /* set ADC port to low */
  ADC_DDR = Probes.ADC_2;          /* pull-down probe 2 directly */
     d28:	0f 2e       	mov	r0, r31
     d2a:	fd e7       	ldi	r31, 0x7D	; 125
     d2c:	ef 2e       	mov	r14, r31
     d2e:	f1 e0       	ldi	r31, 0x01	; 1
     d30:	ff 2e       	mov	r15, r31
     d32:	f0 2d       	mov	r31, r0
  R_PORT = 0;                      /* set resistor port to low */
  R_DDR = 0;                       /* set resistor port to HiZ */
  U_Zero = ReadU(Probes.Pin_1);    /* get zero voltage (noise) */

  /* charge DUT with up to 500 pulses until it reaches 300mV */
  Pulses = 0;
     d34:	21 2c       	mov	r2, r1
     d36:	31 2c       	mov	r3, r1
  TempByte = 1;
     d38:	44 24       	eor	r4, r4
     d3a:	43 94       	inc	r4

    /* end loop if charging is too slow */
    if ((Pulses == 126) && (U_Cap < 75)) TempByte = 0;
    
    /* end loop if 300mV are reached */
    if (U_Cap >= 300) TempByte = 0;
     d3c:	71 2c       	mov	r7, r1

    /* zero offset */
    if (U_Cap > U_Zero)            /* voltage higher than zero offset */
      U_Cap -= U_Zero;                  /* subtract zero offset */
    else                           /* shouldn't happen but you never know */
      U_Cap = 0;                        /* assume 0V */
     d3e:	52 2c       	mov	r5, r2
     d40:	63 2c       	mov	r6, r3
   */

large_cap:

  /* prepare probes */
  DischargeProbes();                    /* try to discharge probes */
     d42:	0e 94 64 18 	call	0x30c8	; 0x30c8 <DischargeProbes>
  if (Check.Found == COMP_ERROR) return 0;     /* skip on error */
     d46:	d4 01       	movw	r26, r8
     d48:	11 96       	adiw	r26, 0x01	; 1
     d4a:	8c 91       	ld	r24, X
     d4c:	81 30       	cpi	r24, 0x01	; 1
     d4e:	09 f4       	brne	.+2      	; 0xd52 <LargeCap+0x74>
     d50:	e8 c0       	rjmp	.+464    	; 0xf22 <LargeCap+0x244>

  /* setup probes: Gnd -- probe 1 / probe 2 -- Rl -- Vcc */
  ADC_PORT = 0;                    /* set ADC port to low */
     d52:	18 b8       	out	0x08, r1	; 8
  ADC_DDR = Probes.ADC_2;          /* pull-down probe 2 directly */
     d54:	f7 01       	movw	r30, r14
     d56:	82 85       	ldd	r24, Z+10	; 0x0a
     d58:	87 b9       	out	0x07, r24	; 7
  R_PORT = 0;                      /* set resistor port to low */
     d5a:	15 b8       	out	0x05, r1	; 5
  R_DDR = 0;                       /* set resistor port to HiZ */
     d5c:	14 b8       	out	0x04, r1	; 4
  U_Zero = ReadU(Probes.Pin_1);    /* get zero voltage (noise) */
     d5e:	80 81       	ld	r24, Z
     d60:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
     d64:	5c 01       	movw	r10, r24

  /* charge DUT with up to 500 pulses until it reaches 300mV */
  Pulses = 0;
     d66:	02 2d       	mov	r16, r2
     d68:	13 2d       	mov	r17, r3
  TempByte = 1;
     d6a:	d4 2c       	mov	r13, r4
  while (TempByte)
  {
    Pulses++;
     d6c:	0f 5f       	subi	r16, 0xFF	; 255
     d6e:	1f 4f       	sbci	r17, 0xFF	; 255
    PullProbe(Probes.Rl_1, Mode);       /* charging pulse */
     d70:	6c 2d       	mov	r22, r12
     d72:	d7 01       	movw	r26, r14
     d74:	13 96       	adiw	r26, 0x03	; 3
     d76:	8c 91       	ld	r24, X
     d78:	0e 94 2c 19 	call	0x3258	; 0x3258 <PullProbe>
    U_Cap = ReadU(Probes.Pin_1);        /* get voltage */
     d7c:	f7 01       	movw	r30, r14
     d7e:	80 81       	ld	r24, Z
     d80:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>

    /* zero offset */
    if (U_Cap > U_Zero)            /* voltage higher than zero offset */
     d84:	a8 16       	cp	r10, r24
     d86:	b9 06       	cpc	r11, r25
     d88:	08 f0       	brcs	.+2      	; 0xd8c <LargeCap+0xae>
     d8a:	cf c0       	rjmp	.+414    	; 0xf2a <LargeCap+0x24c>
      U_Cap -= U_Zero;                  /* subtract zero offset */
     d8c:	9c 01       	movw	r18, r24
     d8e:	2a 19       	sub	r18, r10
     d90:	3b 09       	sbc	r19, r11
     d92:	3d 83       	std	Y+5, r19	; 0x05
     d94:	2c 83       	std	Y+4, r18	; 0x04
    else                           /* shouldn't happen but you never know */
      U_Cap = 0;                        /* assume 0V */

    /* end loop if charging is too slow */
    if ((Pulses == 126) && (U_Cap < 75)) TempByte = 0;
     d96:	0e 37       	cpi	r16, 0x7E	; 126
     d98:	11 05       	cpc	r17, r1
     d9a:	31 f4       	brne	.+12     	; 0xda8 <LargeCap+0xca>
     d9c:	2b 34       	cpi	r18, 0x4B	; 75
     d9e:	31 05       	cpc	r19, r1
     da0:	08 f0       	brcs	.+2      	; 0xda4 <LargeCap+0xc6>
     da2:	ca c0       	rjmp	.+404    	; 0xf38 <LargeCap+0x25a>
     da4:	d7 2c       	mov	r13, r7
     da6:	c8 c0       	rjmp	.+400    	; 0xf38 <LargeCap+0x25a>
    
    /* end loop if 300mV are reached */
    if (U_Cap >= 300) TempByte = 0;
     da8:	4c 81       	ldd	r20, Y+4	; 0x04
     daa:	5d 81       	ldd	r21, Y+5	; 0x05
     dac:	4c 32       	cpi	r20, 0x2C	; 44
     dae:	51 40       	sbci	r21, 0x01	; 1
     db0:	20 f0       	brcs	.+8      	; 0xdba <LargeCap+0xdc>
     db2:	d7 2c       	mov	r13, r7
     db4:	02 c0       	rjmp	.+4      	; 0xdba <LargeCap+0xdc>

    /* zero offset */
    if (U_Cap > U_Zero)            /* voltage higher than zero offset */
      U_Cap -= U_Zero;                  /* subtract zero offset */
    else                           /* shouldn't happen but you never know */
      U_Cap = 0;                        /* assume 0V */
     db6:	5c 82       	std	Y+4, r5	; 0x04
     db8:	6d 82       	std	Y+5, r6	; 0x05
    
    /* end loop if 300mV are reached */
    if (U_Cap >= 300) TempByte = 0;

    /* end loop if maximum pulses are reached */
    if (Pulses == 500) TempByte = 0;
     dba:	04 3f       	cpi	r16, 0xF4	; 244
     dbc:	81 e0       	ldi	r24, 0x01	; 1
     dbe:	18 07       	cpc	r17, r24
     dc0:	19 f4       	brne	.+6      	; 0xdc8 <LargeCap+0xea>
     dc2:	d7 2c       	mov	r13, r7
     dc4:	01 c0       	rjmp	.+2      	; 0xdc8 <LargeCap+0xea>

    /* end loop if charging is too slow */
    if ((Pulses == 126) && (U_Cap < 75)) TempByte = 0;
    
    /* end loop if 300mV are reached */
    if (U_Cap >= 300) TempByte = 0;
     dc6:	d7 2c       	mov	r13, r7

    /* end loop if maximum pulses are reached */
    if (Pulses == 500) TempByte = 0;

    wdt_reset();                        /* reset watchdog */
     dc8:	a8 95       	wdr
  U_Zero = ReadU(Probes.Pin_1);    /* get zero voltage (noise) */

  /* charge DUT with up to 500 pulses until it reaches 300mV */
  Pulses = 0;
  TempByte = 1;
  while (TempByte)
     dca:	d1 10       	cpse	r13, r1
     dcc:	cf cf       	rjmp	.-98     	; 0xd6c <LargeCap+0x8e>
     dce:	2c 81       	ldd	r18, Y+4	; 0x04
     dd0:	3d 81       	ldd	r19, Y+5	; 0x05
  {
    Pulses++;
     dd2:	c8 01       	movw	r24, r16
    wdt_reset();                        /* reset watchdog */
  }

  /* if 300mV are not reached DUT isn't a cap or much too large (>100mF) */
  /* we can ignore that for mid-sized caps */
  if (U_Cap < 300)
     dd4:	2c 32       	cpi	r18, 0x2C	; 44
     dd6:	a1 e0       	ldi	r26, 0x01	; 1
     dd8:	3a 07       	cpc	r19, r26
     dda:	08 f4       	brcc	.+2      	; 0xdde <LargeCap+0x100>
  {
    Flag = 1;
     ddc:	49 82       	std	Y+1, r4	; 0x01
  }

  /* if 1300mV are reached with one pulse we got a small cap */
  if ((Pulses == 1) && (U_Cap > 1300))
     dde:	81 30       	cpi	r24, 0x01	; 1
     de0:	91 05       	cpc	r25, r1
     de2:	71 f4       	brne	.+28     	; 0xe00 <LargeCap+0x122>
     de4:	25 31       	cpi	r18, 0x15	; 21
     de6:	35 40       	sbci	r19, 0x05	; 5
     de8:	08 f4       	brcc	.+2      	; 0xdec <LargeCap+0x10e>
     dea:	ad c0       	rjmp	.+346    	; 0xf46 <LargeCap+0x268>
  {
    if (Mode & FLAG_10MS)                    /* 10ms pulses (>47킚) */
     dec:	8c 2d       	mov	r24, r12
     dee:	80 71       	andi	r24, 0x10	; 16
    {
      Mode = FLAG_1MS | FLAG_PULLUP;         /* set mode to 1ms charging pulses (<47킚) */
     df0:	0f 2e       	mov	r0, r31
     df2:	f9 e0       	ldi	r31, 0x09	; 9
     df4:	cf 2e       	mov	r12, r31
     df6:	f0 2d       	mov	r31, r0
  }

  /* if 1300mV are reached with one pulse we got a small cap */
  if ((Pulses == 1) && (U_Cap > 1300))
  {
    if (Mode & FLAG_10MS)                    /* 10ms pulses (>47킚) */
     df8:	81 11       	cpse	r24, r1
     dfa:	a3 cf       	rjmp	.-186    	; 0xd42 <LargeCap+0x64>
      Mode = FLAG_1MS | FLAG_PULLUP;         /* set mode to 1ms charging pulses (<47킚) */
      goto large_cap;                        /* and re-run */
    }
    else                                     /* 1ms pulses (<47킚) */
    {
      Flag = 2;                              /* signal low capacitance (<4.7킚) */
     dfc:	82 e0       	ldi	r24, 0x02	; 2
     dfe:	e6 c0       	rjmp	.+460    	; 0xfcc <LargeCap+0x2ee>
  /* charge DUT with up to 500 pulses until it reaches 300mV */
  Pulses = 0;
  TempByte = 1;
  while (TempByte)
  {
    Pulses++;
     e00:	c8 01       	movw	r24, r16
   *  check if DUT sustains the charge and get the voltage drop
   *  - run the same time as before minus the 10ms charging time
   *  - this gives us the approximation of the self-discharging
   */

  if (Flag == 3)
     e02:	e9 81       	ldd	r30, Y+1	; 0x01
     e04:	e3 30       	cpi	r30, 0x03	; 3
     e06:	09 f0       	breq	.+2      	; 0xe0a <LargeCap+0x12c>
     e08:	a4 c0       	rjmp	.+328    	; 0xf52 <LargeCap+0x274>
  {
    /* check self-discharging */
    TempInt = Pulses;
    while (TempInt > 0)
     e0a:	89 2b       	or	r24, r25
     e0c:	11 f4       	brne	.+4      	; 0xe12 <LargeCap+0x134>
     e0e:	18 c0       	rjmp	.+48     	; 0xe40 <LargeCap+0x162>
  /* charge DUT with up to 500 pulses until it reaches 300mV */
  Pulses = 0;
  TempByte = 1;
  while (TempByte)
  {
    Pulses++;
     e10:	8c 01       	movw	r16, r24
     e12:	78 01       	movw	r14, r16
    /* check self-discharging */
    TempInt = Pulses;
    while (TempInt > 0)
    {
      TempInt--;                        /* descrease timeout */
      U_Drop = ReadU(Probes.Pin_1);     /* get voltage */
     e14:	0f 2e       	mov	r0, r31
     e16:	fd e7       	ldi	r31, 0x7D	; 125
     e18:	8f 2e       	mov	r8, r31
     e1a:	f1 e0       	ldi	r31, 0x01	; 1
     e1c:	9f 2e       	mov	r9, r31
     e1e:	f0 2d       	mov	r31, r0
  {
    /* check self-discharging */
    TempInt = Pulses;
    while (TempInt > 0)
    {
      TempInt--;                        /* descrease timeout */
     e20:	f1 e0       	ldi	r31, 0x01	; 1
     e22:	ef 1a       	sub	r14, r31
     e24:	f1 08       	sbc	r15, r1
      U_Drop = ReadU(Probes.Pin_1);     /* get voltage */
     e26:	d4 01       	movw	r26, r8
     e28:	8c 91       	ld	r24, X
     e2a:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
      U_Drop -= U_Zero;                 /* zero offset */
      wdt_reset();                      /* reset watchdog */
     e2e:	a8 95       	wdr

  if (Flag == 3)
  {
    /* check self-discharging */
    TempInt = Pulses;
    while (TempInt > 0)
     e30:	e1 14       	cp	r14, r1
     e32:	f1 04       	cpc	r15, r1
     e34:	a9 f7       	brne	.-22     	; 0xe20 <LargeCap+0x142>
    {
      TempInt--;                        /* descrease timeout */
      U_Drop = ReadU(Probes.Pin_1);     /* get voltage */
      U_Drop -= U_Zero;                 /* zero offset */
     e36:	8a 19       	sub	r24, r10
     e38:	9b 09       	sbc	r25, r11
     e3a:	2c 81       	ldd	r18, Y+4	; 0x04
     e3c:	3d 81       	ldd	r19, Y+5	; 0x05
     e3e:	04 c0       	rjmp	.+8      	; 0xe48 <LargeCap+0x16a>

  if (Flag == 3)
  {
    /* check self-discharging */
    TempInt = Pulses;
    while (TempInt > 0)
     e40:	2c 81       	ldd	r18, Y+4	; 0x04
     e42:	3d 81       	ldd	r19, Y+5	; 0x05
  int8_t            Scale;         /* capacitance scale */
  uint16_t          TempInt;       /* temp. value */
  uint16_t          Pulses;        /* number of charging pulses */
  uint16_t          U_Zero;        /* voltage before charging */
  uint16_t          U_Cap;         /* voltage of DUT */
  uint16_t          U_Drop = 0;    /* voltage drop */
     e44:	80 e0       	ldi	r24, 0x00	; 0
     e46:	90 e0       	ldi	r25, 0x00	; 0
      U_Drop -= U_Zero;                 /* zero offset */
      wdt_reset();                      /* reset watchdog */
    }

    /* calculate voltage drop */
    if (U_Cap > U_Drop) U_Drop = U_Cap - U_Drop;
     e48:	82 17       	cp	r24, r18
     e4a:	93 07       	cpc	r25, r19
     e4c:	88 f4       	brcc	.+34     	; 0xe70 <LargeCap+0x192>
     e4e:	f9 01       	movw	r30, r18
     e50:	e8 1b       	sub	r30, r24
     e52:	f9 0b       	sbc	r31, r25
     e54:	cf 01       	movw	r24, r30
    else U_Drop = 0;

    /* if voltage drop is too large consider DUT not to be a cap */
    if (U_Drop > 100) Flag = 0;
     e56:	e5 36       	cpi	r30, 0x65	; 101
     e58:	f1 05       	cpc	r31, r1
     e5a:	08 f0       	brcs	.+2      	; 0xe5e <LargeCap+0x180>
     e5c:	79 c0       	rjmp	.+242    	; 0xf50 <LargeCap+0x272>
     e5e:	0a c0       	rjmp	.+20     	; 0xe74 <LargeCap+0x196>
   *  calculate capacitance
   *  - use factor from pre-calculated LargeCap_table
   *  - ignore Config.CapZero since it's in the pF range
   */

  if (Flag == 3)
     e60:	f9 81       	ldd	r31, Y+1	; 0x01
     e62:	f3 30       	cpi	r31, 0x03	; 3
     e64:	09 f0       	breq	.+2      	; 0xe68 <LargeCap+0x18a>
     e66:	5f c0       	rjmp	.+190    	; 0xf26 <LargeCap+0x248>
  /* charge DUT with up to 500 pulses until it reaches 300mV */
  Pulses = 0;
  TempByte = 1;
  while (TempByte)
  {
    Pulses++;
     e68:	8c 01       	movw	r16, r24
     e6a:	80 e0       	ldi	r24, 0x00	; 0
     e6c:	90 e0       	ldi	r25, 0x00	; 0
     e6e:	02 c0       	rjmp	.+4      	; 0xe74 <LargeCap+0x196>
     e70:	80 e0       	ldi	r24, 0x00	; 0
     e72:	90 e0       	ldi	r25, 0x00	; 0

  if (Flag == 3)
  {
    Scale = -9;                           /* factor is scaled to nF */
    /* get interpolated factor from table */
    Raw = GetFactor(U_Cap + U_Drop, TABLE_LARGE_CAP);
     e74:	62 e0       	ldi	r22, 0x02	; 2
     e76:	2c 81       	ldd	r18, Y+4	; 0x04
     e78:	3d 81       	ldd	r19, Y+5	; 0x05
     e7a:	82 0f       	add	r24, r18
     e7c:	93 1f       	adc	r25, r19
     e7e:	0e 94 4c 19 	call	0x3298	; 0x3298 <GetFactor>
    Raw *= Pulses;                        /* C = pulses * factor */
     e82:	98 01       	movw	r18, r16
     e84:	dc 01       	movw	r26, r24
     e86:	0e 94 87 28 	call	0x510e	; 0x510e <__umulhisi3>
     e8a:	4b 01       	movw	r8, r22
     e8c:	5c 01       	movw	r10, r24
    if (Mode & FLAG_10MS) Raw *= 10;      /* *10 for 10ms charging pulses */
     e8e:	8c 2d       	mov	r24, r12
     e90:	80 71       	andi	r24, 0x10	; 16
     e92:	09 f4       	brne	.+2      	; 0xe96 <LargeCap+0x1b8>
     e94:	6e c0       	rjmp	.+220    	; 0xf72 <LargeCap+0x294>
     e96:	88 0c       	add	r8, r8
     e98:	99 1c       	adc	r9, r9
     e9a:	aa 1c       	adc	r10, r10
     e9c:	bb 1c       	adc	r11, r11
     e9e:	d5 01       	movw	r26, r10
     ea0:	c4 01       	movw	r24, r8
     ea2:	88 0f       	add	r24, r24
     ea4:	99 1f       	adc	r25, r25
     ea6:	aa 1f       	adc	r26, r26
     ea8:	bb 1f       	adc	r27, r27
     eaa:	88 0f       	add	r24, r24
     eac:	99 1f       	adc	r25, r25
     eae:	aa 1f       	adc	r26, r26
     eb0:	bb 1f       	adc	r27, r27
     eb2:	a5 01       	movw	r20, r10
     eb4:	94 01       	movw	r18, r8
     eb6:	28 0f       	add	r18, r24
     eb8:	39 1f       	adc	r19, r25
     eba:	4a 1f       	adc	r20, r26
     ebc:	5b 1f       	adc	r21, r27
     ebe:	49 01       	movw	r8, r18
     ec0:	5a 01       	movw	r10, r20

    if (Raw > (UINT32_MAX / 1000))        /* scale down if C >4.3mF */
     ec2:	28 33       	cpi	r18, 0x38	; 56
     ec4:	69 e8       	ldi	r22, 0x89	; 137
     ec6:	36 07       	cpc	r19, r22
     ec8:	61 e4       	ldi	r22, 0x41	; 65
     eca:	46 07       	cpc	r20, r22
     ecc:	51 05       	cpc	r21, r1
     ece:	08 f0       	brcs	.+2      	; 0xed2 <LargeCap+0x1f4>
     ed0:	59 c0       	rjmp	.+178    	; 0xf84 <LargeCap+0x2a6>
     ed2:	41 c0       	rjmp	.+130    	; 0xf56 <LargeCap+0x278>

    Value = Raw;                          /* copy raw value */

    /* it seems that we got a systematic error */
    Value *= 100;
    if (Mode & FLAG_10MS) Value /= 109;   /* -9% for large cap */
     ed4:	2d e6       	ldi	r18, 0x6D	; 109
     ed6:	30 e0       	ldi	r19, 0x00	; 0
     ed8:	40 e0       	ldi	r20, 0x00	; 0
     eda:	50 e0       	ldi	r21, 0x00	; 0
     edc:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
     ee0:	06 c0       	rjmp	.+12     	; 0xeee <LargeCap+0x210>
    else Value /= 104;                    /* -4% for mid cap */
     ee2:	28 e6       	ldi	r18, 0x68	; 104
     ee4:	30 e0       	ldi	r19, 0x00	; 0
     ee6:	40 e0       	ldi	r20, 0x00	; 0
     ee8:	50 e0       	ldi	r21, 0x00	; 0
     eea:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>

    /* copy data */
    Cap->A = Probes.Pin_2;    /* pull-down probe pin */
     eee:	ed e7       	ldi	r30, 0x7D	; 125
     ef0:	f1 e0       	ldi	r31, 0x01	; 1
     ef2:	81 81       	ldd	r24, Z+1	; 0x01
     ef4:	aa 81       	ldd	r26, Y+2	; 0x02
     ef6:	bb 81       	ldd	r27, Y+3	; 0x03
     ef8:	8c 93       	st	X, r24
    Cap->B = Probes.Pin_1;    /* pull-up probe pin */
     efa:	80 81       	ld	r24, Z
     efc:	11 96       	adiw	r26, 0x01	; 1
     efe:	8c 93       	st	X, r24
     f00:	11 97       	sbiw	r26, 0x01	; 1
    Cap->Scale = Scale;       /* -9 or -6 */
     f02:	12 96       	adiw	r26, 0x02	; 2
     f04:	1c 93       	st	X, r17
     f06:	12 97       	sbiw	r26, 0x02	; 2
    Cap->Raw = Raw;
     f08:	fd 01       	movw	r30, r26
     f0a:	87 82       	std	Z+7, r8	; 0x07
     f0c:	90 86       	std	Z+8, r9	; 0x08
     f0e:	a1 86       	std	Z+9, r10	; 0x09
     f10:	b2 86       	std	Z+10, r11	; 0x0a
    Cap->Value = Value;       /* max. 4.3*10^6nF or 100*10^3킚 */ 
     f12:	13 96       	adiw	r26, 0x03	; 3
     f14:	2d 93       	st	X+, r18
     f16:	3d 93       	st	X+, r19
     f18:	4d 93       	st	X+, r20
     f1a:	5c 93       	st	X, r21
     f1c:	16 97       	sbiw	r26, 0x06	; 6
  }

  return Flag;
     f1e:	83 e0       	ldi	r24, 0x03	; 3
     f20:	55 c0       	rjmp	.+170    	; 0xfcc <LargeCap+0x2ee>

large_cap:

  /* prepare probes */
  DischargeProbes();                    /* try to discharge probes */
  if (Check.Found == COMP_ERROR) return 0;     /* skip on error */
     f22:	80 e0       	ldi	r24, 0x00	; 0
     f24:	53 c0       	rjmp	.+166    	; 0xfcc <LargeCap+0x2ee>
     f26:	89 81       	ldd	r24, Y+1	; 0x01
     f28:	51 c0       	rjmp	.+162    	; 0xfcc <LargeCap+0x2ee>
      U_Cap -= U_Zero;                  /* subtract zero offset */
    else                           /* shouldn't happen but you never know */
      U_Cap = 0;                        /* assume 0V */

    /* end loop if charging is too slow */
    if ((Pulses == 126) && (U_Cap < 75)) TempByte = 0;
     f2a:	0e 37       	cpi	r16, 0x7E	; 126
     f2c:	11 05       	cpc	r17, r1
     f2e:	09 f0       	breq	.+2      	; 0xf32 <LargeCap+0x254>
     f30:	42 cf       	rjmp	.-380    	; 0xdb6 <LargeCap+0xd8>

    /* zero offset */
    if (U_Cap > U_Zero)            /* voltage higher than zero offset */
      U_Cap -= U_Zero;                  /* subtract zero offset */
    else                           /* shouldn't happen but you never know */
      U_Cap = 0;                        /* assume 0V */
     f32:	5c 82       	std	Y+4, r5	; 0x04
     f34:	6d 82       	std	Y+5, r6	; 0x05

    /* end loop if charging is too slow */
    if ((Pulses == 126) && (U_Cap < 75)) TempByte = 0;
     f36:	d7 2c       	mov	r13, r7
    
    /* end loop if 300mV are reached */
    if (U_Cap >= 300) TempByte = 0;
     f38:	ec 81       	ldd	r30, Y+4	; 0x04
     f3a:	fd 81       	ldd	r31, Y+5	; 0x05
     f3c:	ec 32       	cpi	r30, 0x2C	; 44
     f3e:	f1 40       	sbci	r31, 0x01	; 1
     f40:	08 f0       	brcs	.+2      	; 0xf44 <LargeCap+0x266>
     f42:	41 cf       	rjmp	.-382    	; 0xdc6 <LargeCap+0xe8>
     f44:	3a cf       	rjmp	.-396    	; 0xdba <LargeCap+0xdc>
   *  check if DUT sustains the charge and get the voltage drop
   *  - run the same time as before minus the 10ms charging time
   *  - this gives us the approximation of the self-discharging
   */

  if (Flag == 3)
     f46:	39 81       	ldd	r19, Y+1	; 0x01
     f48:	33 30       	cpi	r19, 0x03	; 3
     f4a:	09 f4       	brne	.+2      	; 0xf4e <LargeCap+0x270>
     f4c:	61 cf       	rjmp	.-318    	; 0xe10 <LargeCap+0x132>
     f4e:	88 cf       	rjmp	.-240    	; 0xe60 <LargeCap+0x182>
    /* calculate voltage drop */
    if (U_Cap > U_Drop) U_Drop = U_Cap - U_Drop;
    else U_Drop = 0;

    /* if voltage drop is too large consider DUT not to be a cap */
    if (U_Drop > 100) Flag = 0;
     f50:	19 82       	std	Y+1, r1	; 0x01
     f52:	89 81       	ldd	r24, Y+1	; 0x01
     f54:	3b c0       	rjmp	.+118    	; 0xfcc <LargeCap+0x2ee>
    }

    Value = Raw;                          /* copy raw value */

    /* it seems that we got a systematic error */
    Value *= 100;
     f56:	a4 e6       	ldi	r26, 0x64	; 100
     f58:	b0 e0       	ldi	r27, 0x00	; 0
     f5a:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
   *  - ignore Config.CapZero since it's in the pF range
   */

  if (Flag == 3)
  {
    Scale = -9;                           /* factor is scaled to nF */
     f5e:	17 ef       	ldi	r17, 0xF7	; 247
     f60:	b9 cf       	rjmp	.-142    	; 0xed4 <LargeCap+0x1f6>
    }

    Value = Raw;                          /* copy raw value */

    /* it seems that we got a systematic error */
    Value *= 100;
     f62:	a4 e6       	ldi	r26, 0x64	; 100
     f64:	b0 e0       	ldi	r27, 0x00	; 0
     f66:	a5 01       	movw	r20, r10
     f68:	94 01       	movw	r18, r8
     f6a:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
   *  - ignore Config.CapZero since it's in the pF range
   */

  if (Flag == 3)
  {
    Scale = -9;                           /* factor is scaled to nF */
     f6e:	17 ef       	ldi	r17, 0xF7	; 247
     f70:	b8 cf       	rjmp	.-144    	; 0xee2 <LargeCap+0x204>
    /* get interpolated factor from table */
    Raw = GetFactor(U_Cap + U_Drop, TABLE_LARGE_CAP);
    Raw *= Pulses;                        /* C = pulses * factor */
    if (Mode & FLAG_10MS) Raw *= 10;      /* *10 for 10ms charging pulses */

    if (Raw > (UINT32_MAX / 1000))        /* scale down if C >4.3mF */
     f72:	48 e3       	ldi	r20, 0x38	; 56
     f74:	84 16       	cp	r8, r20
     f76:	49 e8       	ldi	r20, 0x89	; 137
     f78:	94 06       	cpc	r9, r20
     f7a:	41 e4       	ldi	r20, 0x41	; 65
     f7c:	a4 06       	cpc	r10, r20
     f7e:	b1 04       	cpc	r11, r1
     f80:	98 f4       	brcc	.+38     	; 0xfa8 <LargeCap+0x2ca>
     f82:	ef cf       	rjmp	.-34     	; 0xf62 <LargeCap+0x284>
    {
      Raw /= 1000;                        /* scale down by 10^3 */
     f84:	ca 01       	movw	r24, r20
     f86:	b9 01       	movw	r22, r18
     f88:	28 ee       	ldi	r18, 0xE8	; 232
     f8a:	33 e0       	ldi	r19, 0x03	; 3
     f8c:	40 e0       	ldi	r20, 0x00	; 0
     f8e:	50 e0       	ldi	r21, 0x00	; 0
     f90:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
     f94:	82 2e       	mov	r8, r18
     f96:	93 2e       	mov	r9, r19
     f98:	a4 2e       	mov	r10, r20
     f9a:	b5 2e       	mov	r11, r21
    }

    Value = Raw;                          /* copy raw value */

    /* it seems that we got a systematic error */
    Value *= 100;
     f9c:	a4 e6       	ldi	r26, 0x64	; 100
     f9e:	b0 e0       	ldi	r27, 0x00	; 0
     fa0:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
    if (Mode & FLAG_10MS) Raw *= 10;      /* *10 for 10ms charging pulses */

    if (Raw > (UINT32_MAX / 1000))        /* scale down if C >4.3mF */
    {
      Raw /= 1000;                        /* scale down by 10^3 */
      Scale += 3;                         /* add 3 to the exponent */
     fa4:	1a ef       	ldi	r17, 0xFA	; 250
     fa6:	96 cf       	rjmp	.-212    	; 0xed4 <LargeCap+0x1f6>
    Raw *= Pulses;                        /* C = pulses * factor */
    if (Mode & FLAG_10MS) Raw *= 10;      /* *10 for 10ms charging pulses */

    if (Raw > (UINT32_MAX / 1000))        /* scale down if C >4.3mF */
    {
      Raw /= 1000;                        /* scale down by 10^3 */
     fa8:	c5 01       	movw	r24, r10
     faa:	b4 01       	movw	r22, r8
     fac:	28 ee       	ldi	r18, 0xE8	; 232
     fae:	33 e0       	ldi	r19, 0x03	; 3
     fb0:	40 e0       	ldi	r20, 0x00	; 0
     fb2:	50 e0       	ldi	r21, 0x00	; 0
     fb4:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
     fb8:	82 2e       	mov	r8, r18
     fba:	93 2e       	mov	r9, r19
     fbc:	a4 2e       	mov	r10, r20
     fbe:	b5 2e       	mov	r11, r21
    }

    Value = Raw;                          /* copy raw value */

    /* it seems that we got a systematic error */
    Value *= 100;
     fc0:	a4 e6       	ldi	r26, 0x64	; 100
     fc2:	b0 e0       	ldi	r27, 0x00	; 0
     fc4:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
    if (Mode & FLAG_10MS) Raw *= 10;      /* *10 for 10ms charging pulses */

    if (Raw > (UINT32_MAX / 1000))        /* scale down if C >4.3mF */
    {
      Raw /= 1000;                        /* scale down by 10^3 */
      Scale += 3;                         /* add 3 to the exponent */
     fc8:	1a ef       	ldi	r17, 0xFA	; 250
     fca:	8b cf       	rjmp	.-234    	; 0xee2 <LargeCap+0x204>
    Cap->Raw = Raw;
    Cap->Value = Value;       /* max. 4.3*10^6nF or 100*10^3킚 */ 
  }

  return Flag;
}
     fcc:	0f 90       	pop	r0
     fce:	0f 90       	pop	r0
     fd0:	0f 90       	pop	r0
     fd2:	0f 90       	pop	r0
     fd4:	0f 90       	pop	r0
     fd6:	df 91       	pop	r29
     fd8:	cf 91       	pop	r28
     fda:	1f 91       	pop	r17
     fdc:	0f 91       	pop	r16
     fde:	ff 90       	pop	r15
     fe0:	ef 90       	pop	r14
     fe2:	df 90       	pop	r13
     fe4:	cf 90       	pop	r12
     fe6:	bf 90       	pop	r11
     fe8:	af 90       	pop	r10
     fea:	9f 90       	pop	r9
     fec:	8f 90       	pop	r8
     fee:	7f 90       	pop	r7
     ff0:	6f 90       	pop	r6
     ff2:	5f 90       	pop	r5
     ff4:	4f 90       	pop	r4
     ff6:	3f 90       	pop	r3
     ff8:	2f 90       	pop	r2
     ffa:	08 95       	ret

00000ffc <SmallCap>:
 *  - 1 if capacitance is too high
 *  - 0 on any problem
 */

uint8_t SmallCap(Capacitor_Type *Cap)
{
     ffc:	8f 92       	push	r8
     ffe:	9f 92       	push	r9
    1000:	af 92       	push	r10
    1002:	bf 92       	push	r11
    1004:	cf 92       	push	r12
    1006:	df 92       	push	r13
    1008:	ef 92       	push	r14
    100a:	ff 92       	push	r15
    100c:	0f 93       	push	r16
    100e:	1f 93       	push	r17
    1010:	cf 93       	push	r28
    1012:	df 93       	push	r29
    1014:	4c 01       	movw	r8, r24
  /*
   *  init hardware
   */

  /* prepare probes */
  DischargeProbes();                    /* try to discharge probes */
    1016:	0e 94 64 18 	call	0x30c8	; 0x30c8 <DischargeProbes>
  if (Check.Found == COMP_ERROR) return 0;     /* skip on error */
    101a:	80 91 01 01 	lds	r24, 0x0101
    101e:	81 30       	cpi	r24, 0x01	; 1
    1020:	09 f4       	brne	.+2      	; 0x1024 <SmallCap+0x28>
    1022:	20 c1       	rjmp	.+576    	; 0x1264 <SmallCap+0x268>

  /* set probes: Gnd -- all probes / Gnd -- Rh -- probe-1 */
  R_PORT = 0;                           /* set resistor port to low */
    1024:	15 b8       	out	0x05, r1	; 5
  /* set ADC probe pins to output mode */
  ADC_DDR = (1 << TP1) | (1 << TP2) | (1 << TP3);
    1026:	87 e0       	ldi	r24, 0x07	; 7
    1028:	87 b9       	out	0x07, r24	; 7
  ADC_PORT = 0;                         /* set ADC port to low */
    102a:	18 b8       	out	0x08, r1	; 8
  R_DDR = Probes.Rh_1;                  /* pull-down probe-1 via Rh */
    102c:	cd e7       	ldi	r28, 0x7D	; 125
    102e:	d1 e0       	ldi	r29, 0x01	; 1
    1030:	8c 81       	ldd	r24, Y+4	; 0x04
    1032:	84 b9       	out	0x04, r24	; 4

  /* setup analog comparator */
  ADCSRB = (1 << ACME);                 /* use ADC multiplexer as negative input */
    1034:	80 e4       	ldi	r24, 0x40	; 64
    1036:	80 93 7b 00 	sts	0x007B, r24
  ACSR =  (1 << ACBG) | (1 << ACIC);    /* use bandgap as positive input, trigger timer1 */
    103a:	84 e4       	ldi	r24, 0x44	; 68
    103c:	80 bf       	out	0x30, r24	; 48
  ADMUX = (1 << REFS0) | Probes.Pin_1;  /* switch ADC multiplexer to probe 1 */
    103e:	88 81       	ld	r24, Y
    1040:	80 64       	ori	r24, 0x40	; 64
    1042:	80 93 7c 00 	sts	0x007C, r24
                                        /* and set AREF to Vcc */
  ADCSRA = ADC_CLOCK_DIV;               /* disable ADC, but keep clock dividers */
    1046:	83 e0       	ldi	r24, 0x03	; 3
    1048:	80 93 7a 00 	sts	0x007A, r24
  wait200us();
    104c:	0e 94 83 00 	call	0x106	; 0x106 <wait200us>

  /* setup timer */
  TCCR1A = 0;                           /* set default mode */
    1050:	10 92 80 00 	sts	0x0080, r1
  TCCR1B = 0;                           /* set more timer modes */
    1054:	10 92 81 00 	sts	0x0081, r1
  /* timer stopped, falling edge detection, noise canceler disabled */
  TCNT1 = 0;                            /* set Counter1 to 0 */
    1058:	10 92 85 00 	sts	0x0085, r1
    105c:	10 92 84 00 	sts	0x0084, r1
  /* clear all flags (input capture, compare A & B, overflow */
  TIFR1 = (1 << ICF1) | (1 << OCF1B) | (1 << OCF1A) | (1 << TOV1);
    1060:	87 e2       	ldi	r24, 0x27	; 39
    1062:	86 bb       	out	0x16, r24	; 22
  R_PORT = Probes.Rh_1;                 /* pull-up probe-1 via Rh */  
    1064:	8c 81       	ldd	r24, Y+4	; 0x04
    1066:	85 b9       	out	0x05, r24	; 5
                                        
  /* enable timer */
  if (Check.Found == COMP_FET)
    1068:	80 91 01 01 	lds	r24, 0x0101
    106c:	86 31       	cpi	r24, 0x16	; 22
    106e:	61 f4       	brne	.+24     	; 0x1088 <SmallCap+0x8c>
  {
    /* keep all probe pins pulled down but probe-1 */
    TempByte = (((1 << TP1) | (1 << TP2) | (1 << TP3)) & ~(1 << Probes.Pin_1));    
    1070:	81 e0       	ldi	r24, 0x01	; 1
    1072:	90 e0       	ldi	r25, 0x00	; 0
    1074:	00 90 7d 01 	lds	r0, 0x017D
    1078:	02 c0       	rjmp	.+4      	; 0x107e <SmallCap+0x82>
    107a:	88 0f       	add	r24, r24
    107c:	99 1f       	adc	r25, r25
    107e:	0a 94       	dec	r0
    1080:	e2 f7       	brpl	.-8      	; 0x107a <SmallCap+0x7e>
    1082:	80 95       	com	r24
    1084:	87 70       	andi	r24, 0x07	; 7
    1086:	02 c0       	rjmp	.+4      	; 0x108c <SmallCap+0x90>
  }
  else
  {
    TempByte = Probes.ADC_2;            /* keep just probe-1 pulled down */
    1088:	80 91 87 01 	lds	r24, 0x0187
  }

  /* start timer by setting clock prescaler (1/1 clock divider) */
  TCCR1B = (1 << CS10);
    108c:	91 e0       	ldi	r25, 0x01	; 1
    108e:	90 93 81 00 	sts	0x0081, r25
  ADC_DDR = TempByte;                   /* start charging DUT */
    1092:	87 b9       	out	0x07, r24	; 7
   *  Remark:
   *  The analog comparator has an Input Leakage Current of -50nA up to 50nA 
   *  at Vcc/2. The Input Offset is <10mV at Vcc/2.
   */

  Ticks2 = 0;                           /* reset timer overflow counter */
    1094:	e1 2c       	mov	r14, r1
    1096:	f1 2c       	mov	r15, r1

     /* detect timer overflow by checking the overflow flag */
     if (TempByte & (1 << TOV1))
     {
       /* happens at 65.536ms for 1MHz or 8.192ms for 8MHz */
       TIFR1 = (1 << TOV1);             /* reset flag */
    1098:	81 e0       	ldi	r24, 0x01	; 1
   *  - detect timer overflows
   */

   while (1)
   {
     TempByte = TIFR1;                  /* get timer1 flags */
    109a:	96 b3       	in	r25, 0x16	; 22

     /* end loop if input capture flag is set (= same voltage) */
     if (TempByte & (1 << ICF1)) break;
    109c:	95 fd       	sbrc	r25, 5
    109e:	0c c0       	rjmp	.+24     	; 0x10b8 <SmallCap+0xbc>

     /* detect timer overflow by checking the overflow flag */
     if (TempByte & (1 << TOV1))
    10a0:	90 ff       	sbrs	r25, 0
    10a2:	fb cf       	rjmp	.-10     	; 0x109a <SmallCap+0x9e>
     {
       /* happens at 65.536ms for 1MHz or 8.192ms for 8MHz */
       TIFR1 = (1 << TOV1);             /* reset flag */
    10a4:	86 bb       	out	0x16, r24	; 22
       wdt_reset();                     /* reset watchdog */
    10a6:	a8 95       	wdr
       Ticks2++;                        /* increase overflow counter */
    10a8:	2f ef       	ldi	r18, 0xFF	; 255
    10aa:	e2 1a       	sub	r14, r18
    10ac:	f2 0a       	sbc	r15, r18

       /* end loop if charging takes too long (13.1s) */
       if (Ticks2 == (CPU_FREQ / 5000)) break;
    10ae:	98 ec       	ldi	r25, 0xC8	; 200
    10b0:	e9 16       	cp	r14, r25
    10b2:	f1 04       	cpc	r15, r1
    10b4:	91 f7       	brne	.-28     	; 0x109a <SmallCap+0x9e>
    10b6:	de c0       	rjmp	.+444    	; 0x1274 <SmallCap+0x278>
     }
   }

  /* stop counter */
  TCCR1B = 0;                           /* stop timer */
    10b8:	10 92 81 00 	sts	0x0081, r1
  TIFR1 = (1 << ICF1);                  /* reset Input Capture flag */
    10bc:	80 e2       	ldi	r24, 0x20	; 32
    10be:	86 bb       	out	0x16, r24	; 22

  Ticks = ICR1;                         /* get counter value */
    10c0:	c0 90 86 00 	lds	r12, 0x0086
    10c4:	d0 90 87 00 	lds	r13, 0x0087

  /* disable charging */
  R_DDR = 0;                  /* set resistor port to HiZ mode */
    10c8:	14 b8       	out	0x04, r1	; 4

  /* catch missed timer overflow */
  if ((TCNT1 > Ticks) && (TempByte & (1 << TOV1)))
    10ca:	20 91 84 00 	lds	r18, 0x0084
    10ce:	30 91 85 00 	lds	r19, 0x0085
    10d2:	c2 16       	cp	r12, r18
    10d4:	d3 06       	cpc	r13, r19
    10d6:	38 f4       	brcc	.+14     	; 0x10e6 <SmallCap+0xea>
    10d8:	90 ff       	sbrs	r25, 0
    10da:	05 c0       	rjmp	.+10     	; 0x10e6 <SmallCap+0xea>
  {
    TIFR1 = (1 << TOV1);                /* reset overflow flag */
    10dc:	81 e0       	ldi	r24, 0x01	; 1
    10de:	86 bb       	out	0x16, r24	; 22
    Ticks2++;                           /* increase overflow counter */
    10e0:	af ef       	ldi	r26, 0xFF	; 255
    10e2:	ea 1a       	sub	r14, r26
    10e4:	fa 0a       	sbc	r15, r26
  }

  /* enable ADC again */
  ADCSRA = (1 << ADEN) | (1 << ADIF) | ADC_CLOCK_DIV;
    10e6:	83 e9       	ldi	r24, 0x93	; 147
    10e8:	80 93 7a 00 	sts	0x007A, r24

  /* get voltage of DUT */
  U_c = ReadU(Probes.Pin_1);       /* get voltage of cap */
    10ec:	cd e7       	ldi	r28, 0x7D	; 125
    10ee:	d1 e0       	ldi	r29, 0x01	; 1
    10f0:	88 81       	ld	r24, Y
    10f2:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    10f6:	8c 01       	movw	r16, r24

  /* start discharging DUT */
  R_PORT = 0;                      /* pull down probe-2 via Rh */
    10f8:	15 b8       	out	0x05, r1	; 5
  R_DDR = Probes.Rh_1;             /* enable Rh for probe-1 again */
    10fa:	8c 81       	ldd	r24, Y+4	; 0x04
    10fc:	84 b9       	out	0x04, r24	; 4

  /* skip measurement if charging took too long */
  if (Ticks2 >= (CPU_FREQ / 5000)) Flag = 1;
    10fe:	b8 ec       	ldi	r27, 0xC8	; 200
    1100:	eb 16       	cp	r14, r27
    1102:	f1 04       	cpc	r15, r1
    1104:	08 f4       	brcc	.+2      	; 0x1108 <SmallCap+0x10c>
    1106:	c8 c0       	rjmp	.+400    	; 0x1298 <SmallCap+0x29c>
    1108:	af c0       	rjmp	.+350    	; 0x1268 <SmallCap+0x26c>
  if (Flag == 3)
  {
    /*  combine both counter values */
    Raw = (uint32_t)Ticks;                /* set lower 16 bits */
    Raw |= (uint32_t)Ticks2 << 16;        /* set upper 16 bits */
    if (Raw > 2) Raw -= 2;                /* subtract processing time overhead */
    110a:	c2 e0       	ldi	r28, 0x02	; 2
    110c:	cc 1a       	sub	r12, r28
    110e:	d1 08       	sbc	r13, r1
    1110:	e1 08       	sbc	r14, r1
    1112:	f1 08       	sbc	r15, r1

    Scale = -12;                          /* default factor is for pF scale */
    if (Raw > (UINT32_MAX / 1000))        /* prevent overflow (4.3*10^6) */
    1114:	d8 e3       	ldi	r29, 0x38	; 56
    1116:	cd 16       	cp	r12, r29
    1118:	d9 e8       	ldi	r29, 0x89	; 137
    111a:	dd 06       	cpc	r13, r29
    111c:	d1 e4       	ldi	r29, 0x41	; 65
    111e:	ed 06       	cpc	r14, r29
    1120:	f1 04       	cpc	r15, r1
    1122:	08 f4       	brcc	.+2      	; 0x1126 <SmallCap+0x12a>
    1124:	d0 c0       	rjmp	.+416    	; 0x12c6 <SmallCap+0x2ca>
    {
      Raw /= 1000;                        /* scale down by 10^3 */
    1126:	c7 01       	movw	r24, r14
    1128:	b6 01       	movw	r22, r12
    112a:	28 ee       	ldi	r18, 0xE8	; 232
    112c:	33 e0       	ldi	r19, 0x03	; 3
    112e:	40 e0       	ldi	r20, 0x00	; 0
    1130:	50 e0       	ldi	r21, 0x00	; 0
    1132:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    1136:	69 01       	movw	r12, r18
    1138:	7a 01       	movw	r14, r20
      Scale += 3;                         /* add 3 to the exponent (nF) */
    }

    /* multiply with factor from table */
    Raw *= GetFactor(Config.Bandgap + Config.CompOffset, TABLE_SMALL_CAP);
    113a:	ee e8       	ldi	r30, 0x8E	; 142
    113c:	f1 e0       	ldi	r31, 0x01	; 1
    113e:	21 89       	ldd	r18, Z+17	; 0x11
    1140:	85 81       	ldd	r24, Z+5	; 0x05
    1142:	96 81       	ldd	r25, Z+6	; 0x06
    1144:	61 e0       	ldi	r22, 0x01	; 1
    1146:	82 0f       	add	r24, r18
    1148:	91 1d       	adc	r25, r1
    114a:	27 fd       	sbrc	r18, 7
    114c:	9a 95       	dec	r25
    114e:	0e 94 4c 19 	call	0x3298	; 0x3298 <GetFactor>
    1152:	dc 01       	movw	r26, r24
    1154:	a7 01       	movw	r20, r14
    1156:	96 01       	movw	r18, r12
    1158:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>

    /* divide by CPU frequency to get the time and multiply with table scale */
    Raw /= (CPU_FREQ / 10000);
    115c:	24 e6       	ldi	r18, 0x64	; 100
    115e:	30 e0       	ldi	r19, 0x00	; 0
    1160:	40 e0       	ldi	r20, 0x00	; 0
    1162:	50 e0       	ldi	r21, 0x00	; 0
    1164:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
        Value = 0;                        /* set value to 0 */
      }
    }

    /* copy data */
    Cap->A = Probes.Pin_2;    /* pull-down probe pin */
    1168:	ed e7       	ldi	r30, 0x7D	; 125
    116a:	f1 e0       	ldi	r31, 0x01	; 1
    116c:	81 81       	ldd	r24, Z+1	; 0x01
    116e:	d4 01       	movw	r26, r8
    1170:	8c 93       	st	X, r24
    Cap->B = Probes.Pin_1;    /* pull-up probe pin */
    1172:	80 81       	ld	r24, Z
    1174:	11 96       	adiw	r26, 0x01	; 1
    1176:	8c 93       	st	X, r24
    1178:	11 97       	sbiw	r26, 0x01	; 1
    Cap->Scale = Scale;       /* -12 or -9 */
    117a:	87 ef       	ldi	r24, 0xF7	; 247
    117c:	12 96       	adiw	r26, 0x02	; 2
    117e:	8c 93       	st	X, r24
    Cap->Raw = Raw;
    1180:	e4 01       	movw	r28, r8
    1182:	2f 83       	std	Y+7, r18	; 0x07
    1184:	38 87       	std	Y+8, r19	; 0x08
    1186:	49 87       	std	Y+9, r20	; 0x09
    1188:	5a 87       	std	Y+10, r21	; 0x0a
    Cap->Value = Value;       /* max. 5.1*10^6pF or 125*10^3nF */
    118a:	2b 83       	std	Y+3, r18	; 0x03
    118c:	3c 83       	std	Y+4, r19	; 0x04
    118e:	4d 83       	std	Y+5, r20	; 0x05
    1190:	5e 83       	std	Y+6, r21	; 0x06
     *  should keep the voltage stable long enough for the measurements. 
     *  Changed offsets will be used in next test run.
     */

    if (((Scale == -12) && (Value >= 100000)) ||
        ((Scale == -9) && (Value <= 20000)))
    1192:	21 32       	cpi	r18, 0x21	; 33
    1194:	3e 44       	sbci	r19, 0x4E	; 78
    1196:	41 05       	cpc	r20, r1
    1198:	51 05       	cpc	r21, r1
    119a:	10 f1       	brcs	.+68     	; 0x11e0 <SmallCap+0x1e4>
      /* limit offset to a valid range of -50mV - 50mV */
      if ((Offset > -50) && (Offset < 50)) Config.CompOffset = Offset;
    }
  }

  return Flag;
    119c:	83 e0       	ldi	r24, 0x03	; 3
    119e:	e1 c0       	rjmp	.+450    	; 0x1362 <SmallCap+0x366>
    /* take care about zero offset if feasable */
    if (Scale == -12)                     /* pF scale */
    {
      if (Value >= Config.CapZero)        /* if value is larger than offset */
      {
        Value -= Config.CapZero;          /* substract offset */
    11a0:	69 01       	movw	r12, r18
    11a2:	7a 01       	movw	r14, r20
    11a4:	c8 1a       	sub	r12, r24
    11a6:	d9 0a       	sbc	r13, r25
    11a8:	ea 0a       	sbc	r14, r26
    11aa:	fb 0a       	sbc	r15, r27
        Value = 0;                        /* set value to 0 */
      }
    }

    /* copy data */
    Cap->A = Probes.Pin_2;    /* pull-down probe pin */
    11ac:	ed e7       	ldi	r30, 0x7D	; 125
    11ae:	f1 e0       	ldi	r31, 0x01	; 1
    11b0:	61 81       	ldd	r22, Z+1	; 0x01
    11b2:	e4 01       	movw	r28, r8
    11b4:	68 83       	st	Y, r22
    Cap->B = Probes.Pin_1;    /* pull-up probe pin */
    11b6:	60 81       	ld	r22, Z
    11b8:	69 83       	std	Y+1, r22	; 0x01
    Cap->Scale = Scale;       /* -12 or -9 */
    11ba:	64 ef       	ldi	r22, 0xF4	; 244
    11bc:	6a 83       	std	Y+2, r22	; 0x02
    Cap->Raw = Raw;
    11be:	2f 83       	std	Y+7, r18	; 0x07
    11c0:	38 87       	std	Y+8, r19	; 0x08
    11c2:	49 87       	std	Y+9, r20	; 0x09
    11c4:	5a 87       	std	Y+10, r21	; 0x0a
    Cap->Value = Value;       /* max. 5.1*10^6pF or 125*10^3nF */
    11c6:	cb 82       	std	Y+3, r12	; 0x03
    11c8:	dc 82       	std	Y+4, r13	; 0x04
    11ca:	ed 82       	std	Y+5, r14	; 0x05
    11cc:	fe 82       	std	Y+6, r15	; 0x06
     *  bandgap reference if C is 100nF up to 20킚. The minimum of 100nF
     *  should keep the voltage stable long enough for the measurements. 
     *  Changed offsets will be used in next test run.
     */

    if (((Scale == -12) && (Value >= 100000)) ||
    11ce:	d0 ea       	ldi	r29, 0xA0	; 160
    11d0:	cd 16       	cp	r12, r29
    11d2:	d6 e8       	ldi	r29, 0x86	; 134
    11d4:	dd 06       	cpc	r13, r29
    11d6:	d1 e0       	ldi	r29, 0x01	; 1
    11d8:	ed 06       	cpc	r14, r29
    11da:	f1 04       	cpc	r15, r1
    11dc:	08 f4       	brcc	.+2      	; 0x11e0 <SmallCap+0x1e4>
    11de:	46 c0       	rjmp	.+140    	; 0x126c <SmallCap+0x270>
       *  by measuring a voltage lower than the bandgap reference, one time
       *  with the bandgap as reference and a second time with Vcc as
       *  reference. The common voltage source is the cap we just measured.
       */

       while (ReadU(Probes.Pin_1) > 980)
    11e0:	cd e7       	ldi	r28, 0x7D	; 125
    11e2:	d1 e0       	ldi	r29, 0x01	; 1
    11e4:	88 81       	ld	r24, Y
    11e6:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    11ea:	85 3d       	cpi	r24, 0xD5	; 213
    11ec:	93 40       	sbci	r25, 0x03	; 3
    11ee:	d0 f7       	brcc	.-12     	; 0x11e4 <SmallCap+0x1e8>
       {
         /* keep discharging */
       }

       R_DDR = 0;                       /* stop discharging */
    11f0:	14 b8       	out	0x04, r1	; 4

       Config.AutoScale = 0;            /* disable auto scaling */
    11f2:	0f 2e       	mov	r0, r31
    11f4:	fe e8       	ldi	r31, 0x8E	; 142
    11f6:	cf 2e       	mov	r12, r31
    11f8:	f1 e0       	ldi	r31, 0x01	; 1
    11fa:	df 2e       	mov	r13, r31
    11fc:	f0 2d       	mov	r31, r0
    11fe:	d6 01       	movw	r26, r12
    1200:	13 96       	adiw	r26, 0x03	; 3
    1202:	1c 92       	st	X, r1
       Ticks = ReadU(Probes.Pin_1);     /* U_c with Vcc reference */
    1204:	cd e7       	ldi	r28, 0x7D	; 125
    1206:	d1 e0       	ldi	r29, 0x01	; 1
    1208:	88 81       	ld	r24, Y
    120a:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    120e:	7c 01       	movw	r14, r24
       Config.AutoScale = 1;            /* enable auto scaling again */
    1210:	81 e0       	ldi	r24, 0x01	; 1
    1212:	f6 01       	movw	r30, r12
    1214:	83 83       	std	Z+3, r24	; 0x03
       Ticks2 = ReadU(Probes.Pin_1);    /* U_c with bandgap reference */
    1216:	88 81       	ld	r24, Y
    1218:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    121c:	ac 01       	movw	r20, r24

       R_DDR = Probes.Rh_1;             /* resume discharging */
    121e:	8c 81       	ldd	r24, Y+4	; 0x04
    1220:	84 b9       	out	0x04, r24	; 4

       Offset = Ticks - Ticks2;
    1222:	d7 01       	movw	r26, r14
    1224:	a4 1b       	sub	r26, r20
    1226:	b5 0b       	sbc	r27, r21
       /* allow some offset caused by the different voltage resolutions
          (4.88 vs. 1.07) */
       if ((Offset < -4) || (Offset > 4))    /* offset too large */
    1228:	cd 01       	movw	r24, r26
    122a:	04 96       	adiw	r24, 0x04	; 4
    122c:	09 97       	sbiw	r24, 0x09	; 9
    122e:	58 f0       	brcs	.+22     	; 0x1246 <SmallCap+0x24a>
          *  - first get offset per mV: Offset / U_c
          *  - total offset for U_ref: (Offset / U_c) * U_ref
          */

         TempLong = Offset;
         TempLong *= Config.Bandgap;         /* * U_ref */
    1230:	e6 01       	movw	r28, r12
    1232:	2d 81       	ldd	r18, Y+5	; 0x05
    1234:	3e 81       	ldd	r19, Y+6	; 0x06
    1236:	0e 94 96 28 	call	0x512c	; 0x512c <__usmulhisi3>
         TempLong /= Ticks2;                 /* / U_c */
    123a:	9a 01       	movw	r18, r20
    123c:	40 e0       	ldi	r20, 0x00	; 0
    123e:	50 e0       	ldi	r21, 0x00	; 0
    1240:	0e 94 62 28 	call	0x50c4	; 0x50c4 <__divmodsi4>

         Config.RefOffset = (int8_t)TempLong;
    1244:	28 8b       	std	Y+16, r18	; 0x10
       *  MCU used actually U_bandgap - U_offset. We get that offset by
       *  comparing the bandgap reference with the voltage of the cap:
       *  U_c = U_bandgap - U_offset -> U_offset = U_c - U_bandgap
       */

      Offset = U_c - Config.Bandgap;
    1246:	80 91 93 01 	lds	r24, 0x0193
    124a:	90 91 94 01 	lds	r25, 0x0194
    124e:	08 1b       	sub	r16, r24
    1250:	19 0b       	sbc	r17, r25

      /* limit offset to a valid range of -50mV - 50mV */
      if ((Offset > -50) && (Offset < 50)) Config.CompOffset = Offset;
    1252:	c8 01       	movw	r24, r16
    1254:	c1 96       	adiw	r24, 0x31	; 49
    1256:	83 36       	cpi	r24, 0x63	; 99
    1258:	91 05       	cpc	r25, r1
    125a:	50 f4       	brcc	.+20     	; 0x1270 <SmallCap+0x274>
    125c:	00 93 9f 01 	sts	0x019F, r16
    }
  }

  return Flag;
    1260:	83 e0       	ldi	r24, 0x03	; 3
    1262:	7f c0       	rjmp	.+254    	; 0x1362 <SmallCap+0x366>
   *  init hardware
   */

  /* prepare probes */
  DischargeProbes();                    /* try to discharge probes */
  if (Check.Found == COMP_ERROR) return 0;     /* skip on error */
    1264:	80 e0       	ldi	r24, 0x00	; 0
    1266:	7d c0       	rjmp	.+250    	; 0x1362 <SmallCap+0x366>
  /* start discharging DUT */
  R_PORT = 0;                      /* pull down probe-2 via Rh */
  R_DDR = Probes.Rh_1;             /* enable Rh for probe-1 again */

  /* skip measurement if charging took too long */
  if (Ticks2 >= (CPU_FREQ / 5000)) Flag = 1;
    1268:	81 e0       	ldi	r24, 0x01	; 1
    126a:	7b c0       	rjmp	.+246    	; 0x1362 <SmallCap+0x366>
      /* limit offset to a valid range of -50mV - 50mV */
      if ((Offset > -50) && (Offset < 50)) Config.CompOffset = Offset;
    }
  }

  return Flag;
    126c:	83 e0       	ldi	r24, 0x03	; 3
    126e:	79 c0       	rjmp	.+242    	; 0x1362 <SmallCap+0x366>
    1270:	83 e0       	ldi	r24, 0x03	; 3
    1272:	77 c0       	rjmp	.+238    	; 0x1362 <SmallCap+0x366>
       if (Ticks2 == (CPU_FREQ / 5000)) break;
     }
   }

  /* stop counter */
  TCCR1B = 0;                           /* stop timer */
    1274:	10 92 81 00 	sts	0x0081, r1
  TIFR1 = (1 << ICF1);                  /* reset Input Capture flag */
    1278:	80 e2       	ldi	r24, 0x20	; 32
    127a:	86 bb       	out	0x16, r24	; 22

  Ticks = ICR1;                         /* get counter value */
    127c:	c0 90 86 00 	lds	r12, 0x0086
    1280:	d0 90 87 00 	lds	r13, 0x0087

  /* disable charging */
  R_DDR = 0;                  /* set resistor port to HiZ mode */
    1284:	14 b8       	out	0x04, r1	; 4

  /* catch missed timer overflow */
  if ((TCNT1 > Ticks) && (TempByte & (1 << TOV1)))
    1286:	80 91 84 00 	lds	r24, 0x0084
    128a:	90 91 85 00 	lds	r25, 0x0085
    128e:	c8 16       	cp	r12, r24
    1290:	d9 06       	cpc	r13, r25
    1292:	08 f4       	brcc	.+2      	; 0x1296 <SmallCap+0x29a>
    1294:	23 cf       	rjmp	.-442    	; 0x10dc <SmallCap+0xe0>
    1296:	59 c0       	rjmp	.+178    	; 0x134a <SmallCap+0x34e>
   */

  if (Flag == 3)
  {
    /*  combine both counter values */
    Raw = (uint32_t)Ticks;                /* set lower 16 bits */
    1298:	c6 01       	movw	r24, r12
    129a:	a0 e0       	ldi	r26, 0x00	; 0
    129c:	b0 e0       	ldi	r27, 0x00	; 0
    Raw |= (uint32_t)Ticks2 << 16;        /* set upper 16 bits */
    129e:	a7 01       	movw	r20, r14
    12a0:	60 e0       	ldi	r22, 0x00	; 0
    12a2:	70 e0       	ldi	r23, 0x00	; 0
    12a4:	ba 01       	movw	r22, r20
    12a6:	55 27       	eor	r21, r21
    12a8:	44 27       	eor	r20, r20
    12aa:	6a 01       	movw	r12, r20
    12ac:	7b 01       	movw	r14, r22
    12ae:	c8 2a       	or	r12, r24
    12b0:	d9 2a       	or	r13, r25
    12b2:	ea 2a       	or	r14, r26
    12b4:	fb 2a       	or	r15, r27
    if (Raw > 2) Raw -= 2;                /* subtract processing time overhead */
    12b6:	f3 e0       	ldi	r31, 0x03	; 3
    12b8:	cf 16       	cp	r12, r31
    12ba:	d1 04       	cpc	r13, r1
    12bc:	e1 04       	cpc	r14, r1
    12be:	f1 04       	cpc	r15, r1
    12c0:	08 f0       	brcs	.+2      	; 0x12c4 <SmallCap+0x2c8>
    12c2:	23 cf       	rjmp	.-442    	; 0x110a <SmallCap+0x10e>
    12c4:	27 cf       	rjmp	.-434    	; 0x1114 <SmallCap+0x118>
      Raw /= 1000;                        /* scale down by 10^3 */
      Scale += 3;                         /* add 3 to the exponent (nF) */
    }

    /* multiply with factor from table */
    Raw *= GetFactor(Config.Bandgap + Config.CompOffset, TABLE_SMALL_CAP);
    12c6:	0f 2e       	mov	r0, r31
    12c8:	fe e8       	ldi	r31, 0x8E	; 142
    12ca:	af 2e       	mov	r10, r31
    12cc:	f1 e0       	ldi	r31, 0x01	; 1
    12ce:	bf 2e       	mov	r11, r31
    12d0:	f0 2d       	mov	r31, r0
    12d2:	d5 01       	movw	r26, r10
    12d4:	51 96       	adiw	r26, 0x11	; 17
    12d6:	2c 91       	ld	r18, X
    12d8:	51 97       	sbiw	r26, 0x11	; 17
    12da:	15 96       	adiw	r26, 0x05	; 5
    12dc:	8d 91       	ld	r24, X+
    12de:	9c 91       	ld	r25, X
    12e0:	16 97       	sbiw	r26, 0x06	; 6
    12e2:	61 e0       	ldi	r22, 0x01	; 1
    12e4:	82 0f       	add	r24, r18
    12e6:	91 1d       	adc	r25, r1
    12e8:	27 fd       	sbrc	r18, 7
    12ea:	9a 95       	dec	r25
    12ec:	0e 94 4c 19 	call	0x3298	; 0x3298 <GetFactor>
    12f0:	dc 01       	movw	r26, r24
    12f2:	a7 01       	movw	r20, r14
    12f4:	96 01       	movw	r18, r12
    12f6:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>

    /* divide by CPU frequency to get the time and multiply with table scale */
    Raw /= (CPU_FREQ / 10000);
    12fa:	24 e6       	ldi	r18, 0x64	; 100
    12fc:	30 e0       	ldi	r19, 0x00	; 0
    12fe:	40 e0       	ldi	r20, 0x00	; 0
    1300:	50 e0       	ldi	r21, 0x00	; 0
    1302:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    Value = Raw;                          /* take raw value */

    /* take care about zero offset if feasable */
    if (Scale == -12)                     /* pF scale */
    {
      if (Value >= Config.CapZero)        /* if value is larger than offset */
    1306:	e5 01       	movw	r28, r10
    1308:	8f 85       	ldd	r24, Y+15	; 0x0f
    130a:	90 e0       	ldi	r25, 0x00	; 0
    130c:	a0 e0       	ldi	r26, 0x00	; 0
    130e:	b0 e0       	ldi	r27, 0x00	; 0
    1310:	28 17       	cp	r18, r24
    1312:	39 07       	cpc	r19, r25
    1314:	4a 07       	cpc	r20, r26
    1316:	5b 07       	cpc	r21, r27
    1318:	08 f0       	brcs	.+2      	; 0x131c <SmallCap+0x320>
    131a:	42 cf       	rjmp	.-380    	; 0x11a0 <SmallCap+0x1a4>
        Value = 0;                        /* set value to 0 */
      }
    }

    /* copy data */
    Cap->A = Probes.Pin_2;    /* pull-down probe pin */
    131c:	ed e7       	ldi	r30, 0x7D	; 125
    131e:	f1 e0       	ldi	r31, 0x01	; 1
    1320:	81 81       	ldd	r24, Z+1	; 0x01
    1322:	d4 01       	movw	r26, r8
    1324:	8c 93       	st	X, r24
    Cap->B = Probes.Pin_1;    /* pull-up probe pin */
    1326:	80 81       	ld	r24, Z
    1328:	11 96       	adiw	r26, 0x01	; 1
    132a:	8c 93       	st	X, r24
    132c:	11 97       	sbiw	r26, 0x01	; 1
    Cap->Scale = Scale;       /* -12 or -9 */
    132e:	84 ef       	ldi	r24, 0xF4	; 244
    1330:	12 96       	adiw	r26, 0x02	; 2
    1332:	8c 93       	st	X, r24
    Cap->Raw = Raw;
    1334:	e4 01       	movw	r28, r8
    1336:	2f 83       	std	Y+7, r18	; 0x07
    1338:	38 87       	std	Y+8, r19	; 0x08
    133a:	49 87       	std	Y+9, r20	; 0x09
    133c:	5a 87       	std	Y+10, r21	; 0x0a
    Cap->Value = Value;       /* max. 5.1*10^6pF or 125*10^3nF */
    133e:	1b 82       	std	Y+3, r1	; 0x03
    1340:	1c 82       	std	Y+4, r1	; 0x04
    1342:	1d 82       	std	Y+5, r1	; 0x05
    1344:	1e 82       	std	Y+6, r1	; 0x06
      /* limit offset to a valid range of -50mV - 50mV */
      if ((Offset > -50) && (Offset < 50)) Config.CompOffset = Offset;
    }
  }

  return Flag;
    1346:	83 e0       	ldi	r24, 0x03	; 3
    1348:	0c c0       	rjmp	.+24     	; 0x1362 <SmallCap+0x366>
    TIFR1 = (1 << TOV1);                /* reset overflow flag */
    Ticks2++;                           /* increase overflow counter */
  }

  /* enable ADC again */
  ADCSRA = (1 << ADEN) | (1 << ADIF) | ADC_CLOCK_DIV;
    134a:	83 e9       	ldi	r24, 0x93	; 147
    134c:	80 93 7a 00 	sts	0x007A, r24

  /* get voltage of DUT */
  U_c = ReadU(Probes.Pin_1);       /* get voltage of cap */
    1350:	cd e7       	ldi	r28, 0x7D	; 125
    1352:	d1 e0       	ldi	r29, 0x01	; 1
    1354:	88 81       	ld	r24, Y
    1356:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>

  /* start discharging DUT */
  R_PORT = 0;                      /* pull down probe-2 via Rh */
    135a:	15 b8       	out	0x05, r1	; 5
  R_DDR = Probes.Rh_1;             /* enable Rh for probe-1 again */
    135c:	8c 81       	ldd	r24, Y+4	; 0x04
    135e:	84 b9       	out	0x04, r24	; 4

  /* skip measurement if charging took too long */
  if (Ticks2 >= (CPU_FREQ / 5000)) Flag = 1;
    1360:	81 e0       	ldi	r24, 0x01	; 1
      if ((Offset > -50) && (Offset < 50)) Config.CompOffset = Offset;
    }
  }

  return Flag;
}
    1362:	df 91       	pop	r29
    1364:	cf 91       	pop	r28
    1366:	1f 91       	pop	r17
    1368:	0f 91       	pop	r16
    136a:	ff 90       	pop	r15
    136c:	ef 90       	pop	r14
    136e:	df 90       	pop	r13
    1370:	cf 90       	pop	r12
    1372:	bf 90       	pop	r11
    1374:	af 90       	pop	r10
    1376:	9f 90       	pop	r9
    1378:	8f 90       	pop	r8
    137a:	08 95       	ret

0000137c <MeasureCap>:
 *  - Probe2: ID of probe to be pulled down [0-2]
 *  - ID: capacitor ID [0-2]
 */

void MeasureCap(uint8_t Probe1, uint8_t Probe2, uint8_t ID)
{
    137c:	5f 92       	push	r5
    137e:	6f 92       	push	r6
    1380:	7f 92       	push	r7
    1382:	8f 92       	push	r8
    1384:	9f 92       	push	r9
    1386:	af 92       	push	r10
    1388:	bf 92       	push	r11
    138a:	cf 92       	push	r12
    138c:	df 92       	push	r13
    138e:	ef 92       	push	r14
    1390:	ff 92       	push	r15
    1392:	0f 93       	push	r16
    1394:	1f 93       	push	r17
    1396:	cf 93       	push	r28
    1398:	df 93       	push	r29
   *  init
   */

  /* reset cap data */
  Cap = &Caps[ID];
  Cap->A = 0;
    139a:	c4 2e       	mov	r12, r20
    139c:	d1 2c       	mov	r13, r1
    139e:	9b e0       	ldi	r25, 0x0B	; 11
    13a0:	49 9f       	mul	r20, r25
    13a2:	f0 01       	movw	r30, r0
    13a4:	11 24       	eor	r1, r1
    13a6:	e7 5d       	subi	r30, 0xD7	; 215
    13a8:	fe 4f       	sbci	r31, 0xFE	; 254
    13aa:	10 82       	st	Z, r1
  Cap->B = 0;
    13ac:	11 82       	std	Z+1, r1	; 0x01
  Cap->Scale = -12;           /* pF by default */
    13ae:	94 ef       	ldi	r25, 0xF4	; 244
    13b0:	92 83       	std	Z+2, r25	; 0x02
  Cap->Raw = 0;
    13b2:	17 82       	std	Z+7, r1	; 0x07
    13b4:	10 86       	std	Z+8, r1	; 0x08
    13b6:	11 86       	std	Z+9, r1	; 0x09
    13b8:	12 86       	std	Z+10, r1	; 0x0a
  Cap->Value = 0;
    13ba:	13 82       	std	Z+3, r1	; 0x03
    13bc:	14 82       	std	Z+4, r1	; 0x04
    13be:	15 82       	std	Z+5, r1	; 0x05
    13c0:	16 82       	std	Z+6, r1	; 0x06

  if (Check.Found == COMP_ERROR) return;    /* skip check on any error */
    13c2:	90 91 01 01 	lds	r25, 0x0101
    13c6:	91 30       	cpi	r25, 0x01	; 1
    13c8:	09 f4       	brne	.+2      	; 0x13cc <MeasureCap+0x50>
    13ca:	bc c0       	rjmp	.+376    	; 0x1544 <MeasureCap+0x1c8>
    13cc:	c6 2f       	mov	r28, r22
    13ce:	d8 2f       	mov	r29, r24
  /*
   *  Normaly we would skip resistors, but a resistor < 10 Ohms could be
   *  also a large cap.
   */

  if (Check.Found == COMP_RESISTOR)
    13d0:	9a 30       	cpi	r25, 0x0A	; 10
    13d2:	09 f0       	breq	.+2      	; 0x13d6 <MeasureCap+0x5a>
    13d4:	4c c0       	rjmp	.+152    	; 0x146e <MeasureCap+0xf2>
  {
    Resistor = &Resistors[0];         /* pointer to first resistor */
    TempByte = 0;

    while (TempByte < Check.Resistors)       /* loop through all resistors */
    13d6:	80 91 03 01 	lds	r24, 0x0103
    13da:	88 23       	and	r24, r24
    13dc:	09 f4       	brne	.+2      	; 0x13e0 <MeasureCap+0x64>
    13de:	b2 c0       	rjmp	.+356    	; 0x1544 <MeasureCap+0x1c8>
    13e0:	0f 2e       	mov	r0, r31
    13e2:	f9 e0       	ldi	r31, 0x09	; 9
    13e4:	af 2e       	mov	r10, r31
    13e6:	f1 e0       	ldi	r31, 0x01	; 1
    13e8:	bf 2e       	mov	r11, r31
    13ea:	f0 2d       	mov	r31, r0
    13ec:	0f 2e       	mov	r0, r31
    13ee:	fa e0       	ldi	r31, 0x0A	; 10
    13f0:	8f 2e       	mov	r8, r31
    13f2:	f1 e0       	ldi	r31, 0x01	; 1
    13f4:	9f 2e       	mov	r9, r31
    13f6:	f0 2d       	mov	r31, r0
    13f8:	f1 2c       	mov	r15, r1
      if (((Resistor->A == Probe1) && (Resistor->B == Probe2)) ||
          ((Resistor->A == Probe2) && (Resistor->B == Probe1)))
      {
        /* check for low value < 10 Ohms */
        if (CmpValue(Resistor->Value, Resistor->Scale, 10UL, 0) == -1)
          TempByte = 99;                /* signal low resistance and end loop */
    13fa:	0f 2e       	mov	r0, r31
    13fc:	f3 e6       	ldi	r31, 0x63	; 99
    13fe:	5f 2e       	mov	r5, r31
    1400:	f0 2d       	mov	r31, r0
  if (Check.Found == COMP_RESISTOR)
  {
    Resistor = &Resistors[0];         /* pointer to first resistor */
    TempByte = 0;

    while (TempByte < Check.Resistors)       /* loop through all resistors */
    1402:	0f 2e       	mov	r0, r31
    1404:	f0 e0       	ldi	r31, 0x00	; 0
    1406:	6f 2e       	mov	r6, r31
    1408:	f1 e0       	ldi	r31, 0x01	; 1
    140a:	7f 2e       	mov	r7, r31
    140c:	f0 2d       	mov	r31, r0
    140e:	d5 01       	movw	r26, r10
    1410:	f5 01       	movw	r30, r10
    1412:	31 97       	sbiw	r30, 0x01	; 1
    {
      /* got matching pins */
      if (((Resistor->A == Probe1) && (Resistor->B == Probe2)) ||
    1414:	80 81       	ld	r24, Z
    1416:	8d 13       	cpse	r24, r29
    1418:	04 c0       	rjmp	.+8      	; 0x1422 <MeasureCap+0xa6>
    141a:	f5 01       	movw	r30, r10
    141c:	90 81       	ld	r25, Z
    141e:	9c 17       	cp	r25, r28
    1420:	29 f0       	breq	.+10     	; 0x142c <MeasureCap+0xb0>
    1422:	8c 13       	cpse	r24, r28
    1424:	15 c0       	rjmp	.+42     	; 0x1450 <MeasureCap+0xd4>
          ((Resistor->A == Probe2) && (Resistor->B == Probe1)))
    1426:	8c 91       	ld	r24, X
    1428:	8d 13       	cpse	r24, r29
    142a:	12 c0       	rjmp	.+36     	; 0x1450 <MeasureCap+0xd4>
      {
        /* check for low value < 10 Ohms */
        if (CmpValue(Resistor->Value, Resistor->Scale, 10UL, 0) == -1)
    142c:	12 96       	adiw	r26, 0x02	; 2
    142e:	6d 91       	ld	r22, X+
    1430:	7d 91       	ld	r23, X+
    1432:	8d 91       	ld	r24, X+
    1434:	9c 91       	ld	r25, X
    1436:	15 97       	sbiw	r26, 0x05	; 5
    1438:	e1 2c       	mov	r14, r1
    143a:	0a e0       	ldi	r16, 0x0A	; 10
    143c:	10 e0       	ldi	r17, 0x00	; 0
    143e:	20 e0       	ldi	r18, 0x00	; 0
    1440:	30 e0       	ldi	r19, 0x00	; 0
    1442:	d4 01       	movw	r26, r8
    1444:	4c 91       	ld	r20, X
    1446:	0e 94 a6 24 	call	0x494c	; 0x494c <CmpValue>
    144a:	8f 3f       	cpi	r24, 0xFF	; 255
    144c:	09 f4       	brne	.+2      	; 0x1450 <MeasureCap+0xd4>
          TempByte = 99;                /* signal low resistance and end loop */
    144e:	f5 2c       	mov	r15, r5
      }

      TempByte++;      /* next one */
    1450:	f3 94       	inc	r15
    1452:	b7 e0       	ldi	r27, 0x07	; 7
    1454:	ab 0e       	add	r10, r27
    1456:	b1 1c       	adc	r11, r1
    1458:	e7 e0       	ldi	r30, 0x07	; 7
    145a:	8e 0e       	add	r8, r30
    145c:	91 1c       	adc	r9, r1
  if (Check.Found == COMP_RESISTOR)
  {
    Resistor = &Resistors[0];         /* pointer to first resistor */
    TempByte = 0;

    while (TempByte < Check.Resistors)       /* loop through all resistors */
    145e:	d3 01       	movw	r26, r6
    1460:	13 96       	adiw	r26, 0x03	; 3
    1462:	8c 91       	ld	r24, X
    1464:	f8 16       	cp	r15, r24
    1466:	98 f2       	brcs	.-90     	; 0x140e <MeasureCap+0x92>
      TempByte++;      /* next one */
      Resistor++;      /* next one */  
    }

    /* we got a valid resistor */ 
    if (TempByte != 100) return;        /* skip this one */
    1468:	b4 e6       	ldi	r27, 0x64	; 100
    146a:	fb 12       	cpse	r15, r27
    146c:	6b c0       	rjmp	.+214    	; 0x1544 <MeasureCap+0x1c8>
   *  - when Vf collides with the voltage of the capacitance measurement
   */

  Diode = &Diodes[0];         /* pointer to first diode */

  for (TempByte = 0; TempByte < Check.Diodes; TempByte++)
    146e:	30 91 04 01 	lds	r19, 0x0104
    1472:	33 23       	and	r19, r19
    1474:	b9 f0       	breq	.+46     	; 0x14a4 <MeasureCap+0x128>
    1476:	eb e4       	ldi	r30, 0x4B	; 75
    1478:	f1 e0       	ldi	r31, 0x01	; 1
    147a:	90 e0       	ldi	r25, 0x00	; 0
  {
    /* got matching pins and low threshold voltage */
    if ((Diode->C == Probe2) &&
    147c:	20 81       	ld	r18, Z
    147e:	2c 13       	cpse	r18, r28
    1480:	0d c0       	rjmp	.+26     	; 0x149c <MeasureCap+0x120>
    1482:	af 01       	movw	r20, r30
    1484:	41 50       	subi	r20, 0x01	; 1
    1486:	51 09       	sbc	r21, r1
    1488:	da 01       	movw	r26, r20
    148a:	8c 91       	ld	r24, X
    148c:	8d 13       	cpse	r24, r29
    148e:	06 c0       	rjmp	.+12     	; 0x149c <MeasureCap+0x120>
        (Diode->A == Probe1) &&
    1490:	41 81       	ldd	r20, Z+1	; 0x01
    1492:	52 81       	ldd	r21, Z+2	; 0x02
    1494:	4c 3d       	cpi	r20, 0xDC	; 220
    1496:	55 40       	sbci	r21, 0x05	; 5
    1498:	08 f4       	brcc	.+2      	; 0x149c <MeasureCap+0x120>
    149a:	54 c0       	rjmp	.+168    	; 0x1544 <MeasureCap+0x1c8>
   *  - when Vf collides with the voltage of the capacitance measurement
   */

  Diode = &Diodes[0];         /* pointer to first diode */

  for (TempByte = 0; TempByte < Check.Diodes; TempByte++)
    149c:	9f 5f       	subi	r25, 0xFF	; 255
    149e:	36 96       	adiw	r30, 0x06	; 6
    14a0:	93 13       	cpse	r25, r19
    14a2:	ec cf       	rjmp	.-40     	; 0x147c <MeasureCap+0x100>
  /*
   *  init
   */

  /* reset cap data */
  Cap = &Caps[ID];
    14a4:	8b e0       	ldi	r24, 0x0B	; 11
    14a6:	8c 9d       	mul	r24, r12
    14a8:	80 01       	movw	r16, r0
    14aa:	8d 9d       	mul	r24, r13
    14ac:	10 0d       	add	r17, r0
    14ae:	11 24       	eor	r1, r1
    14b0:	07 5d       	subi	r16, 0xD7	; 215
    14b2:	1e 4f       	sbci	r17, 0xFE	; 254

  /*
   *  run measurements
   */

  UpdateProbes(Probe1, Probe2, 0);           /* update bitmasks and probes */
    14b4:	40 e0       	ldi	r20, 0x00	; 0
    14b6:	6c 2f       	mov	r22, r28
    14b8:	8d 2f       	mov	r24, r29
    14ba:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <UpdateProbes>

  /* first run measurement for large caps */ 
  TempByte = LargeCap(Cap);
    14be:	c8 01       	movw	r24, r16
    14c0:	0e 94 6f 06 	call	0xcde	; 0xcde <LargeCap>

  /* if cap is too small run measurement for small caps */
  if (TempByte == 2)
    14c4:	82 30       	cpi	r24, 0x02	; 2
    14c6:	19 f4       	brne	.+6      	; 0x14ce <MeasureCap+0x152>
  {
    TempByte = SmallCap(Cap);
    14c8:	c8 01       	movw	r24, r16
    14ca:	0e 94 fe 07 	call	0xffc	; 0xffc <SmallCap>
   *  check for plausibility
   */

  /* if there aren't any diodes in reverse direction which could be
     detected as capacitors by mistake */
  if (Check.Diodes == 0)
    14ce:	80 91 04 01 	lds	r24, 0x0104
    14d2:	81 11       	cpse	r24, r1
    14d4:	31 c0       	rjmp	.+98     	; 0x1538 <MeasureCap+0x1bc>
  {
    /* low resistance might be a large cap */
    if (Check.Found == COMP_RESISTOR)
    14d6:	80 91 01 01 	lds	r24, 0x0101
    14da:	8a 30       	cpi	r24, 0x0A	; 10
    14dc:	79 f4       	brne	.+30     	; 0x14fc <MeasureCap+0x180>
    {
      /* report capacitor only for a large C (> 4.3킚) */
      if (Cap->Scale >= -6) Check.Found = COMP_CAPACITOR;
    14de:	8b e0       	ldi	r24, 0x0B	; 11
    14e0:	8c 9d       	mul	r24, r12
    14e2:	f0 01       	movw	r30, r0
    14e4:	8d 9d       	mul	r24, r13
    14e6:	f0 0d       	add	r31, r0
    14e8:	11 24       	eor	r1, r1
    14ea:	e7 5d       	subi	r30, 0xD7	; 215
    14ec:	fe 4f       	sbci	r31, 0xFE	; 254
    14ee:	82 81       	ldd	r24, Z+2	; 0x02
    14f0:	8a 3f       	cpi	r24, 0xFA	; 250
    14f2:	14 f1       	brlt	.+68     	; 0x1538 <MeasureCap+0x1bc>
    14f4:	8b e0       	ldi	r24, 0x0B	; 11
    14f6:	80 93 01 01 	sts	0x0101, r24
    14fa:	1e c0       	rjmp	.+60     	; 0x1538 <MeasureCap+0x1bc>
    }

    /* we consider values below 5pF being just ghosts */
    else if ((Cap->Scale > -12) || (Cap->Value >= 5UL))
    14fc:	8b e0       	ldi	r24, 0x0B	; 11
    14fe:	8c 9d       	mul	r24, r12
    1500:	f0 01       	movw	r30, r0
    1502:	8d 9d       	mul	r24, r13
    1504:	f0 0d       	add	r31, r0
    1506:	11 24       	eor	r1, r1
    1508:	e7 5d       	subi	r30, 0xD7	; 215
    150a:	fe 4f       	sbci	r31, 0xFE	; 254
    150c:	82 81       	ldd	r24, Z+2	; 0x02
    150e:	85 3f       	cpi	r24, 0xF5	; 245
    1510:	84 f4       	brge	.+32     	; 0x1532 <MeasureCap+0x1b6>
    1512:	8b e0       	ldi	r24, 0x0B	; 11
    1514:	8c 9d       	mul	r24, r12
    1516:	f0 01       	movw	r30, r0
    1518:	8d 9d       	mul	r24, r13
    151a:	f0 0d       	add	r31, r0
    151c:	11 24       	eor	r1, r1
    151e:	e7 5d       	subi	r30, 0xD7	; 215
    1520:	fe 4f       	sbci	r31, 0xFE	; 254
    1522:	83 81       	ldd	r24, Z+3	; 0x03
    1524:	94 81       	ldd	r25, Z+4	; 0x04
    1526:	a5 81       	ldd	r26, Z+5	; 0x05
    1528:	b6 81       	ldd	r27, Z+6	; 0x06
    152a:	05 97       	sbiw	r24, 0x05	; 5
    152c:	a1 05       	cpc	r26, r1
    152e:	b1 05       	cpc	r27, r1
    1530:	18 f0       	brcs	.+6      	; 0x1538 <MeasureCap+0x1bc>
    {
      Check.Found = COMP_CAPACITOR;     /* report capacitor */
    1532:	8b e0       	ldi	r24, 0x0B	; 11
    1534:	80 93 01 01 	sts	0x0101, r24

  /*
   *  clean up
   */

  DischargeProbes();               /* discharge DUT */
    1538:	0e 94 64 18 	call	0x30c8	; 0x30c8 <DischargeProbes>

  /* reset all ports and pins */
  ADC_DDR = 0;                     /* set ADC port to input */
    153c:	17 b8       	out	0x07, r1	; 7
  ADC_PORT = 0;                    /* set ADC port low */
    153e:	18 b8       	out	0x08, r1	; 8
  R_DDR = 0;                       /* set resistor port to input */
    1540:	14 b8       	out	0x04, r1	; 4
  R_PORT = 0;                      /* set resistor port low */
    1542:	15 b8       	out	0x05, r1	; 5
}
    1544:	df 91       	pop	r29
    1546:	cf 91       	pop	r28
    1548:	1f 91       	pop	r17
    154a:	0f 91       	pop	r16
    154c:	ff 90       	pop	r15
    154e:	ef 90       	pop	r14
    1550:	df 90       	pop	r13
    1552:	cf 90       	pop	r12
    1554:	bf 90       	pop	r11
    1556:	af 90       	pop	r10
    1558:	9f 90       	pop	r9
    155a:	8f 90       	pop	r8
    155c:	7f 90       	pop	r7
    155e:	6f 90       	pop	r6
    1560:	5f 90       	pop	r5
    1562:	08 95       	ret

00001564 <ToolInfo>:
/*
 *  display probe pins used
 */

void ToolInfo(const unsigned char *String)
{
    1564:	0f 93       	push	r16
    1566:	1f 93       	push	r17
    1568:	cf 93       	push	r28
    156a:	df 93       	push	r29
    156c:	8c 01       	movw	r16, r24
  uint8_t           n = 0;
  uint8_t           Key = 0;

  LCD_ClearLine2();                /* info goes to line #2 */
    156e:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <LCD_ClearLine2>
 *  display probe pins used
 */

void ToolInfo(const unsigned char *String)
{
  uint8_t           n = 0;
    1572:	d0 e0       	ldi	r29, 0x00	; 0
  LCD_ClearLine2();                /* info goes to line #2 */

  /* blink text up to three times */
  while (n <= 2)
  {
    LCD_EEString2(Probes_str);     /* show text */
    1574:	80 e2       	ldi	r24, 0x20	; 32
    1576:	91 e0       	ldi	r25, 0x01	; 1
    1578:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
    LCD_EEString(String);
    157c:	c8 01       	movw	r24, r16
    157e:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
    Key = TestKey(700, 0);         /* wait 700ms */
    1582:	60 e0       	ldi	r22, 0x00	; 0
    1584:	8c eb       	ldi	r24, 0xBC	; 188
    1586:	92 e0       	ldi	r25, 0x02	; 2
    1588:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <TestKey>
    158c:	c8 2f       	mov	r28, r24

    LCD_ClearLine2();              /* clear line #2 */
    158e:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <LCD_ClearLine2>
    if (Key == 0) Key = TestKey(300, 0);      /* wait 300ms */
    1592:	c1 11       	cpse	r28, r1
    1594:	0a c0       	rjmp	.+20     	; 0x15aa <ToolInfo+0x46>
    1596:	60 e0       	ldi	r22, 0x00	; 0
    1598:	8c e2       	ldi	r24, 0x2C	; 44
    159a:	91 e0       	ldi	r25, 0x01	; 1
    159c:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <TestKey>

    if (Key > 0) n = 3;            /* on key press end loop */
    15a0:	81 11       	cpse	r24, r1
    15a2:	03 c0       	rjmp	.+6      	; 0x15aa <ToolInfo+0x46>
    n++;                           /* next run */
    15a4:	df 5f       	subi	r29, 0xFF	; 255
  uint8_t           Key = 0;

  LCD_ClearLine2();                /* info goes to line #2 */

  /* blink text up to three times */
  while (n <= 2)
    15a6:	d3 30       	cpi	r29, 0x03	; 3
    15a8:	28 f3       	brcs	.-54     	; 0x1574 <ToolInfo+0x10>

    if (Key > 0) n = 3;            /* on key press end loop */
    n++;                           /* next run */
  }

  MilliSleep(250);                 /* smooth UI */
    15aa:	8a ef       	ldi	r24, 0xFA	; 250
    15ac:	90 e0       	ldi	r25, 0x00	; 0
    15ae:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>
}
    15b2:	df 91       	pop	r29
    15b4:	cf 91       	pop	r28
    15b6:	1f 91       	pop	r17
    15b8:	0f 91       	pop	r16
    15ba:	08 95       	ret

000015bc <PWM_Tool>:
 *  requires:
 *  - Freqency in Hz
 */

void PWM_Tool(uint16_t Frequency)
{
    15bc:	4f 92       	push	r4
    15be:	5f 92       	push	r5
    15c0:	6f 92       	push	r6
    15c2:	7f 92       	push	r7
    15c4:	8f 92       	push	r8
    15c6:	9f 92       	push	r9
    15c8:	af 92       	push	r10
    15ca:	bf 92       	push	r11
    15cc:	cf 92       	push	r12
    15ce:	df 92       	push	r13
    15d0:	ef 92       	push	r14
    15d2:	ff 92       	push	r15
    15d4:	0f 93       	push	r16
    15d6:	1f 93       	push	r17
    15d8:	cf 93       	push	r28
    15da:	df 93       	push	r29
    15dc:	6c 01       	movw	r12, r24
      8          500kHz    7.6Hz        125kHz
      64         62.5kHz   0.95Hz       15625Hz
      256        15625Hz   0.24Hz       3906.25Hz
  */

  ShortCircuit(0);                    /* make sure probes are not shorted */
    15de:	80 e0       	ldi	r24, 0x00	; 0
    15e0:	0e 94 d1 26 	call	0x4da2	; 0x4da2 <ShortCircuit>
  LCD_Clear();
    15e4:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>
  LCD_EEString2(PWM_str);             /* display: PWM */
    15e8:	84 e1       	ldi	r24, 0x14	; 20
    15ea:	91 e0       	ldi	r25, 0x01	; 1
    15ec:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
  DisplayValue(Frequency, 0, 'H');    /* display frequency */
    15f0:	e1 2c       	mov	r14, r1
    15f2:	f1 2c       	mov	r15, r1
    15f4:	28 e4       	ldi	r18, 0x48	; 72
    15f6:	40 e0       	ldi	r20, 0x00	; 0
    15f8:	c7 01       	movw	r24, r14
    15fa:	b6 01       	movw	r22, r12
    15fc:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
  LCD_Data('z');                      /* make it Hz :-) */
    1600:	8a e7       	ldi	r24, 0x7A	; 122
    1602:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
  ToolInfo(PWM_Probes_str);           /* show probes used */
    1606:	8f e0       	ldi	r24, 0x0F	; 15
    1608:	91 e0       	ldi	r25, 0x01	; 1
    160a:	0e 94 b2 0a 	call	0x1564	; 0x1564 <ToolInfo>

  /* probes 1 and 3 are signal ground, probe 2 is signal output */
  ADC_PORT = 0;                         /* pull down directly: */
    160e:	18 b8       	out	0x08, r1	; 8
  ADC_DDR = (1 << TP1) | (1 << TP3);    /* probe 1 & 3 */
    1610:	85 e0       	ldi	r24, 0x05	; 5
    1612:	87 b9       	out	0x07, r24	; 7
  R_DDR = (1 << (TP2 * 2));             /* enable Rl for probe 2 */
    1614:	84 e0       	ldi	r24, 0x04	; 4
    1616:	84 b9       	out	0x04, r24	; 4
  R_PORT = 0;                           /* pull down probe 2 initially */
    1618:	15 b8       	out	0x05, r1	; 5
   *
   *    top = f_MCU / (2 * prescaler * f_PWM)
   */

  Value = CPU_FREQ / 2;
  Value /= Frequency;
    161a:	60 e2       	ldi	r22, 0x20	; 32
    161c:	71 ea       	ldi	r23, 0xA1	; 161
    161e:	87 e0       	ldi	r24, 0x07	; 7
    1620:	90 e0       	ldi	r25, 0x00	; 0
    1622:	a7 01       	movw	r20, r14
    1624:	96 01       	movw	r18, r12
    1626:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    162a:	29 01       	movw	r4, r18
    162c:	3a 01       	movw	r6, r20
  if (Value > 2000000)        /* low frequency (<20Hz @8MHz) */
  {
    Value /= 256;
    Prescaler = (1 << CS12);                 /* 256 */
  }
  else if (Value > 16000)     /* mid-range frequency (<250Hz @8MHz) */
    162e:	21 38       	cpi	r18, 0x81	; 129
    1630:	3e 43       	sbci	r19, 0x3E	; 62
    1632:	41 05       	cpc	r20, r1
    1634:	51 05       	cpc	r21, r1
    1636:	50 f0       	brcs	.+20     	; 0x164c <PWM_Tool+0x90>
  {
    Value /= 64;
    1638:	68 94       	set
    163a:	15 f8       	bld	r1, 5
    163c:	76 94       	lsr	r7
    163e:	67 94       	ror	r6
    1640:	57 94       	ror	r5
    1642:	47 94       	ror	r4
    1644:	16 94       	lsr	r1
    1646:	d1 f7       	brne	.-12     	; 0x163c <PWM_Tool+0x80>
    Prescaler = (1 << CS11) | (1 << CS10);   /* 64 */
    1648:	23 e0       	ldi	r18, 0x03	; 3
    164a:	01 c0       	rjmp	.+2      	; 0x164e <PWM_Tool+0x92>
  }
  else                        /* high frequency */
  {
    Prescaler = (1 << CS10);                 /* 1 */
    164c:	21 e0       	ldi	r18, 0x01	; 1
   *  - top value by OCR1A
   *  - OC1B non-inverted output
   */

  Ratio = 50;                                /* default ratio is 50% */
  Toggle = (Top / 2) - 1;                    /* compare value for 50% */
    164e:	c2 01       	movw	r24, r4
    1650:	96 95       	lsr	r25
    1652:	87 95       	ror	r24
    1654:	01 97       	sbiw	r24, 0x01	; 1
  /* power save mode would disable timer1 */
  Config.SleepMode = SLEEP_MODE_IDLE;        /* change sleep mode to Idle */
    1656:	10 92 8f 01 	sts	0x018F, r1

  TCCR1B = 0;                                /* disable timer */
    165a:	e1 e8       	ldi	r30, 0x81	; 129
    165c:	f0 e0       	ldi	r31, 0x00	; 0
    165e:	10 82       	st	Z, r1
  /* enable OC1B pin and set timer mode */
  TCCR1A = (1 << WGM11) | (1 << WGM10) | (1 << COM1B1);
    1660:	33 e2       	ldi	r19, 0x23	; 35
    1662:	30 93 80 00 	sts	0x0080, r19
  TCCR1B = (1 << WGM13);
    1666:	30 e1       	ldi	r19, 0x10	; 16
    1668:	30 83       	st	Z, r19
  TCNT1 = 0;                                 /* set counter to 0 */
    166a:	10 92 85 00 	sts	0x0085, r1
    166e:	10 92 84 00 	sts	0x0084, r1
  OCR1A = Top - 1;                           /* set top value (-1) */
    1672:	a2 01       	movw	r20, r4
    1674:	41 50       	subi	r20, 0x01	; 1
    1676:	51 09       	sbc	r21, r1
    1678:	50 93 89 00 	sts	0x0089, r21
    167c:	40 93 88 00 	sts	0x0088, r20
  OCR1B = Toggle;                            /* set value to compare with */
    1680:	90 93 8b 00 	sts	0x008B, r25
    1684:	80 93 8a 00 	sts	0x008A, r24

  /* enable counter by setting clock prescaler */
  TCCR1B = (1 << WGM13) | Prescaler;
    1688:	82 2f       	mov	r24, r18
    168a:	80 61       	ori	r24, 0x10	; 16
    168c:	80 83       	st	Z, r24
   *  - phase correct PWM
   *  - top value by OCR1A
   *  - OC1B non-inverted output
   */

  Ratio = 50;                                /* default ratio is 50% */
    168e:	c2 e3       	ldi	r28, 0x32	; 50
    {
      if (Ratio >= 5) Ratio -= 5;         /* -5% and limit to 0% */
    }

    /* calculate toggle value: (top * (ratio / 100)) - 1 */
    Value = (uint32_t)Top * Ratio;
    1690:	53 01       	movw	r10, r6
    1692:	42 01       	movw	r8, r4
    1694:	aa 24       	eor	r10, r10
    1696:	bb 24       	eor	r11, r11
    Value /= 100;
    1698:	0f 2e       	mov	r0, r31
    169a:	f4 e6       	ldi	r31, 0x64	; 100
    169c:	cf 2e       	mov	r12, r31
    169e:	d1 2c       	mov	r13, r1
    16a0:	e1 2c       	mov	r14, r1
    16a2:	f1 2c       	mov	r15, r1
    16a4:	f0 2d       	mov	r31, r0
    Toggle = (uint16_t)Value;
    Toggle--;

    OCR1B = Toggle;                     /* update compare value */
    16a6:	0a e8       	ldi	r16, 0x8A	; 138
    16a8:	10 e0       	ldi	r17, 0x00	; 0
   */

  while (Test > 0)
  {
    /* show current ratio */
    LCD_ClearLine2();
    16aa:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <LCD_ClearLine2>
    DisplayValue(Ratio, 0, '%');        /* show ratio in % */
    16ae:	8c 2f       	mov	r24, r28
    16b0:	90 e0       	ldi	r25, 0x00	; 0
    16b2:	a0 e0       	ldi	r26, 0x00	; 0
    16b4:	b0 e0       	ldi	r27, 0x00	; 0
    16b6:	25 e2       	ldi	r18, 0x25	; 37
    16b8:	40 e0       	ldi	r20, 0x00	; 0
    16ba:	bc 01       	movw	r22, r24
    16bc:	cd 01       	movw	r24, r26
    16be:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
    #ifdef HW_ENCODER
    if (Test < 3)                       /* just for test button usage */
    #endif
    MilliSleep(500);                    /* smooth UI */
    16c2:	84 ef       	ldi	r24, 0xF4	; 244
    16c4:	91 e0       	ldi	r25, 0x01	; 1
    16c6:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>
        short key press -> increase ratio
        long key press -> decrease ratio
        two short key presses -> exit tool
     */

    Test = TestKey(0, 0);               /* wait for user feedback */
    16ca:	60 e0       	ldi	r22, 0x00	; 0
    16cc:	80 e0       	ldi	r24, 0x00	; 0
    16ce:	90 e0       	ldi	r25, 0x00	; 0
    16d0:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <TestKey>
    16d4:	d8 2f       	mov	r29, r24
    if (Test == 1)                      /* short key press */
    16d6:	81 30       	cpi	r24, 0x01	; 1
    16d8:	79 f4       	brne	.+30     	; 0x16f8 <PWM_Tool+0x13c>
    {
      MilliSleep(50);                   /* debounce button a little bit longer */
    16da:	82 e3       	ldi	r24, 0x32	; 50
    16dc:	90 e0       	ldi	r25, 0x00	; 0
    16de:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>
      Prescaler = TestKey(200, 0);      /* check for second key press */
    16e2:	60 e0       	ldi	r22, 0x00	; 0
    16e4:	88 ec       	ldi	r24, 0xC8	; 200
    16e6:	90 e0       	ldi	r25, 0x00	; 0
    16e8:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <TestKey>
      if (Prescaler > 0)                /* second key press */
    16ec:	81 11       	cpse	r24, r1
    16ee:	31 c0       	rjmp	.+98     	; 0x1752 <PWM_Tool+0x196>
      {
        Test = 0;                         /* end loop */
      }
      else                              /* single key press */
      {
        if (Ratio <= 95) Ratio += 5;      /* +5% and limit to 100% */
    16f0:	c0 36       	cpi	r28, 0x60	; 96
    16f2:	f8 f4       	brcc	.+62     	; 0x1732 <PWM_Tool+0x176>
    16f4:	cb 5f       	subi	r28, 0xFB	; 251
    16f6:	1d c0       	rjmp	.+58     	; 0x1732 <PWM_Tool+0x176>
      if (Ratio >= 1) Ratio -= 1;         /* -1% and limit to 0% */
    }
    #endif
    else                                /* long key press */
    {
      if (Ratio >= 5) Ratio -= 5;         /* -5% and limit to 0% */
    16f8:	c5 30       	cpi	r28, 0x05	; 5
    16fa:	08 f0       	brcs	.+2      	; 0x16fe <PWM_Tool+0x142>
    16fc:	c5 50       	subi	r28, 0x05	; 5
    }

    /* calculate toggle value: (top * (ratio / 100)) - 1 */
    Value = (uint32_t)Top * Ratio;
    16fe:	ac 2f       	mov	r26, r28
    1700:	b0 e0       	ldi	r27, 0x00	; 0
    1702:	a5 01       	movw	r20, r10
    1704:	94 01       	movw	r18, r8
    1706:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
    Value /= 100;
    170a:	a7 01       	movw	r20, r14
    170c:	96 01       	movw	r18, r12
    170e:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    Toggle = (uint16_t)Value;
    Toggle--;
    1712:	21 50       	subi	r18, 0x01	; 1
    1714:	31 09       	sbc	r19, r1

    OCR1B = Toggle;                     /* update compare value */
    1716:	f8 01       	movw	r30, r16
    1718:	31 83       	std	Z+1, r19	; 0x01
    171a:	20 83       	st	Z, r18

  /*
   *  ratio control
   */

  while (Test > 0)
    171c:	d1 11       	cpse	r29, r1
    171e:	c5 cf       	rjmp	.-118    	; 0x16aa <PWM_Tool+0xee>

    OCR1B = Toggle;                     /* update compare value */
  }

  /* clean up */
  TCCR1B = 0;                 /* disable timer */
    1720:	10 92 81 00 	sts	0x0081, r1
  TCCR1A = 0;                 /* reset flags (also frees PB2) */
    1724:	10 92 80 00 	sts	0x0080, r1
  R_DDR = 0;                  /* set HiZ mode */
    1728:	14 b8       	out	0x04, r1	; 4
  Config.SleepMode = SLEEP_MODE_PWR_SAVE;    /* reset sleep mode to default */
    172a:	86 e0       	ldi	r24, 0x06	; 6
    172c:	80 93 8f 01 	sts	0x018F, r24
    1730:	25 c0       	rjmp	.+74     	; 0x177c <PWM_Tool+0x1c0>
    {
      if (Ratio >= 5) Ratio -= 5;         /* -5% and limit to 0% */
    }

    /* calculate toggle value: (top * (ratio / 100)) - 1 */
    Value = (uint32_t)Top * Ratio;
    1732:	ac 2f       	mov	r26, r28
    1734:	b0 e0       	ldi	r27, 0x00	; 0
    1736:	a5 01       	movw	r20, r10
    1738:	94 01       	movw	r18, r8
    173a:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
    Value /= 100;
    173e:	a7 01       	movw	r20, r14
    1740:	96 01       	movw	r18, r12
    1742:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    Toggle = (uint16_t)Value;
    Toggle--;
    1746:	21 50       	subi	r18, 0x01	; 1
    1748:	31 09       	sbc	r19, r1

    OCR1B = Toggle;                     /* update compare value */
    174a:	f8 01       	movw	r30, r16
    174c:	31 83       	std	Z+1, r19	; 0x01
    174e:	20 83       	st	Z, r18
    1750:	ac cf       	rjmp	.-168    	; 0x16aa <PWM_Tool+0xee>
    {
      if (Ratio >= 5) Ratio -= 5;         /* -5% and limit to 0% */
    }

    /* calculate toggle value: (top * (ratio / 100)) - 1 */
    Value = (uint32_t)Top * Ratio;
    1752:	a3 01       	movw	r20, r6
    1754:	92 01       	movw	r18, r4
    1756:	44 27       	eor	r20, r20
    1758:	55 27       	eor	r21, r21
    175a:	ac 2f       	mov	r26, r28
    175c:	b0 e0       	ldi	r27, 0x00	; 0
    175e:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
    Value /= 100;
    1762:	24 e6       	ldi	r18, 0x64	; 100
    1764:	30 e0       	ldi	r19, 0x00	; 0
    1766:	40 e0       	ldi	r20, 0x00	; 0
    1768:	50 e0       	ldi	r21, 0x00	; 0
    176a:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    Toggle = (uint16_t)Value;
    Toggle--;
    176e:	21 50       	subi	r18, 0x01	; 1
    1770:	31 09       	sbc	r19, r1

    OCR1B = Toggle;                     /* update compare value */
    1772:	30 93 8b 00 	sts	0x008B, r19
    1776:	20 93 8a 00 	sts	0x008A, r18
    177a:	d2 cf       	rjmp	.-92     	; 0x1720 <PWM_Tool+0x164>
  /* clean up */
  TCCR1B = 0;                 /* disable timer */
  TCCR1A = 0;                 /* reset flags (also frees PB2) */
  R_DDR = 0;                  /* set HiZ mode */
  Config.SleepMode = SLEEP_MODE_PWR_SAVE;    /* reset sleep mode to default */
}
    177c:	df 91       	pop	r29
    177e:	cf 91       	pop	r28
    1780:	1f 91       	pop	r17
    1782:	0f 91       	pop	r16
    1784:	ff 90       	pop	r15
    1786:	ef 90       	pop	r14
    1788:	df 90       	pop	r13
    178a:	cf 90       	pop	r12
    178c:	bf 90       	pop	r11
    178e:	af 90       	pop	r10
    1790:	9f 90       	pop	r9
    1792:	8f 90       	pop	r8
    1794:	7f 90       	pop	r7
    1796:	6f 90       	pop	r6
    1798:	5f 90       	pop	r5
    179a:	4f 90       	pop	r4
    179c:	08 95       	ret

0000179e <ESR_Tool>:
/*
 *  ESR tool
 */

void ESR_Tool(void)
{
    179e:	0f 93       	push	r16
    17a0:	1f 93       	push	r17
    17a2:	cf 93       	push	r28
    17a4:	df 93       	push	r29
  uint8_t           Run = 1;       /* control flag */
  uint8_t           Test;          /* temp. value */
  Capacitor_Type    *Cap;          /* pointer to cap */
  uint16_t          ESR;           /* ESR (in 0.01 Ohms) */

  Check.Diodes = 0;                /* disable diode check in cap measurement */
    17a6:	10 92 04 01 	sts	0x0104, r1
  #ifdef HW_RELAY
  ADC_DDR = (1<<TP_REF);           /* short circuit probes */
  #endif

  /* show tool info */
  LCD_Clear();
    17aa:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>
  LCD_EEString(ESR_str);           /* display: ESR */
    17ae:	8c e1       	ldi	r24, 0x1C	; 28
    17b0:	91 e0       	ldi	r25, 0x01	; 1
    17b2:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
  ToolInfo(ESR_Probes_str);        /* show probes used */
    17b6:	88 e1       	ldi	r24, 0x18	; 24
    17b8:	91 e0       	ldi	r25, 0x01	; 1
    17ba:	0e 94 b2 0a 	call	0x1564	; 0x1564 <ToolInfo>
  LCD_Data('-');                   /* display "no value" */
    17be:	8d e2       	ldi	r24, 0x2D	; 45
    17c0:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
      LCD_ClearLine2();                /* update line #2 */
      LCD_EEString(Running_str);       /* display: probing... */
      MeasureCap(TP2, TP1, 0);         /* probe 2 = Gnd, probe 1 = Vcc */
      LCD_ClearLine2();                /* update line #2 */
      
      if (Check.Found == COMP_CAPACITOR)     /* found capacitor */
    17c4:	c0 e0       	ldi	r28, 0x00	; 0
    17c6:	d1 e0       	ldi	r29, 0x01	; 1
      {
        /* show capacitance */
        DisplayValue(Cap->Value, Cap->Scale, 'F');
    17c8:	09 e2       	ldi	r16, 0x29	; 41
    17ca:	11 e0       	ldi	r17, 0x01	; 1
    /*
     *  short or long key press -> measure
     *  two short key presses -> exit tool
     */

    Test = TestKey(0, 0);               /* wait for user feedback */
    17cc:	60 e0       	ldi	r22, 0x00	; 0
    17ce:	80 e0       	ldi	r24, 0x00	; 0
    17d0:	90 e0       	ldi	r25, 0x00	; 0
    17d2:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <TestKey>
    if (Test == 1)                      /* short key press */
    17d6:	81 30       	cpi	r24, 0x01	; 1
    17d8:	59 f4       	brne	.+22     	; 0x17f0 <ESR_Tool+0x52>
    {
      MilliSleep(50);                   /* debounce button a little bit longer */
    17da:	82 e3       	ldi	r24, 0x32	; 50
    17dc:	90 e0       	ldi	r25, 0x00	; 0
    17de:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>
      Test = TestKey(200, 0);           /* check for second key press */
    17e2:	60 e0       	ldi	r22, 0x00	; 0
    17e4:	88 ec       	ldi	r24, 0xC8	; 200
    17e6:	90 e0       	ldi	r25, 0x00	; 0
    17e8:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <TestKey>
      if (Test > 0)                     /* second key press */
    17ec:	81 11       	cpse	r24, r1
    17ee:	30 c0       	rjmp	.+96     	; 0x1850 <ESR_Tool+0xb2>
    {
      #ifdef HW_RELAY
      ADC_DDR = 0;                     /* remove short circuit */
      #endif

      LCD_ClearLine2();                /* update line #2 */
    17f0:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <LCD_ClearLine2>
      LCD_EEString(Running_str);       /* display: probing... */
    17f4:	8d e7       	ldi	r24, 0x7D	; 125
    17f6:	92 e0       	ldi	r25, 0x02	; 2
    17f8:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
      MeasureCap(TP2, TP1, 0);         /* probe 2 = Gnd, probe 1 = Vcc */
    17fc:	40 e0       	ldi	r20, 0x00	; 0
    17fe:	60 e0       	ldi	r22, 0x00	; 0
    1800:	81 e0       	ldi	r24, 0x01	; 1
    1802:	0e 94 be 09 	call	0x137c	; 0x137c <MeasureCap>
      LCD_ClearLine2();                /* update line #2 */
    1806:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <LCD_ClearLine2>
      
      if (Check.Found == COMP_CAPACITOR)     /* found capacitor */
    180a:	99 81       	ldd	r25, Y+1	; 0x01
    180c:	9b 30       	cpi	r25, 0x0B	; 11
    180e:	e1 f4       	brne	.+56     	; 0x1848 <ESR_Tool+0xaa>
      {
        /* show capacitance */
        DisplayValue(Cap->Value, Cap->Scale, 'F');
    1810:	f8 01       	movw	r30, r16
    1812:	63 81       	ldd	r22, Z+3	; 0x03
    1814:	74 81       	ldd	r23, Z+4	; 0x04
    1816:	85 81       	ldd	r24, Z+5	; 0x05
    1818:	96 81       	ldd	r25, Z+6	; 0x06
    181a:	26 e4       	ldi	r18, 0x46	; 70
    181c:	42 81       	ldd	r20, Z+2	; 0x02
    181e:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>

        /* show ESR */
        LCD_Space();
    1822:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>
        ESR = MeasureESR(Cap);
    1826:	c8 01       	movw	r24, r16
    1828:	0e 94 43 06 	call	0xc86	; 0xc86 <MeasureESR>
        if (ESR > 0)                    /* got valid ESR */
    182c:	00 97       	sbiw	r24, 0x00	; 0
    182e:	41 f0       	breq	.+16     	; 0x1840 <ESR_Tool+0xa2>
        {
          DisplayValue(ESR, -2, LCD_CHAR_OMEGA);
    1830:	bc 01       	movw	r22, r24
    1832:	80 e0       	ldi	r24, 0x00	; 0
    1834:	90 e0       	ldi	r25, 0x00	; 0
    1836:	24 ef       	ldi	r18, 0xF4	; 244
    1838:	4e ef       	ldi	r20, 0xFE	; 254
    183a:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
    183e:	c6 cf       	rjmp	.-116    	; 0x17cc <ESR_Tool+0x2e>
        }
        else                            /* no ESR */
        {
          LCD_Data('-');
    1840:	8d e2       	ldi	r24, 0x2D	; 45
    1842:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    1846:	c2 cf       	rjmp	.-124    	; 0x17cc <ESR_Tool+0x2e>
        }
      }
      else                                   /* no capacitor */
      {
        LCD_Data('-');
    1848:	8d e2       	ldi	r24, 0x2D	; 45
    184a:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    184e:	be cf       	rjmp	.-132    	; 0x17cc <ESR_Tool+0x2e>
  }

  #ifdef HW_RELAY
  ADC_DDR = 0;                     /* remove short circuit */
  #endif
}
    1850:	df 91       	pop	r29
    1852:	cf 91       	pop	r28
    1854:	1f 91       	pop	r17
    1856:	0f 91       	pop	r16
    1858:	08 95       	ret

0000185a <CheckEncoder>:
 *  requires:
 *  - pointer to encoder history
 */

uint8_t CheckEncoder(uint8_t *History)
{
    185a:	0f 93       	push	r16
    185c:	1f 93       	push	r17
    185e:	cf 93       	push	r28
    1860:	df 93       	push	r29
    1862:	8c 01       	movw	r16, r24
  uint8_t           Steps;                   /* encoder steps */
  uint8_t           Temp;                    /* temporary value */

  /* we assume: probe-1 = A / probe-2 = B / probe-3 = Common */
  /* setup probes: probe-1 -- Rl -- Vcc / probe-2 -- Rl -- Vcc / Gnd -- probe-3 */
  R_PORT = Probes.Rl_1 | Probes.Rl_2;   /* pullup via Rl */
    1864:	cd e7       	ldi	r28, 0x7D	; 125
    1866:	d1 e0       	ldi	r29, 0x01	; 1
    1868:	9d 81       	ldd	r25, Y+5	; 0x05
    186a:	8b 81       	ldd	r24, Y+3	; 0x03
    186c:	89 2b       	or	r24, r25
    186e:	85 b9       	out	0x05, r24	; 5
  R_DDR =  Probes.Rl_1 | Probes.Rl_2;   /* enable pull-up resistors */
    1870:	84 b9       	out	0x04, r24	; 4
  ADC_PORT = 0;                         /* pull down directly */
    1872:	18 b8       	out	0x08, r1	; 8
  ADC_DDR = Probes.ADC_3;               /* enable Gnd for probe-3 */
    1874:	8b 85       	ldd	r24, Y+11	; 0x0b
    1876:	87 b9       	out	0x07, r24	; 7
  wait500us();                          /* settle time */
    1878:	0e 94 80 00 	call	0x100	; 0x100 <wait500us>

  /* get A & B signals */
  Temp = ADC_PIN;
    187c:	26 b1       	in	r18, 0x06	; 6
  if (Temp & Probes.ADC_1) AB = 0b00000010;
    187e:	99 85       	ldd	r25, Y+9	; 0x09
    1880:	92 23       	and	r25, r18
    1882:	11 f0       	breq	.+4      	; 0x1888 <CheckEncoder+0x2e>
    1884:	c2 e0       	ldi	r28, 0x02	; 2
    1886:	01 c0       	rjmp	.+2      	; 0x188a <CheckEncoder+0x30>

uint8_t CheckEncoder(uint8_t *History)
{
  uint8_t           Action = DIR_NONE;       /* return value */
  uint8_t           Old_AB;                  /* old AB state */
  uint8_t           AB = 0;                  /* new AB state */
    1888:	c0 e0       	ldi	r28, 0x00	; 0
  wait500us();                          /* settle time */

  /* get A & B signals */
  Temp = ADC_PIN;
  if (Temp & Probes.ADC_1) AB = 0b00000010;
  if (Temp & Probes.ADC_2) AB |= 0b00000001;
    188a:	80 91 87 01 	lds	r24, 0x0187
    188e:	82 23       	and	r24, r18
    1890:	09 f0       	breq	.+2      	; 0x1894 <CheckEncoder+0x3a>
    1892:	c1 60       	ori	r28, 0x01	; 1

  R_DDR = 0;                  /* reset probes */
    1894:	14 b8       	out	0x04, r1	; 4
  ADC_DDR = 0;
    1896:	17 b8       	out	0x07, r1	; 7

  /* unpack history */
  Temp = *History;
    1898:	f8 01       	movw	r30, r16
    189a:	20 81       	ld	r18, Z
  Old_AB = Temp & 0b00000011;      /* old AB state, first 2 bits */
  Temp >>=2 ;                      /* move 2 bits */
    189c:	92 2f       	mov	r25, r18
    189e:	96 95       	lsr	r25
    18a0:	96 95       	lsr	r25
  Dir = Temp & 0b00000011;         /* direction, next 2 bits */
    18a2:	39 2f       	mov	r19, r25
    18a4:	33 70       	andi	r19, 0x03	; 3
  Temp >>= 2;                      /* move 2 bits */
    18a6:	96 95       	lsr	r25
    18a8:	96 95       	lsr	r25
  Steps = Temp;                    /* steps, remaining 4 bits */

  /* update state history */
  if (Dir == (DIR_RIGHT | DIR_LEFT))    /* first scan */
    18aa:	33 30       	cpi	r19, 0x03	; 3
    18ac:	09 f4       	brne	.+2      	; 0x18b0 <CheckEncoder+0x56>
    18ae:	41 c0       	rjmp	.+130    	; 0x1932 <CheckEncoder+0xd8>
  R_DDR = 0;                  /* reset probes */
  ADC_DDR = 0;

  /* unpack history */
  Temp = *History;
  Old_AB = Temp & 0b00000011;      /* old AB state, first 2 bits */
    18b0:	23 70       	andi	r18, 0x03	; 3
    Old_AB = AB;              /* set as last state */
    Dir = DIR_NONE;           /* reset direction */
  }

  /* process signals */
  if (Old_AB != AB)           /* signals changed */
    18b2:	c2 17       	cp	r28, r18
    18b4:	09 f4       	brne	.+2      	; 0x18b8 <CheckEncoder+0x5e>
    18b6:	40 c0       	rjmp	.+128    	; 0x1938 <CheckEncoder+0xde>
  {
    /* check if only one bit has changed (Gray code) */
    Temp = AB ^ Old_AB;                 /* get bit difference */
    18b8:	8c 2f       	mov	r24, r28
    18ba:	82 27       	eor	r24, r18
    if (!(Temp & 0b00000001)) Temp >>= 1;
    18bc:	80 ff       	sbrs	r24, 0
    18be:	86 95       	lsr	r24
    if (Temp == 1)                      /* valid change */
    18c0:	81 30       	cpi	r24, 0x01	; 1
    18c2:	e9 f5       	brne	.+122    	; 0x193e <CheckEncoder+0xe4>
    {
      /* determine direction */
      /* Gray code: 00 01 11 10 */
      Temp = 0b10001101;                /* expected values for a right turn */
      Temp >>= (Old_AB * 2);            /* get expected value by shifting */
    18c4:	22 0f       	add	r18, r18
    18c6:	4d e8       	ldi	r20, 0x8D	; 141
    18c8:	50 e0       	ldi	r21, 0x00	; 0
    18ca:	02 c0       	rjmp	.+4      	; 0x18d0 <CheckEncoder+0x76>
    18cc:	55 95       	asr	r21
    18ce:	47 95       	ror	r20
    18d0:	2a 95       	dec	r18
    18d2:	e2 f7       	brpl	.-8      	; 0x18cc <CheckEncoder+0x72>
      Temp &= 0b00000011;               /* select value */
    18d4:	43 70       	andi	r20, 0x03	; 3
      if (Temp == AB)                   /* value matches */
    18d6:	4c 17       	cp	r20, r28
    18d8:	11 f0       	breq	.+4      	; 0x18de <CheckEncoder+0x84>
        Temp = DIR_RIGHT;               /* turn to the right */
      else                              /* value mismatches */
        Temp = DIR_LEFT;                /* turn to the left */
    18da:	d2 e0       	ldi	r29, 0x02	; 2
    18dc:	01 c0       	rjmp	.+2      	; 0x18e0 <CheckEncoder+0x86>
      /* Gray code: 00 01 11 10 */
      Temp = 0b10001101;                /* expected values for a right turn */
      Temp >>= (Old_AB * 2);            /* get expected value by shifting */
      Temp &= 0b00000011;               /* select value */
      if (Temp == AB)                   /* value matches */
        Temp = DIR_RIGHT;               /* turn to the right */
    18de:	d1 e0       	ldi	r29, 0x01	; 1
      else                              /* value mismatches */
        Temp = DIR_LEFT;                /* turn to the left */

      /* detection logic */
      if (Temp == Dir)                  /* turn in same direction */
    18e0:	d3 13       	cpse	r29, r19
    18e2:	30 c0       	rjmp	.+96     	; 0x1944 <CheckEncoder+0xea>
      {
        Steps++;                        /* got another step */
    18e4:	9f 5f       	subi	r25, 0xFF	; 255

        /* for proper detection we need 4 Gray code steps */
        if (Steps == 4)                 /* got 4 steps */
    18e6:	94 30       	cpi	r25, 0x04	; 4
    18e8:	81 f5       	brne	.+96     	; 0x194a <CheckEncoder+0xf0>
        {
          LCD_ClearLine2();
    18ea:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <LCD_ClearLine2>
           *  The turning direction determines A and B:
           *  - right: A = Probe #1 / B = Probe #2
           *  - left:  A = Probe #2 / B = Probe #1
           */

          if (Dir == DIR_RIGHT)         /* right */
    18ee:	d1 30       	cpi	r29, 0x01	; 1
    18f0:	51 f4       	brne	.+20     	; 0x1906 <CheckEncoder+0xac>
          {
            Semi.A = Probes.Pin_1;
    18f2:	ef e6       	ldi	r30, 0x6F	; 111
    18f4:	f1 e0       	ldi	r31, 0x01	; 1
    18f6:	ad e7       	ldi	r26, 0x7D	; 125
    18f8:	b1 e0       	ldi	r27, 0x01	; 1
    18fa:	8c 91       	ld	r24, X
    18fc:	80 83       	st	Z, r24
            Semi.B = Probes.Pin_2;
    18fe:	11 96       	adiw	r26, 0x01	; 1
    1900:	8c 91       	ld	r24, X
    1902:	81 83       	std	Z+1, r24	; 0x01
    1904:	0a c0       	rjmp	.+20     	; 0x191a <CheckEncoder+0xc0>
          }
          else                          /* left */
          {
            Semi.A = Probes.Pin_2;
    1906:	ef e6       	ldi	r30, 0x6F	; 111
    1908:	f1 e0       	ldi	r31, 0x01	; 1
    190a:	ad e7       	ldi	r26, 0x7D	; 125
    190c:	b1 e0       	ldi	r27, 0x01	; 1
    190e:	11 96       	adiw	r26, 0x01	; 1
    1910:	8c 91       	ld	r24, X
    1912:	11 97       	sbiw	r26, 0x01	; 1
    1914:	80 83       	st	Z, r24
            Semi.B = Probes.Pin_1;
    1916:	8c 91       	ld	r24, X
    1918:	81 83       	std	Z+1, r24	; 0x01
          }

          Semi.C = Probes.Pin_3;        /* Common */
    191a:	80 91 7f 01 	lds	r24, 0x017F
    191e:	80 93 71 01 	sts	0x0171, r24

          /* display pinout */
          Show_SemiPinout('A', 'B', 'C');
    1922:	43 e4       	ldi	r20, 0x43	; 67
    1924:	62 e4       	ldi	r22, 0x42	; 66
    1926:	81 e4       	ldi	r24, 0x41	; 65
    1928:	0e 94 d9 0f 	call	0x1fb2	; 0x1fb2 <Show_SemiPinout>

          Steps = 0;                      /* reset steps */
          Action = Temp;                  /* signal valid step */
    192c:	8d 2f       	mov	r24, r29
          Semi.C = Probes.Pin_3;        /* Common */

          /* display pinout */
          Show_SemiPinout('A', 'B', 'C');

          Steps = 0;                      /* reset steps */
    192e:	90 e0       	ldi	r25, 0x00	; 0
    1930:	0d c0       	rjmp	.+26     	; 0x194c <CheckEncoder+0xf2>

  /* update state history */
  if (Dir == (DIR_RIGHT | DIR_LEFT))    /* first scan */
  {
    Old_AB = AB;              /* set as last state */
    Dir = DIR_NONE;           /* reset direction */
    1932:	d0 e0       	ldi	r29, 0x00	; 0
 *  - pointer to encoder history
 */

uint8_t CheckEncoder(uint8_t *History)
{
  uint8_t           Action = DIR_NONE;       /* return value */
    1934:	80 e0       	ldi	r24, 0x00	; 0
    1936:	0a c0       	rjmp	.+20     	; 0x194c <CheckEncoder+0xf2>

  /* unpack history */
  Temp = *History;
  Old_AB = Temp & 0b00000011;      /* old AB state, first 2 bits */
  Temp >>=2 ;                      /* move 2 bits */
  Dir = Temp & 0b00000011;         /* direction, next 2 bits */
    1938:	d3 2f       	mov	r29, r19
 *  - pointer to encoder history
 */

uint8_t CheckEncoder(uint8_t *History)
{
  uint8_t           Action = DIR_NONE;       /* return value */
    193a:	80 e0       	ldi	r24, 0x00	; 0
    193c:	07 c0       	rjmp	.+14     	; 0x194c <CheckEncoder+0xf2>

      Dir = Temp;                  /* update direction */
    }
    else                                /* invalid change */
    {
      Dir = DIR_RIGHT | DIR_LEFT;       /* trigger reset of history */
    193e:	d3 e0       	ldi	r29, 0x03	; 3
 *  - pointer to encoder history
 */

uint8_t CheckEncoder(uint8_t *History)
{
  uint8_t           Action = DIR_NONE;       /* return value */
    1940:	80 e0       	ldi	r24, 0x00	; 0
    1942:	04 c0       	rjmp	.+8      	; 0x194c <CheckEncoder+0xf2>
          Action = Temp;                  /* signal valid step */
        }
      }
      else                         /* turn has changed direction */
      {
        Steps = 1;                 /* first step for new direction */
    1944:	91 e0       	ldi	r25, 0x01	; 1
 *  - pointer to encoder history
 */

uint8_t CheckEncoder(uint8_t *History)
{
  uint8_t           Action = DIR_NONE;       /* return value */
    1946:	80 e0       	ldi	r24, 0x00	; 0
    1948:	01 c0       	rjmp	.+2      	; 0x194c <CheckEncoder+0xf2>
    194a:	80 e0       	ldi	r24, 0x00	; 0
    }
  }

  /* pack new history */
  Temp = AB;             /* AB state, first 2 bits */
  Dir <<= 2;             /* direction, next 2 bits */
    194c:	dd 0f       	add	r29, r29
    194e:	dd 0f       	add	r29, r29
  Temp |= Dir;
  Steps <<= 4;           /* steps, remaining 4 bits */
    1950:	92 95       	swap	r25
    1952:	90 7f       	andi	r25, 0xF0	; 240
    1954:	9d 2b       	or	r25, r29
  Temp |= Steps;
    1956:	9c 2b       	or	r25, r28
  *History = Temp;       /* save new history */
    1958:	f8 01       	movw	r30, r16
    195a:	90 83       	st	Z, r25

  return Action;
}
    195c:	df 91       	pop	r29
    195e:	cf 91       	pop	r28
    1960:	1f 91       	pop	r17
    1962:	0f 91       	pop	r16
    1964:	08 95       	ret

00001966 <Encoder_Tool>:
/*
 *  rotary encoder check
 */

void Encoder_Tool(void)
{
    1966:	1f 93       	push	r17
    1968:	cf 93       	push	r28
    196a:	df 93       	push	r29
    196c:	00 d0       	rcall	.+0      	; 0x196e <Encoder_Tool+0x8>
    196e:	1f 92       	push	r1
    1970:	cd b7       	in	r28, 0x3d	; 61
    1972:	de b7       	in	r29, 0x3e	; 62
   *  - 0000xx00 turning direction
   *  - xxxx0000 steps               
   */

  /* show info */
  LCD_Clear();
    1974:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>
  LCD_EEString(Encoder_str);       /* display: Rotary Encoder */
    1978:	8a ed       	ldi	r24, 0xDA	; 218
    197a:	91 e0       	ldi	r25, 0x01	; 1
    197c:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>

  /* init array */
  for (Flag = 0; Flag <= 2; Flag++)
  {
    History[Flag] = (DIR_RIGHT | DIR_LEFT) << 2;
    1980:	8c e0       	ldi	r24, 0x0C	; 12
    1982:	89 83       	std	Y+1, r24	; 0x01
    1984:	8a 83       	std	Y+2, r24	; 0x02
    1986:	8b 83       	std	Y+3, r24	; 0x03
    1988:	85 e0       	ldi	r24, 0x05	; 5
    }

    if (Flag > 0)             /* detected encoder */
    {
      TestKey(3000, 11);           /* let the user read */
      Flag = 5;                    /* reset flag */
    198a:	15 e0       	ldi	r17, 0x05	; 5

  /* processing loop */
  Flag = 5;
  while (Flag < 10)
  {
    wdt_reset();
    198c:	a8 95       	wdr

    if (Flag == 5)                 /* ask user to turn */
    198e:	85 30       	cpi	r24, 0x05	; 5
    1990:	31 f4       	brne	.+12     	; 0x199e <Encoder_Tool+0x38>
    {
      LCD_ClearLine2();
    1992:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <LCD_ClearLine2>
      LCD_EEString(TurnRight_str);     /* display: Turn right! */
    1996:	8e ec       	ldi	r24, 0xCE	; 206
    1998:	91 e0       	ldi	r25, 0x01	; 1
    199a:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
      Flag = 0;                        /* reset flag */
    }

    UpdateProbes(TP1, TP2, TP3);       /* check first pinout */
    199e:	42 e0       	ldi	r20, 0x02	; 2
    19a0:	61 e0       	ldi	r22, 0x01	; 1
    19a2:	80 e0       	ldi	r24, 0x00	; 0
    19a4:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <UpdateProbes>
    Flag = CheckEncoder(&History[0]);
    19a8:	ce 01       	movw	r24, r28
    19aa:	01 96       	adiw	r24, 0x01	; 1
    19ac:	0e 94 2d 0c 	call	0x185a	; 0x185a <CheckEncoder>

    if (Flag == 0)
    19b0:	81 11       	cpse	r24, r1
    19b2:	15 c0       	rjmp	.+42     	; 0x19de <Encoder_Tool+0x78>
    {
      UpdateProbes(TP1, TP3, TP2);     /* check second pinout */
    19b4:	41 e0       	ldi	r20, 0x01	; 1
    19b6:	62 e0       	ldi	r22, 0x02	; 2
    19b8:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <UpdateProbes>
      Flag = CheckEncoder(&History[1]);
    19bc:	ce 01       	movw	r24, r28
    19be:	02 96       	adiw	r24, 0x02	; 2
    19c0:	0e 94 2d 0c 	call	0x185a	; 0x185a <CheckEncoder>
    }

    if (Flag == 0)
    19c4:	81 11       	cpse	r24, r1
    19c6:	0b c0       	rjmp	.+22     	; 0x19de <Encoder_Tool+0x78>
    {    
      UpdateProbes(TP2, TP3, TP1);     /* check third pinout */
    19c8:	40 e0       	ldi	r20, 0x00	; 0
    19ca:	62 e0       	ldi	r22, 0x02	; 2
    19cc:	81 e0       	ldi	r24, 0x01	; 1
    19ce:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <UpdateProbes>
      Flag = CheckEncoder(&History[2]);
    19d2:	ce 01       	movw	r24, r28
    19d4:	03 96       	adiw	r24, 0x03	; 3
    19d6:	0e 94 2d 0c 	call	0x185a	; 0x185a <CheckEncoder>
    }

    if (Flag > 0)             /* detected encoder */
    19da:	88 23       	and	r24, r24
    19dc:	39 f0       	breq	.+14     	; 0x19ec <Encoder_Tool+0x86>
    {
      TestKey(3000, 11);           /* let the user read */
    19de:	6b e0       	ldi	r22, 0x0B	; 11
    19e0:	88 eb       	ldi	r24, 0xB8	; 184
    19e2:	9b e0       	ldi	r25, 0x0B	; 11
    19e4:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <TestKey>
      Flag = 5;                    /* reset flag */
    19e8:	81 2f       	mov	r24, r17
    19ea:	d0 cf       	rjmp	.-96     	; 0x198c <Encoder_Tool+0x26>
    }
    else                      /* nothing found yet */
    {
      if (!(CONTROL_PIN & (1 << TEST_BUTTON)))   /* if key is pressed */
    19ec:	4f 99       	sbic	0x09, 7	; 9
    19ee:	ce cf       	rjmp	.-100    	; 0x198c <Encoder_Tool+0x26>
      {
        MilliSleep(100);           /* smooth UI */
    19f0:	84 e6       	ldi	r24, 0x64	; 100
    19f2:	90 e0       	ldi	r25, 0x00	; 0
    19f4:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>
        Flag = 10;                 /* end loop */
      }
    }
  }
}
    19f8:	0f 90       	pop	r0
    19fa:	0f 90       	pop	r0
    19fc:	0f 90       	pop	r0
    19fe:	df 91       	pop	r29
    1a00:	cf 91       	pop	r28
    1a02:	1f 91       	pop	r17
    1a04:	08 95       	ret

00001a06 <MeasureInductance>:
 *  - 1 if inductance is too high
 *  - 0 on any problem
 */

uint8_t MeasureInductance(uint32_t *Time, uint8_t Mode)
{
    1a06:	0f 93       	push	r16
    1a08:	1f 93       	push	r17
    1a0a:	cf 93       	push	r28
    1a0c:	df 93       	push	r29
  uint16_t          Ticks_L;       /* timer counter */
  uint16_t          Ticks_H;       /* timer overflow counter */
  uint32_t          Counter;       /* counter */

  /* sanity check */
  if (Time == NULL) return 0;
    1a0e:	00 97       	sbiw	r24, 0x00	; 0
    1a10:	09 f4       	brne	.+2      	; 0x1a14 <MeasureInductance+0xe>
    1a12:	b3 c0       	rjmp	.+358    	; 0x1b7a <MeasureInductance+0x174>
    1a14:	16 2f       	mov	r17, r22
    1a16:	ec 01       	movw	r28, r24

  DischargeProbes();                    /* try to discharge probes */
    1a18:	0e 94 64 18 	call	0x30c8	; 0x30c8 <DischargeProbes>
  if (Check.Found == COMP_ERROR) return 0;
    1a1c:	80 91 01 01 	lds	r24, 0x0101
    1a20:	81 30       	cpi	r24, 0x01	; 1
    1a22:	09 f4       	brne	.+2      	; 0x1a26 <MeasureInductance+0x20>
    1a24:	ac c0       	rjmp	.+344    	; 0x1b7e <MeasureInductance+0x178>
  /*
   *  init hardware
   */

  /* set probes: Gnd -- probe-1 / Gnd -- Rl -- probe-2 */
  R_PORT = 0;                           /* set resistor port to low */
    1a26:	15 b8       	out	0x05, r1	; 5
  ADC_PORT = 0;                         /* set ADC port to low */
    1a28:	18 b8       	out	0x08, r1	; 8

  if (Mode & MODE_LOW_CURRENT)     /* low current */
    1a2a:	10 ff       	sbrs	r17, 0
    1a2c:	07 c0       	rjmp	.+14     	; 0x1a3c <MeasureInductance+0x36>
  {
    R_DDR = Probes.Rl_2;                /* pull down probe-2 via Rl */
    1a2e:	ed e7       	ldi	r30, 0x7D	; 125
    1a30:	f1 e0       	ldi	r31, 0x01	; 1
    1a32:	85 81       	ldd	r24, Z+5	; 0x05
    1a34:	84 b9       	out	0x04, r24	; 4
    ADC_DDR = Probes.ADC_1;             /* pull down probe-1 directly */
    1a36:	81 85       	ldd	r24, Z+9	; 0x09
    1a38:	87 b9       	out	0x07, r24	; 7
    1a3a:	07 c0       	rjmp	.+14     	; 0x1a4a <MeasureInductance+0x44>
  }
  else                             /* high current */
  {
    R_DDR = 0;                          /* disable probe resistors */
    1a3c:	14 b8       	out	0x04, r1	; 4
    /* pull down probe-1 and probe-2 directly */
    ADC_DDR = Probes.ADC_1 | Probes.ADC_2;
    1a3e:	ed e7       	ldi	r30, 0x7D	; 125
    1a40:	f1 e0       	ldi	r31, 0x01	; 1
    1a42:	92 85       	ldd	r25, Z+10	; 0x0a
    1a44:	81 85       	ldd	r24, Z+9	; 0x09
    1a46:	89 2b       	or	r24, r25
    1a48:	87 b9       	out	0x07, r24	; 7
  }

  /* setup analog comparator */
  ADCSRB = (1 << ACME);                 /* use ADC multiplexer as negative input */
    1a4a:	80 e4       	ldi	r24, 0x40	; 64
    1a4c:	80 93 7b 00 	sts	0x007B, r24
  ACSR =  (1 << ACBG) | (1 << ACIC);    /* use bandgap as positive input, trigger timer1 */
    1a50:	84 e4       	ldi	r24, 0x44	; 68
    1a52:	80 bf       	out	0x30, r24	; 48
  ADMUX = (1 << REFS0) | Probes.Pin_2;  /* switch ADC multiplexer to probe-2 */
    1a54:	80 91 7e 01 	lds	r24, 0x017E
    1a58:	80 64       	ori	r24, 0x40	; 64
    1a5a:	80 93 7c 00 	sts	0x007C, r24
                                        /* and set AREF to Vcc */
  ADCSRA = ADC_CLOCK_DIV;               /* disable ADC, but keep clock dividers */
    1a5e:	83 e0       	ldi	r24, 0x03	; 3
    1a60:	80 93 7a 00 	sts	0x007A, r24
  wait200us();                          /* allow bandgap reference to settle */
    1a64:	0e 94 83 00 	call	0x106	; 0x106 <wait200us>
  /*
   *  setup timer
   */

  Ticks_H = 0;                          /* reset timer overflow counter */
  TCCR1A = 0;                           /* set default mode */
    1a68:	10 92 80 00 	sts	0x0080, r1
  TCCR1B = 0;                           /* set more timer modes */
    1a6c:	10 92 81 00 	sts	0x0081, r1
  /* timer stopped, falling edge detection, noise canceler disabled */
  TCNT1 = 0;                            /* set Counter1 to 0 */
    1a70:	10 92 85 00 	sts	0x0085, r1
    1a74:	10 92 84 00 	sts	0x0084, r1
  /* clear all flags (input capture, compare A & B, overflow */
  TIFR1 = (1 << ICF1) | (1 << OCF1B) | (1 << OCF1A) | (1 << TOV1);
    1a78:	87 e2       	ldi	r24, 0x27	; 39
    1a7a:	86 bb       	out	0x16, r24	; 22

  if (Mode & MODE_DELAYED_START)        /* delayed start */
    1a7c:	a1 2f       	mov	r26, r17
    1a7e:	a4 70       	andi	r26, 0x04	; 4
    1a80:	12 ff       	sbrs	r17, 2
    1a82:	0a c0       	rjmp	.+20     	; 0x1a98 <MeasureInductance+0x92>
  {
    Test = (CPU_FREQ / 1000000);        /* MCU cycles per 탎 */

    /* change probes: Gnd -- Rl -- probe-2 / probe-1 -- Vcc */
    ADC_PORT = Probes.ADC_1;            /* pull up probe-1 directly */
    1a84:	80 91 86 01 	lds	r24, 0x0186
    1a88:	88 b9       	out	0x08, r24	; 8
     */

    while (Test > 0)
    {
      Test--;
      asm volatile("nop\n\t"::);
    1a8a:	00 00       	nop
    }

    TCCR1B |= (1 << CS10);              /* start timer (1/1 clock divider) */
    1a8c:	e1 e8       	ldi	r30, 0x81	; 129
    1a8e:	f0 e0       	ldi	r31, 0x00	; 0
    1a90:	80 81       	ld	r24, Z
    1a92:	81 60       	ori	r24, 0x01	; 1
    1a94:	80 83       	st	Z, r24
    1a96:	08 c0       	rjmp	.+16     	; 0x1aa8 <MeasureInductance+0xa2>
  }
  else                                  /* immediate start */
  {
    TCCR1B |= (1 << CS10);              /* start timer (1/1 clock divider) */
    1a98:	e1 e8       	ldi	r30, 0x81	; 129
    1a9a:	f0 e0       	ldi	r31, 0x00	; 0
    1a9c:	80 81       	ld	r24, Z
    1a9e:	81 60       	ori	r24, 0x01	; 1
    1aa0:	80 83       	st	Z, r24
    /* change probes: Gnd -- Rl -- probe-2 / probe-1 -- Vcc */
    ADC_PORT = Probes.ADC_1;            /* pull up probe-1 directly */
    1aa2:	80 91 86 01 	lds	r24, 0x0186
    1aa6:	88 b9       	out	0x08, r24	; 8
 *  - 1 if inductance is too high
 *  - 0 on any problem
 */

uint8_t MeasureInductance(uint32_t *Time, uint8_t Mode)
{
    1aa8:	00 e0       	ldi	r16, 0x00	; 0
    1aaa:	10 e0       	ldi	r17, 0x00	; 0

    /* detect timer overflow by checking the overflow flag */
    if (Test & (1 << TOV1))
    {
      /* happens at 65.536ms for 1MHz or 8.192ms for 8MHz */
      TIFR1 = (1 << TOV1);              /* reset flag */
    1aac:	81 e0       	ldi	r24, 0x01	; 1
   *  - detect timer overflows
   */

  while (1)
  {
    Test = TIFR1;                       /* get timer1 flags */
    1aae:	96 b3       	in	r25, 0x16	; 22

    /* end loop if input capture flag is set (= same voltage) */
    if (Test & (1 << ICF1)) break;
    1ab0:	95 fd       	sbrc	r25, 5
    1ab2:	0a c0       	rjmp	.+20     	; 0x1ac8 <MeasureInductance+0xc2>

    /* detect timer overflow by checking the overflow flag */
    if (Test & (1 << TOV1))
    1ab4:	90 ff       	sbrs	r25, 0
    1ab6:	fb cf       	rjmp	.-10     	; 0x1aae <MeasureInductance+0xa8>
    {
      /* happens at 65.536ms for 1MHz or 8.192ms for 8MHz */
      TIFR1 = (1 << TOV1);              /* reset flag */
    1ab8:	86 bb       	out	0x16, r24	; 22
      wdt_reset();                      /* reset watchdog */
    1aba:	a8 95       	wdr
      Ticks_H++;                        /* increase overflow counter */
    1abc:	0f 5f       	subi	r16, 0xFF	; 255
    1abe:	1f 4f       	sbci	r17, 0xFF	; 255

      /* if it takes too long (0.26s) */
      if (Ticks_H == (CPU_FREQ / 250000))
    1ac0:	04 30       	cpi	r16, 0x04	; 4
    1ac2:	11 05       	cpc	r17, r1
    1ac4:	a1 f7       	brne	.-24     	; 0x1aae <MeasureInductance+0xa8>
    1ac6:	5d c0       	rjmp	.+186    	; 0x1b82 <MeasureInductance+0x17c>
      }
    }
  }

  /* stop counter */
  TCCR1B = 0;                           /* stop timer */
    1ac8:	10 92 81 00 	sts	0x0081, r1
  TIFR1 = (1 << ICF1);                  /* reset Input Capture flag */
    1acc:	80 e2       	ldi	r24, 0x20	; 32
    1ace:	86 bb       	out	0x16, r24	; 22

  Ticks_L = ICR1;                       /* get counter value */
    1ad0:	60 91 86 00 	lds	r22, 0x0086
    1ad4:	70 91 87 00 	lds	r23, 0x0087

  /* prepare cut off: Gnd -- Rl -- probe-2 / probe-1 -- Rl -- Gnd */
  R_DDR = Probes.Rl_2 | Probes.Rl_1;  
    1ad8:	ed e7       	ldi	r30, 0x7D	; 125
    1ada:	f1 e0       	ldi	r31, 0x01	; 1
    1adc:	23 81       	ldd	r18, Z+3	; 0x03
    1ade:	85 81       	ldd	r24, Z+5	; 0x05
    1ae0:	82 2b       	or	r24, r18
    1ae2:	84 b9       	out	0x04, r24	; 4

  /* stop current flow */
  ADC_DDR = 0;
    1ae4:	17 b8       	out	0x07, r1	; 7

  /* catch missed timer overflow */
  if ((TCNT1 > Ticks_L) && (Test & (1 << TOV1)))
    1ae6:	20 91 84 00 	lds	r18, 0x0084
    1aea:	30 91 85 00 	lds	r19, 0x0085
    1aee:	62 17       	cp	r22, r18
    1af0:	73 07       	cpc	r23, r19
    1af2:	50 f4       	brcc	.+20     	; 0x1b08 <MeasureInductance+0x102>
    1af4:	90 ff       	sbrs	r25, 0
    1af6:	0a c0       	rjmp	.+20     	; 0x1b0c <MeasureInductance+0x106>
 *  - 0 on any problem
 */

uint8_t MeasureInductance(uint32_t *Time, uint8_t Mode)
{
  uint8_t           Flag = 3;      /* return value */
    1af8:	e3 e0       	ldi	r30, 0x03	; 3
    1afa:	01 c0       	rjmp	.+2      	; 0x1afe <MeasureInductance+0xf8>
      Ticks_H++;                        /* increase overflow counter */

      /* if it takes too long (0.26s) */
      if (Ticks_H == (CPU_FREQ / 250000))
      {
        Flag = 0;             /* signal timeout */
    1afc:	e0 e0       	ldi	r30, 0x00	; 0
  ADC_DDR = 0;

  /* catch missed timer overflow */
  if ((TCNT1 > Ticks_L) && (Test & (1 << TOV1)))
  {
    TIFR1 = (1 << TOV1);                /* reset overflow flag */
    1afe:	81 e0       	ldi	r24, 0x01	; 1
    1b00:	86 bb       	out	0x16, r24	; 22
    Ticks_H++;                          /* increase overflow counter */
    1b02:	0f 5f       	subi	r16, 0xFF	; 255
    1b04:	1f 4f       	sbci	r17, 0xFF	; 255
    1b06:	03 c0       	rjmp	.+6      	; 0x1b0e <MeasureInductance+0x108>
 *  - 0 on any problem
 */

uint8_t MeasureInductance(uint32_t *Time, uint8_t Mode)
{
  uint8_t           Flag = 3;      /* return value */
    1b08:	e3 e0       	ldi	r30, 0x03	; 3
    1b0a:	01 c0       	rjmp	.+2      	; 0x1b0e <MeasureInductance+0x108>
    1b0c:	e3 e0       	ldi	r30, 0x03	; 3
    TIFR1 = (1 << TOV1);                /* reset overflow flag */
    Ticks_H++;                          /* increase overflow counter */
  }

  /* enable ADC again */
  ADCSRA = (1 << ADEN) | (1 << ADIF) | ADC_CLOCK_DIV;
    1b0e:	83 e9       	ldi	r24, 0x93	; 147
    1b10:	80 93 7a 00 	sts	0x007A, r24
  /*
   *  process counters
   */

  /* combine both counter values */
  Counter = (uint32_t)Ticks_L;          /* lower 16 bits */
    1b14:	ab 01       	movw	r20, r22
    1b16:	60 e0       	ldi	r22, 0x00	; 0
    1b18:	70 e0       	ldi	r23, 0x00	; 0
  Counter |= (uint32_t)Ticks_H << 16;   /* upper 16 bits */
    1b1a:	20 e0       	ldi	r18, 0x00	; 0
    1b1c:	30 e0       	ldi	r19, 0x00	; 0
    1b1e:	98 01       	movw	r18, r16
    1b20:	11 27       	eor	r17, r17
    1b22:	00 27       	eor	r16, r16
    1b24:	cb 01       	movw	r24, r22
    1b26:	ba 01       	movw	r22, r20
    1b28:	60 2b       	or	r22, r16
    1b2a:	71 2b       	or	r23, r17
    1b2c:	82 2b       	or	r24, r18
    1b2e:	93 2b       	or	r25, r19

  Offset = -3;                /* subtract processing overhead */

  if (Mode & MODE_DELAYED_START)             /* delayed start */
    1b30:	a1 11       	cpse	r26, r1
    1b32:	05 c0       	rjmp	.+10     	; 0x1b3e <MeasureInductance+0x138>
    1b34:	3f c0       	rjmp	.+126    	; 0x1bb4 <MeasureInductance+0x1ae>
  }
  else                        /* negative offset */
  {
    Offset *= -1;                            /* make it positive */
    if (Counter < Offset) Counter = 0;       /* prevent underflow */
    else Counter -= Offset;                  /* subtract offset */
    1b36:	64 50       	subi	r22, 0x04	; 4
    1b38:	71 09       	sbc	r23, r1
    1b3a:	81 09       	sbc	r24, r1
    1b3c:	91 09       	sbc	r25, r1
  }

  /* convert counter (MCU cycles) to time (in ns) */
  if (Counter > 0)
    1b3e:	61 15       	cp	r22, r1
    1b40:	71 05       	cpc	r23, r1
    1b42:	81 05       	cpc	r24, r1
    1b44:	91 05       	cpc	r25, r1
    1b46:	69 f0       	breq	.+26     	; 0x1b62 <MeasureInductance+0x15c>
  {
    Counter *= (1000000000 / CPU_FREQ);      /* divide by frequeny and scale to ns */
    1b48:	a8 ee       	ldi	r26, 0xE8	; 232
    1b4a:	b3 e0       	ldi	r27, 0x03	; 3
    1b4c:	9b 01       	movw	r18, r22
    1b4e:	ac 01       	movw	r20, r24
    1b50:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
  }

  if (Counter <= 100) Flag = 2;         /* signal "inductance too low" */
    1b54:	65 36       	cpi	r22, 0x65	; 101
    1b56:	71 05       	cpc	r23, r1
    1b58:	81 05       	cpc	r24, r1
    1b5a:	91 05       	cpc	r25, r1
    1b5c:	40 f4       	brcc	.+16     	; 0x1b6e <MeasureInductance+0x168>
    1b5e:	e2 e0       	ldi	r30, 0x02	; 2
    1b60:	06 c0       	rjmp	.+12     	; 0x1b6e <MeasureInductance+0x168>
    1b62:	e2 e0       	ldi	r30, 0x02	; 2
    1b64:	04 c0       	rjmp	.+8      	; 0x1b6e <MeasureInductance+0x168>
    1b66:	60 e0       	ldi	r22, 0x00	; 0
    1b68:	70 e0       	ldi	r23, 0x00	; 0
    1b6a:	cb 01       	movw	r24, r22
    1b6c:	e2 e0       	ldi	r30, 0x02	; 2
  *Time = Counter;                      /* save time */
    1b6e:	68 83       	st	Y, r22
    1b70:	79 83       	std	Y+1, r23	; 0x01
    1b72:	8a 83       	std	Y+2, r24	; 0x02
    1b74:	9b 83       	std	Y+3, r25	; 0x03

  return Flag;
    1b76:	8e 2f       	mov	r24, r30
    1b78:	23 c0       	rjmp	.+70     	; 0x1bc0 <MeasureInductance+0x1ba>
  uint16_t          Ticks_L;       /* timer counter */
  uint16_t          Ticks_H;       /* timer overflow counter */
  uint32_t          Counter;       /* counter */

  /* sanity check */
  if (Time == NULL) return 0;
    1b7a:	80 e0       	ldi	r24, 0x00	; 0
    1b7c:	21 c0       	rjmp	.+66     	; 0x1bc0 <MeasureInductance+0x1ba>

  DischargeProbes();                    /* try to discharge probes */
  if (Check.Found == COMP_ERROR) return 0;
    1b7e:	80 e0       	ldi	r24, 0x00	; 0
    1b80:	1f c0       	rjmp	.+62     	; 0x1bc0 <MeasureInductance+0x1ba>
      }
    }
  }

  /* stop counter */
  TCCR1B = 0;                           /* stop timer */
    1b82:	10 92 81 00 	sts	0x0081, r1
  TIFR1 = (1 << ICF1);                  /* reset Input Capture flag */
    1b86:	80 e2       	ldi	r24, 0x20	; 32
    1b88:	86 bb       	out	0x16, r24	; 22

  Ticks_L = ICR1;                       /* get counter value */
    1b8a:	60 91 86 00 	lds	r22, 0x0086
    1b8e:	70 91 87 00 	lds	r23, 0x0087

  /* prepare cut off: Gnd -- Rl -- probe-2 / probe-1 -- Rl -- Gnd */
  R_DDR = Probes.Rl_2 | Probes.Rl_1;  
    1b92:	ed e7       	ldi	r30, 0x7D	; 125
    1b94:	f1 e0       	ldi	r31, 0x01	; 1
    1b96:	93 81       	ldd	r25, Z+3	; 0x03
    1b98:	85 81       	ldd	r24, Z+5	; 0x05
    1b9a:	89 2b       	or	r24, r25
    1b9c:	84 b9       	out	0x04, r24	; 4

  /* stop current flow */
  ADC_DDR = 0;
    1b9e:	17 b8       	out	0x07, r1	; 7

  /* catch missed timer overflow */
  if ((TCNT1 > Ticks_L) && (Test & (1 << TOV1)))
    1ba0:	80 91 84 00 	lds	r24, 0x0084
    1ba4:	90 91 85 00 	lds	r25, 0x0085
    1ba8:	68 17       	cp	r22, r24
    1baa:	79 07       	cpc	r23, r25
    1bac:	08 f4       	brcc	.+2      	; 0x1bb0 <MeasureInductance+0x1aa>
    1bae:	a6 cf       	rjmp	.-180    	; 0x1afc <MeasureInductance+0xf6>
      Ticks_H++;                        /* increase overflow counter */

      /* if it takes too long (0.26s) */
      if (Ticks_H == (CPU_FREQ / 250000))
      {
        Flag = 0;             /* signal timeout */
    1bb0:	e0 e0       	ldi	r30, 0x00	; 0
    1bb2:	ad cf       	rjmp	.-166    	; 0x1b0e <MeasureInductance+0x108>
    Counter += Offset;
  }
  else                        /* negative offset */
  {
    Offset *= -1;                            /* make it positive */
    if (Counter < Offset) Counter = 0;       /* prevent underflow */
    1bb4:	64 30       	cpi	r22, 0x04	; 4
    1bb6:	71 05       	cpc	r23, r1
    1bb8:	81 05       	cpc	r24, r1
    1bba:	91 05       	cpc	r25, r1
    1bbc:	a0 f2       	brcs	.-88     	; 0x1b66 <MeasureInductance+0x160>
    1bbe:	bb cf       	rjmp	.-138    	; 0x1b36 <MeasureInductance+0x130>

  if (Counter <= 100) Flag = 2;         /* signal "inductance too low" */
  *Time = Counter;                      /* save time */

  return Flag;
}
    1bc0:	df 91       	pop	r29
    1bc2:	cf 91       	pop	r28
    1bc4:	1f 91       	pop	r17
    1bc6:	0f 91       	pop	r16
    1bc8:	08 95       	ret

00001bca <MeasureInductor>:
 *  - 1 on success
 *  - 0 on any error
 */

uint8_t MeasureInductor(Resistor_Type *Resistor)
{
    1bca:	4f 92       	push	r4
    1bcc:	5f 92       	push	r5
    1bce:	6f 92       	push	r6
    1bd0:	7f 92       	push	r7
    1bd2:	8f 92       	push	r8
    1bd4:	9f 92       	push	r9
    1bd6:	af 92       	push	r10
    1bd8:	bf 92       	push	r11
    1bda:	cf 92       	push	r12
    1bdc:	df 92       	push	r13
    1bde:	ef 92       	push	r14
    1be0:	ff 92       	push	r15
    1be2:	0f 93       	push	r16
    1be4:	1f 93       	push	r17
    1be6:	cf 93       	push	r28
    1be8:	df 93       	push	r29
    1bea:	cd b7       	in	r28, 0x3d	; 61
    1bec:	de b7       	in	r29, 0x3e	; 62
    1bee:	28 97       	sbiw	r28, 0x08	; 8
    1bf0:	0f b6       	in	r0, 0x3f	; 63
    1bf2:	f8 94       	cli
    1bf4:	de bf       	out	0x3e, r29	; 62
    1bf6:	0f be       	out	0x3f, r0	; 63
    1bf8:	cd bf       	out	0x3d, r28	; 61
  uint32_t          Value;         /* value */
  uint32_t          Time1;         /* time #1 */
  uint32_t          Time2;         /* time #2 */

  /* reset data */
  Inductor.Scale = 0;
    1bfa:	e9 e8       	ldi	r30, 0x89	; 137
    1bfc:	f1 e0       	ldi	r31, 0x01	; 1
    1bfe:	10 82       	st	Z, r1
  Inductor.Value = 0;
    1c00:	11 82       	std	Z+1, r1	; 0x01
    1c02:	12 82       	std	Z+2, r1	; 0x02
    1c04:	13 82       	std	Z+3, r1	; 0x03
    1c06:	14 82       	std	Z+4, r1	; 0x04

  /* sanity check */
  if (Resistor == NULL) return Test;
    1c08:	00 97       	sbiw	r24, 0x00	; 0
    1c0a:	09 f4       	brne	.+2      	; 0x1c0e <MeasureInductor+0x44>
    1c0c:	f9 c0       	rjmp	.+498    	; 0x1e00 <MeasureInductor+0x236>
    1c0e:	6c 01       	movw	r12, r24

  /* limit resistor to 2k (feasibilty & prevent variable overflow) */ 
  if (CmpValue(Resistor->Value, Resistor->Scale, 2000, 0) >= 0) return Test;
    1c10:	fc 01       	movw	r30, r24
    1c12:	63 81       	ldd	r22, Z+3	; 0x03
    1c14:	74 81       	ldd	r23, Z+4	; 0x04
    1c16:	85 81       	ldd	r24, Z+5	; 0x05
    1c18:	96 81       	ldd	r25, Z+6	; 0x06
    1c1a:	e1 2c       	mov	r14, r1
    1c1c:	00 ed       	ldi	r16, 0xD0	; 208
    1c1e:	17 e0       	ldi	r17, 0x07	; 7
    1c20:	20 e0       	ldi	r18, 0x00	; 0
    1c22:	30 e0       	ldi	r19, 0x00	; 0
    1c24:	42 81       	ldd	r20, Z+2	; 0x02
    1c26:	0e 94 a6 24 	call	0x494c	; 0x494c <CmpValue>
    1c2a:	88 23       	and	r24, r24
    1c2c:	0c f0       	brlt	.+2      	; 0x1c30 <MeasureInductor+0x66>
    1c2e:	ea c0       	rjmp	.+468    	; 0x1e04 <MeasureInductor+0x23a>
   *    of large inductors and keep smaller time
   *  - in case of a small inductance run in high current mode (implies
   *    immediate mode only)
   */

  UpdateProbes(Resistor->A, Resistor->B, 0);      /* update probes */
    1c30:	40 e0       	ldi	r20, 0x00	; 0
    1c32:	f6 01       	movw	r30, r12
    1c34:	61 81       	ldd	r22, Z+1	; 0x01
    1c36:	80 81       	ld	r24, Z
    1c38:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <UpdateProbes>

  Mode = MODE_LOW_CURRENT;
  Test = MeasureInductance(&Time1, Mode);
    1c3c:	61 e0       	ldi	r22, 0x01	; 1
    1c3e:	ce 01       	movw	r24, r28
    1c40:	01 96       	adiw	r24, 0x01	; 1
    1c42:	0e 94 03 0d 	call	0x1a06	; 0x1a06 <MeasureInductance>
 
  if (Test == 2)                   /* inductance too low */
    1c46:	82 30       	cpi	r24, 0x02	; 2
    1c48:	b1 f4       	brne	.+44     	; 0x1c76 <MeasureInductor+0xac>
  {
    /* if resistance < 40 Ohms we may run the high current test */
    if (CmpValue(Resistor->Value, Resistor->Scale, 40, 0) < 0)
    1c4a:	f6 01       	movw	r30, r12
    1c4c:	63 81       	ldd	r22, Z+3	; 0x03
    1c4e:	74 81       	ldd	r23, Z+4	; 0x04
    1c50:	85 81       	ldd	r24, Z+5	; 0x05
    1c52:	96 81       	ldd	r25, Z+6	; 0x06
    1c54:	08 e2       	ldi	r16, 0x28	; 40
    1c56:	10 e0       	ldi	r17, 0x00	; 0
    1c58:	20 e0       	ldi	r18, 0x00	; 0
    1c5a:	30 e0       	ldi	r19, 0x00	; 0
    1c5c:	42 81       	ldd	r20, Z+2	; 0x02
    1c5e:	0e 94 a6 24 	call	0x494c	; 0x494c <CmpValue>
    1c62:	88 23       	and	r24, r24
    1c64:	0c f0       	brlt	.+2      	; 0x1c68 <MeasureInductor+0x9e>
    1c66:	d2 c0       	rjmp	.+420    	; 0x1e0c <MeasureInductor+0x242>
    {
      Mode = MODE_HIGH_CURRENT;
      Test = MeasureInductance(&Time1, Mode);
    1c68:	62 e0       	ldi	r22, 0x02	; 2
    1c6a:	ce 01       	movw	r24, r28
    1c6c:	01 96       	adiw	r24, 0x01	; 1
    1c6e:	0e 94 03 0d 	call	0x1a06	; 0x1a06 <MeasureInductance>
  if (Test == 2)                   /* inductance too low */
  {
    /* if resistance < 40 Ohms we may run the high current test */
    if (CmpValue(Resistor->Value, Resistor->Scale, 40, 0) < 0)
    {
      Mode = MODE_HIGH_CURRENT;
    1c72:	12 e0       	ldi	r17, 0x02	; 2
    1c74:	1c c0       	rjmp	.+56     	; 0x1cae <MeasureInductor+0xe4>
      Test = MeasureInductance(&Time1, Mode);
    }
  }
  else if (Test == 3)              /* valid time */
    1c76:	83 30       	cpi	r24, 0x03	; 3
    1c78:	09 f0       	breq	.+2      	; 0x1c7c <MeasureInductor+0xb2>
    1c7a:	c8 c0       	rjmp	.+400    	; 0x1e0c <MeasureInductor+0x242>
  {
    /* let's run the delayed mode */
    Mode = MODE_LOW_CURRENT | MODE_DELAYED_START;
    Test = MeasureInductance(&Time2, Mode);
    1c7c:	65 e0       	ldi	r22, 0x05	; 5
    1c7e:	ce 01       	movw	r24, r28
    1c80:	05 96       	adiw	r24, 0x05	; 5
    1c82:	0e 94 03 0d 	call	0x1a06	; 0x1a06 <MeasureInductance>
    if (Time1 > Time2) Time1 = Time2;        /* lower value wins */
    1c86:	4d 81       	ldd	r20, Y+5	; 0x05
    1c88:	5e 81       	ldd	r21, Y+6	; 0x06
    1c8a:	6f 81       	ldd	r22, Y+7	; 0x07
    1c8c:	78 85       	ldd	r23, Y+8	; 0x08
    1c8e:	89 80       	ldd	r8, Y+1	; 0x01
    1c90:	9a 80       	ldd	r9, Y+2	; 0x02
    1c92:	ab 80       	ldd	r10, Y+3	; 0x03
    1c94:	bc 80       	ldd	r11, Y+4	; 0x04
    1c96:	48 15       	cp	r20, r8
    1c98:	59 05       	cpc	r21, r9
    1c9a:	6a 05       	cpc	r22, r10
    1c9c:	7b 05       	cpc	r23, r11
    1c9e:	30 f4       	brcc	.+12     	; 0x1cac <MeasureInductor+0xe2>
    1ca0:	49 83       	std	Y+1, r20	; 0x01
    1ca2:	5a 83       	std	Y+2, r21	; 0x02
    1ca4:	6b 83       	std	Y+3, r22	; 0x03
    1ca6:	7c 83       	std	Y+4, r23	; 0x04
    }
  }
  else if (Test == 3)              /* valid time */
  {
    /* let's run the delayed mode */
    Mode = MODE_LOW_CURRENT | MODE_DELAYED_START;
    1ca8:	15 e0       	ldi	r17, 0x05	; 5
    1caa:	01 c0       	rjmp	.+2      	; 0x1cae <MeasureInductor+0xe4>
    1cac:	15 e0       	ldi	r17, 0x05	; 5
    Test = MeasureInductance(&Time2, Mode);
    if (Time1 > Time2) Time1 = Time2;        /* lower value wins */
  }  

  if (Test != 3) Test = 0;         /* measurements failed */
    1cae:	83 30       	cpi	r24, 0x03	; 3
    1cb0:	09 f0       	breq	.+2      	; 0x1cb4 <MeasureInductor+0xea>
    1cb2:	aa c0       	rjmp	.+340    	; 0x1e08 <MeasureInductor+0x23e>
    /*
     *  resistances
     */

    /* total resistance (in 0.1 Ohms) */
    R_total = RescaleValue(Resistor->Value, Resistor->Scale, -1);  /* R_L */
    1cb4:	f6 01       	movw	r30, r12
    1cb6:	63 81       	ldd	r22, Z+3	; 0x03
    1cb8:	74 81       	ldd	r23, Z+4	; 0x04
    1cba:	85 81       	ldd	r24, Z+5	; 0x05
    1cbc:	96 81       	ldd	r25, Z+6	; 0x06
    1cbe:	2f ef       	ldi	r18, 0xFF	; 255
    1cc0:	42 81       	ldd	r20, Z+2	; 0x02
    1cc2:	0e 94 26 25 	call	0x4a4c	; 0x4a4c <RescaleValue>
    R_total += Config.RiH + Config.RiL;
    1cc6:	ae e8       	ldi	r26, 0x8E	; 142
    1cc8:	b1 e0       	ldi	r27, 0x01	; 1
    1cca:	19 96       	adiw	r26, 0x09	; 9
    1ccc:	ed 91       	ld	r30, X+
    1cce:	fc 91       	ld	r31, X
    1cd0:	1a 97       	sbiw	r26, 0x0a	; 10
    1cd2:	1b 96       	adiw	r26, 0x0b	; 11
    1cd4:	8d 90       	ld	r8, X+
    1cd6:	9c 90       	ld	r9, X
    1cd8:	1c 97       	sbiw	r26, 0x0c	; 12
    1cda:	8e 0e       	add	r8, r30
    1cdc:	9f 1e       	adc	r9, r31
    1cde:	68 0d       	add	r22, r8
    1ce0:	79 1d       	adc	r23, r9

    /* shunt resistance (in 0.1 Ohms) */
    Factor = Config.RiL;

    if (Mode & MODE_LOW_CURRENT)        /* low current measurement mode */
    1ce2:	10 ff       	sbrs	r17, 0
    1ce4:	04 c0       	rjmp	.+8      	; 0x1cee <MeasureInductor+0x124>
    {
      /* add R_l */
      R_total += (R_LOW * 10);
    1ce6:	60 57       	subi	r22, 0x70	; 112
    1ce8:	75 4e       	sbci	r23, 0xE5	; 229
      Factor += (R_LOW * 10);
    1cea:	e0 57       	subi	r30, 0x70	; 112
    1cec:	f5 4e       	sbci	r31, 0xE5	; 229
     *  ratio and factor
     *  - ratio = ((U_ref * R_total) / (5V * R_shunt)) * 10^3
     */

    /* calculate ratio */
    Value = Config.Bandgap + Config.CompOffset;   /* = U_ref (in mV) */
    1cee:	ae e8       	ldi	r26, 0x8E	; 142
    1cf0:	b1 e0       	ldi	r27, 0x01	; 1
    1cf2:	51 96       	adiw	r26, 0x11	; 17
    1cf4:	8c 91       	ld	r24, X
    1cf6:	51 97       	sbiw	r26, 0x11	; 17
    1cf8:	15 96       	adiw	r26, 0x05	; 5
    1cfa:	0d 90       	ld	r0, X+
    1cfc:	bc 91       	ld	r27, X
    1cfe:	a0 2d       	mov	r26, r0
    1d00:	a8 0f       	add	r26, r24
    1d02:	b1 1d       	adc	r27, r1
    1d04:	87 fd       	sbrc	r24, 7
    1d06:	ba 95       	dec	r27
    Value *= R_total;                             /* * R_total (in 0.1 Ohms) */
    1d08:	4b 01       	movw	r8, r22
    1d0a:	a1 2c       	mov	r10, r1
    1d0c:	b1 2c       	mov	r11, r1
    1d0e:	a5 01       	movw	r20, r10
    1d10:	94 01       	movw	r18, r8
    1d12:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
    Value /= Factor;                              /* / R_shunt (in 0.1 Ohms) */
    1d16:	9f 01       	movw	r18, r30
    1d18:	40 e0       	ldi	r20, 0x00	; 0
    1d1a:	50 e0       	ldi	r21, 0x00	; 0
    1d1c:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    Value /= 5;                                   /* / 5000mV, * 10^3 */
    1d20:	ca 01       	movw	r24, r20
    1d22:	b9 01       	movw	r22, r18
    1d24:	25 e0       	ldi	r18, 0x05	; 5
    1d26:	30 e0       	ldi	r19, 0x00	; 0
    1d28:	40 e0       	ldi	r20, 0x00	; 0
    1d2a:	50 e0       	ldi	r21, 0x00	; 0
    1d2c:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>

    /* get ratio based factor */
    Factor = GetFactor((uint16_t)Value, TABLE_INDUCTOR);
    1d30:	63 e0       	ldi	r22, 0x03	; 3
    1d32:	c9 01       	movw	r24, r18
    1d34:	0e 94 4c 19 	call	0x3298	; 0x3298 <GetFactor>
    1d38:	7c 01       	movw	r14, r24
    *  calculate inductance
    *  L = t_stop * R_total * factor
    */

    Scale = -9;               /* nH by default */
    Value = Time1;            /* t_stop (in ns) */
    1d3a:	29 81       	ldd	r18, Y+1	; 0x01
    1d3c:	3a 81       	ldd	r19, Y+2	; 0x02
    1d3e:	4b 81       	ldd	r20, Y+3	; 0x03
    1d40:	5c 81       	ldd	r21, Y+4	; 0x04

    while (Value > 100000)    /* re-scale to prevent overflow */
    1d42:	21 3a       	cpi	r18, 0xA1	; 161
    1d44:	f6 e8       	ldi	r31, 0x86	; 134
    1d46:	3f 07       	cpc	r19, r31
    1d48:	f1 e0       	ldi	r31, 0x01	; 1
    1d4a:	4f 07       	cpc	r20, r31
    1d4c:	51 05       	cpc	r21, r1
    1d4e:	d8 f0       	brcs	.+54     	; 0x1d86 <MeasureInductor+0x1bc>
    1d50:	17 ef       	ldi	r17, 0xF7	; 247
    {
      Value += 5;             /* for automagic rounding */
      Value /= 10;            /* scale down by 10^1 */
    1d52:	0f 2e       	mov	r0, r31
    1d54:	fa e0       	ldi	r31, 0x0A	; 10
    1d56:	4f 2e       	mov	r4, r31
    1d58:	51 2c       	mov	r5, r1
    1d5a:	61 2c       	mov	r6, r1
    1d5c:	71 2c       	mov	r7, r1
    1d5e:	f0 2d       	mov	r31, r0
    Scale = -9;               /* nH by default */
    Value = Time1;            /* t_stop (in ns) */

    while (Value > 100000)    /* re-scale to prevent overflow */
    {
      Value += 5;             /* for automagic rounding */
    1d60:	ca 01       	movw	r24, r20
    1d62:	b9 01       	movw	r22, r18
    1d64:	6b 5f       	subi	r22, 0xFB	; 251
    1d66:	7f 4f       	sbci	r23, 0xFF	; 255
    1d68:	8f 4f       	sbci	r24, 0xFF	; 255
    1d6a:	9f 4f       	sbci	r25, 0xFF	; 255
      Value /= 10;            /* scale down by 10^1 */
    1d6c:	a3 01       	movw	r20, r6
    1d6e:	92 01       	movw	r18, r4
    1d70:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
      Scale++;                /* increase exponent by 1 */
    1d74:	1f 5f       	subi	r17, 0xFF	; 255
    */

    Scale = -9;               /* nH by default */
    Value = Time1;            /* t_stop (in ns) */

    while (Value > 100000)    /* re-scale to prevent overflow */
    1d76:	21 3a       	cpi	r18, 0xA1	; 161
    1d78:	86 e8       	ldi	r24, 0x86	; 134
    1d7a:	38 07       	cpc	r19, r24
    1d7c:	81 e0       	ldi	r24, 0x01	; 1
    1d7e:	48 07       	cpc	r20, r24
    1d80:	51 05       	cpc	r21, r1
    1d82:	70 f7       	brcc	.-36     	; 0x1d60 <MeasureInductor+0x196>
    1d84:	01 c0       	rjmp	.+2      	; 0x1d88 <MeasureInductor+0x1be>
   /*
    *  calculate inductance
    *  L = t_stop * R_total * factor
    */

    Scale = -9;               /* nH by default */
    1d86:	17 ef       	ldi	r17, 0xF7	; 247
      Value += 5;             /* for automagic rounding */
      Value /= 10;            /* scale down by 10^1 */
      Scale++;                /* increase exponent by 1 */
    }

    Value *= Factor;          /* * factor (in 10^-3) */
    1d88:	d7 01       	movw	r26, r14
    1d8a:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
    1d8e:	9b 01       	movw	r18, r22
    1d90:	ac 01       	movw	r20, r24

    while (Value > 100000)    /* re-scale to prevent overflow */
    1d92:	61 3a       	cpi	r22, 0xA1	; 161
    1d94:	76 48       	sbci	r23, 0x86	; 134
    1d96:	81 40       	sbci	r24, 0x01	; 1
    1d98:	91 05       	cpc	r25, r1
    1d9a:	c8 f0       	brcs	.+50     	; 0x1dce <MeasureInductor+0x204>
    {
      Value += 5;             /* for automagic rounding */
      Value /= 10;            /* scale down by 10^1 */
    1d9c:	0f 2e       	mov	r0, r31
    1d9e:	fa e0       	ldi	r31, 0x0A	; 10
    1da0:	cf 2e       	mov	r12, r31
    1da2:	d1 2c       	mov	r13, r1
    1da4:	e1 2c       	mov	r14, r1
    1da6:	f1 2c       	mov	r15, r1
    1da8:	f0 2d       	mov	r31, r0

    Value *= Factor;          /* * factor (in 10^-3) */

    while (Value > 100000)    /* re-scale to prevent overflow */
    {
      Value += 5;             /* for automagic rounding */
    1daa:	ca 01       	movw	r24, r20
    1dac:	b9 01       	movw	r22, r18
    1dae:	6b 5f       	subi	r22, 0xFB	; 251
    1db0:	7f 4f       	sbci	r23, 0xFF	; 255
    1db2:	8f 4f       	sbci	r24, 0xFF	; 255
    1db4:	9f 4f       	sbci	r25, 0xFF	; 255
      Value /= 10;            /* scale down by 10^1 */
    1db6:	a7 01       	movw	r20, r14
    1db8:	96 01       	movw	r18, r12
    1dba:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
      Scale++;                /* increase exponent by 1 */
    1dbe:	1f 5f       	subi	r17, 0xFF	; 255
      Scale++;                /* increase exponent by 1 */
    }

    Value *= Factor;          /* * factor (in 10^-3) */

    while (Value > 100000)    /* re-scale to prevent overflow */
    1dc0:	21 3a       	cpi	r18, 0xA1	; 161
    1dc2:	f6 e8       	ldi	r31, 0x86	; 134
    1dc4:	3f 07       	cpc	r19, r31
    1dc6:	f1 e0       	ldi	r31, 0x01	; 1
    1dc8:	4f 07       	cpc	r20, r31
    1dca:	51 05       	cpc	r21, r1
    1dcc:	70 f7       	brcc	.-36     	; 0x1daa <MeasureInductor+0x1e0>
      Value += 5;             /* for automagic rounding */
      Value /= 10;            /* scale down by 10^1 */
      Scale++;                /* increase exponent by 1 */
    }

    Value *= R_total;         /* * R_total (in 0.1 Ohms) */
    1dce:	c5 01       	movw	r24, r10
    1dd0:	b4 01       	movw	r22, r8
    1dd2:	0e 94 08 28 	call	0x5010	; 0x5010 <__mulsi3>
    Value /= 10000;           /* /1o for 1 Ohms, /1000 for factor */

    /* update data */
    Inductor.Scale = Scale;
    1dd6:	0f 2e       	mov	r0, r31
    1dd8:	f9 e8       	ldi	r31, 0x89	; 137
    1dda:	ef 2e       	mov	r14, r31
    1ddc:	f1 e0       	ldi	r31, 0x01	; 1
    1dde:	ff 2e       	mov	r15, r31
    1de0:	f0 2d       	mov	r31, r0
    1de2:	f7 01       	movw	r30, r14
    1de4:	10 83       	st	Z, r17
      Value /= 10;            /* scale down by 10^1 */
      Scale++;                /* increase exponent by 1 */
    }

    Value *= R_total;         /* * R_total (in 0.1 Ohms) */
    Value /= 10000;           /* /1o for 1 Ohms, /1000 for factor */
    1de6:	20 e1       	ldi	r18, 0x10	; 16
    1de8:	37 e2       	ldi	r19, 0x27	; 39
    1dea:	40 e0       	ldi	r20, 0x00	; 0
    1dec:	50 e0       	ldi	r21, 0x00	; 0
    1dee:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>

    /* update data */
    Inductor.Scale = Scale;
    Inductor.Value = Value;
    1df2:	f7 01       	movw	r30, r14
    1df4:	21 83       	std	Z+1, r18	; 0x01
    1df6:	32 83       	std	Z+2, r19	; 0x02
    1df8:	43 83       	std	Z+3, r20	; 0x03
    1dfa:	54 83       	std	Z+4, r21	; 0x04
    Test = 1;                 /* signal success */
    1dfc:	81 e0       	ldi	r24, 0x01	; 1
    1dfe:	07 c0       	rjmp	.+14     	; 0x1e0e <MeasureInductor+0x244>
  /* reset data */
  Inductor.Scale = 0;
  Inductor.Value = 0;

  /* sanity check */
  if (Resistor == NULL) return Test;
    1e00:	80 e0       	ldi	r24, 0x00	; 0
    1e02:	05 c0       	rjmp	.+10     	; 0x1e0e <MeasureInductor+0x244>

  /* limit resistor to 2k (feasibilty & prevent variable overflow) */ 
  if (CmpValue(Resistor->Value, Resistor->Scale, 2000, 0) >= 0) return Test;
    1e04:	80 e0       	ldi	r24, 0x00	; 0
    1e06:	03 c0       	rjmp	.+6      	; 0x1e0e <MeasureInductor+0x244>
    Mode = MODE_LOW_CURRENT | MODE_DELAYED_START;
    Test = MeasureInductance(&Time2, Mode);
    if (Time1 > Time2) Time1 = Time2;        /* lower value wins */
  }  

  if (Test != 3) Test = 0;         /* measurements failed */
    1e08:	80 e0       	ldi	r24, 0x00	; 0
    1e0a:	01 c0       	rjmp	.+2      	; 0x1e0e <MeasureInductor+0x244>
    1e0c:	80 e0       	ldi	r24, 0x00	; 0
    Inductor.Value = Value;
    Test = 1;                 /* signal success */
  }

  return Test;
}
    1e0e:	28 96       	adiw	r28, 0x08	; 8
    1e10:	0f b6       	in	r0, 0x3f	; 63
    1e12:	f8 94       	cli
    1e14:	de bf       	out	0x3e, r29	; 62
    1e16:	0f be       	out	0x3f, r0	; 63
    1e18:	cd bf       	out	0x3d, r28	; 61
    1e1a:	df 91       	pop	r29
    1e1c:	cf 91       	pop	r28
    1e1e:	1f 91       	pop	r17
    1e20:	0f 91       	pop	r16
    1e22:	ff 90       	pop	r15
    1e24:	ef 90       	pop	r14
    1e26:	df 90       	pop	r13
    1e28:	cf 90       	pop	r12
    1e2a:	bf 90       	pop	r11
    1e2c:	af 90       	pop	r10
    1e2e:	9f 90       	pop	r9
    1e30:	8f 90       	pop	r8
    1e32:	7f 90       	pop	r7
    1e34:	6f 90       	pop	r6
    1e36:	5f 90       	pop	r5
    1e38:	4f 90       	pop	r4
    1e3a:	08 95       	ret

00001e3c <LCD_Enable>:
 *  - LCD needs a pulse to take in data for processing
 */

void LCD_Enable(void)
{
   LCD_PORT |= (1 << LCD_EN1);     /* set enable bit */
    1e3c:	5d 9a       	sbi	0x0b, 5	; 11

   /* the LCD needs some time */
   /* if required adjust time according to LCD's datasheet */
   wait10us();
    1e3e:	0e 94 89 00 	call	0x112	; 0x112 <wait10us>

   LCD_PORT &= ~(1 << LCD_EN1);    /* unset enable bit */
    1e42:	5d 98       	cbi	0x0b, 5	; 11
    1e44:	08 95       	ret

00001e46 <LCD_Send>:
 *  requires:
 *  - byte value to send
 */

void LCD_Send(unsigned char Byte)
{
    1e46:	cf 93       	push	r28
    1e48:	c8 2f       	mov	r28, r24
  /* set upper nibble of byte */
  LCD_PORT = (LCD_PORT & 0xF0) | ((Byte >> 4) & 0x0F);
    1e4a:	9b b1       	in	r25, 0x0b	; 11
    1e4c:	82 95       	swap	r24
    1e4e:	8f 70       	andi	r24, 0x0F	; 15
    1e50:	90 7f       	andi	r25, 0xF0	; 240
    1e52:	98 2b       	or	r25, r24
    1e54:	9b b9       	out	0x0b, r25	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1e56:	00 c0       	rjmp	.+0      	; 0x1e58 <LCD_Send+0x12>
    1e58:	00 c0       	rjmp	.+0      	; 0x1e5a <LCD_Send+0x14>
    1e5a:	00 00       	nop
    _delay_us(5);
  #else
    wait5us();
  #endif

  LCD_Enable();          /* trigger LCD */
    1e5c:	0e 94 1e 0f 	call	0x1e3c	; 0x1e3c <LCD_Enable>

  /* set lower nibble of byte */ 
  LCD_PORT = (LCD_PORT & 0xF0) | (Byte & 0x0F);
    1e60:	9b b1       	in	r25, 0x0b	; 11
    1e62:	8c 2f       	mov	r24, r28
    1e64:	8f 70       	andi	r24, 0x0F	; 15
    1e66:	90 7f       	andi	r25, 0xF0	; 240
    1e68:	89 2b       	or	r24, r25
    1e6a:	8b b9       	out	0x0b, r24	; 11
    1e6c:	00 c0       	rjmp	.+0      	; 0x1e6e <LCD_Send+0x28>
    1e6e:	00 c0       	rjmp	.+0      	; 0x1e70 <LCD_Send+0x2a>
    1e70:	00 00       	nop
    _delay_us(5);
  #else
    wait5us();
  #endif

  LCD_Enable();          /* trigger LCD */
    1e72:	0e 94 1e 0f 	call	0x1e3c	; 0x1e3c <LCD_Enable>
  wait50us();            /* LCD needs some time for processing */
    1e76:	0e 94 85 00 	call	0x10a	; 0x10a <wait50us>
  LCD_PORT &= 0xF0;      /* clear data on port */
    1e7a:	8b b1       	in	r24, 0x0b	; 11
    1e7c:	80 7f       	andi	r24, 0xF0	; 240
    1e7e:	8b b9       	out	0x0b, r24	; 11
}
    1e80:	cf 91       	pop	r28
    1e82:	08 95       	ret

00001e84 <LCD_Cmd>:
 *  - byte value to send
 */
 
void LCD_Cmd(unsigned char Cmd)
{
  LCD_PORT &= ~(1 << LCD_RS);    /* set RS to 0 (command mode) */
    1e84:	5c 98       	cbi	0x0b, 4	; 11
  LCD_Send(Cmd);                 /* send command */
    1e86:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <LCD_Send>
    1e8a:	08 95       	ret

00001e8c <LCD_Data>:
 *  - byte value to send
 */

void LCD_Data(unsigned char Data)
{
  LCD_PORT |= (1 << LCD_RS);       /* set RS to 1 (data mode) */ 
    1e8c:	5c 9a       	sbi	0x0b, 4	; 11
  LCD_Send(Data);                  /* send data */
    1e8e:	0e 94 23 0f 	call	0x1e46	; 0x1e46 <LCD_Send>
    1e92:	08 95       	ret

00001e94 <LCD_Clear>:
 *  clear the display 
 */ 

void LCD_Clear(void)
{
  LCD_Cmd(CMD_CLEAR_DISPLAY);      /* send command */
    1e94:	81 e0       	ldi	r24, 0x01	; 1
    1e96:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <LCD_Cmd>
  MilliSleep(2);                   /* LCD needs some time for processing */
    1e9a:	82 e0       	ldi	r24, 0x02	; 2
    1e9c:	90 e0       	ldi	r25, 0x00	; 0
    1e9e:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>
    1ea2:	08 95       	ret

00001ea4 <LCD_Line2>:
  uint8_t           Cmd;

  /* command for moving cursor to start of line #2 */
  Cmd = CMD_SET_DD_RAM_ADDR | 0x40;

  LCD_Cmd(Cmd);               /* send command */
    1ea4:	80 ec       	ldi	r24, 0xC0	; 192
    1ea6:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <LCD_Cmd>
    1eaa:	08 95       	ret

00001eac <LCD_Init>:
 */
 
void LCD_Init(void)
{
  /* set port pins to output mode */
  LCD_DDR = LCD_DDR | 0x0F | (1 << LCD_RS) | (1 << LCD_EN1);
    1eac:	8a b1       	in	r24, 0x0a	; 10
    1eae:	8f 63       	ori	r24, 0x3F	; 63
    1eb0:	8a b9       	out	0x0a, r24	; 10
   *  - RS and R/W unset
   *  - DB4 and DB5 set
   */

   /* round #1 */
   MilliSleep(30);
    1eb2:	8e e1       	ldi	r24, 0x1E	; 30
    1eb4:	90 e0       	ldi	r25, 0x00	; 0
    1eb6:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>
   LCD_PORT = (LCD_PORT & 0xF0 & ~(1 << LCD_RS)) | 0x03;
    1eba:	8b b1       	in	r24, 0x0b	; 11
    1ebc:	80 7e       	andi	r24, 0xE0	; 224
    1ebe:	83 60       	ori	r24, 0x03	; 3
    1ec0:	8b b9       	out	0x0b, r24	; 11
   LCD_Enable();
    1ec2:	0e 94 1e 0f 	call	0x1e3c	; 0x1e3c <LCD_Enable>

   /* round #2 */
   MilliSleep(5);
    1ec6:	85 e0       	ldi	r24, 0x05	; 5
    1ec8:	90 e0       	ldi	r25, 0x00	; 0
    1eca:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>
   LCD_Enable();
    1ece:	0e 94 1e 0f 	call	0x1e3c	; 0x1e3c <LCD_Enable>

   /* round #3 */
   MilliSleep(1);
    1ed2:	81 e0       	ldi	r24, 0x01	; 1
    1ed4:	90 e0       	ldi	r25, 0x00	; 0
    1ed6:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>
   LCD_Enable();
    1eda:	0e 94 1e 0f 	call	0x1e3c	; 0x1e3c <LCD_Enable>
   /*
    *  set modes
    */

   /* init 4 bit mode  */
   MilliSleep(1);
    1ede:	81 e0       	ldi	r24, 0x01	; 1
    1ee0:	90 e0       	ldi	r25, 0x00	; 0
    1ee2:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>
   LCD_PORT = (LCD_PORT & 0xF0 & ~(1 << LCD_RS)) | 0x02;
    1ee6:	8b b1       	in	r24, 0x0b	; 11
    1ee8:	80 7e       	andi	r24, 0xE0	; 224
    1eea:	82 60       	ori	r24, 0x02	; 2
    1eec:	8b b9       	out	0x0b, r24	; 11
   MilliSleep(1);
    1eee:	81 e0       	ldi	r24, 0x01	; 1
    1ef0:	90 e0       	ldi	r25, 0x00	; 0
    1ef2:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>
   LCD_Enable();
    1ef6:	0e 94 1e 0f 	call	0x1e3c	; 0x1e3c <LCD_Enable>
   MilliSleep(1);
    1efa:	81 e0       	ldi	r24, 0x01	; 1
    1efc:	90 e0       	ldi	r25, 0x00	; 0
    1efe:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>

   /* function set: 4 bit interface / 2 rows / font 5x7 */
   LCD_Cmd(CMD_FUNCTION_SET | 0x08);
    1f02:	88 e2       	ldi	r24, 0x28	; 40
    1f04:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <LCD_Cmd>

   /* display: display on / cursor off / no blinking */
   LCD_Cmd(CMD_DISPLAY_CONTROL | 0x04);
    1f08:	8c e0       	ldi	r24, 0x0C	; 12
    1f0a:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <LCD_Cmd>

   /* entry mode: increment cursor position / no scrolling */    
   LCD_Cmd(CMD_ENTRY_MODE_SET | 0x02);	
    1f0e:	86 e0       	ldi	r24, 0x06	; 6
    1f10:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <LCD_Cmd>

   /* and clear display */
   LCD_Clear();
    1f14:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>
    1f18:	08 95       	ret

00001f1a <LCD_EELoadChar>:
 *  - pointer of fixed character data
 *  - ID for custom character (0-7)
 */

void LCD_EELoadChar(const unsigned char *CharData, uint8_t ID)
{
    1f1a:	0f 93       	push	r16
    1f1c:	1f 93       	push	r17
    1f1e:	cf 93       	push	r28
    1f20:	df 93       	push	r29
    1f22:	ec 01       	movw	r28, r24
   *  - higher 3 bits determine the start of the character
   *  - so we have to shift the ID to the higher part
   *  - LCD module supports up to 8 custom characters for 5x8 font
   */

  LCD_Cmd(CMD_SET_CG_RAM_ADDR | (ID << 3));
    1f24:	86 2f       	mov	r24, r22
    1f26:	88 0f       	add	r24, r24
    1f28:	88 0f       	add	r24, r24
    1f2a:	88 0f       	add	r24, r24
    1f2c:	80 64       	ori	r24, 0x40	; 64
    1f2e:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <LCD_Cmd>
    1f32:	8e 01       	movw	r16, r28
    1f34:	08 5f       	subi	r16, 0xF8	; 248
    1f36:	1f 4f       	sbci	r17, 0xFF	; 255

  /* write custom character */
  for (i = 0; i < 8; i++)               /* do 8 times */
  {
    LCD_Data(eeprom_read_byte(CharData));    /* send byte */
    1f38:	ce 01       	movw	r24, r28
    1f3a:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <eeprom_read_byte>
    1f3e:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    CharData++;                              /* next one */
    1f42:	21 96       	adiw	r28, 0x01	; 1
   */

  LCD_Cmd(CMD_SET_CG_RAM_ADDR | (ID << 3));

  /* write custom character */
  for (i = 0; i < 8; i++)               /* do 8 times */
    1f44:	c0 17       	cp	r28, r16
    1f46:	d1 07       	cpc	r29, r17
    1f48:	b9 f7       	brne	.-18     	; 0x1f38 <LCD_EELoadChar+0x1e>
  {
    LCD_Data(eeprom_read_byte(CharData));    /* send byte */
    CharData++;                              /* next one */
  }
}
    1f4a:	df 91       	pop	r29
    1f4c:	cf 91       	pop	r28
    1f4e:	1f 91       	pop	r17
    1f50:	0f 91       	pop	r16
    1f52:	08 95       	ret

00001f54 <LCD_ClearLine2>:
 *  - by writing 20 spaces
 *  - cursor is set to first char of line
 */

void LCD_ClearLine2(void)
{
    1f54:	cf 93       	push	r28
  unsigned char     Pos;

  LCD_Line2();                     /* go to beginning of line */
    1f56:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>
    1f5a:	c4 e1       	ldi	r28, 0x14	; 20

  for (Pos = 0; Pos < 20; Pos++)   /* for 20 times */
  {
    LCD_Data(' ');                   /* send space */
    1f5c:	80 e2       	ldi	r24, 0x20	; 32
    1f5e:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    1f62:	c1 50       	subi	r28, 0x01	; 1
{
  unsigned char     Pos;

  LCD_Line2();                     /* go to beginning of line */

  for (Pos = 0; Pos < 20; Pos++)   /* for 20 times */
    1f64:	d9 f7       	brne	.-10     	; 0x1f5c <LCD_ClearLine2+0x8>
  {
    LCD_Data(' ');                   /* send space */
  }

  LCD_Line2();                     /* go back to beginning of line */  
    1f66:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>
}
    1f6a:	cf 91       	pop	r28
    1f6c:	08 95       	ret

00001f6e <LCD_ProbeNumber>:
 */
 
void LCD_ProbeNumber(unsigned char Probe)
{
  /* since TP1 is 0 we simply add the value to '1' */
  LCD_Data('1' + Probe);           /* send data */
    1f6e:	8f 5c       	subi	r24, 0xCF	; 207
    1f70:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    1f74:	08 95       	ret

00001f76 <LCD_Space>:
 *  display a space
 */

void LCD_Space(void)
{
  LCD_Data(' ');
    1f76:	80 e2       	ldi	r24, 0x20	; 32
    1f78:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    1f7c:	08 95       	ret

00001f7e <LCD_EEString>:
 *  requires:
 *  - pointer to fixed string
 */

void LCD_EEString(const unsigned char *String)
{
    1f7e:	cf 93       	push	r28
    1f80:	df 93       	push	r29
    1f82:	ec 01       	movw	r28, r24
  unsigned char     Char;

  while (1)
  {
    Char = eeprom_read_byte(String);    /* read character */
    1f84:	ce 01       	movw	r24, r28
    1f86:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <eeprom_read_byte>

    /* check for end of string */
    if ((Char == 0) || (Char == 128)) break;
    1f8a:	98 2f       	mov	r25, r24
    1f8c:	9f 77       	andi	r25, 0x7F	; 127
    1f8e:	21 f0       	breq	.+8      	; 0x1f98 <LCD_EEString+0x1a>

    LCD_Data(Char);                     /* send character */
    1f90:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    String++;                           /* next one */
    1f94:	21 96       	adiw	r28, 0x01	; 1
  }
    1f96:	f6 cf       	rjmp	.-20     	; 0x1f84 <LCD_EEString+0x6>
}
    1f98:	df 91       	pop	r29
    1f9a:	cf 91       	pop	r28
    1f9c:	08 95       	ret

00001f9e <LCD_EEString2>:
 *  - pointer to fixed string
 */

void LCD_EEString2(const unsigned char *String)
{
  LCD_EEString(String);       /* display string */
    1f9e:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
  LCD_Space();                /* print space */
    1fa2:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>
    1fa6:	08 95       	ret

00001fa8 <UpdateLine2>:
 *  wait for key press and goto display line #2
 */

void UpdateLine2(void)
{
  WaitKey();                  /* next page */
    1fa8:	0e 94 cb 26 	call	0x4d96	; 0x4d96 <WaitKey>
  LCD_ClearLine2();           /* only change line #2 */
    1fac:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <LCD_ClearLine2>
    1fb0:	08 95       	ret

00001fb2 <Show_SemiPinout>:
 *  - character for pin B
 *  - character for pin C
 */

void Show_SemiPinout(uint8_t A, uint8_t B, uint8_t C)
{
    1fb2:	8f 92       	push	r8
    1fb4:	9f 92       	push	r9
    1fb6:	af 92       	push	r10
    1fb8:	bf 92       	push	r11
    1fba:	df 92       	push	r13
    1fbc:	ef 92       	push	r14
    1fbe:	ff 92       	push	r15
    1fc0:	0f 93       	push	r16
    1fc2:	1f 93       	push	r17
    1fc4:	cf 93       	push	r28
    1fc6:	df 93       	push	r29
    1fc8:	00 d0       	rcall	.+0      	; 0x1fca <Show_SemiPinout+0x18>
    1fca:	00 d0       	rcall	.+0      	; 0x1fcc <Show_SemiPinout+0x1a>
    1fcc:	00 d0       	rcall	.+0      	; 0x1fce <Show_SemiPinout+0x1c>
    1fce:	cd b7       	in	r28, 0x3d	; 61
    1fd0:	de b7       	in	r29, 0x3e	; 62
  uint8_t           i, j;     /* counter */
  unsigned char     Pin[3];   /* component pins */
  unsigned char     ID[3];    /* component pin IDs */

  /* copy probe pin numbers */
  Pin[0] = Semi.A;
    1fd2:	ef e6       	ldi	r30, 0x6F	; 111
    1fd4:	f1 e0       	ldi	r31, 0x01	; 1
    1fd6:	90 81       	ld	r25, Z
    1fd8:	99 83       	std	Y+1, r25	; 0x01
  Pin[1] = Semi.B;
    1fda:	91 81       	ldd	r25, Z+1	; 0x01
    1fdc:	9a 83       	std	Y+2, r25	; 0x02
  Pin[2] = Semi.C;
    1fde:	92 81       	ldd	r25, Z+2	; 0x02
    1fe0:	9b 83       	std	Y+3, r25	; 0x03

  /* copy pin characters/IDs */
  ID[0] = A;
    1fe2:	8c 83       	std	Y+4, r24	; 0x04
  ID[1] = B;
    1fe4:	6d 83       	std	Y+5, r22	; 0x05
  ID[2] = C;
    1fe6:	4e 83       	std	Y+6, r20	; 0x06

  /* display: 123 */
  for (i = 0; i <= 2; i++)
  {
    LCD_ProbeNumber(i);
    1fe8:	80 e0       	ldi	r24, 0x00	; 0
    1fea:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <LCD_ProbeNumber>
    1fee:	81 e0       	ldi	r24, 0x01	; 1
    1ff0:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <LCD_ProbeNumber>
    1ff4:	82 e0       	ldi	r24, 0x02	; 2
    1ff6:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <LCD_ProbeNumber>
  }

  /* display: = */
  LCD_Data('=');
    1ffa:	8d e3       	ldi	r24, 0x3D	; 61
    1ffc:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>

  /* display pin IDs */
  for (i = 0; i <= 2; i++)         /* loop through probe pins */
    2000:	d1 2c       	mov	r13, r1
    2002:	4e 01       	movw	r8, r28
    2004:	84 e0       	ldi	r24, 0x04	; 4
    2006:	88 0e       	add	r8, r24
    2008:	91 1c       	adc	r9, r1
    200a:	54 01       	movw	r10, r8
    200c:	13 c0       	rjmp	.+38     	; 0x2034 <Show_SemiPinout+0x82>
  {
    for (j = 0; j <= 2; j++)       /* loop through component pins */
    {
      if (i == Pin[j])        /* probe pin matches */
    200e:	f8 01       	movw	r30, r16
    2010:	81 91       	ld	r24, Z+
    2012:	8f 01       	movw	r16, r30
    2014:	8d 11       	cpse	r24, r13
    2016:	04 c0       	rjmp	.+8      	; 0x2020 <Show_SemiPinout+0x6e>
      {
        LCD_Data(ID[j]);           /* show ID */
    2018:	f7 01       	movw	r30, r14
    201a:	80 81       	ld	r24, Z
    201c:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    2020:	ff ef       	ldi	r31, 0xFF	; 255
    2022:	ef 1a       	sub	r14, r31
    2024:	ff 0a       	sbc	r15, r31
  LCD_Data('=');

  /* display pin IDs */
  for (i = 0; i <= 2; i++)         /* loop through probe pins */
  {
    for (j = 0; j <= 2; j++)       /* loop through component pins */
    2026:	0a 15       	cp	r16, r10
    2028:	1b 05       	cpc	r17, r11
    202a:	89 f7       	brne	.-30     	; 0x200e <Show_SemiPinout+0x5c>

  /* display: = */
  LCD_Data('=');

  /* display pin IDs */
  for (i = 0; i <= 2; i++)         /* loop through probe pins */
    202c:	d3 94       	inc	r13
    202e:	83 e0       	ldi	r24, 0x03	; 3
    2030:	d8 16       	cp	r13, r24
    2032:	29 f0       	breq	.+10     	; 0x203e <Show_SemiPinout+0x8c>
    2034:	8e 01       	movw	r16, r28
    2036:	0f 5f       	subi	r16, 0xFF	; 255
    2038:	1f 4f       	sbci	r17, 0xFF	; 255
    203a:	74 01       	movw	r14, r8
    203c:	e8 cf       	rjmp	.-48     	; 0x200e <Show_SemiPinout+0x5c>
      {
        LCD_Data(ID[j]);           /* show ID */
      }
    }
  }
}
    203e:	26 96       	adiw	r28, 0x06	; 6
    2040:	0f b6       	in	r0, 0x3f	; 63
    2042:	f8 94       	cli
    2044:	de bf       	out	0x3e, r29	; 62
    2046:	0f be       	out	0x3f, r0	; 63
    2048:	cd bf       	out	0x3d, r28	; 61
    204a:	df 91       	pop	r29
    204c:	cf 91       	pop	r28
    204e:	1f 91       	pop	r17
    2050:	0f 91       	pop	r16
    2052:	ff 90       	pop	r15
    2054:	ef 90       	pop	r14
    2056:	df 90       	pop	r13
    2058:	bf 90       	pop	r11
    205a:	af 90       	pop	r10
    205c:	9f 90       	pop	r9
    205e:	8f 90       	pop	r8
    2060:	08 95       	ret

00002062 <Show_Fail>:
 */

void Show_Fail(void)
{
  /* display info */
  LCD_EEString(Failed1_str);            /* display: No component */
    2062:	87 e6       	ldi	r24, 0x67	; 103
    2064:	92 e0       	ldi	r25, 0x02	; 2
    2066:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
  LCD_Line2();                          /* move to line #2 */
    206a:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>
  LCD_EEString(Failed2_str);            /* display: found!*/  
    206e:	80 e6       	ldi	r24, 0x60	; 96
    2070:	92 e0       	ldi	r25, 0x02	; 2
    2072:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>

  /* display numbers of diodes found */
  if (Check.Diodes > 0)                 /* diodes found */
    2076:	80 91 04 01 	lds	r24, 0x0104
    207a:	88 23       	and	r24, r24
    207c:	69 f0       	breq	.+26     	; 0x2098 <Show_Fail+0x36>
  {
    LCD_Space();                        /* display space */
    207e:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>
    LCD_Data(Check.Diodes + '0');       /* display number of diodes found */
    2082:	80 91 04 01 	lds	r24, 0x0104
    2086:	80 5d       	subi	r24, 0xD0	; 208
    2088:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    LCD_Space();                        /* display space */
    208c:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>
    LCD_EEString(Diode_AC_str);         /* display: -|>|- */    
    2090:	84 e0       	ldi	r24, 0x04	; 4
    2092:	91 e0       	ldi	r25, 0x01	; 1
    2094:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
  }

  RunsMissed++;               /* increase counter */
    2098:	80 91 7c 01 	lds	r24, 0x017C
    209c:	8f 5f       	subi	r24, 0xFF	; 255
    209e:	80 93 7c 01 	sts	0x017C, r24
  RunsPassed = 0;             /* reset counter */
    20a2:	10 92 6e 01 	sts	0x016E, r1
    20a6:	08 95       	ret

000020a8 <Show_Error>:
/*
 *  show error
 */

void Show_Error()
{
    20a8:	cf 93       	push	r28
    20aa:	df 93       	push	r29
  if (Check.Type == TYPE_DISCHARGE)     /* discharge failed */
    20ac:	80 91 02 01 	lds	r24, 0x0102
    20b0:	81 30       	cpi	r24, 0x01	; 1
    20b2:	c1 f4       	brne	.+48     	; 0x20e4 <Show_Error+0x3c>
  {
    LCD_EEString(DischargeFailed_str);  /* display: Battery? */
    20b4:	88 e0       	ldi	r24, 0x08	; 8
    20b6:	92 e0       	ldi	r25, 0x02	; 2
    20b8:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>

    /* display probe number and remaining voltage */
    LCD_Line2();
    20bc:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>
    LCD_ProbeNumber(Check.Probe);
    20c0:	c0 e0       	ldi	r28, 0x00	; 0
    20c2:	d1 e0       	ldi	r29, 0x01	; 1
    20c4:	8d 81       	ldd	r24, Y+5	; 0x05
    20c6:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <LCD_ProbeNumber>
    LCD_Data(':');
    20ca:	8a e3       	ldi	r24, 0x3A	; 58
    20cc:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    LCD_Space();
    20d0:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>
    DisplayValue(Check.U, -3, 'V');
    20d4:	6e 81       	ldd	r22, Y+6	; 0x06
    20d6:	7f 81       	ldd	r23, Y+7	; 0x07
    20d8:	80 e0       	ldi	r24, 0x00	; 0
    20da:	90 e0       	ldi	r25, 0x00	; 0
    20dc:	26 e5       	ldi	r18, 0x56	; 86
    20de:	4d ef       	ldi	r20, 0xFD	; 253
    20e0:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
  }
}
    20e4:	df 91       	pop	r29
    20e6:	cf 91       	pop	r28
    20e8:	08 95       	ret

000020ea <Show_SingleResistor>:
 *  - ID1 pin ID character
 *  - ID2 pin ID character
 */

void Show_SingleResistor(uint8_t ID1, uint8_t ID2)
{
    20ea:	cf 93       	push	r28
    20ec:	c6 2f       	mov	r28, r22
  Resistor_Type     *Resistor;     /* pointer to resistor */

  Resistor = &Resistors[0];        /* pointer to first resistor */

  /* show pinout */
  LCD_Data(ID1);
    20ee:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
  LCD_EEString(Resistor_str);
    20f2:	8b ef       	ldi	r24, 0xFB	; 251
    20f4:	90 e0       	ldi	r25, 0x00	; 0
    20f6:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
  LCD_Data(ID2); 
    20fa:	8c 2f       	mov	r24, r28
    20fc:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>

  /* show resistance value */
  LCD_Space();
    2100:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>
  DisplayValue(Resistor->Value, Resistor->Scale, LCD_CHAR_OMEGA);
    2104:	e8 e0       	ldi	r30, 0x08	; 8
    2106:	f1 e0       	ldi	r31, 0x01	; 1
    2108:	63 81       	ldd	r22, Z+3	; 0x03
    210a:	74 81       	ldd	r23, Z+4	; 0x04
    210c:	85 81       	ldd	r24, Z+5	; 0x05
    210e:	96 81       	ldd	r25, Z+6	; 0x06
    2110:	24 ef       	ldi	r18, 0xF4	; 244
    2112:	42 81       	ldd	r20, Z+2	; 0x02
    2114:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
}
    2118:	cf 91       	pop	r28
    211a:	08 95       	ret

0000211c <Show_Resistor>:
/*
 *  show resistor(s)
 */

void Show_Resistor(void)
{
    211c:	cf 92       	push	r12
    211e:	df 92       	push	r13
    2120:	ef 92       	push	r14
    2122:	ff 92       	push	r15
    2124:	0f 93       	push	r16
    2126:	1f 93       	push	r17
    2128:	cf 93       	push	r28
    212a:	df 93       	push	r29
  Resistor_Type     *R2;           /* pointer to resistor #2 */
  uint8_t           Pin;           /* ID of common pin */

  R1 = &Resistors[0];              /* pointer to first resistor */

  if (Check.Resistors == 1)        /* single resistor */
    212c:	80 91 03 01 	lds	r24, 0x0103
    2130:	81 30       	cpi	r24, 0x01	; 1
    2132:	39 f4       	brne	.+14     	; 0x2142 <Show_Resistor+0x26>
  {
    R2 = NULL;                     /* disable second resistor */
    Pin = R1->A;                   /* make B the first pin */
    2134:	f0 90 08 01 	lds	r15, 0x0108

  R1 = &Resistors[0];              /* pointer to first resistor */

  if (Check.Resistors == 1)        /* single resistor */
  {
    R2 = NULL;                     /* disable second resistor */
    2138:	c0 e0       	ldi	r28, 0x00	; 0
    213a:	d0 e0       	ldi	r29, 0x00	; 0
{
  Resistor_Type     *R1;           /* pointer to resistor #1 */
  Resistor_Type     *R2;           /* pointer to resistor #2 */
  uint8_t           Pin;           /* ID of common pin */

  R1 = &Resistors[0];              /* pointer to first resistor */
    213c:	08 e0       	ldi	r16, 0x08	; 8
    213e:	11 e0       	ldi	r17, 0x01	; 1
    2140:	57 c0       	rjmp	.+174    	; 0x21f0 <Show_Resistor+0xd4>
  else                             /* multiple resistors */
  {
    R2 = R1;
    R2++;                          /* pointer to second resistor */

    if (Check.Resistors == 3)      /* three resistors */
    2142:	83 30       	cpi	r24, 0x03	; 3
    2144:	09 f0       	breq	.+2      	; 0x2148 <Show_Resistor+0x2c>
    2146:	47 c0       	rjmp	.+142    	; 0x21d6 <Show_Resistor+0xba>
       */

      Rmax = R1;                   /* starting point */
      for (Pin = 1; Pin <= 2; Pin++)
      {
        if (CmpValue(R2->Value, R2->Scale, Rmax->Value, Rmax->Scale) == 1)
    2148:	e8 e0       	ldi	r30, 0x08	; 8
    214a:	f1 e0       	ldi	r31, 0x01	; 1
    214c:	03 81       	ldd	r16, Z+3	; 0x03
    214e:	14 81       	ldd	r17, Z+4	; 0x04
    2150:	25 81       	ldd	r18, Z+5	; 0x05
    2152:	36 81       	ldd	r19, Z+6	; 0x06
    2154:	62 85       	ldd	r22, Z+10	; 0x0a
    2156:	73 85       	ldd	r23, Z+11	; 0x0b
    2158:	84 85       	ldd	r24, Z+12	; 0x0c
    215a:	95 85       	ldd	r25, Z+13	; 0x0d
    215c:	e2 80       	ldd	r14, Z+2	; 0x02
    215e:	41 85       	ldd	r20, Z+9	; 0x09
    2160:	0e 94 a6 24 	call	0x494c	; 0x494c <CmpValue>
    2164:	81 30       	cpi	r24, 0x01	; 1
    2166:	39 f4       	brne	.+14     	; 0x2176 <Show_Resistor+0x5a>
    2168:	0f 2e       	mov	r0, r31
    216a:	ff e0       	ldi	r31, 0x0F	; 15
    216c:	cf 2e       	mov	r12, r31
    216e:	f1 e0       	ldi	r31, 0x01	; 1
    2170:	df 2e       	mov	r13, r31
    2172:	f0 2d       	mov	r31, r0
    2174:	06 c0       	rjmp	.+12     	; 0x2182 <Show_Resistor+0x66>
    2176:	0f 2e       	mov	r0, r31
    2178:	f8 e0       	ldi	r31, 0x08	; 8
    217a:	cf 2e       	mov	r12, r31
    217c:	f1 e0       	ldi	r31, 0x01	; 1
    217e:	df 2e       	mov	r13, r31
    2180:	f0 2d       	mov	r31, r0
    2182:	d6 01       	movw	r26, r12
    2184:	13 96       	adiw	r26, 0x03	; 3
    2186:	0d 91       	ld	r16, X+
    2188:	1d 91       	ld	r17, X+
    218a:	2d 91       	ld	r18, X+
    218c:	3c 91       	ld	r19, X
    218e:	16 97       	sbiw	r26, 0x06	; 6
    2190:	e8 e0       	ldi	r30, 0x08	; 8
    2192:	f1 e0       	ldi	r31, 0x01	; 1
    2194:	61 89       	ldd	r22, Z+17	; 0x11
    2196:	72 89       	ldd	r23, Z+18	; 0x12
    2198:	83 89       	ldd	r24, Z+19	; 0x13
    219a:	94 89       	ldd	r25, Z+20	; 0x14
    219c:	12 96       	adiw	r26, 0x02	; 2
    219e:	ec 90       	ld	r14, X
    21a0:	40 89       	ldd	r20, Z+16	; 0x10
    21a2:	0e 94 a6 24 	call	0x494c	; 0x494c <CmpValue>
    21a6:	81 30       	cpi	r24, 0x01	; 1
    21a8:	09 f4       	brne	.+2      	; 0x21ac <Show_Resistor+0x90>
    21aa:	7b c0       	rjmp	.+246    	; 0x22a2 <Show_Resistor+0x186>

        R2++;                 /* next one */
      }

      /* get the two smaller resistors */
      if (R1 == Rmax) R1++;
    21ac:	b8 e0       	ldi	r27, 0x08	; 8
    21ae:	cb 16       	cp	r12, r27
    21b0:	b1 e0       	ldi	r27, 0x01	; 1
    21b2:	db 06       	cpc	r13, r27
    21b4:	19 f0       	breq	.+6      	; 0x21bc <Show_Resistor+0xa0>
{
  Resistor_Type     *R1;           /* pointer to resistor #1 */
  Resistor_Type     *R2;           /* pointer to resistor #2 */
  uint8_t           Pin;           /* ID of common pin */

  R1 = &Resistors[0];              /* pointer to first resistor */
    21b6:	08 e0       	ldi	r16, 0x08	; 8
    21b8:	11 e0       	ldi	r17, 0x01	; 1
    21ba:	02 c0       	rjmp	.+4      	; 0x21c0 <Show_Resistor+0xa4>

        R2++;                 /* next one */
      }

      /* get the two smaller resistors */
      if (R1 == Rmax) R1++;
    21bc:	0f e0       	ldi	r16, 0x0F	; 15
    21be:	11 e0       	ldi	r17, 0x01	; 1
      R2 = R1;
      R2++;
    21c0:	e8 01       	movw	r28, r16
    21c2:	27 96       	adiw	r28, 0x07	; 7
      if (R2 == Rmax) R2++;
    21c4:	cc 16       	cp	r12, r28
    21c6:	dd 06       	cpc	r13, r29
    21c8:	51 f4       	brne	.+20     	; 0x21de <Show_Resistor+0xc2>
    21ca:	02 c0       	rjmp	.+4      	; 0x21d0 <Show_Resistor+0xb4>

        R2++;                 /* next one */
      }

      /* get the two smaller resistors */
      if (R1 == Rmax) R1++;
    21cc:	0f e0       	ldi	r16, 0x0F	; 15
    21ce:	11 e0       	ldi	r17, 0x01	; 1
      R2 = R1;
      R2++;
      if (R2 == Rmax) R2++;
    21d0:	e8 01       	movw	r28, r16
    21d2:	2e 96       	adiw	r28, 0x0e	; 14
    21d4:	04 c0       	rjmp	.+8      	; 0x21de <Show_Resistor+0xc2>
    Pin = R1->A;                   /* make B the first pin */
  }
  else                             /* multiple resistors */
  {
    R2 = R1;
    R2++;                          /* pointer to second resistor */
    21d6:	cf e0       	ldi	r28, 0x0F	; 15
    21d8:	d1 e0       	ldi	r29, 0x01	; 1
{
  Resistor_Type     *R1;           /* pointer to resistor #1 */
  Resistor_Type     *R2;           /* pointer to resistor #2 */
  uint8_t           Pin;           /* ID of common pin */

  R1 = &Resistors[0];              /* pointer to first resistor */
    21da:	08 e0       	ldi	r16, 0x08	; 8
    21dc:	11 e0       	ldi	r17, 0x01	; 1
      R2++;
      if (R2 == Rmax) R2++;
    }

    /* find common pin of both resistors */
    if ((R1->A == R2->A) || (R1->A == R2->B)) Pin = R1->A;
    21de:	f8 01       	movw	r30, r16
    21e0:	80 81       	ld	r24, Z
    21e2:	f8 80       	ld	r15, Y
    21e4:	8f 15       	cp	r24, r15
    21e6:	59 f0       	breq	.+22     	; 0x21fe <Show_Resistor+0xe2>
    21e8:	f9 80       	ldd	r15, Y+1	; 0x01
    21ea:	8f 15       	cp	r24, r15
    21ec:	41 f0       	breq	.+16     	; 0x21fe <Show_Resistor+0xe2>
    else Pin = R1->B;
    21ee:	f1 80       	ldd	r15, Z+1	; 0x01
  /*
   *  display the pins
   */

  /* first resistor */
  if (R1->A != Pin) LCD_ProbeNumber(R1->A);
    21f0:	d8 01       	movw	r26, r16
    21f2:	8c 91       	ld	r24, X
    21f4:	8f 15       	cp	r24, r15
    21f6:	19 f0       	breq	.+6      	; 0x21fe <Show_Resistor+0xe2>
    21f8:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <LCD_ProbeNumber>
    21fc:	04 c0       	rjmp	.+8      	; 0x2206 <Show_Resistor+0xea>
  else LCD_ProbeNumber(R1->B);
    21fe:	f8 01       	movw	r30, r16
    2200:	81 81       	ldd	r24, Z+1	; 0x01
    2202:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <LCD_ProbeNumber>
  LCD_EEString(Resistor_str);
    2206:	8b ef       	ldi	r24, 0xFB	; 251
    2208:	90 e0       	ldi	r25, 0x00	; 0
    220a:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
  LCD_ProbeNumber(Pin);
    220e:	8f 2d       	mov	r24, r15
    2210:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <LCD_ProbeNumber>

  if (R2)           /* second resistor */
    2214:	20 97       	sbiw	r28, 0x00	; 0
    2216:	a1 f1       	breq	.+104    	; 0x2280 <Show_Resistor+0x164>
  {
    LCD_EEString(Resistor_str);
    2218:	8b ef       	ldi	r24, 0xFB	; 251
    221a:	90 e0       	ldi	r25, 0x00	; 0
    221c:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
    if (R2->A != Pin) LCD_ProbeNumber(R2->A);
    2220:	88 81       	ld	r24, Y
    2222:	8f 15       	cp	r24, r15
    2224:	19 f0       	breq	.+6      	; 0x222c <Show_Resistor+0x110>
    2226:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <LCD_ProbeNumber>
    222a:	11 c0       	rjmp	.+34     	; 0x224e <Show_Resistor+0x132>
    else LCD_ProbeNumber(R2->B);
    222c:	89 81       	ldd	r24, Y+1	; 0x01
    222e:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <LCD_ProbeNumber>
    2232:	0d c0       	rjmp	.+26     	; 0x224e <Show_Resistor+0x132>
  else                   /* single resistor */
  {
    /* get inductance and display if relevant */
    if (MeasureInductor(R1) == 1)
    {
      LCD_Space();
    2234:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>
      DisplayValue(Inductor.Value, Inductor.Scale, 'H');
    2238:	e9 e8       	ldi	r30, 0x89	; 137
    223a:	f1 e0       	ldi	r31, 0x01	; 1
    223c:	61 81       	ldd	r22, Z+1	; 0x01
    223e:	72 81       	ldd	r23, Z+2	; 0x02
    2240:	83 81       	ldd	r24, Z+3	; 0x03
    2242:	94 81       	ldd	r25, Z+4	; 0x04
    2244:	28 e4       	ldi	r18, 0x48	; 72
    2246:	40 81       	ld	r20, Z
    2248:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
    224c:	33 c0       	rjmp	.+102    	; 0x22b4 <Show_Resistor+0x198>
  /*
   *  display the values
   */

  /* first resistor */
  LCD_Line2();
    224e:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>
  DisplayValue(R1->Value, R1->Scale, LCD_CHAR_OMEGA);
    2252:	d8 01       	movw	r26, r16
    2254:	13 96       	adiw	r26, 0x03	; 3
    2256:	6d 91       	ld	r22, X+
    2258:	7d 91       	ld	r23, X+
    225a:	8d 91       	ld	r24, X+
    225c:	9c 91       	ld	r25, X
    225e:	16 97       	sbiw	r26, 0x06	; 6
    2260:	24 ef       	ldi	r18, 0xF4	; 244
    2262:	12 96       	adiw	r26, 0x02	; 2
    2264:	4c 91       	ld	r20, X
    2266:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>

  if (R2)                /* second resistor */
  {
    LCD_Space();
    226a:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>
    DisplayValue(R2->Value, R2->Scale, LCD_CHAR_OMEGA);
    226e:	6b 81       	ldd	r22, Y+3	; 0x03
    2270:	7c 81       	ldd	r23, Y+4	; 0x04
    2272:	8d 81       	ldd	r24, Y+5	; 0x05
    2274:	9e 81       	ldd	r25, Y+6	; 0x06
    2276:	24 ef       	ldi	r18, 0xF4	; 244
    2278:	4a 81       	ldd	r20, Y+2	; 0x02
    227a:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
    227e:	1a c0       	rjmp	.+52     	; 0x22b4 <Show_Resistor+0x198>
  /*
   *  display the values
   */

  /* first resistor */
  LCD_Line2();
    2280:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>
  DisplayValue(R1->Value, R1->Scale, LCD_CHAR_OMEGA);
    2284:	f8 01       	movw	r30, r16
    2286:	63 81       	ldd	r22, Z+3	; 0x03
    2288:	74 81       	ldd	r23, Z+4	; 0x04
    228a:	85 81       	ldd	r24, Z+5	; 0x05
    228c:	96 81       	ldd	r25, Z+6	; 0x06
    228e:	24 ef       	ldi	r18, 0xF4	; 244
    2290:	42 81       	ldd	r20, Z+2	; 0x02
    2292:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
  }
  #ifdef SW_INDUCTOR
  else                   /* single resistor */
  {
    /* get inductance and display if relevant */
    if (MeasureInductor(R1) == 1)
    2296:	c8 01       	movw	r24, r16
    2298:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <MeasureInductor>
    229c:	81 30       	cpi	r24, 0x01	; 1
    229e:	51 f4       	brne	.+20     	; 0x22b4 <Show_Resistor+0x198>
    22a0:	c9 cf       	rjmp	.-110    	; 0x2234 <Show_Resistor+0x118>

        R2++;                 /* next one */
      }

      /* get the two smaller resistors */
      if (R1 == Rmax) R1++;
    22a2:	86 e1       	ldi	r24, 0x16	; 22
    22a4:	91 e0       	ldi	r25, 0x01	; 1
    22a6:	f1 e0       	ldi	r31, 0x01	; 1
    22a8:	88 30       	cpi	r24, 0x08	; 8
    22aa:	9f 07       	cpc	r25, r31
    22ac:	09 f4       	brne	.+2      	; 0x22b0 <Show_Resistor+0x194>
    22ae:	8e cf       	rjmp	.-228    	; 0x21cc <Show_Resistor+0xb0>
        if (CmpValue(R2->Value, R2->Scale, Rmax->Value, Rmax->Scale) == 1)
        {
          Rmax = R2;          /* update largest one */
        }

        R2++;                 /* next one */
    22b0:	6c 01       	movw	r12, r24
    22b2:	81 cf       	rjmp	.-254    	; 0x21b6 <Show_Resistor+0x9a>
      LCD_Space();
      DisplayValue(Inductor.Value, Inductor.Scale, 'H');
    }
  }
  #endif
}
    22b4:	df 91       	pop	r29
    22b6:	cf 91       	pop	r28
    22b8:	1f 91       	pop	r17
    22ba:	0f 91       	pop	r16
    22bc:	ff 90       	pop	r15
    22be:	ef 90       	pop	r14
    22c0:	df 90       	pop	r13
    22c2:	cf 90       	pop	r12
    22c4:	08 95       	ret

000022c6 <Show_Capacitor>:
/*
 *  show capacitor
 */

void Show_Capacitor(void)
{
    22c6:	ef 92       	push	r14
    22c8:	0f 93       	push	r16
    22ca:	1f 93       	push	r17
    22cc:	cf 93       	push	r28
    22ce:	df 93       	push	r29

  for (Counter = 1; Counter <= 2; Counter++) 
  {
    Cap++;                         /* next cap */

    if (CmpValue(Cap->Value, Cap->Scale, MaxCap->Value, MaxCap->Scale) == 1)
    22d0:	e9 e2       	ldi	r30, 0x29	; 41
    22d2:	f1 e0       	ldi	r31, 0x01	; 1
    22d4:	03 81       	ldd	r16, Z+3	; 0x03
    22d6:	14 81       	ldd	r17, Z+4	; 0x04
    22d8:	25 81       	ldd	r18, Z+5	; 0x05
    22da:	36 81       	ldd	r19, Z+6	; 0x06
    22dc:	66 85       	ldd	r22, Z+14	; 0x0e
    22de:	77 85       	ldd	r23, Z+15	; 0x0f
    22e0:	80 89       	ldd	r24, Z+16	; 0x10
    22e2:	91 89       	ldd	r25, Z+17	; 0x11
    22e4:	e2 80       	ldd	r14, Z+2	; 0x02
    22e6:	45 85       	ldd	r20, Z+13	; 0x0d
    22e8:	0e 94 a6 24 	call	0x494c	; 0x494c <CmpValue>
    22ec:	81 30       	cpi	r24, 0x01	; 1
    22ee:	19 f4       	brne	.+6      	; 0x22f6 <Show_Capacitor+0x30>
  MaxCap = &Caps[0];               /* pointer to first cap */
  Cap = MaxCap;

  for (Counter = 1; Counter <= 2; Counter++) 
  {
    Cap++;                         /* next cap */
    22f0:	c4 e3       	ldi	r28, 0x34	; 52
    22f2:	d1 e0       	ldi	r29, 0x01	; 1
    22f4:	02 c0       	rjmp	.+4      	; 0x22fa <Show_Capacitor+0x34>
  uint16_t          ESR;           /* ESR (in 0.01 Ohms) */
  #endif
  uint8_t           Counter;       /* loop counter */

  /* find largest cap */
  MaxCap = &Caps[0];               /* pointer to first cap */
    22f6:	c9 e2       	ldi	r28, 0x29	; 41
    22f8:	d1 e0       	ldi	r29, 0x01	; 1

  for (Counter = 1; Counter <= 2; Counter++) 
  {
    Cap++;                         /* next cap */

    if (CmpValue(Cap->Value, Cap->Scale, MaxCap->Value, MaxCap->Scale) == 1)
    22fa:	0b 81       	ldd	r16, Y+3	; 0x03
    22fc:	1c 81       	ldd	r17, Y+4	; 0x04
    22fe:	2d 81       	ldd	r18, Y+5	; 0x05
    2300:	3e 81       	ldd	r19, Y+6	; 0x06
    2302:	e9 e2       	ldi	r30, 0x29	; 41
    2304:	f1 e0       	ldi	r31, 0x01	; 1
    2306:	61 8d       	ldd	r22, Z+25	; 0x19
    2308:	72 8d       	ldd	r23, Z+26	; 0x1a
    230a:	83 8d       	ldd	r24, Z+27	; 0x1b
    230c:	94 8d       	ldd	r25, Z+28	; 0x1c
    230e:	ea 80       	ldd	r14, Y+2	; 0x02
    2310:	40 8d       	ldd	r20, Z+24	; 0x18
    2312:	0e 94 a6 24 	call	0x494c	; 0x494c <CmpValue>
    2316:	81 30       	cpi	r24, 0x01	; 1
    2318:	11 f4       	brne	.+4      	; 0x231e <Show_Capacitor+0x58>
  MaxCap = &Caps[0];               /* pointer to first cap */
  Cap = MaxCap;

  for (Counter = 1; Counter <= 2; Counter++) 
  {
    Cap++;                         /* next cap */
    231a:	cf e3       	ldi	r28, 0x3F	; 63
    231c:	d1 e0       	ldi	r29, 0x01	; 1
      MaxCap = Cap;
    }
  }

  /* display pinout */
  LCD_ProbeNumber(MaxCap->A);      /* display pin #1 */
    231e:	88 81       	ld	r24, Y
    2320:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <LCD_ProbeNumber>
  LCD_EEString(Cap_str);           /* display capacitor symbol */
    2324:	88 e0       	ldi	r24, 0x08	; 8
    2326:	91 e0       	ldi	r25, 0x01	; 1
    2328:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
  LCD_ProbeNumber(MaxCap->B);      /* display pin #2 */
    232c:	89 81       	ldd	r24, Y+1	; 0x01
    232e:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <LCD_ProbeNumber>

  /* show capacitance */
  LCD_Line2();                     /* move to line #2 */
    2332:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>
  DisplayValue(MaxCap->Value, MaxCap->Scale, 'F');
    2336:	6b 81       	ldd	r22, Y+3	; 0x03
    2338:	7c 81       	ldd	r23, Y+4	; 0x04
    233a:	8d 81       	ldd	r24, Y+5	; 0x05
    233c:	9e 81       	ldd	r25, Y+6	; 0x06
    233e:	26 e4       	ldi	r18, 0x46	; 70
    2340:	4a 81       	ldd	r20, Y+2	; 0x02
    2342:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>

  #ifdef SW_ESR
  /* show ESR */
  ESR = MeasureESR(MaxCap);        /* measure ESR */
    2346:	ce 01       	movw	r24, r28
    2348:	0e 94 43 06 	call	0xc86	; 0xc86 <MeasureESR>
    234c:	ec 01       	movw	r28, r24
  if (ESR > 0)                     /* if successfull */
    234e:	89 2b       	or	r24, r25
    2350:	49 f0       	breq	.+18     	; 0x2364 <Show_Capacitor+0x9e>
  {
    LCD_Space();
    2352:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>
//    UpdateLine2();                           /* key press for line #2 */
//    LCD_EEString2(ESR_str);                  /* display: ESR */
    DisplayValue(ESR, -2, LCD_CHAR_OMEGA);   /* display ESR */
    2356:	be 01       	movw	r22, r28
    2358:	80 e0       	ldi	r24, 0x00	; 0
    235a:	90 e0       	ldi	r25, 0x00	; 0
    235c:	24 ef       	ldi	r18, 0xF4	; 244
    235e:	4e ef       	ldi	r20, 0xFE	; 254
    2360:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
  }
  #endif
}
    2364:	df 91       	pop	r29
    2366:	cf 91       	pop	r28
    2368:	1f 91       	pop	r17
    236a:	0f 91       	pop	r16
    236c:	ef 90       	pop	r14
    236e:	08 95       	ret

00002370 <Show_Diode_Cap>:
 */

void Show_Diode_Cap(Diode_Type *Diode)
{
  /* sanity check */
  if (Diode == NULL) return;
    2370:	00 97       	sbiw	r24, 0x00	; 0
    2372:	81 f0       	breq	.+32     	; 0x2394 <Show_Diode_Cap+0x24>
    2374:	fc 01       	movw	r30, r24

  /* get capacitance (opposite of flow direction) */
  MeasureCap(Diode->C, Diode->A, 0);
    2376:	40 e0       	ldi	r20, 0x00	; 0
    2378:	60 81       	ld	r22, Z
    237a:	81 81       	ldd	r24, Z+1	; 0x01
    237c:	0e 94 be 09 	call	0x137c	; 0x137c <MeasureCap>

  /* and show capacitance */
  DisplayValue(Caps[0].Value, Caps[0].Scale, 'F');
    2380:	e9 e2       	ldi	r30, 0x29	; 41
    2382:	f1 e0       	ldi	r31, 0x01	; 1
    2384:	63 81       	ldd	r22, Z+3	; 0x03
    2386:	74 81       	ldd	r23, Z+4	; 0x04
    2388:	85 81       	ldd	r24, Z+5	; 0x05
    238a:	96 81       	ldd	r25, Z+6	; 0x06
    238c:	26 e4       	ldi	r18, 0x46	; 70
    238e:	42 81       	ldd	r20, Z+2	; 0x02
    2390:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
    2394:	08 95       	ret

00002396 <Show_Diode>:
/*
 *  show diode
 */

void Show_Diode(void)
{
    2396:	bf 92       	push	r11
    2398:	cf 92       	push	r12
    239a:	df 92       	push	r13
    239c:	ef 92       	push	r14
    239e:	ff 92       	push	r15
    23a0:	0f 93       	push	r16
    23a2:	1f 93       	push	r17
    23a4:	cf 93       	push	r28
    23a6:	df 93       	push	r29

  /*
   *  figure out which diodes to display
   */

  if (Check.Diodes == 1)           /* single diode */
    23a8:	80 91 04 01 	lds	r24, 0x0104
    23ac:	81 30       	cpi	r24, 0x01	; 1
    23ae:	a1 f4       	brne	.+40     	; 0x23d8 <Show_Diode+0x42>
  {
    C = D1->C;                     /* make anode first pin */
    23b0:	00 91 4b 01 	lds	r16, 0x014B
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
  uint8_t           R_Pin2 = 5;    /* B_E resistor's pin #2 */
    23b4:	0f 2e       	mov	r0, r31
    23b6:	f5 e0       	ldi	r31, 0x05	; 5
    23b8:	bf 2e       	mov	r11, r31
    23ba:	f0 2d       	mov	r31, r0
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
    23bc:	0f 2e       	mov	r0, r31
    23be:	f5 e0       	ldi	r31, 0x05	; 5
    23c0:	df 2e       	mov	r13, r31
    23c2:	f0 2d       	mov	r31, r0
void Show_Diode(void)
{
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
    23c4:	15 e0       	ldi	r17, 0x05	; 5
 */

void Show_Diode(void)
{
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
    23c6:	c0 e0       	ldi	r28, 0x00	; 0
    23c8:	d0 e0       	ldi	r29, 0x00	; 0
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
  uint8_t           R_Pin2 = 5;    /* B_E resistor's pin #2 */
  uint16_t          I_leak;        /* leakage current */

  D1 = &Diodes[0];                 /* pointer to first diode */
    23ca:	0f 2e       	mov	r0, r31
    23cc:	fa e4       	ldi	r31, 0x4A	; 74
    23ce:	ef 2e       	mov	r14, r31
    23d0:	f1 e0       	ldi	r31, 0x01	; 1
    23d2:	ff 2e       	mov	r15, r31
    23d4:	f0 2d       	mov	r31, r0
    23d6:	66 c1       	rjmp	.+716    	; 0x26a4 <Show_Diode+0x30e>

  if (Check.Diodes == 1)           /* single diode */
  {
    C = D1->C;                     /* make anode first pin */
  }
  else if (Check.Diodes == 2)      /* two diodes */
    23d8:	82 30       	cpi	r24, 0x02	; 2
    23da:	31 f5       	brne	.+76     	; 0x2428 <Show_Diode+0x92>
  {
    D2 = D1;
    D2++;                          /* pointer to second diode */

    if (D1->A == D2->A)            /* common anode */
    23dc:	ea e4       	ldi	r30, 0x4A	; 74
    23de:	f1 e0       	ldi	r31, 0x01	; 1
    23e0:	10 81       	ld	r17, Z
    23e2:	b6 80       	ldd	r11, Z+6	; 0x06
    23e4:	1b 11       	cpse	r17, r11
    23e6:	06 c0       	rjmp	.+12     	; 0x23f4 <Show_Diode+0x5e>
    {
      A = D1->A;                   /* save common anode */

      /* possible PNP BJT with low value B-E resistor and flyback diode */
      R_Pin1 = D1->C;
    23e8:	d1 80       	ldd	r13, Z+1	; 0x01
      R_Pin2 = D2->C;
    23ea:	b7 80       	ldd	r11, Z+7	; 0x07
{
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
    23ec:	05 e0       	ldi	r16, 0x05	; 5

void Show_Diode(void)
{
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
    23ee:	cc 24       	eor	r12, r12
    23f0:	c3 94       	inc	r12
    23f2:	7d c0       	rjmp	.+250    	; 0x24ee <Show_Diode+0x158>

      /* possible PNP BJT with low value B-E resistor and flyback diode */
      R_Pin1 = D1->C;
      R_Pin2 = D2->C;
    }
    else if (D1->C == D2->C)       /* common cathode */
    23f4:	ea e4       	ldi	r30, 0x4A	; 74
    23f6:	f1 e0       	ldi	r31, 0x01	; 1
    23f8:	81 81       	ldd	r24, Z+1	; 0x01
    23fa:	07 81       	ldd	r16, Z+7	; 0x07
    23fc:	80 17       	cp	r24, r16
    23fe:	09 f4       	brne	.+2      	; 0x2402 <Show_Diode+0x6c>
    2400:	34 c1       	rjmp	.+616    	; 0x266a <Show_Diode+0x2d4>

      /* possible NPN BJT with low value B-E resistor and flyback diode */
      R_Pin1 = D1->A;
      R_Pin2 = D2->A;
    }
    else if ((D1->A == D2->C) && (D1->C == D2->A))   /* anti-parallel */
    2402:	10 13       	cpse	r17, r16
    2404:	3d c1       	rjmp	.+634    	; 0x2680 <Show_Diode+0x2ea>
    2406:	b8 16       	cp	r11, r24
    2408:	09 f4       	brne	.+2      	; 0x240c <Show_Diode+0x76>
    240a:	67 c0       	rjmp	.+206    	; 0x24da <Show_Diode+0x144>
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
  uint8_t           R_Pin2 = 5;    /* B_E resistor's pin #2 */
    240c:	0f 2e       	mov	r0, r31
    240e:	f5 e0       	ldi	r31, 0x05	; 5
    2410:	bf 2e       	mov	r11, r31
    2412:	f0 2d       	mov	r31, r0
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
    2414:	0f 2e       	mov	r0, r31
    2416:	f5 e0       	ldi	r31, 0x05	; 5
    2418:	df 2e       	mov	r13, r31
    241a:	f0 2d       	mov	r31, r0
{
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
    241c:	05 e0       	ldi	r16, 0x05	; 5
void Show_Diode(void)
{
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
    241e:	15 e0       	ldi	r17, 0x05	; 5
    C = D1->C;                     /* make anode first pin */
  }
  else if (Check.Diodes == 2)      /* two diodes */
  {
    D2 = D1;
    D2++;                          /* pointer to second diode */
    2420:	c0 e5       	ldi	r28, 0x50	; 80
    2422:	d1 e0       	ldi	r29, 0x01	; 1
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
  uint8_t           R_Pin2 = 5;    /* B_E resistor's pin #2 */
  uint16_t          I_leak;        /* leakage current */

  D1 = &Diodes[0];                 /* pointer to first diode */
    2424:	7f 01       	movw	r14, r30
    2426:	3e c1       	rjmp	.+636    	; 0x26a4 <Show_Diode+0x30e>
      A = D1->A;                   /* anode and cathode */
      C = A;                       /* are the same */
      CapFlag = 0;                 /* skip capacitance */
    }
  }
  else if (Check.Diodes == 3)      /* three diodes */
    2428:	83 30       	cpi	r24, 0x03	; 3
    242a:	09 f0       	breq	.+2      	; 0x242e <Show_Diode+0x98>
    242c:	53 c0       	rjmp	.+166    	; 0x24d4 <Show_Diode+0x13e>
    242e:	20 e0       	ldi	r18, 0x00	; 0
    2430:	ca e4       	ldi	r28, 0x4A	; 74
    2432:	d1 e0       	ldi	r29, 0x01	; 1
     *  - Only once the cathode of diode #1 matches the anode of diode #2.
     */

    for (n = 0; n <= 2; n++)       /* loop for first diode */
    {
      D1 = &Diodes[n];             /* get pointer of first diode */
    2434:	f1 2c       	mov	r15, r1
    2436:	50 e0       	ldi	r21, 0x00	; 0
    2438:	62 2f       	mov	r22, r18
    243a:	70 e0       	ldi	r23, 0x00	; 0
    243c:	fe 01       	movw	r30, r28
    243e:	8f 2d       	mov	r24, r15
    2440:	95 2f       	mov	r25, r21
      {
        D2 = &Diodes[m];           /* get pointer of second diode */

        if (n != m)                /* don't check same diode :-) */
        {
          if (D1->C == D2->A)      /* got match */
    2442:	db 01       	movw	r26, r22
    2444:	aa 0f       	add	r26, r26
    2446:	bb 1f       	adc	r27, r27
    2448:	a6 0f       	add	r26, r22
    244a:	b7 1f       	adc	r27, r23
    244c:	aa 0f       	add	r26, r26
    244e:	bb 1f       	adc	r27, r27
    2450:	a5 5b       	subi	r26, 0xB5	; 181
    2452:	be 4f       	sbci	r27, 0xFE	; 254
    {
      D1 = &Diodes[n];             /* get pointer of first diode */

      for (m = 0; m <= 2; m++)     /* loop for second diode */
      {
        D2 = &Diodes[m];           /* get pointer of second diode */
    2454:	8c 01       	movw	r16, r24

        if (n != m)                /* don't check same diode :-) */
    2456:	28 17       	cp	r18, r24
    2458:	29 f0       	breq	.+10     	; 0x2464 <Show_Diode+0xce>
        {
          if (D1->C == D2->A)      /* got match */
    245a:	4c 91       	ld	r20, X
    245c:	30 81       	ld	r19, Z
    245e:	43 13       	cpse	r20, r19
    2460:	02 c0       	rjmp	.+4      	; 0x2466 <Show_Diode+0xd0>
    2462:	0a c0       	rjmp	.+20     	; 0x2478 <Show_Diode+0xe2>
    2464:	28 2f       	mov	r18, r24
    2466:	01 96       	adiw	r24, 0x01	; 1
    2468:	36 96       	adiw	r30, 0x06	; 6

    for (n = 0; n <= 2; n++)       /* loop for first diode */
    {
      D1 = &Diodes[n];             /* get pointer of first diode */

      for (m = 0; m <= 2; m++)     /* loop for second diode */
    246a:	83 30       	cpi	r24, 0x03	; 3
    246c:	91 05       	cpc	r25, r1
    246e:	91 f7       	brne	.-28     	; 0x2454 <Show_Diode+0xbe>
     *  Two diodes in series are additionally detected as third big diode:
     *  - Check for any possible way of 2 diodes be connected in series.
     *  - Only once the cathode of diode #1 matches the anode of diode #2.
     */

    for (n = 0; n <= 2; n++)       /* loop for first diode */
    2470:	2f 5f       	subi	r18, 0xFF	; 255
    2472:	23 30       	cpi	r18, 0x03	; 3
    2474:	08 f3       	brcs	.-62     	; 0x2438 <Show_Diode+0xa2>
    2476:	01 c0       	rjmp	.+2      	; 0x247a <Show_Diode+0xe4>
    2478:	26 e0       	ldi	r18, 0x06	; 6
    {
      D1 = &Diodes[n];             /* get pointer of first diode */
    247a:	7b 01       	movw	r14, r22
    247c:	ee 0c       	add	r14, r14
    247e:	ff 1c       	adc	r15, r15
    2480:	e6 0e       	add	r14, r22
    2482:	f7 1e       	adc	r15, r23
    2484:	c7 01       	movw	r24, r14
    2486:	88 0f       	add	r24, r24
    2488:	99 1f       	adc	r25, r25
    248a:	ac 01       	movw	r20, r24
    248c:	46 5b       	subi	r20, 0xB6	; 182
    248e:	5e 4f       	sbci	r21, 0xFE	; 254
    2490:	7a 01       	movw	r14, r20

      for (m = 0; m <= 2; m++)     /* loop for second diode */
      {
        D2 = &Diodes[m];           /* get pointer of second diode */
    2492:	e8 01       	movw	r28, r16
    2494:	cc 0f       	add	r28, r28
    2496:	dd 1f       	adc	r29, r29
    2498:	c0 0f       	add	r28, r16
    249a:	d1 1f       	adc	r29, r17
    249c:	cc 0f       	add	r28, r28
    249e:	dd 1f       	adc	r29, r29
    24a0:	c6 5b       	subi	r28, 0xB6	; 182
    24a2:	de 4f       	sbci	r29, 0xFE	; 254
          }
        }
      }
    }

    if (n < 5) D2 = NULL;          /* no match found */
    24a4:	25 30       	cpi	r18, 0x05	; 5
    24a6:	10 f4       	brcc	.+4      	; 0x24ac <Show_Diode+0x116>
    24a8:	c0 e0       	ldi	r28, 0x00	; 0
    24aa:	d0 e0       	ldi	r29, 0x00	; 0
    C = D1->C;                     /* cathode of first diode */
    24ac:	fb 01       	movw	r30, r22
    24ae:	ee 0f       	add	r30, r30
    24b0:	ff 1f       	adc	r31, r31
    24b2:	e6 0f       	add	r30, r22
    24b4:	f7 1f       	adc	r31, r23
    24b6:	ee 0f       	add	r30, r30
    24b8:	ff 1f       	adc	r31, r31
    24ba:	e6 5b       	subi	r30, 0xB6	; 182
    24bc:	fe 4f       	sbci	r31, 0xFE	; 254
    24be:	01 81       	ldd	r16, Z+1	; 0x01
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
  uint8_t           R_Pin2 = 5;    /* B_E resistor's pin #2 */
    24c0:	0f 2e       	mov	r0, r31
    24c2:	f5 e0       	ldi	r31, 0x05	; 5
    24c4:	bf 2e       	mov	r11, r31
    24c6:	f0 2d       	mov	r31, r0
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
    24c8:	0f 2e       	mov	r0, r31
    24ca:	f5 e0       	ldi	r31, 0x05	; 5
    24cc:	df 2e       	mov	r13, r31
    24ce:	f0 2d       	mov	r31, r0
      }
    }

    if (n < 5) D2 = NULL;          /* no match found */
    C = D1->C;                     /* cathode of first diode */
    A = 3;                         /* in series mode */
    24d0:	13 e0       	ldi	r17, 0x03	; 3
    24d2:	e8 c0       	rjmp	.+464    	; 0x26a4 <Show_Diode+0x30e>
  }
  else                             /* to much diodes */
  {
    D1 = NULL;                     /* don't display any diode */
    Show_Fail();                   /* and tell user */
    24d4:	0e 94 31 10 	call	0x2062	; 0x2062 <Show_Fail>
    return;
    24d8:	46 c1       	rjmp	.+652    	; 0x2766 <Show_Diode+0x3d0>
      R_Pin2 = D2->A;
    }
    else if ((D1->A == D2->C) && (D1->C == D2->A))   /* anti-parallel */
    {
      A = D1->A;                   /* anode and cathode */
      C = A;                       /* are the same */
    24da:	01 2f       	mov	r16, r17
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
  uint8_t           R_Pin2 = 5;    /* B_E resistor's pin #2 */
    24dc:	0f 2e       	mov	r0, r31
    24de:	f5 e0       	ldi	r31, 0x05	; 5
    24e0:	bf 2e       	mov	r11, r31
    24e2:	f0 2d       	mov	r31, r0
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
    24e4:	0f 2e       	mov	r0, r31
    24e6:	f5 e0       	ldi	r31, 0x05	; 5
    24e8:	df 2e       	mov	r13, r31
    24ea:	f0 2d       	mov	r31, r0
    }
    else if ((D1->A == D2->C) && (D1->C == D2->A))   /* anti-parallel */
    {
      A = D1->A;                   /* anode and cathode */
      C = A;                       /* are the same */
      CapFlag = 0;                 /* skip capacitance */
    24ec:	c1 2c       	mov	r12, r1
  /*
   *  display pins 
   */

  /* first Diode */
  if (A < 3) LCD_ProbeNumber(D1->C);       /* common anode */
    24ee:	13 30       	cpi	r17, 0x03	; 3
    24f0:	a0 f4       	brcc	.+40     	; 0x251a <Show_Diode+0x184>
    24f2:	80 91 4b 01 	lds	r24, 0x014B
    24f6:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <LCD_ProbeNumber>
  else LCD_ProbeNumber(D1->A);             /* common cathode */

  if (A < 3) LCD_EEString(Diode_CA_str);   /* common anode */
    24fa:	80 e0       	ldi	r24, 0x00	; 0
    24fc:	91 e0       	ldi	r25, 0x01	; 1
    24fe:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
  else LCD_EEString(Diode_AC_str);         /* common cathode */

  if (A < 3) LCD_ProbeNumber(A);           /* common anode */
    2502:	81 2f       	mov	r24, r17
    2504:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <LCD_ProbeNumber>
    2508:	c0 e5       	ldi	r28, 0x50	; 80
    250a:	d1 e0       	ldi	r29, 0x01	; 1
    250c:	0f 2e       	mov	r0, r31
    250e:	fa e4       	ldi	r31, 0x4A	; 74
    2510:	ef 2e       	mov	r14, r31
    2512:	f1 e0       	ldi	r31, 0x01	; 1
    2514:	ff 2e       	mov	r15, r31
    2516:	f0 2d       	mov	r31, r0
    2518:	13 c0       	rjmp	.+38     	; 0x2540 <Show_Diode+0x1aa>
    251a:	c0 e5       	ldi	r28, 0x50	; 80
    251c:	d1 e0       	ldi	r29, 0x01	; 1
    251e:	0f 2e       	mov	r0, r31
    2520:	fa e4       	ldi	r31, 0x4A	; 74
    2522:	ef 2e       	mov	r14, r31
    2524:	f1 e0       	ldi	r31, 0x01	; 1
    2526:	ff 2e       	mov	r15, r31
    2528:	f0 2d       	mov	r31, r0
   *  display pins 
   */

  /* first Diode */
  if (A < 3) LCD_ProbeNumber(D1->C);       /* common anode */
  else LCD_ProbeNumber(D1->A);             /* common cathode */
    252a:	f7 01       	movw	r30, r14
    252c:	80 81       	ld	r24, Z
    252e:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <LCD_ProbeNumber>

  if (A < 3) LCD_EEString(Diode_CA_str);   /* common anode */
  else LCD_EEString(Diode_AC_str);         /* common cathode */
    2532:	84 e0       	ldi	r24, 0x04	; 4
    2534:	91 e0       	ldi	r25, 0x01	; 1
    2536:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>

  if (A < 3) LCD_ProbeNumber(A);           /* common anode */
  else LCD_ProbeNumber(C);                 /* common cathode */
    253a:	80 2f       	mov	r24, r16
    253c:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <LCD_ProbeNumber>

  if (D2)           /* second diode */
    2540:	20 97       	sbiw	r28, 0x00	; 0
    2542:	09 f4       	brne	.+2      	; 0x2546 <Show_Diode+0x1b0>
    2544:	da c0       	rjmp	.+436    	; 0x26fa <Show_Diode+0x364>
  {
    if (A <= 3) LCD_EEString(Diode_AC_str);  /* common anode or in series */
    2546:	14 30       	cpi	r17, 0x04	; 4
    2548:	38 f4       	brcc	.+14     	; 0x2558 <Show_Diode+0x1c2>
    254a:	84 e0       	ldi	r24, 0x04	; 4
    254c:	91 e0       	ldi	r25, 0x01	; 1
    254e:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
    else LCD_EEString(Diode_CA_str);         /* common cathode */

    if (A == C) LCD_ProbeNumber(D2->A);           /* anti parallel */
    2552:	10 13       	cpse	r17, r16
    2554:	0b c0       	rjmp	.+22     	; 0x256c <Show_Diode+0x1d6>
    2556:	06 c0       	rjmp	.+12     	; 0x2564 <Show_Diode+0x1ce>
  else LCD_ProbeNumber(C);                 /* common cathode */

  if (D2)           /* second diode */
  {
    if (A <= 3) LCD_EEString(Diode_AC_str);  /* common anode or in series */
    else LCD_EEString(Diode_CA_str);         /* common cathode */
    2558:	80 e0       	ldi	r24, 0x00	; 0
    255a:	91 e0       	ldi	r25, 0x01	; 1
    255c:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>

    if (A == C) LCD_ProbeNumber(D2->A);           /* anti parallel */
    2560:	10 13       	cpse	r17, r16
    2562:	08 c0       	rjmp	.+16     	; 0x2574 <Show_Diode+0x1de>
    2564:	88 81       	ld	r24, Y
    2566:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <LCD_ProbeNumber>
    256a:	b1 c0       	rjmp	.+354    	; 0x26ce <Show_Diode+0x338>
    else if (A <= 3) LCD_ProbeNumber(D2->C);      /* common anode or in series */
    256c:	89 81       	ldd	r24, Y+1	; 0x01
    256e:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <LCD_ProbeNumber>
    2572:	ad c0       	rjmp	.+346    	; 0x26ce <Show_Diode+0x338>
    else LCD_ProbeNumber(D2->A);                  /* common cathode */
    2574:	88 81       	ld	r24, Y
    2576:	0e 94 b7 0f 	call	0x1f6e	; 0x1f6e <LCD_ProbeNumber>
    257a:	a9 c0       	rjmp	.+338    	; 0x26ce <Show_Diode+0x338>
  if (R_Pin1 < 5)                  /* possible BJT */
  {
    if (CheckSingleResistor(R_Pin1, R_Pin2) == 1) /* found B-E resistor */
    {
      /* show: PNP/NPN? */
      LCD_Space();
    257c:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>
      if (A < 3) LCD_EEString(PNP_str);
    2580:	13 30       	cpi	r17, 0x03	; 3
    2582:	28 f4       	brcc	.+10     	; 0x258e <Show_Diode+0x1f8>
    2584:	8e e8       	ldi	r24, 0x8E	; 142
    2586:	91 e0       	ldi	r25, 0x01	; 1
    2588:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
    258c:	04 c0       	rjmp	.+8      	; 0x2596 <Show_Diode+0x200>
      else LCD_EEString(NPN_str);
    258e:	82 e9       	ldi	r24, 0x92	; 146
    2590:	91 e0       	ldi	r25, 0x01	; 1
    2592:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
      LCD_Data('?');
    2596:	8f e3       	ldi	r24, 0x3F	; 63
    2598:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>

      LCD_Line2();                        /* go to line #2 */
    259c:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>
      R_Pin1 += '1';                      /* convert to character */
      R_Pin2 += '1';
    25a0:	61 e3       	ldi	r22, 0x31	; 49
    25a2:	6b 0d       	add	r22, r11
      Show_SingleResistor(R_Pin1, R_Pin2);   /* show resistor */
    25a4:	81 e3       	ldi	r24, 0x31	; 49
    25a6:	8d 0d       	add	r24, r13
    25a8:	0e 94 75 10 	call	0x20ea	; 0x20ea <Show_SingleResistor>
      WaitKey();                          /* next page */
    25ac:	0e 94 cb 26 	call	0x4d96	; 0x4d96 <WaitKey>
   *  - reverse leakage current (for single diodes)
   *  - capacitance (not for anti-parallel diodes)
   */

  /* display Uf */
  LCD_ClearLine2();                /* only change line #2 */  
    25b0:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <LCD_ClearLine2>
  LCD_EEString2(Vf_str);           /* display: Vf */
    25b4:	86 e7       	ldi	r24, 0x76	; 118
    25b6:	91 e0       	ldi	r25, 0x01	; 1
    25b8:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>

  /* first diode */
  DisplayValue(D1->V_f, -3, 'V');
    25bc:	f7 01       	movw	r30, r14
    25be:	62 81       	ldd	r22, Z+2	; 0x02
    25c0:	73 81       	ldd	r23, Z+3	; 0x03
    25c2:	80 e0       	ldi	r24, 0x00	; 0
    25c4:	90 e0       	ldi	r25, 0x00	; 0
    25c6:	26 e5       	ldi	r18, 0x56	; 86
    25c8:	4d ef       	ldi	r20, 0xFD	; 253
    25ca:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>

  LCD_Space();
    25ce:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>

  /* display low current Uf and reverse leakage current for a single diode */
  if (D2 == NULL)                       /* single diode */
    25d2:	20 97       	sbiw	r28, 0x00	; 0
    25d4:	79 f5       	brne	.+94     	; 0x2634 <Show_Diode+0x29e>
      LCD_Line2();                        /* go to line #2 */
      R_Pin1 += '1';                      /* convert to character */
      R_Pin2 += '1';
      Show_SingleResistor(R_Pin1, R_Pin2);   /* show resistor */
      WaitKey();                          /* next page */
      CapFlag = 0;                        /* skip capacitance */
    25d6:	c1 2c       	mov	r12, r1

  /* display low current Uf and reverse leakage current for a single diode */
  if (D2 == NULL)                       /* single diode */
  {
    /* display low current Uf if it's quite low (Ge/Schottky diode) */
    if (D1->V_f2 < 250)
    25d8:	f7 01       	movw	r30, r14
    25da:	84 81       	ldd	r24, Z+4	; 0x04
    25dc:	95 81       	ldd	r25, Z+5	; 0x05
    25de:	8a 3f       	cpi	r24, 0xFA	; 250
    25e0:	91 05       	cpc	r25, r1
    25e2:	78 f4       	brcc	.+30     	; 0x2602 <Show_Diode+0x26c>
    {
      LCD_Data('(');
    25e4:	88 e2       	ldi	r24, 0x28	; 40
    25e6:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
      DisplayValue(D1->V_f2, 0, 0);
    25ea:	f7 01       	movw	r30, r14
    25ec:	64 81       	ldd	r22, Z+4	; 0x04
    25ee:	75 81       	ldd	r23, Z+5	; 0x05
    25f0:	80 e0       	ldi	r24, 0x00	; 0
    25f2:	90 e0       	ldi	r25, 0x00	; 0
    25f4:	20 e0       	ldi	r18, 0x00	; 0
    25f6:	40 e0       	ldi	r20, 0x00	; 0
    25f8:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
      LCD_Data(')');
    25fc:	89 e2       	ldi	r24, 0x29	; 41
    25fe:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    }

    /* reverse leakage current */
    UpdateProbes(D1->C, D1->A, 0);      /* reverse diode */
    2602:	40 e0       	ldi	r20, 0x00	; 0
    2604:	f7 01       	movw	r30, r14
    2606:	60 81       	ld	r22, Z
    2608:	81 81       	ldd	r24, Z+1	; 0x01
    260a:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <UpdateProbes>
    I_leak = GetLeakageCurrent();       /* get current (in 킕) */
    260e:	0e 94 e9 1f 	call	0x3fd2	; 0x3fd2 <GetLeakageCurrent>
    2612:	8c 01       	movw	r16, r24
    if (I_leak > 0)                     /* show if not zero */
    2614:	89 2b       	or	r24, r25
    2616:	b9 f0       	breq	.+46     	; 0x2646 <Show_Diode+0x2b0>
    {
      UpdateLine2();                    /* key press for line #2 */
    2618:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <UpdateLine2>
      LCD_EEString2(I_R_str);           /* display: I_R */
    261c:	8c e6       	ldi	r24, 0x6C	; 108
    261e:	91 e0       	ldi	r25, 0x01	; 1
    2620:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
      DisplayValue(I_leak, -6, 'A');    /* display current */
    2624:	b8 01       	movw	r22, r16
    2626:	80 e0       	ldi	r24, 0x00	; 0
    2628:	90 e0       	ldi	r25, 0x00	; 0
    262a:	21 e4       	ldi	r18, 0x41	; 65
    262c:	4a ef       	ldi	r20, 0xFA	; 250
    262e:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
    2632:	09 c0       	rjmp	.+18     	; 0x2646 <Show_Diode+0x2b0>
      LCD_Line2();                        /* go to line #2 */
      R_Pin1 += '1';                      /* convert to character */
      R_Pin2 += '1';
      Show_SingleResistor(R_Pin1, R_Pin2);   /* show resistor */
      WaitKey();                          /* next page */
      CapFlag = 0;                        /* skip capacitance */
    2634:	c1 2c       	mov	r12, r1
    }
  }
  else                                  /* two diodes */
  {
    /* show Uf of second diode */
    DisplayValue(D2->V_f, -3, 'V');
    2636:	6a 81       	ldd	r22, Y+2	; 0x02
    2638:	7b 81       	ldd	r23, Y+3	; 0x03
    263a:	80 e0       	ldi	r24, 0x00	; 0
    263c:	90 e0       	ldi	r25, 0x00	; 0
    263e:	26 e5       	ldi	r18, 0x56	; 86
    2640:	4d ef       	ldi	r20, 0xFD	; 253
    2642:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
  }

  /* display capacitance */
  if (CapFlag == 1)                     /* if requested */ 
    2646:	f1 e0       	ldi	r31, 0x01	; 1
    2648:	cf 12       	cpse	r12, r31
    264a:	8d c0       	rjmp	.+282    	; 0x2766 <Show_Diode+0x3d0>
  {
    UpdateLine2();                      /* key press for line #2 */
    264c:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <UpdateLine2>
    LCD_EEString2(DiodeCap_str);        /* display: C */
    2650:	84 e7       	ldi	r24, 0x74	; 116
    2652:	91 e0       	ldi	r25, 0x01	; 1
    2654:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
    Show_Diode_Cap(D1);                 /* first diode */
    2658:	c7 01       	movw	r24, r14
    265a:	0e 94 b8 11 	call	0x2370	; 0x2370 <Show_Diode_Cap>
    LCD_Space();
    265e:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>
    Show_Diode_Cap(D2);                 /* second diode (optional) */
    2662:	ce 01       	movw	r24, r28
    2664:	0e 94 b8 11 	call	0x2370	; 0x2370 <Show_Diode_Cap>
    2668:	7e c0       	rjmp	.+252    	; 0x2766 <Show_Diode+0x3d0>
    else if (D1->C == D2->C)       /* common cathode */
    {
      C = D1->C;                   /* save common cathode */

      /* possible NPN BJT with low value B-E resistor and flyback diode */
      R_Pin1 = D1->A;
    266a:	d1 2e       	mov	r13, r17
void Show_Diode(void)
{
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
    266c:	15 e0       	ldi	r17, 0x05	; 5
    C = D1->C;                     /* make anode first pin */
  }
  else if (Check.Diodes == 2)      /* two diodes */
  {
    D2 = D1;
    D2++;                          /* pointer to second diode */
    266e:	c0 e5       	ldi	r28, 0x50	; 80
    2670:	d1 e0       	ldi	r29, 0x01	; 1
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
  uint8_t           R_Pin2 = 5;    /* B_E resistor's pin #2 */
  uint16_t          I_leak;        /* leakage current */

  D1 = &Diodes[0];                 /* pointer to first diode */
    2672:	0f 2e       	mov	r0, r31
    2674:	fa e4       	ldi	r31, 0x4A	; 74
    2676:	ef 2e       	mov	r14, r31
    2678:	f1 e0       	ldi	r31, 0x01	; 1
    267a:	ff 2e       	mov	r15, r31
    267c:	f0 2d       	mov	r31, r0
    267e:	12 c0       	rjmp	.+36     	; 0x26a4 <Show_Diode+0x30e>
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
  uint8_t           R_Pin2 = 5;    /* B_E resistor's pin #2 */
    2680:	0f 2e       	mov	r0, r31
    2682:	f5 e0       	ldi	r31, 0x05	; 5
    2684:	bf 2e       	mov	r11, r31
    2686:	f0 2d       	mov	r31, r0
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
    2688:	0f 2e       	mov	r0, r31
    268a:	f5 e0       	ldi	r31, 0x05	; 5
    268c:	df 2e       	mov	r13, r31
    268e:	f0 2d       	mov	r31, r0
{
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
    2690:	05 e0       	ldi	r16, 0x05	; 5
void Show_Diode(void)
{
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
    2692:	15 e0       	ldi	r17, 0x05	; 5
    C = D1->C;                     /* make anode first pin */
  }
  else if (Check.Diodes == 2)      /* two diodes */
  {
    D2 = D1;
    D2++;                          /* pointer to second diode */
    2694:	c0 e5       	ldi	r28, 0x50	; 80
    2696:	d1 e0       	ldi	r29, 0x01	; 1
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
  uint8_t           R_Pin2 = 5;    /* B_E resistor's pin #2 */
  uint16_t          I_leak;        /* leakage current */

  D1 = &Diodes[0];                 /* pointer to first diode */
    2698:	0f 2e       	mov	r0, r31
    269a:	fa e4       	ldi	r31, 0x4A	; 74
    269c:	ef 2e       	mov	r14, r31
    269e:	f1 e0       	ldi	r31, 0x01	; 1
    26a0:	ff 2e       	mov	r15, r31
    26a2:	f0 2d       	mov	r31, r0
    26a4:	cc 24       	eor	r12, r12
    26a6:	c3 94       	inc	r12
    26a8:	40 cf       	rjmp	.-384    	; 0x252a <Show_Diode+0x194>
   *  - reverse leakage current (for single diodes)
   *  - capacitance (not for anti-parallel diodes)
   */

  /* display Uf */
  LCD_ClearLine2();                /* only change line #2 */  
    26aa:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <LCD_ClearLine2>
  LCD_EEString2(Vf_str);           /* display: Vf */
    26ae:	86 e7       	ldi	r24, 0x76	; 118
    26b0:	91 e0       	ldi	r25, 0x01	; 1
    26b2:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>

  /* first diode */
  DisplayValue(D1->V_f, -3, 'V');
    26b6:	f7 01       	movw	r30, r14
    26b8:	62 81       	ldd	r22, Z+2	; 0x02
    26ba:	73 81       	ldd	r23, Z+3	; 0x03
    26bc:	80 e0       	ldi	r24, 0x00	; 0
    26be:	90 e0       	ldi	r25, 0x00	; 0
    26c0:	26 e5       	ldi	r18, 0x56	; 86
    26c2:	4d ef       	ldi	r20, 0xFD	; 253
    26c4:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>

  LCD_Space();
    26c8:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>
    26cc:	b4 cf       	rjmp	.-152    	; 0x2636 <Show_Diode+0x2a0>
    else if (A <= 3) LCD_ProbeNumber(D2->C);      /* common anode or in series */
    else LCD_ProbeNumber(D2->A);                  /* common cathode */
  }

  /* check for B-E resistor for possible BJT */
  if (R_Pin1 < 5)                  /* possible BJT */
    26ce:	f4 e0       	ldi	r31, 0x04	; 4
    26d0:	fd 15       	cp	r31, r13
    26d2:	58 f3       	brcs	.-42     	; 0x26aa <Show_Diode+0x314>
    26d4:	28 c0       	rjmp	.+80     	; 0x2726 <Show_Diode+0x390>
   *  - reverse leakage current (for single diodes)
   *  - capacitance (not for anti-parallel diodes)
   */

  /* display Uf */
  LCD_ClearLine2();                /* only change line #2 */  
    26d6:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <LCD_ClearLine2>
  LCD_EEString2(Vf_str);           /* display: Vf */
    26da:	86 e7       	ldi	r24, 0x76	; 118
    26dc:	91 e0       	ldi	r25, 0x01	; 1
    26de:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>

  /* first diode */
  DisplayValue(D1->V_f, -3, 'V');
    26e2:	f7 01       	movw	r30, r14
    26e4:	62 81       	ldd	r22, Z+2	; 0x02
    26e6:	73 81       	ldd	r23, Z+3	; 0x03
    26e8:	80 e0       	ldi	r24, 0x00	; 0
    26ea:	90 e0       	ldi	r25, 0x00	; 0
    26ec:	26 e5       	ldi	r18, 0x56	; 86
    26ee:	4d ef       	ldi	r20, 0xFD	; 253
    26f0:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>

  LCD_Space();
    26f4:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>
    26f8:	6f cf       	rjmp	.-290    	; 0x25d8 <Show_Diode+0x242>
    else if (A <= 3) LCD_ProbeNumber(D2->C);      /* common anode or in series */
    else LCD_ProbeNumber(D2->A);                  /* common cathode */
  }

  /* check for B-E resistor for possible BJT */
  if (R_Pin1 < 5)                  /* possible BJT */
    26fa:	f4 e0       	ldi	r31, 0x04	; 4
    26fc:	fd 15       	cp	r31, r13
    26fe:	58 f3       	brcs	.-42     	; 0x26d6 <Show_Diode+0x340>
    2700:	2b c0       	rjmp	.+86     	; 0x2758 <Show_Diode+0x3c2>
   *  - reverse leakage current (for single diodes)
   *  - capacitance (not for anti-parallel diodes)
   */

  /* display Uf */
  LCD_ClearLine2();                /* only change line #2 */  
    2702:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <LCD_ClearLine2>
  LCD_EEString2(Vf_str);           /* display: Vf */
    2706:	86 e7       	ldi	r24, 0x76	; 118
    2708:	91 e0       	ldi	r25, 0x01	; 1
    270a:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>

  /* first diode */
  DisplayValue(D1->V_f, -3, 'V');
    270e:	f7 01       	movw	r30, r14
    2710:	62 81       	ldd	r22, Z+2	; 0x02
    2712:	73 81       	ldd	r23, Z+3	; 0x03
    2714:	80 e0       	ldi	r24, 0x00	; 0
    2716:	90 e0       	ldi	r25, 0x00	; 0
    2718:	26 e5       	ldi	r18, 0x56	; 86
    271a:	4d ef       	ldi	r20, 0xFD	; 253
    271c:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>

  LCD_Space();
    2720:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>
    2724:	88 cf       	rjmp	.-240    	; 0x2636 <Show_Diode+0x2a0>
  }

  /* check for B-E resistor for possible BJT */
  if (R_Pin1 < 5)                  /* possible BJT */
  {
    if (CheckSingleResistor(R_Pin1, R_Pin2) == 1) /* found B-E resistor */
    2726:	6b 2d       	mov	r22, r11
    2728:	8d 2d       	mov	r24, r13
    272a:	0e 94 6a 1e 	call	0x3cd4	; 0x3cd4 <CheckSingleResistor>
    272e:	81 30       	cpi	r24, 0x01	; 1
    2730:	41 f7       	brne	.-48     	; 0x2702 <Show_Diode+0x36c>
    2732:	24 cf       	rjmp	.-440    	; 0x257c <Show_Diode+0x1e6>
   *  - reverse leakage current (for single diodes)
   *  - capacitance (not for anti-parallel diodes)
   */

  /* display Uf */
  LCD_ClearLine2();                /* only change line #2 */  
    2734:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <LCD_ClearLine2>
  LCD_EEString2(Vf_str);           /* display: Vf */
    2738:	86 e7       	ldi	r24, 0x76	; 118
    273a:	91 e0       	ldi	r25, 0x01	; 1
    273c:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>

  /* first diode */
  DisplayValue(D1->V_f, -3, 'V');
    2740:	f7 01       	movw	r30, r14
    2742:	62 81       	ldd	r22, Z+2	; 0x02
    2744:	73 81       	ldd	r23, Z+3	; 0x03
    2746:	80 e0       	ldi	r24, 0x00	; 0
    2748:	90 e0       	ldi	r25, 0x00	; 0
    274a:	26 e5       	ldi	r18, 0x56	; 86
    274c:	4d ef       	ldi	r20, 0xFD	; 253
    274e:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>

  LCD_Space();
    2752:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>
    2756:	40 cf       	rjmp	.-384    	; 0x25d8 <Show_Diode+0x242>
  }

  /* check for B-E resistor for possible BJT */
  if (R_Pin1 < 5)                  /* possible BJT */
  {
    if (CheckSingleResistor(R_Pin1, R_Pin2) == 1) /* found B-E resistor */
    2758:	6b 2d       	mov	r22, r11
    275a:	8d 2d       	mov	r24, r13
    275c:	0e 94 6a 1e 	call	0x3cd4	; 0x3cd4 <CheckSingleResistor>
    2760:	81 30       	cpi	r24, 0x01	; 1
    2762:	41 f7       	brne	.-48     	; 0x2734 <Show_Diode+0x39e>
    2764:	0b cf       	rjmp	.-490    	; 0x257c <Show_Diode+0x1e6>
    LCD_EEString2(DiodeCap_str);        /* display: C */
    Show_Diode_Cap(D1);                 /* first diode */
    LCD_Space();
    Show_Diode_Cap(D2);                 /* second diode (optional) */
  }
}
    2766:	df 91       	pop	r29
    2768:	cf 91       	pop	r28
    276a:	1f 91       	pop	r17
    276c:	0f 91       	pop	r16
    276e:	ff 90       	pop	r15
    2770:	ef 90       	pop	r14
    2772:	df 90       	pop	r13
    2774:	cf 90       	pop	r12
    2776:	bf 90       	pop	r11
    2778:	08 95       	ret

0000277a <Show_FlybackDiode>:
 *  show intrinsic/freewheeling diode of transistor
 */

void Show_FlybackDiode(void)
{
  LCD_Space();                /* display space */
    277a:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>

  /* first pin */
  if (Check.Found == COMP_FET)     /* FET */
    277e:	80 91 01 01 	lds	r24, 0x0101
    2782:	86 31       	cpi	r24, 0x16	; 22
    2784:	21 f4       	brne	.+8      	; 0x278e <Show_FlybackDiode+0x14>
  {
    LCD_Data('D');                 /* drain */
    2786:	84 e4       	ldi	r24, 0x44	; 68
    2788:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    278c:	03 c0       	rjmp	.+6      	; 0x2794 <Show_FlybackDiode+0x1a>
  }
  else                             /* BJT/IGBT */
  {
    LCD_Data('C');                 /* collector */
    278e:	83 e4       	ldi	r24, 0x43	; 67
    2790:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
  }

  /* diode */
  if (Check.Type & TYPE_N_CHANNEL)      /* n-channel/NPN */
    2794:	80 91 02 01 	lds	r24, 0x0102
    2798:	80 ff       	sbrs	r24, 0
    279a:	04 c0       	rjmp	.+8      	; 0x27a4 <Show_FlybackDiode+0x2a>
    /*
     *  anode pointing to source/emitter
     *  cathode pointing to drain/collector
     */

    LCD_Data(LCD_CHAR_DIODE_CA);        /* |<| */
    279c:	82 e0       	ldi	r24, 0x02	; 2
    279e:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    27a2:	03 c0       	rjmp	.+6      	; 0x27aa <Show_FlybackDiode+0x30>
    /*
     *  anode pointing to drain/collector
     *  cathode pointing to source/emitter
     */

    LCD_Data(LCD_CHAR_DIODE_AC);        /* |>| */
    27a4:	81 e0       	ldi	r24, 0x01	; 1
    27a6:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
  }

  /* second pin */
  if (Check.Found == COMP_FET)     /* FET */
    27aa:	80 91 01 01 	lds	r24, 0x0101
    27ae:	86 31       	cpi	r24, 0x16	; 22
    27b0:	21 f4       	brne	.+8      	; 0x27ba <Show_FlybackDiode+0x40>
  {
    LCD_Data('S');                 /* source */
    27b2:	83 e5       	ldi	r24, 0x53	; 83
    27b4:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    27b8:	08 95       	ret
  }
  else                             /* BJT/IGBT */
  {
    LCD_Data('E');                 /* emitter */
    27ba:	85 e4       	ldi	r24, 0x45	; 69
    27bc:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    27c0:	08 95       	ret

000027c2 <Show_BJT>:
/*
 *  show BJT
 */

void Show_BJT(void)
{
    27c2:	4f 92       	push	r4
    27c4:	5f 92       	push	r5
    27c6:	6f 92       	push	r6
    27c8:	7f 92       	push	r7
    27ca:	9f 92       	push	r9
    27cc:	af 92       	push	r10
    27ce:	bf 92       	push	r11
    27d0:	cf 92       	push	r12
    27d2:	df 92       	push	r13
    27d4:	ef 92       	push	r14
    27d6:	ff 92       	push	r15
    27d8:	0f 93       	push	r16
    27da:	1f 93       	push	r17
    27dc:	cf 93       	push	r28
    27de:	df 93       	push	r29
   *  I_1 - I_CE0 (킕)
   *  F_1 - hFE
   */

  /* preset stuff based on BJT type */
  if (Check.Type & TYPE_NPN)       /* NPN */
    27e0:	80 91 02 01 	lds	r24, 0x0102
    27e4:	80 ff       	sbrs	r24, 0
    27e6:	07 c0       	rjmp	.+14     	; 0x27f6 <Show_BJT+0x34>
  {
    String = (unsigned char *)NPN_str;       /* "NPN" */

    /* direction of B-E diode: B -> E */
    A_Pin = Semi.A;      /* anode at base */
    27e8:	ef e6       	ldi	r30, 0x6F	; 111
    27ea:	f1 e0       	ldi	r31, 0x01	; 1
    27ec:	10 81       	ld	r17, Z
    C_Pin = Semi.C;      /* cathode at emitter */
    27ee:	02 81       	ldd	r16, Z+2	; 0x02
   */

  /* preset stuff based on BJT type */
  if (Check.Type & TYPE_NPN)       /* NPN */
  {
    String = (unsigned char *)NPN_str;       /* "NPN" */
    27f0:	c2 e9       	ldi	r28, 0x92	; 146
    27f2:	d1 e0       	ldi	r29, 0x01	; 1
    27f4:	06 c0       	rjmp	.+12     	; 0x2802 <Show_BJT+0x40>
  else                             /* PNP */
  {
    String = (unsigned char *)PNP_str;       /* "PNP" */

    /* direction of B-E diode: E -> B */
    A_Pin = Semi.C;      /* anode at emitter */
    27f6:	ef e6       	ldi	r30, 0x6F	; 111
    27f8:	f1 e0       	ldi	r31, 0x01	; 1
    27fa:	12 81       	ldd	r17, Z+2	; 0x02
    C_Pin = Semi.A;      /* cathode at base */
    27fc:	00 81       	ld	r16, Z
    A_Pin = Semi.A;      /* anode at base */
    C_Pin = Semi.C;      /* cathode at emitter */
  }
  else                             /* PNP */
  {
    String = (unsigned char *)PNP_str;       /* "PNP" */
    27fe:	ce e8       	ldi	r28, 0x8E	; 142
    2800:	d1 e0       	ldi	r29, 0x01	; 1
    A_Pin = Semi.C;      /* anode at emitter */
    C_Pin = Semi.A;      /* cathode at base */
  }

  /* display type */
  LCD_EEString2(BJT_str);          /* display: BJT */
    2802:	88 ef       	ldi	r24, 0xF8	; 248
    2804:	91 e0       	ldi	r25, 0x01	; 1
    2806:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
  LCD_EEString(String);            /* display: NPN / PNP */
    280a:	ce 01       	movw	r24, r28
    280c:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>

  /* parasitic BJT (freewheeling diode on same substrate) */
  if (Check.Type & TYPE_PARASITIC)
    2810:	80 91 02 01 	lds	r24, 0x0102
    2814:	82 ff       	sbrs	r24, 2
    2816:	03 c0       	rjmp	.+6      	; 0x281e <Show_BJT+0x5c>
  {
    LCD_Data('+');
    2818:	8b e2       	ldi	r24, 0x2B	; 43
    281a:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
  }

  LCD_Line2();                     /* move to line #2 */
    281e:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>

  /* display pinout */
  Show_SemiPinout('B', 'C', 'E');
    2822:	45 e4       	ldi	r20, 0x45	; 69
    2824:	63 e4       	ldi	r22, 0x43	; 67
    2826:	82 e4       	ldi	r24, 0x42	; 66
    2828:	0e 94 d9 0f 	call	0x1fb2	; 0x1fb2 <Show_SemiPinout>

  /* optional freewheeling diode */
  if (Check.Diodes > 2)       /* transistor is a set of two diodes :-) */
    282c:	80 91 04 01 	lds	r24, 0x0104
    2830:	83 30       	cpi	r24, 0x03	; 3
    2832:	10 f0       	brcs	.+4      	; 0x2838 <Show_BJT+0x76>
  {
    Show_FlybackDiode();           /* show diode */
    2834:	0e 94 bd 13 	call	0x277a	; 0x277a <Show_FlybackDiode>
  }

  UpdateLine2();                   /* key press for line #2 */
    2838:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <UpdateLine2>

  /* display either optional B-E resistor or hFE & V_BE */
  if (CheckSingleResistor(C_Pin, A_Pin) == 1)     /* found B-E resistor */
    283c:	61 2f       	mov	r22, r17
    283e:	80 2f       	mov	r24, r16
    2840:	0e 94 6a 1e 	call	0x3cd4	; 0x3cd4 <CheckSingleResistor>
    2844:	81 30       	cpi	r24, 0x01	; 1
    2846:	29 f4       	brne	.+10     	; 0x2852 <Show_BJT+0x90>
  {
    Show_SingleResistor('B', 'E');
    2848:	65 e4       	ldi	r22, 0x45	; 69
    284a:	82 e4       	ldi	r24, 0x42	; 66
    284c:	0e 94 75 10 	call	0x20ea	; 0x20ea <Show_SingleResistor>
    2850:	68 c0       	rjmp	.+208    	; 0x2922 <Show_BJT+0x160>
  else                                            /* no B-E resistor found */
  {
    /* hFE and V_BE */

    /* display hFE */
    LCD_EEString2(hFE_str);        /* display: h_FE */
    2852:	89 e8       	ldi	r24, 0x89	; 137
    2854:	91 e0       	ldi	r25, 0x01	; 1
    2856:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
    DisplayValue(Semi.F_1, 0, 0);
    285a:	60 91 78 01 	lds	r22, 0x0178
    285e:	70 91 79 01 	lds	r23, 0x0179
    2862:	80 91 7a 01 	lds	r24, 0x017A
    2866:	90 91 7b 01 	lds	r25, 0x017B
    286a:	20 e0       	ldi	r18, 0x00	; 0
    286c:	40 e0       	ldi	r20, 0x00	; 0
    286e:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>

    /* display V_BE (taken from diode forward voltage) */
    Diode = &Diodes[0];                 /* get pointer of first diode */  
    Counter = 0;
    2872:	80 e0       	ldi	r24, 0x00	; 0
    /* display hFE */
    LCD_EEString2(hFE_str);        /* display: h_FE */
    DisplayValue(Semi.F_1, 0, 0);

    /* display V_BE (taken from diode forward voltage) */
    Diode = &Diodes[0];                 /* get pointer of first diode */  
    2874:	ca e4       	ldi	r28, 0x4A	; 74
    2876:	d1 e0       	ldi	r29, 0x01	; 1
    Counter = 0;

    while (Counter < Check.Diodes)      /* check all diodes */
    2878:	0f 2e       	mov	r0, r31
    287a:	f0 e0       	ldi	r31, 0x00	; 0
    287c:	ef 2e       	mov	r14, r31
    287e:	f1 e0       	ldi	r31, 0x01	; 1
    2880:	ff 2e       	mov	r15, r31
    2882:	f0 2d       	mov	r31, r0
        /* calculate slope for one decade */
        Slope = Diode->V_f - Diode->V_f2;
        Slope /= 3;

        /* select V_BE based on hFE */
        if (Semi.F_1 < 100)             /* low hFE */
    2884:	0f 2e       	mov	r0, r31
    2886:	ff e6       	ldi	r31, 0x6F	; 111
    2888:	cf 2e       	mov	r12, r31
    288a:	f1 e0       	ldi	r31, 0x01	; 1
    288c:	df 2e       	mov	r13, r31
    288e:	f0 2d       	mov	r31, r0
          V_BE = Diode->V_f2 + Slope;
        }

        DisplayValue(V_BE, -3, 'V');

        Counter = 10;              /* end loop */
    2890:	0f 2e       	mov	r0, r31
    2892:	fa e0       	ldi	r31, 0x0A	; 10
    2894:	9f 2e       	mov	r9, r31
    2896:	f0 2d       	mov	r31, r0
         *  3 decades.
         */

        /* calculate slope for one decade */
        Slope = Diode->V_f - Diode->V_f2;
        Slope /= 3;
    2898:	0f 2e       	mov	r0, r31
    289a:	f3 e0       	ldi	r31, 0x03	; 3
    289c:	af 2e       	mov	r10, r31
    289e:	b1 2c       	mov	r11, r1
    28a0:	f0 2d       	mov	r31, r0

    /* display V_BE (taken from diode forward voltage) */
    Diode = &Diodes[0];                 /* get pointer of first diode */  
    Counter = 0;

    while (Counter < Check.Diodes)      /* check all diodes */
    28a2:	3a c0       	rjmp	.+116    	; 0x2918 <Show_BJT+0x156>
    {
      /* if the diode matches the transistor's B-E diode */
      if ((Diode->A == A_Pin) && (Diode->C == C_Pin))
    28a4:	98 81       	ld	r25, Y
    28a6:	91 13       	cpse	r25, r17
    28a8:	35 c0       	rjmp	.+106    	; 0x2914 <Show_BJT+0x152>
    28aa:	99 81       	ldd	r25, Y+1	; 0x01
    28ac:	90 13       	cpse	r25, r16
    28ae:	32 c0       	rjmp	.+100    	; 0x2914 <Show_BJT+0x152>
      {
        UpdateLine2();                  /* key press for line #2 */
    28b0:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <UpdateLine2>
        LCD_EEString2(V_BE_str);        /* display: V_BE */
    28b4:	84 e8       	ldi	r24, 0x84	; 132
    28b6:	91 e0       	ldi	r25, 0x01	; 1
    28b8:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
         *  and high test current is 7mA. That's a logarithmic scale of
         *  3 decades.
         */

        /* calculate slope for one decade */
        Slope = Diode->V_f - Diode->V_f2;
    28bc:	2a 81       	ldd	r18, Y+2	; 0x02
    28be:	3b 81       	ldd	r19, Y+3	; 0x03
    28c0:	ec 81       	ldd	r30, Y+4	; 0x04
    28c2:	fd 81       	ldd	r31, Y+5	; 0x05
        Slope /= 3;

        /* select V_BE based on hFE */
        if (Semi.F_1 < 100)             /* low hFE */
    28c4:	d6 01       	movw	r26, r12
    28c6:	19 96       	adiw	r26, 0x09	; 9
    28c8:	4d 90       	ld	r4, X+
    28ca:	5d 90       	ld	r5, X+
    28cc:	6d 90       	ld	r6, X+
    28ce:	7c 90       	ld	r7, X
    28d0:	1c 97       	sbiw	r26, 0x0c	; 12
    28d2:	b4 e6       	ldi	r27, 0x64	; 100
    28d4:	4b 16       	cp	r4, r27
    28d6:	51 04       	cpc	r5, r1
    28d8:	61 04       	cpc	r6, r1
    28da:	71 04       	cpc	r7, r1
    28dc:	90 f0       	brcs	.+36     	; 0x2902 <Show_BJT+0x140>
         *  and high test current is 7mA. That's a logarithmic scale of
         *  3 decades.
         */

        /* calculate slope for one decade */
        Slope = Diode->V_f - Diode->V_f2;
    28de:	c9 01       	movw	r24, r18
    28e0:	8e 1b       	sub	r24, r30
    28e2:	9f 0b       	sbc	r25, r31
        Slope /= 3;
    28e4:	b5 01       	movw	r22, r10
    28e6:	0e 94 2c 28 	call	0x5058	; 0x5058 <__divmodhi4>
           *  measurement (7mA). 
           */

          V_BE = Diode->V_f;
        }
        else if (Semi.F_1 < 250)        /* mid-range hFE */
    28ea:	8a ef       	ldi	r24, 0xFA	; 250
    28ec:	48 16       	cp	r4, r24
    28ee:	51 04       	cpc	r5, r1
    28f0:	61 04       	cpc	r6, r1
    28f2:	71 04       	cpc	r7, r1
    28f4:	18 f4       	brcc	.+6      	; 0x28fc <Show_BJT+0x13a>
           *  BJTs with a mid-range hFE are signal transistors and need
           *  a small I_b to drive the load. So we interpolate Vf for
           *  a virtual test current of about 1mA.
           */

          V_BE = Diode->V_f - Slope;
    28f6:	26 1b       	sub	r18, r22
    28f8:	37 0b       	sbc	r19, r23
    28fa:	03 c0       	rjmp	.+6      	; 0x2902 <Show_BJT+0x140>
           *  BJTs with a high hFE are small signal transistors and need
           *  only a very small I_b to drive the load. So we interpolate Vf
           *  for a virtual test current of about 0.1mA.
           */

          V_BE = Diode->V_f2 + Slope;
    28fc:	9b 01       	movw	r18, r22
    28fe:	2e 0f       	add	r18, r30
    2900:	3f 1f       	adc	r19, r31
        }

        DisplayValue(V_BE, -3, 'V');
    2902:	b9 01       	movw	r22, r18
    2904:	80 e0       	ldi	r24, 0x00	; 0
    2906:	90 e0       	ldi	r25, 0x00	; 0
    2908:	26 e5       	ldi	r18, 0x56	; 86
    290a:	4d ef       	ldi	r20, 0xFD	; 253
    290c:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>

        Counter = 10;              /* end loop */
    2910:	89 2d       	mov	r24, r9
    2912:	02 c0       	rjmp	.+4      	; 0x2918 <Show_BJT+0x156>
      }
      else                         /* diode doesn't match */
      {
        Counter++;                      /* increase counter */
    2914:	8f 5f       	subi	r24, 0xFF	; 255
        Diode++;                        /* next one */
    2916:	26 96       	adiw	r28, 0x06	; 6

    /* display V_BE (taken from diode forward voltage) */
    Diode = &Diodes[0];                 /* get pointer of first diode */  
    Counter = 0;

    while (Counter < Check.Diodes)      /* check all diodes */
    2918:	d7 01       	movw	r26, r14
    291a:	14 96       	adiw	r26, 0x04	; 4
    291c:	9c 91       	ld	r25, X
    291e:	89 17       	cp	r24, r25
    2920:	08 f2       	brcs	.-126    	; 0x28a4 <Show_BJT+0xe2>
      }
    }
  }

  /* I_CEO: collector emitter cutoff current (leakage) */
  if (Semi.I_1 > 0)                     /* show if not zero */
    2922:	80 91 76 01 	lds	r24, 0x0176
    2926:	90 91 77 01 	lds	r25, 0x0177
    292a:	89 2b       	or	r24, r25
    292c:	81 f0       	breq	.+32     	; 0x294e <Show_BJT+0x18c>
  {
    UpdateLine2();                      /* key press for line #2 */
    292e:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <UpdateLine2>
    LCD_EEString2(I_CEO_str);           /* display: I_CE0 */
    2932:	89 e7       	ldi	r24, 0x79	; 121
    2934:	91 e0       	ldi	r25, 0x01	; 1
    2936:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
    DisplayValue(Semi.I_1, -6, 'A');    /* display current */
    293a:	60 91 76 01 	lds	r22, 0x0176
    293e:	70 91 77 01 	lds	r23, 0x0177
    2942:	80 e0       	ldi	r24, 0x00	; 0
    2944:	90 e0       	ldi	r25, 0x00	; 0
    2946:	21 e4       	ldi	r18, 0x41	; 65
    2948:	4a ef       	ldi	r20, 0xFA	; 250
    294a:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
  }
}
    294e:	df 91       	pop	r29
    2950:	cf 91       	pop	r28
    2952:	1f 91       	pop	r17
    2954:	0f 91       	pop	r16
    2956:	ff 90       	pop	r15
    2958:	ef 90       	pop	r14
    295a:	df 90       	pop	r13
    295c:	cf 90       	pop	r12
    295e:	bf 90       	pop	r11
    2960:	af 90       	pop	r10
    2962:	9f 90       	pop	r9
    2964:	7f 90       	pop	r7
    2966:	6f 90       	pop	r6
    2968:	5f 90       	pop	r5
    296a:	4f 90       	pop	r4
    296c:	08 95       	ret

0000296e <Show_FET_Extras>:
 */

void Show_FET_Extras(void)
{
  /* show instrinsic/freewheeling diode */
  if (Check.Diodes > 0)            /* diode found */
    296e:	80 91 04 01 	lds	r24, 0x0104
    2972:	81 11       	cpse	r24, r1
  {
    Show_FlybackDiode();           /* show diode */
    2974:	0e 94 bd 13 	call	0x277a	; 0x277a <Show_FlybackDiode>
  }

  /* skip remaining stuff for depletion-mode FETs/IGBTs */
  if (Check.Type & TYPE_DEPLETION) return;
    2978:	80 91 02 01 	lds	r24, 0x0102
    297c:	83 fd       	sbrc	r24, 3
    297e:	2f c0       	rjmp	.+94     	; 0x29de <Show_FET_Extras+0x70>

  /* gate threshold voltage */
  if (Semi.U_2 != 0)
    2980:	80 91 74 01 	lds	r24, 0x0174
    2984:	90 91 75 01 	lds	r25, 0x0175
    2988:	89 2b       	or	r24, r25
    298a:	91 f0       	breq	.+36     	; 0x29b0 <Show_FET_Extras+0x42>
  {
    UpdateLine2();                      /* key press for line #2 */
    298c:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <UpdateLine2>
    LCD_EEString2(Vth_str);             /* display: Vth */
    2990:	80 e7       	ldi	r24, 0x70	; 112
    2992:	91 e0       	ldi	r25, 0x01	; 1
    2994:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
    DisplaySignedValue(Semi.U_2, -3, 'V');   /* display V_th in mV */
    2998:	60 91 74 01 	lds	r22, 0x0174
    299c:	70 91 75 01 	lds	r23, 0x0175
    29a0:	07 2e       	mov	r0, r23
    29a2:	00 0c       	add	r0, r0
    29a4:	88 0b       	sbc	r24, r24
    29a6:	99 0b       	sbc	r25, r25
    29a8:	26 e5       	ldi	r18, 0x56	; 86
    29aa:	4d ef       	ldi	r20, 0xFD	; 253
    29ac:	0e 94 2e 26 	call	0x4c5c	; 0x4c5c <DisplaySignedValue>
  }

  /* display gate-source capacitance */
  UpdateLine2();                      /* key press for line #2 */
    29b0:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <UpdateLine2>
  LCD_EEString2(GateCap_str);         /* display: Cgs */
    29b4:	86 e9       	ldi	r24, 0x96	; 150
    29b6:	91 e0       	ldi	r25, 0x01	; 1
    29b8:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
  MeasureCap(Semi.A, Semi.C, 0);      /* measure capacitance */
    29bc:	ef e6       	ldi	r30, 0x6F	; 111
    29be:	f1 e0       	ldi	r31, 0x01	; 1
    29c0:	40 e0       	ldi	r20, 0x00	; 0
    29c2:	62 81       	ldd	r22, Z+2	; 0x02
    29c4:	80 81       	ld	r24, Z
    29c6:	0e 94 be 09 	call	0x137c	; 0x137c <MeasureCap>
  /* display value and unit */
  DisplayValue(Caps[0].Value, Caps[0].Scale, 'F');
    29ca:	e9 e2       	ldi	r30, 0x29	; 41
    29cc:	f1 e0       	ldi	r31, 0x01	; 1
    29ce:	63 81       	ldd	r22, Z+3	; 0x03
    29d0:	74 81       	ldd	r23, Z+4	; 0x04
    29d2:	85 81       	ldd	r24, Z+5	; 0x05
    29d4:	96 81       	ldd	r25, Z+6	; 0x06
    29d6:	26 e4       	ldi	r18, 0x46	; 70
    29d8:	42 81       	ldd	r20, Z+2	; 0x02
    29da:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
    29de:	08 95       	ret

000029e0 <Show_FET_Channel>:
 *  show FET/IGBT channel type
 */

void Show_FET_Channel(void)
{
  LCD_Space();                     /* display space */
    29e0:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>

  /* channel type */
  if (Check.Type & TYPE_N_CHANNEL)   /* n-channel */
    29e4:	80 91 02 01 	lds	r24, 0x0102
    29e8:	80 ff       	sbrs	r24, 0
    29ea:	04 c0       	rjmp	.+8      	; 0x29f4 <Show_FET_Channel+0x14>
  {
    LCD_Data('N');
    29ec:	8e e4       	ldi	r24, 0x4E	; 78
    29ee:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    29f2:	03 c0       	rjmp	.+6      	; 0x29fa <Show_FET_Channel+0x1a>
  }
  else                               /* p-channel */
  {
    LCD_Data('P');
    29f4:	80 e5       	ldi	r24, 0x50	; 80
    29f6:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
  }

  LCD_EEString(Channel_str);         /* display: -ch */
    29fa:	89 ea       	ldi	r24, 0xA9	; 169
    29fc:	91 e0       	ldi	r25, 0x01	; 1
    29fe:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
    2a02:	08 95       	ret

00002a04 <Show_FET_Mode>:
 *  show FET/IGBT mode
 */

void Show_FET_Mode(void)
{
  LCD_Space();
    2a04:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>

  if (Check.Type & TYPE_ENHANCEMENT)    /* enhancement mode */
    2a08:	80 91 02 01 	lds	r24, 0x0102
    2a0c:	82 ff       	sbrs	r24, 2
    2a0e:	05 c0       	rjmp	.+10     	; 0x2a1a <Show_FET_Mode+0x16>
  {
    LCD_EEString(Enhancement_str);
    2a10:	84 ea       	ldi	r24, 0xA4	; 164
    2a12:	91 e0       	ldi	r25, 0x01	; 1
    2a14:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
    2a18:	08 95       	ret
  }
  else                                  /* depletion mode */
  {
    LCD_EEString(Depletion_str);
    2a1a:	8f e9       	ldi	r24, 0x9F	; 159
    2a1c:	91 e0       	ldi	r25, 0x01	; 1
    2a1e:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
    2a22:	08 95       	ret

00002a24 <Show_FET>:
   *  C   - Source pin
   *  U_2 - V_th (mV)
   */

  /* display type */
  if (Check.Type & TYPE_MOSFET)    /* MOSFET */
    2a24:	80 91 02 01 	lds	r24, 0x0102
    2a28:	84 ff       	sbrs	r24, 4
    2a2a:	05 c0       	rjmp	.+10     	; 0x2a36 <Show_FET+0x12>
  {
    LCD_EEString(MOS_str);           /* display: MOS */
    2a2c:	81 eb       	ldi	r24, 0xB1	; 177
    2a2e:	91 e0       	ldi	r25, 0x01	; 1
    2a30:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
    2a34:	03 c0       	rjmp	.+6      	; 0x2a3c <Show_FET+0x18>
  }
  else                             /* JFET */
  {
    LCD_Data('J');                   /* display: J */
    2a36:	8a e4       	ldi	r24, 0x4A	; 74
    2a38:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
  }
  LCD_EEString(FET_str);           /* display: FET */
    2a3c:	8d ea       	ldi	r24, 0xAD	; 173
    2a3e:	91 e0       	ldi	r25, 0x01	; 1
    2a40:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>

  /* display channel type */
  Show_FET_Channel();
    2a44:	0e 94 f0 14 	call	0x29e0	; 0x29e0 <Show_FET_Channel>
      
  /* display mode for MOSFETs*/
  if (Check.Type & TYPE_MOSFET) Show_FET_Mode();
    2a48:	80 91 02 01 	lds	r24, 0x0102
    2a4c:	84 fd       	sbrc	r24, 4
    2a4e:	0e 94 02 15 	call	0x2a04	; 0x2a04 <Show_FET_Mode>

  /* pinout */
  LCD_Line2();                          /* move to line #2 */
    2a52:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>

  if (Check.Type & TYPE_SYMMETRICAL)    /* symmetrical Drain and Source */
    2a56:	80 91 02 01 	lds	r24, 0x0102
    2a5a:	86 ff       	sbrs	r24, 6
    2a5c:	06 c0       	rjmp	.+12     	; 0x2a6a <Show_FET+0x46>
  {
    /* we can't distinguish D and S */
    Show_SemiPinout('G', 'x', 'x');     /* show pinout */
    2a5e:	48 e7       	ldi	r20, 0x78	; 120
    2a60:	68 e7       	ldi	r22, 0x78	; 120
    2a62:	87 e4       	ldi	r24, 0x47	; 71
    2a64:	0e 94 d9 0f 	call	0x1fb2	; 0x1fb2 <Show_SemiPinout>
    2a68:	05 c0       	rjmp	.+10     	; 0x2a74 <Show_FET+0x50>
  }
  else                                  /* unsymmetrical Drain and Source */
  {
    Show_SemiPinout('G', 'D', 'S');     /* show pinout */
    2a6a:	43 e5       	ldi	r20, 0x53	; 83
    2a6c:	64 e4       	ldi	r22, 0x44	; 68
    2a6e:	87 e4       	ldi	r24, 0x47	; 71
    2a70:	0e 94 d9 0f 	call	0x1fb2	; 0x1fb2 <Show_SemiPinout>
  }

  /* show diode, V_th and Cgs for MOSFETs */
  if (Check.Type & TYPE_MOSFET) Show_FET_Extras();
    2a74:	80 91 02 01 	lds	r24, 0x0102
    2a78:	84 fd       	sbrc	r24, 4
    2a7a:	0e 94 b7 14 	call	0x296e	; 0x296e <Show_FET_Extras>
    2a7e:	08 95       	ret

00002a80 <Show_IGBT>:
   *  B   - Collector pin
   *  C   - Emitter pin
   *  U_2 - V_th (mV)
   */

  LCD_EEString(IGBT_str);          /* display: IGBT */
    2a80:	8a e9       	ldi	r24, 0x9A	; 154
    2a82:	91 e0       	ldi	r25, 0x01	; 1
    2a84:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
  Show_FET_Channel();              /* display channel type */
    2a88:	0e 94 f0 14 	call	0x29e0	; 0x29e0 <Show_FET_Channel>
  Show_FET_Mode();                 /* display mode */
    2a8c:	0e 94 02 15 	call	0x2a04	; 0x2a04 <Show_FET_Mode>

  LCD_Line2();                     /* move to line #2 */
    2a90:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>
  Show_SemiPinout('G', 'C', 'E');  /* show pinout */
    2a94:	45 e4       	ldi	r20, 0x45	; 69
    2a96:	63 e4       	ldi	r22, 0x43	; 67
    2a98:	87 e4       	ldi	r24, 0x47	; 71
    2a9a:	0e 94 d9 0f 	call	0x1fb2	; 0x1fb2 <Show_SemiPinout>
  Show_FET_Extras();               /* show diode, V_th and C_GE */
    2a9e:	0e 94 b7 14 	call	0x296e	; 0x296e <Show_FET_Extras>
    2aa2:	08 95       	ret

00002aa4 <Show_Special>:
   *  C   - Cathode/MT1 pin
   *  U_1 - V_GT (mV)
   */

  /* display component type any pinout */
  if (Check.Found == COMP_THYRISTOR)    /* SCR */
    2aa4:	80 91 01 01 	lds	r24, 0x0101
    2aa8:	89 31       	cpi	r24, 0x19	; 25
    2aaa:	61 f4       	brne	.+24     	; 0x2ac4 <Show_Special+0x20>
  {
    LCD_EEString(Thyristor_str);        /* display: thyristor */
    2aac:	84 ef       	ldi	r24, 0xF4	; 244
    2aae:	91 e0       	ldi	r25, 0x01	; 1
    2ab0:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
    LCD_Line2();                        /* move to line #2 */
    2ab4:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>
    Show_SemiPinout('G', 'A', 'C');     /* display pinout */
    2ab8:	43 e4       	ldi	r20, 0x43	; 67
    2aba:	61 e4       	ldi	r22, 0x41	; 65
    2abc:	87 e4       	ldi	r24, 0x47	; 71
    2abe:	0e 94 d9 0f 	call	0x1fb2	; 0x1fb2 <Show_SemiPinout>
    2ac2:	0b c0       	rjmp	.+22     	; 0x2ada <Show_Special+0x36>
  }
  else                                  /* Triac */
  {
    LCD_EEString(Triac_str);            /* display: triac */
    2ac4:	8e ee       	ldi	r24, 0xEE	; 238
    2ac6:	91 e0       	ldi	r25, 0x01	; 1
    2ac8:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
    LCD_Line2();                        /* move to line #2 */
    2acc:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>
    Show_SemiPinout('G', '2', '1');     /* display pinout */
    2ad0:	41 e3       	ldi	r20, 0x31	; 49
    2ad2:	62 e3       	ldi	r22, 0x32	; 50
    2ad4:	87 e4       	ldi	r24, 0x47	; 71
    2ad6:	0e 94 d9 0f 	call	0x1fb2	; 0x1fb2 <Show_SemiPinout>
  }

  /* show V_GT (gate trigger voltage) */
  if (Semi.U_1 > 0)                /* show if not zero */
    2ada:	80 91 72 01 	lds	r24, 0x0172
    2ade:	90 91 73 01 	lds	r25, 0x0173
    2ae2:	89 2b       	or	r24, r25
    2ae4:	81 f0       	breq	.+32     	; 0x2b06 <Show_Special+0x62>
  {
    UpdateLine2();                      /* key press for line #2 */
    2ae6:	0e 94 d4 0f 	call	0x1fa8	; 0x1fa8 <UpdateLine2>
    LCD_EEString2(V_GT_str);            /* display: V_GT */
    2aea:	8f e7       	ldi	r24, 0x7F	; 127
    2aec:	91 e0       	ldi	r25, 0x01	; 1
    2aee:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
    DisplayValue(Semi.U_1, -3, 'V');    /* display V_GT in mV */
    2af2:	60 91 72 01 	lds	r22, 0x0172
    2af6:	70 91 73 01 	lds	r23, 0x0173
    2afa:	80 e0       	ldi	r24, 0x00	; 0
    2afc:	90 e0       	ldi	r25, 0x00	; 0
    2afe:	26 e5       	ldi	r18, 0x56	; 86
    2b00:	4d ef       	ldi	r20, 0xFD	; 253
    2b02:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
    2b06:	08 95       	ret

00002b08 <main>:
/*
 *  main function
 */

int main(void)
{
    2b08:	af 92       	push	r10
    2b0a:	bf 92       	push	r11
    2b0c:	cf 92       	push	r12
    2b0e:	df 92       	push	r13
    2b10:	ef 92       	push	r14
    2b12:	ff 92       	push	r15
    2b14:	0f 93       	push	r16
    2b16:	1f 93       	push	r17
    2b18:	cf 93       	push	r28
    2b1a:	df 93       	push	r29
  /*
   *  init
   */

  /* switch on power to keep me alive */
  CONTROL_DDR = (1 << POWER_CTRL);      /* set pin as output */
    2b1c:	80 e4       	ldi	r24, 0x40	; 64
    2b1e:	8a b9       	out	0x0a, r24	; 10
  CONTROL_PORT = (1 << POWER_CTRL);     /* set pin to drive power management transistor */
    2b20:	8b b9       	out	0x0b, r24	; 11

  /* setup MCU */
  MCUCR = (1 << PUD);                        /* disable pull-up resistors globally */
    2b22:	80 e1       	ldi	r24, 0x10	; 16
    2b24:	85 bf       	out	0x35, r24	; 53
  ADCSRA = (1 << ADEN) | ADC_CLOCK_DIV;      /* enable ADC and set clock divider */
    2b26:	83 e8       	ldi	r24, 0x83	; 131
    2b28:	80 93 7a 00 	sts	0x007A, r24
                                      /* ADC_PORT should be 0 */
  ADC_DDR = (1 << TP_REF);            /* short circuit probes */
  #endif

  /* catch watchdog */  
  Test = (MCUSR & (1 << WDRF));         /* save watchdog flag */
    2b2c:	94 b7       	in	r25, 0x34	; 52
  MCUSR &= ~(1 << WDRF);                /* reset watchdog flag */
    2b2e:	84 b7       	in	r24, 0x34	; 52
    2b30:	87 7f       	andi	r24, 0xF7	; 247
    2b32:	84 bf       	out	0x34, r24	; 52
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    2b34:	0f b6       	in	r0, 0x3f	; 63
    2b36:	f8 94       	cli
    2b38:	a8 95       	wdr
    2b3a:	80 91 60 00 	lds	r24, 0x0060
    2b3e:	88 61       	ori	r24, 0x18	; 24
    2b40:	80 93 60 00 	sts	0x0060, r24
    2b44:	10 92 60 00 	sts	0x0060, r1
    2b48:	0f be       	out	0x3f, r0	; 63
   *  - Does only work if the capacitor at the base of the power management
   *    transistor is large enough to survive a MCU reset. Otherwise the
   *    tester simply looses power.
   */

  if (Test)
    2b4a:	93 ff       	sbrs	r25, 3
    2b4c:	12 c0       	rjmp	.+36     	; 0x2b72 <main+0x6a>
  {
    LCD_Clear();                        /* display was initialized before */
    2b4e:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>
    LCD_EEString(Timeout_str);          /* display: timeout */
    2b52:	84 e6       	ldi	r24, 0x64	; 100
    2b54:	91 e0       	ldi	r25, 0x01	; 1
    2b56:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
    LCD_Line2();
    2b5a:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>
    LCD_EEString(Error_str);            /* display: error */
    2b5e:	81 e0       	ldi	r24, 0x01	; 1
    2b60:	92 e0       	ldi	r25, 0x02	; 2
    2b62:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
    MilliSleep(2000);                   /* give user some time to read */
    2b66:	80 ed       	ldi	r24, 0xD0	; 208
    2b68:	97 e0       	ldi	r25, 0x07	; 7
    2b6a:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>
    CONTROL_PORT = 0;                   /* power off myself */
    2b6e:	1b b8       	out	0x0b, r1	; 11
    return 0;                           /* exit program */
    2b70:	83 c1       	rjmp	.+774    	; 0x2e78 <main+0x370>

  /*
   *  init LCD module and load custom characters
   */

  LCD_Init();                           /* initialize LCD */
    2b72:	0e 94 56 0f 	call	0x1eac	; 0x1eac <LCD_Init>

  /* custom symbols for components */
  LCD_EELoadChar(DiodeIcon1, LCD_CHAR_DIODE_AC);  /* diode symbol '|>|' */
    2b76:	61 e0       	ldi	r22, 0x01	; 1
    2b78:	8c ee       	ldi	r24, 0xEC	; 236
    2b7a:	90 e0       	ldi	r25, 0x00	; 0
    2b7c:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <LCD_EELoadChar>
  LCD_EELoadChar(DiodeIcon2, LCD_CHAR_DIODE_CA);  /* diode symbol '|<|' */
    2b80:	62 e0       	ldi	r22, 0x02	; 2
    2b82:	84 ee       	ldi	r24, 0xE4	; 228
    2b84:	90 e0       	ldi	r25, 0x00	; 0
    2b86:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <LCD_EELoadChar>
  LCD_EELoadChar(CapIcon, LCD_CHAR_CAP);          /* capacitor symbol '||' */
    2b8a:	63 e0       	ldi	r22, 0x03	; 3
    2b8c:	8c ed       	ldi	r24, 0xDC	; 220
    2b8e:	90 e0       	ldi	r25, 0x00	; 0
    2b90:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <LCD_EELoadChar>
  LCD_EELoadChar(ResIcon1, LCD_CHAR_RESISTOR_L);  /* resistor symbol '[' */
    2b94:	66 e0       	ldi	r22, 0x06	; 6
    2b96:	84 ed       	ldi	r24, 0xD4	; 212
    2b98:	90 e0       	ldi	r25, 0x00	; 0
    2b9a:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <LCD_EELoadChar>
  LCD_EELoadChar(ResIcon2, LCD_CHAR_RESISTOR_R);  /* resistor symbol ']' */
    2b9e:	67 e0       	ldi	r22, 0x07	; 7
    2ba0:	8c ec       	ldi	r24, 0xCC	; 204
    2ba2:	90 e0       	ldi	r25, 0x00	; 0
    2ba4:	0e 94 8d 0f 	call	0x1f1a	; 0x1f1a <LCD_EELoadChar>
  LCD_EELoadChar(OmegaIcon, LCD_CHAR_OMEGA);      /* Omega */
  LCD_EELoadChar(MicroIcon, LCD_CHAR_MICRO);      /*  / micro */
  #endif

  /* return to normal output */
  LCD_Clear();
    2ba8:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>

  /*
   *  operation mode selection
   */

  Config.SleepMode = SLEEP_MODE_PWR_SAVE;    /* default: power save */
    2bac:	ee e8       	ldi	r30, 0x8E	; 142
    2bae:	f1 e0       	ldi	r31, 0x01	; 1
    2bb0:	86 e0       	ldi	r24, 0x06	; 6
    2bb2:	81 83       	std	Z+1, r24	; 0x01
  Config.TesterMode = MODE_CONTINOUS;        /* set default mode: continous */
    2bb4:	10 82       	st	Z, r1

  /* catch long key press */
  if (!(CONTROL_PIN & (1 << TEST_BUTTON)))   /* if test button is pressed */
    2bb6:	4f 99       	sbic	0x09, 7	; 9
    2bb8:	09 c0       	rjmp	.+18     	; 0x2bcc <main+0xc4>
  {
    MilliSleep(300);                         /* wait to catch a long key press */
    2bba:	8c e2       	ldi	r24, 0x2C	; 44
    2bbc:	91 e0       	ldi	r25, 0x01	; 1
    2bbe:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>
    if (!(CONTROL_PIN & (1 << TEST_BUTTON))) /* if button is still pressed */
    2bc2:	4f 99       	sbic	0x09, 7	; 9
    2bc4:	03 c0       	rjmp	.+6      	; 0x2bcc <main+0xc4>
    {
      Config.TesterMode = MODE_AUTOHOLD;     /* set auto-hold mode */
    2bc6:	81 e0       	ldi	r24, 0x01	; 1
    2bc8:	80 93 8e 01 	sts	0x018E, r24

  /*
   *  welcome user
   */

  LCD_EEString(Tester_str);        /* display: Component Tester */
    2bcc:	8d eb       	ldi	r24, 0xBD	; 189
    2bce:	91 e0       	ldi	r25, 0x01	; 1
    2bd0:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
  LCD_Line2();                     /* move to line #2 */
    2bd4:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>
  LCD_EEString(Version_str);       /* display firmware version */
    2bd8:	84 ef       	ldi	r24, 0xF4	; 244
    2bda:	90 e0       	ldi	r25, 0x00	; 0
    2bdc:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
  MilliSleep(1000);                /* let the user read the display */
    2be0:	88 ee       	ldi	r24, 0xE8	; 232
    2be2:	93 e0       	ldi	r25, 0x03	; 3
    2be4:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>
  /*
   *  init variables
   */

  /* cycling */
  RunsMissed = 0;
    2be8:	10 92 7c 01 	sts	0x017C, r1
  RunsPassed = 0;
    2bec:	10 92 6e 01 	sts	0x016E, r1

  /* default offsets and values */
  Config.Samples = ADC_SAMPLES;         /* number of ADC samples */
    2bf0:	ee e8       	ldi	r30, 0x8E	; 142
    2bf2:	f1 e0       	ldi	r31, 0x01	; 1
    2bf4:	89 e1       	ldi	r24, 0x19	; 25
    2bf6:	82 83       	std	Z+2, r24	; 0x02
  Config.AutoScale = 1;                 /* enable ADC auto scaling */
    2bf8:	81 e0       	ldi	r24, 0x01	; 1
    2bfa:	83 83       	std	Z+3, r24	; 0x03
  Config.RefFlag = 1;                   /* no ADC reference set yet */
    2bfc:	84 83       	std	Z+4, r24	; 0x04
  Config.Vcc = UREF_VCC;                /* voltage of Vcc */
    2bfe:	89 e8       	ldi	r24, 0x89	; 137
    2c00:	93 e1       	ldi	r25, 0x13	; 19
    2c02:	90 87       	std	Z+8, r25	; 0x08
    2c04:	87 83       	std	Z+7, r24	; 0x07
  LoadAdjust();                         /* load adjustment values */
    2c06:	0e 94 72 01 	call	0x2e4	; 0x2e4 <LoadAdjust>
				: "r0"
		);
	}
	else
	{
		__asm__ __volatile__ (
    2c0a:	9f e0       	ldi	r25, 0x0F	; 15
    2c0c:	88 e1       	ldi	r24, 0x18	; 24
    2c0e:	0f b6       	in	r0, 0x3f	; 63
    2c10:	f8 94       	cli
    2c12:	a8 95       	wdr
    2c14:	80 93 60 00 	sts	0x0060, r24
    2c18:	0f be       	out	0x3f, r0	; 63
    2c1a:	90 93 60 00 	sts	0x0060, r25
   */

start:

  /* reset variabels */
  Check.Found = COMP_NONE;
    2c1e:	c0 e0       	ldi	r28, 0x00	; 0
    2c20:	d1 e0       	ldi	r29, 0x01	; 1
  Check.Type = 0;
  Check.Done = 0;
  Check.Diodes = 0;
  Check.Resistors = 0;
  Semi.U_1 = 0;
    2c22:	0f 2e       	mov	r0, r31
    2c24:	ff e6       	ldi	r31, 0x6F	; 111
    2c26:	ef 2e       	mov	r14, r31
    2c28:	f1 e0       	ldi	r31, 0x01	; 1
    2c2a:	ff 2e       	mov	r15, r31
    2c2c:	f0 2d       	mov	r31, r0
    Config.Vcc = (uint16_t)Temp;
  }
  #endif

  /* internal bandgap reference */
  Config.Bandgap = ReadU(0x0e);         /* dummy read for bandgap stabilization */
    2c2e:	0e e8       	ldi	r16, 0x8E	; 142
    2c30:	11 e0       	ldi	r17, 0x01	; 1
  Config.Samples = 200;                 /* do a lot of samples for high accuracy */
    2c32:	0f 2e       	mov	r0, r31
    2c34:	f8 ec       	ldi	r31, 0xC8	; 200
    2c36:	af 2e       	mov	r10, r31
    2c38:	f0 2d       	mov	r31, r0
  Config.Bandgap = ReadU(0x0e);         /* get voltage of bandgap reference (mV) */
  Config.Samples = ADC_SAMPLES;         /* set samples back to default */
    2c3a:	0f 2e       	mov	r0, r31
    2c3c:	f9 e1       	ldi	r31, 0x19	; 25
    2c3e:	bf 2e       	mov	r11, r31
    2c40:	f0 2d       	mov	r31, r0
   */

start:

  /* reset variabels */
  Check.Found = COMP_NONE;
    2c42:	19 82       	std	Y+1, r1	; 0x01
  Check.Type = 0;
    2c44:	1a 82       	std	Y+2, r1	; 0x02
  Check.Done = 0;
    2c46:	18 82       	st	Y, r1
  Check.Diodes = 0;
    2c48:	1c 82       	std	Y+4, r1	; 0x04
  Check.Resistors = 0;
    2c4a:	1b 82       	std	Y+3, r1	; 0x03
  Semi.U_1 = 0;
    2c4c:	f7 01       	movw	r30, r14
    2c4e:	14 82       	std	Z+4, r1	; 0x04
    2c50:	13 82       	std	Z+3, r1	; 0x03
  Semi.I_1 = 0;
    2c52:	10 86       	std	Z+8, r1	; 0x08
    2c54:	17 82       	std	Z+7, r1	; 0x07
  Semi.F_1 = 0;
    2c56:	11 86       	std	Z+9, r1	; 0x09
    2c58:	12 86       	std	Z+10, r1	; 0x0a
    2c5a:	13 86       	std	Z+11, r1	; 0x0b
    2c5c:	14 86       	std	Z+12, r1	; 0x0c

  /* reset hardware */
  ADC_DDR = 0;                     /* set all pins of ADC port as input */
    2c5e:	17 b8       	out	0x07, r1	; 7
                                   /* also remove short circuit by relay */
  LCD_Clear();                     /* clear LCD */
    2c60:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>
    Config.Vcc = (uint16_t)Temp;
  }
  #endif

  /* internal bandgap reference */
  Config.Bandgap = ReadU(0x0e);         /* dummy read for bandgap stabilization */
    2c64:	8e e0       	ldi	r24, 0x0E	; 14
    2c66:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    2c6a:	f8 01       	movw	r30, r16
    2c6c:	96 83       	std	Z+6, r25	; 0x06
    2c6e:	85 83       	std	Z+5, r24	; 0x05
  Config.Samples = 200;                 /* do a lot of samples for high accuracy */
    2c70:	a2 82       	std	Z+2, r10	; 0x02
  Config.Bandgap = ReadU(0x0e);         /* get voltage of bandgap reference (mV) */
    2c72:	8e e0       	ldi	r24, 0x0E	; 14
    2c74:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
  Config.Samples = ADC_SAMPLES;         /* set samples back to default */
    2c78:	f8 01       	movw	r30, r16
    2c7a:	b2 82       	std	Z+2, r11	; 0x02
  Config.Bandgap += Config.RefOffset;   /* add voltage offset */ 
    2c7c:	20 89       	ldd	r18, Z+16	; 0x10
    2c7e:	82 0f       	add	r24, r18
    2c80:	91 1d       	adc	r25, r1
    2c82:	27 fd       	sbrc	r18, 7
    2c84:	9a 95       	dec	r25
    2c86:	96 83       	std	Z+6, r25	; 0x06
    2c88:	85 83       	std	Z+5, r24	; 0x05
   *  Ul = (Uin / (Rh + Rl)) * Rl  ->  Uin = (Ul * (Rh + Rl)) / Rl
   *  Uin = (Ul * (10k + 3k3)) / 3k3 = 4 * Ul  
   */

  /* get current voltage */
  U_Bat = ReadU(TP_BAT);                /* read voltage (mV) */
    2c8a:	85 e0       	ldi	r24, 0x05	; 5
    2c8c:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
  U_Bat *= 4;                           /* calculate U_bat (mV) */
    2c90:	88 0f       	add	r24, r24
    2c92:	99 1f       	adc	r25, r25
    2c94:	88 0f       	add	r24, r24
    2c96:	99 1f       	adc	r25, r25
  U_Bat += BAT_OFFSET;                  /* add offset for voltage drop */
    2c98:	6c 01       	movw	r12, r24
    2c9a:	fe ed       	ldi	r31, 0xDE	; 222
    2c9c:	cf 1a       	sub	r12, r31
    2c9e:	fe ef       	ldi	r31, 0xFE	; 254
    2ca0:	df 0a       	sbc	r13, r31

  /* display battery voltage */
  LCD_EEString2(Battery_str);           /* display: Bat. */
    2ca2:	88 eb       	ldi	r24, 0xB8	; 184
    2ca4:	91 e0       	ldi	r25, 0x01	; 1
    2ca6:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
  DisplayValue(U_Bat / 10, -2, 'V');    /* display battery voltage */
    2caa:	96 01       	movw	r18, r12
    2cac:	ad ec       	ldi	r26, 0xCD	; 205
    2cae:	bc ec       	ldi	r27, 0xCC	; 204
    2cb0:	0e 94 87 28 	call	0x510e	; 0x510e <__umulhisi3>
    2cb4:	96 95       	lsr	r25
    2cb6:	87 95       	ror	r24
    2cb8:	96 95       	lsr	r25
    2cba:	87 95       	ror	r24
    2cbc:	96 95       	lsr	r25
    2cbe:	87 95       	ror	r24
    2cc0:	bc 01       	movw	r22, r24
    2cc2:	80 e0       	ldi	r24, 0x00	; 0
    2cc4:	90 e0       	ldi	r25, 0x00	; 0
    2cc6:	26 e5       	ldi	r18, 0x56	; 86
    2cc8:	4e ef       	ldi	r20, 0xFE	; 254
    2cca:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
  LCD_Space();
    2cce:	0e 94 bb 0f 	call	0x1f76	; 0x1f76 <LCD_Space>

  /* check limits */
  if (U_Bat < BAT_POOR)                 /* low level reached */
    2cd2:	c1 14       	cp	r12, r1
    2cd4:	29 e1       	ldi	r18, 0x19	; 25
    2cd6:	d2 06       	cpc	r13, r18
    2cd8:	48 f4       	brcc	.+18     	; 0x2cec <main+0x1e4>
  {
    LCD_EEString(Low_str);              /* display: low */
    2cda:	84 e7       	ldi	r24, 0x74	; 116
    2cdc:	92 e0       	ldi	r25, 0x02	; 2
    2cde:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
    MilliSleep(2000);                   /* let user read info */
    2ce2:	80 ed       	ldi	r24, 0xD0	; 208
    2ce4:	97 e0       	ldi	r25, 0x07	; 7
    2ce6:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>
    goto power_off;                     /* power off */
    2cea:	b4 c0       	rjmp	.+360    	; 0x2e54 <main+0x34c>
  }
  else if (U_Bat < BAT_POOR + 1000)     /* warning level reached */
    2cec:	88 ee       	ldi	r24, 0xE8	; 232
    2cee:	c8 16       	cp	r12, r24
    2cf0:	8c e1       	ldi	r24, 0x1C	; 28
    2cf2:	d8 06       	cpc	r13, r24
    2cf4:	28 f4       	brcc	.+10     	; 0x2d00 <main+0x1f8>
  {
    LCD_EEString(Weak_str);             /* display: weak */
    2cf6:	88 e7       	ldi	r24, 0x78	; 120
    2cf8:	92 e0       	ldi	r25, 0x02	; 2
    2cfa:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
    2cfe:	04 c0       	rjmp	.+8      	; 0x2d08 <main+0x200>
  }
  else                                  /* ok */
  {
    LCD_EEString(OK_str);               /* display: ok */
    2d00:	85 eb       	ldi	r24, 0xB5	; 181
    2d02:	91 e0       	ldi	r25, 0x01	; 1
    2d04:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
  /*
   *  probing
   */

  /* display start of probing */
  LCD_Line2();                     /* move to line #2 */
    2d08:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>
  LCD_EEString(Running_str);       /* display: probing... */
    2d0c:	8d e7       	ldi	r24, 0x7D	; 125
    2d0e:	92 e0       	ldi	r25, 0x02	; 2
    2d10:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>

  /* try to discharge any connected component */
  DischargeProbes();
    2d14:	0e 94 64 18 	call	0x30c8	; 0x30c8 <DischargeProbes>
  if (Check.Found == COMP_ERROR)   /* discharge failed */
    2d18:	89 81       	ldd	r24, Y+1	; 0x01
    2d1a:	81 30       	cpi	r24, 0x01	; 1
    2d1c:	09 f4       	brne	.+2      	; 0x2d20 <main+0x218>
    2d1e:	42 c0       	rjmp	.+132    	; 0x2da4 <main+0x29c>
  {
    goto result;                   /* skip all other checks */
  }

  /* enter main menu if requested by short-circuiting all probes */
  if (AllProbesShorted() == 3)
    2d20:	0e 94 52 18 	call	0x30a4	; 0x30a4 <AllProbesShorted>
    2d24:	83 30       	cpi	r24, 0x03	; 3
    2d26:	19 f4       	brne	.+6      	; 0x2d2e <main+0x226>
  {
    MainMenu();                    /* enter mainmenu */;
    2d28:	0e 94 68 27 	call	0x4ed0	; 0x4ed0 <MainMenu>
    goto end;                      /* new cycle after job is is done */
    2d2c:	6e c0       	rjmp	.+220    	; 0x2e0a <main+0x302>
  }

  /* check all 6 combinations of the 3 probes */ 
  CheckProbes(TP1, TP2, TP3);
    2d2e:	42 e0       	ldi	r20, 0x02	; 2
    2d30:	61 e0       	ldi	r22, 0x01	; 1
    2d32:	80 e0       	ldi	r24, 0x00	; 0
    2d34:	0e 94 b9 19 	call	0x3372	; 0x3372 <CheckProbes>
  CheckProbes(TP2, TP1, TP3);
    2d38:	42 e0       	ldi	r20, 0x02	; 2
    2d3a:	60 e0       	ldi	r22, 0x00	; 0
    2d3c:	81 e0       	ldi	r24, 0x01	; 1
    2d3e:	0e 94 b9 19 	call	0x3372	; 0x3372 <CheckProbes>
  CheckProbes(TP1, TP3, TP2);
    2d42:	41 e0       	ldi	r20, 0x01	; 1
    2d44:	62 e0       	ldi	r22, 0x02	; 2
    2d46:	80 e0       	ldi	r24, 0x00	; 0
    2d48:	0e 94 b9 19 	call	0x3372	; 0x3372 <CheckProbes>
  CheckProbes(TP3, TP1, TP2);
    2d4c:	41 e0       	ldi	r20, 0x01	; 1
    2d4e:	60 e0       	ldi	r22, 0x00	; 0
    2d50:	82 e0       	ldi	r24, 0x02	; 2
    2d52:	0e 94 b9 19 	call	0x3372	; 0x3372 <CheckProbes>
  CheckProbes(TP2, TP3, TP1);
    2d56:	40 e0       	ldi	r20, 0x00	; 0
    2d58:	62 e0       	ldi	r22, 0x02	; 2
    2d5a:	81 e0       	ldi	r24, 0x01	; 1
    2d5c:	0e 94 b9 19 	call	0x3372	; 0x3372 <CheckProbes>
  CheckProbes(TP3, TP2, TP1);
    2d60:	40 e0       	ldi	r20, 0x00	; 0
    2d62:	61 e0       	ldi	r22, 0x01	; 1
    2d64:	82 e0       	ldi	r24, 0x02	; 2
    2d66:	0e 94 b9 19 	call	0x3372	; 0x3372 <CheckProbes>

  /* if component might be a capacitor */
  if ((Check.Found == COMP_NONE) ||
    2d6a:	89 81       	ldd	r24, Y+1	; 0x01
    2d6c:	88 23       	and	r24, r24
    2d6e:	11 f0       	breq	.+4      	; 0x2d74 <main+0x26c>
    2d70:	8a 30       	cpi	r24, 0x0A	; 10
    2d72:	c1 f4       	brne	.+48     	; 0x2da4 <main+0x29c>
      (Check.Found == COMP_RESISTOR))
  {
    /* tell user to be patient with large caps :-) */
    LCD_ClearLine2();
    2d74:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <LCD_ClearLine2>
    LCD_EEString2(Running_str);
    2d78:	8d e7       	ldi	r24, 0x7D	; 125
    2d7a:	92 e0       	ldi	r25, 0x02	; 2
    2d7c:	0e 94 cf 0f 	call	0x1f9e	; 0x1f9e <LCD_EEString2>
    LCD_Data('C');    
    2d80:	83 e4       	ldi	r24, 0x43	; 67
    2d82:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>

    /* check all possible combinations */
    MeasureCap(TP3, TP1, 0);
    2d86:	40 e0       	ldi	r20, 0x00	; 0
    2d88:	60 e0       	ldi	r22, 0x00	; 0
    2d8a:	82 e0       	ldi	r24, 0x02	; 2
    2d8c:	0e 94 be 09 	call	0x137c	; 0x137c <MeasureCap>
    MeasureCap(TP3, TP2, 1);
    2d90:	41 e0       	ldi	r20, 0x01	; 1
    2d92:	61 e0       	ldi	r22, 0x01	; 1
    2d94:	82 e0       	ldi	r24, 0x02	; 2
    2d96:	0e 94 be 09 	call	0x137c	; 0x137c <MeasureCap>
    MeasureCap(TP2, TP1, 2);
    2d9a:	42 e0       	ldi	r20, 0x02	; 2
    2d9c:	60 e0       	ldi	r22, 0x00	; 0
    2d9e:	81 e0       	ldi	r24, 0x01	; 1
    2da0:	0e 94 be 09 	call	0x137c	; 0x137c <MeasureCap>
   *  output test results
   */

result:

  LCD_Clear();                     /* clear LCD */
    2da4:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>

  /* call output function based on component type */
  switch (Check.Found)
    2da8:	e9 81       	ldd	r30, Y+1	; 0x01
    2daa:	8e 2f       	mov	r24, r30
    2dac:	90 e0       	ldi	r25, 0x00	; 0
    2dae:	fc 01       	movw	r30, r24
    2db0:	31 97       	sbiw	r30, 0x01	; 1
    2db2:	e9 31       	cpi	r30, 0x19	; 25
    2db4:	f1 05       	cpc	r31, r1
    2db6:	f8 f4       	brcc	.+62     	; 0x2df6 <main+0x2ee>
    2db8:	ec 5c       	subi	r30, 0xCC	; 204
    2dba:	ff 4f       	sbci	r31, 0xFF	; 255
    2dbc:	0c 94 81 28 	jmp	0x5102	; 0x5102 <__tablejump2__>
  {
    case COMP_ERROR:
      Show_Error();
    2dc0:	0e 94 54 10 	call	0x20a8	; 0x20a8 <Show_Error>
      goto end;
    2dc4:	22 c0       	rjmp	.+68     	; 0x2e0a <main+0x302>
      break;

    case COMP_DIODE:
      Show_Diode();
    2dc6:	0e 94 cb 11 	call	0x2396	; 0x2396 <Show_Diode>
      break;
    2dca:	18 c0       	rjmp	.+48     	; 0x2dfc <main+0x2f4>

    case COMP_BJT:
      Show_BJT();
    2dcc:	0e 94 e1 13 	call	0x27c2	; 0x27c2 <Show_BJT>
      break;
    2dd0:	15 c0       	rjmp	.+42     	; 0x2dfc <main+0x2f4>

    case COMP_FET:
      Show_FET();
    2dd2:	0e 94 12 15 	call	0x2a24	; 0x2a24 <Show_FET>
      break;
    2dd6:	12 c0       	rjmp	.+36     	; 0x2dfc <main+0x2f4>

    case COMP_IGBT:
      Show_IGBT();
    2dd8:	0e 94 40 15 	call	0x2a80	; 0x2a80 <Show_IGBT>
      break;
    2ddc:	0f c0       	rjmp	.+30     	; 0x2dfc <main+0x2f4>

    case COMP_THYRISTOR:
      Show_Special();
    2dde:	0e 94 52 15 	call	0x2aa4	; 0x2aa4 <Show_Special>
      break;
    2de2:	0c c0       	rjmp	.+24     	; 0x2dfc <main+0x2f4>

    case COMP_TRIAC:
      Show_Special();
    2de4:	0e 94 52 15 	call	0x2aa4	; 0x2aa4 <Show_Special>
      break;
    2de8:	09 c0       	rjmp	.+18     	; 0x2dfc <main+0x2f4>

    case COMP_RESISTOR:
      Show_Resistor();
    2dea:	0e 94 8e 10 	call	0x211c	; 0x211c <Show_Resistor>
      break;
    2dee:	06 c0       	rjmp	.+12     	; 0x2dfc <main+0x2f4>

    case COMP_CAPACITOR:
      Show_Capacitor();
    2df0:	0e 94 63 11 	call	0x22c6	; 0x22c6 <Show_Capacitor>
      break;
    2df4:	03 c0       	rjmp	.+6      	; 0x2dfc <main+0x2f4>

    default:                  /* no component found */
      Show_Fail();
    2df6:	0e 94 31 10 	call	0x2062	; 0x2062 <Show_Fail>
      goto end;
    2dfa:	07 c0       	rjmp	.+14     	; 0x2e0a <main+0x302>
  }

  /* component was found */
  RunsMissed = 0;             /* reset counter */
    2dfc:	10 92 7c 01 	sts	0x017C, r1
  RunsPassed++;               /* increase counter */
    2e00:	80 91 6e 01 	lds	r24, 0x016E
    2e04:	8f 5f       	subi	r24, 0xFF	; 255
    2e06:	80 93 6e 01 	sts	0x016E, r24
  #ifdef HW_RELAY
  ADC_DDR = (1<<TP_REF);              /* short circuit probes */
  #endif

  /* get key press or timeout */
  Test = TestKey((uint16_t)CYCLE_DELAY, 12);
    2e0a:	6c e0       	ldi	r22, 0x0C	; 12
    2e0c:	88 eb       	ldi	r24, 0xB8	; 184
    2e0e:	9b e0       	ldi	r25, 0x0B	; 11
    2e10:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <TestKey>

  if (Test == 0)              /* timeout (no key press) */
    2e14:	81 11       	cpse	r24, r1
    2e16:	0a c0       	rjmp	.+20     	; 0x2e2c <main+0x324>
  {
    /* check if we reached the maximum number of rounds (continious mode only) */
    if ((RunsMissed >= CYCLE_MAX) || (RunsPassed >= CYCLE_MAX * 2))
    2e18:	80 91 7c 01 	lds	r24, 0x017C
    2e1c:	85 30       	cpi	r24, 0x05	; 5
    2e1e:	d0 f4       	brcc	.+52     	; 0x2e54 <main+0x34c>
    2e20:	80 91 6e 01 	lds	r24, 0x016E
    2e24:	8a 30       	cpi	r24, 0x0A	; 10
    2e26:	08 f4       	brcc	.+2      	; 0x2e2a <main+0x322>
    2e28:	0c cf       	rjmp	.-488    	; 0x2c42 <main+0x13a>
    2e2a:	14 c0       	rjmp	.+40     	; 0x2e54 <main+0x34c>
    {
      goto power_off;              /* -> power off */
    }
  }
  else if (Test == 1)         /* short key press */
    2e2c:	81 30       	cpi	r24, 0x01	; 1
    2e2e:	79 f4       	brne	.+30     	; 0x2e4e <main+0x346>
  {
    /* a second key press triggers extra functions */
    MilliSleep(50);
    2e30:	82 e3       	ldi	r24, 0x32	; 50
    2e32:	90 e0       	ldi	r25, 0x00	; 0
    2e34:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>
    Test = TestKey(300, 0);
    2e38:	60 e0       	ldi	r22, 0x00	; 0
    2e3a:	8c e2       	ldi	r24, 0x2C	; 44
    2e3c:	91 e0       	ldi	r25, 0x01	; 1
    2e3e:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <TestKey>

    if (Test > 0)           /* short or long key press */
    2e42:	88 23       	and	r24, r24
    2e44:	09 f4       	brne	.+2      	; 0x2e48 <main+0x340>
    2e46:	fd ce       	rjmp	.-518    	; 0x2c42 <main+0x13a>
    {
      #ifdef HW_RELAY
      ADC_DDR = 0;               /* remove short circuit */
      #endif

      MainMenu();                /* enter main menu */
    2e48:	0e 94 68 27 	call	0x4ed0	; 0x4ed0 <MainMenu>
      goto end;                  /* re-run cycle control */
    2e4c:	de cf       	rjmp	.-68     	; 0x2e0a <main+0x302>
    }
  }
  else if (Test == 2)         /* long key press */
    2e4e:	82 30       	cpi	r24, 0x02	; 2
    2e50:	09 f0       	breq	.+2      	; 0x2e54 <main+0x34c>
    2e52:	f7 ce       	rjmp	.-530    	; 0x2c42 <main+0x13a>


power_off:

  /* display feedback (otherwise the user will wait :-) */
  LCD_Clear();
    2e54:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>
  LCD_EEString(Bye_str);
    2e58:	89 ee       	ldi	r24, 0xE9	; 233
    2e5a:	91 e0       	ldi	r25, 0x01	; 1
    2e5c:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    2e60:	0f b6       	in	r0, 0x3f	; 63
    2e62:	f8 94       	cli
    2e64:	a8 95       	wdr
    2e66:	80 91 60 00 	lds	r24, 0x0060
    2e6a:	88 61       	ori	r24, 0x18	; 24
    2e6c:	80 93 60 00 	sts	0x0060, r24
    2e70:	10 92 60 00 	sts	0x0060, r1
    2e74:	0f be       	out	0x3f, r0	; 63

  wdt_disable();                        /* disable watchdog */
  CONTROL_PORT &= ~(1 << POWER_CTRL);   /* power off myself */
    2e76:	5e 98       	cbi	0x0b, 6	; 11

  return 0;
}
    2e78:	80 e0       	ldi	r24, 0x00	; 0
    2e7a:	90 e0       	ldi	r25, 0x00	; 0
    2e7c:	df 91       	pop	r29
    2e7e:	cf 91       	pop	r28
    2e80:	1f 91       	pop	r17
    2e82:	0f 91       	pop	r16
    2e84:	ff 90       	pop	r15
    2e86:	ef 90       	pop	r14
    2e88:	df 90       	pop	r13
    2e8a:	cf 90       	pop	r12
    2e8c:	bf 90       	pop	r11
    2e8e:	af 90       	pop	r10
    2e90:	08 95       	ret

00002e92 <__vector_7>:
/*
 *  ISR for a match of TCNT2 (Timer2) and OCR2A (Output Compare Register A)
 */

ISR(TIMER2_COMPA_vect, ISR_BLOCK)
{
    2e92:	1f 92       	push	r1
    2e94:	0f 92       	push	r0
    2e96:	0f b6       	in	r0, 0x3f	; 63
    2e98:	0f 92       	push	r0
    2e9a:	11 24       	eor	r1, r1
  /* this automatically clears the OCF2A flag in the Interrupt Flag Register */

  sei();                      /* allow nested interrupts */
    2e9c:	78 94       	sei
  TCCR2B = 0;                 /* disable Timer2 */
    2e9e:	10 92 b1 00 	sts	0x00B1, r1
}
    2ea2:	0f 90       	pop	r0
    2ea4:	0f be       	out	0x3f, r0	; 63
    2ea6:	0f 90       	pop	r0
    2ea8:	1f 90       	pop	r1
    2eaa:	18 95       	reti

00002eac <MilliSleep>:
 *  - valid time 0 - 65535ms
 *  - don't use this function for time critical stuff!
 */

void MilliSleep(uint16_t Time)
{
    2eac:	0f 93       	push	r16
    2eae:	1f 93       	push	r17
    2eb0:	cf 93       	push	r28
    2eb2:	df 93       	push	r29
    2eb4:	ac 01       	movw	r20, r24
      We don't compensate the binary to decimal offset and also not the time
      required for the processing loop, because it would make things much more
      complicated and we don't need exact timing here.
  */

  Mode = Config.SleepMode;              /* get requested sleep mode */
    2eb6:	90 91 8f 01 	lds	r25, 0x018F

  /* calculate required timer cycles (prescaler 1024) */
  Cycles = Time;
    2eba:	60 e0       	ldi	r22, 0x00	; 0
    2ebc:	70 e0       	ldi	r23, 0x00	; 0
  Cycles *= (CPU_FREQ / 1000000);       /* timer cycles based on MCU frequency */

  if (Mode == SLEEP_MODE_PWR_SAVE)      /* power save mode */
    2ebe:	96 30       	cpi	r25, 0x06	; 6
    2ec0:	19 f5       	brne	.+70     	; 0x2f08 <MilliSleep+0x5c>
     *  - ceramic resonator:   1k or 256 cycles
     *  - internal RC osc.:    6 cycles
     */

    /* compensate oscillator start-up */
    Value = Cycles / 256;               /* calculate loop runs */
    2ec2:	05 2f       	mov	r16, r21
    2ec4:	16 2f       	mov	r17, r22
    2ec6:	27 2f       	mov	r18, r23
    2ec8:	33 27       	eor	r19, r19
    Value++;                            /* fix offset by division */
    2eca:	0f 5f       	subi	r16, 0xFF	; 255
    2ecc:	1f 4f       	sbci	r17, 0xFF	; 255
    2ece:	2f 4f       	sbci	r18, 0xFF	; 255
    2ed0:	3f 4f       	sbci	r19, 0xFF	; 255
    /* multiply with startup cycles equivalent to timer cycles */
    Value *= (OSC_STARTUP / 1024);      /* overhead cycles */
    2ed2:	00 0f       	add	r16, r16
    2ed4:	11 1f       	adc	r17, r17
    2ed6:	22 1f       	adc	r18, r18
    2ed8:	33 1f       	adc	r19, r19
    2eda:	00 0f       	add	r16, r16
    2edc:	11 1f       	adc	r17, r17
    2ede:	22 1f       	adc	r18, r18
    2ee0:	33 1f       	adc	r19, r19
    2ee2:	00 0f       	add	r16, r16
    2ee4:	11 1f       	adc	r17, r17
    2ee6:	22 1f       	adc	r18, r18
    2ee8:	33 1f       	adc	r19, r19
    2eea:	00 0f       	add	r16, r16
    2eec:	11 1f       	adc	r17, r17
    2eee:	22 1f       	adc	r18, r18
    2ef0:	33 1f       	adc	r19, r19

    if (Cycles > Value)            /* we are able to compensate */
    2ef2:	04 17       	cp	r16, r20
    2ef4:	15 07       	cpc	r17, r21
    2ef6:	26 07       	cpc	r18, r22
    2ef8:	37 07       	cpc	r19, r23
    2efa:	28 f4       	brcc	.+10     	; 0x2f06 <MilliSleep+0x5a>
    {
      Cycles -= Value;                  /* subtract overhead cycles */
    2efc:	40 1b       	sub	r20, r16
    2efe:	51 0b       	sbc	r21, r17
    2f00:	62 0b       	sbc	r22, r18
    2f02:	73 0b       	sbc	r23, r19
    2f04:	01 c0       	rjmp	.+2      	; 0x2f08 <MilliSleep+0x5c>
    }
    else                           /* no way to compensate */
    {
      /* idle mode doesn't require oscillator start-up after wake-up */ 
      Mode = SLEEP_MODE_IDLE;           /* change sleep mode to Idle */
    2f06:	90 e0       	ldi	r25, 0x00	; 0

  /*
   *  setup timer
   */

  TCCR2B = 0;                      /* disable timer */
    2f08:	10 92 b1 00 	sts	0x00B1, r1
  TCCR2A = (1 << WGM21);           /* set CTC mode */
    2f0c:	82 e0       	ldi	r24, 0x02	; 2
    2f0e:	80 93 b0 00 	sts	0x00B0, r24
  TIMSK2 = (1 << OCIE2A);          /* enable interrupt for OCR0A match */
    2f12:	80 93 70 00 	sts	0x0070, r24

  set_sleep_mode(Mode);            /* set sleep mode */
    2f16:	83 b7       	in	r24, 0x33	; 51
    2f18:	81 7f       	andi	r24, 0xF1	; 241
    2f1a:	89 2b       	or	r24, r25
    2f1c:	83 bf       	out	0x33, r24	; 51
  if (SREG & SREG_I) Flag = 1;     /* check if interrupts are enabled already */
    2f1e:	1f b7       	in	r17, 0x3f	; 63
    2f20:	17 70       	andi	r17, 0x07	; 7
  sei();                           /* enable interrupts */
    2f22:	78 94       	sei
  /*
   *  processing loop
   *  - sleep for several intervals until requested time is reached
   */

  while (Cycles > 0)
    2f24:	41 15       	cp	r20, r1
    2f26:	51 05       	cpc	r21, r1
    2f28:	61 05       	cpc	r22, r1
    2f2a:	71 05       	cpc	r23, r1
    2f2c:	31 f1       	breq	.+76     	; 0x2f7a <MilliSleep+0xce>
  {
    wdt_reset();              /* reset watchdog */

    /* get timeout */
    if (Cycles > 255) Timeout = 255;
    2f2e:	3f ef       	ldi	r19, 0xFF	; 255
    Cycles -= Timeout;
    Timeout--;                     /* interrupt is triggered by cycle after match */
    /* todo: what happens if Timeout is 0? */

    /* update timer */
    TCNT2 = 0;                     /* set counter to 0 */
    2f30:	c2 eb       	ldi	r28, 0xB2	; 178
    2f32:	d0 e0       	ldi	r29, 0x00	; 0
    OCR2A = Timeout;               /* set value to compare with (timeout) */
    2f34:	a3 eb       	ldi	r26, 0xB3	; 179
    2f36:	b0 e0       	ldi	r27, 0x00	; 0

    /* sleep */
    /* enable timer by setting clock prescaler to 1024 */
    TCCR2B = (1 << CS22) | (1 << CS21) | (1 << CS20);
    2f38:	e1 eb       	ldi	r30, 0xB1	; 177
    2f3a:	f0 e0       	ldi	r31, 0x00	; 0
    2f3c:	27 e0       	ldi	r18, 0x07	; 7
   *  - sleep for several intervals until requested time is reached
   */

  while (Cycles > 0)
  {
    wdt_reset();              /* reset watchdog */
    2f3e:	a8 95       	wdr

    /* get timeout */
    if (Cycles > 255) Timeout = 255;
    2f40:	4f 3f       	cpi	r20, 0xFF	; 255
    2f42:	51 05       	cpc	r21, r1
    2f44:	61 05       	cpc	r22, r1
    2f46:	71 05       	cpc	r23, r1
    2f48:	09 f0       	breq	.+2      	; 0x2f4c <MilliSleep+0xa0>
    2f4a:	10 f4       	brcc	.+4      	; 0x2f50 <MilliSleep+0xa4>
    else Timeout = Cycles;
    2f4c:	94 2f       	mov	r25, r20
    2f4e:	01 c0       	rjmp	.+2      	; 0x2f52 <MilliSleep+0xa6>
  while (Cycles > 0)
  {
    wdt_reset();              /* reset watchdog */

    /* get timeout */
    if (Cycles > 255) Timeout = 255;
    2f50:	93 2f       	mov	r25, r19
    else Timeout = Cycles;
    Cycles -= Timeout;
    2f52:	49 1b       	sub	r20, r25
    2f54:	51 09       	sbc	r21, r1
    2f56:	61 09       	sbc	r22, r1
    2f58:	71 09       	sbc	r23, r1
    Timeout--;                     /* interrupt is triggered by cycle after match */
    2f5a:	91 50       	subi	r25, 0x01	; 1
    /* todo: what happens if Timeout is 0? */

    /* update timer */
    TCNT2 = 0;                     /* set counter to 0 */
    2f5c:	18 82       	st	Y, r1
    OCR2A = Timeout;               /* set value to compare with (timeout) */
    2f5e:	9c 93       	st	X, r25

    /* sleep */
    /* enable timer by setting clock prescaler to 1024 */
    TCCR2B = (1 << CS22) | (1 << CS21) | (1 << CS20);
    2f60:	20 83       	st	Z, r18

    sleep_mode();                            /* and sleep */    
    2f62:	83 b7       	in	r24, 0x33	; 51
    2f64:	81 60       	ori	r24, 0x01	; 1
    2f66:	83 bf       	out	0x33, r24	; 51
    2f68:	88 95       	sleep
    2f6a:	83 b7       	in	r24, 0x33	; 51
    2f6c:	8e 7f       	andi	r24, 0xFE	; 254
    2f6e:	83 bf       	out	0x33, r24	; 51
  /*
   *  processing loop
   *  - sleep for several intervals until requested time is reached
   */

  while (Cycles > 0)
    2f70:	41 15       	cp	r20, r1
    2f72:	51 05       	cpc	r21, r1
    2f74:	61 05       	cpc	r22, r1
    2f76:	71 05       	cpc	r23, r1
    2f78:	11 f7       	brne	.-60     	; 0x2f3e <MilliSleep+0x92>
    sleep_mode();                            /* and sleep */    

    /* after wakeup */
  }

  if (Flag == 0) cli();            /* disable interrupts */
    2f7a:	11 11       	cpse	r17, r1
    2f7c:	01 c0       	rjmp	.+2      	; 0x2f80 <MilliSleep+0xd4>
    2f7e:	f8 94       	cli
}
    2f80:	df 91       	pop	r29
    2f82:	cf 91       	pop	r28
    2f84:	1f 91       	pop	r17
    2f86:	0f 91       	pop	r16
    2f88:	08 95       	ret

00002f8a <UpdateProbes>:
 *  - Probe2: pin ID [0-2], mostly low level pin
 *  - Probe3: pin ID [0-2], mostly switch/gate pin
 */

void UpdateProbes(uint8_t Probe1, uint8_t Probe2, uint8_t Probe3)
{
    2f8a:	cf 92       	push	r12
    2f8c:	df 92       	push	r13
    2f8e:	ef 92       	push	r14
    2f90:	ff 92       	push	r15
    2f92:	0f 93       	push	r16
    2f94:	1f 93       	push	r17
    2f96:	cf 93       	push	r28
    2f98:	df 93       	push	r29
    2f9a:	e6 2e       	mov	r14, r22
    2f9c:	04 2f       	mov	r16, r20
  /* set probe IDs */
  Probes.Pin_1 = Probe1;
    2f9e:	cd e7       	ldi	r28, 0x7D	; 125
    2fa0:	d1 e0       	ldi	r29, 0x01	; 1
    2fa2:	88 83       	st	Y, r24
  Probes.Pin_2 = Probe2;
    2fa4:	69 83       	std	Y+1, r22	; 0x01
  Probes.Pin_3 = Probe3;
    2fa6:	4a 83       	std	Y+2, r20	; 0x02

  /* setup masks using bitmask tables */
  Probes.Rl_1 = eeprom_read_byte(&Rl_table[Probe1]);
    2fa8:	c8 2e       	mov	r12, r24
    2faa:	d1 2c       	mov	r13, r1
    2fac:	c6 01       	movw	r24, r12
    2fae:	8a 5f       	subi	r24, 0xFA	; 250
    2fb0:	9f 4f       	sbci	r25, 0xFF	; 255
    2fb2:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <eeprom_read_byte>
    2fb6:	8b 83       	std	Y+3, r24	; 0x03
  Probes.Rh_1 = Probes.Rl_1 + Probes.Rl_1;
    2fb8:	88 0f       	add	r24, r24
    2fba:	8c 83       	std	Y+4, r24	; 0x04
  Probes.ADC_1 = eeprom_read_byte(&ADC_table[Probe1]);
    2fbc:	c6 01       	movw	r24, r12
    2fbe:	80 50       	subi	r24, 0x00	; 0
    2fc0:	90 40       	sbci	r25, 0x00	; 0
    2fc2:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <eeprom_read_byte>
    2fc6:	89 87       	std	Y+9, r24	; 0x09
  Probes.Rl_2 = eeprom_read_byte(&Rl_table[Probe2]);
    2fc8:	f1 2c       	mov	r15, r1
    2fca:	c7 01       	movw	r24, r14
    2fcc:	8a 5f       	subi	r24, 0xFA	; 250
    2fce:	9f 4f       	sbci	r25, 0xFF	; 255
    2fd0:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <eeprom_read_byte>
    2fd4:	8d 83       	std	Y+5, r24	; 0x05
  Probes.Rh_2 = Probes.Rl_2 + Probes.Rl_2;
    2fd6:	88 0f       	add	r24, r24
    2fd8:	8e 83       	std	Y+6, r24	; 0x06
  Probes.ADC_2 = eeprom_read_byte(&ADC_table[Probe2]);
    2fda:	c7 01       	movw	r24, r14
    2fdc:	80 50       	subi	r24, 0x00	; 0
    2fde:	90 40       	sbci	r25, 0x00	; 0
    2fe0:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <eeprom_read_byte>
    2fe4:	8a 87       	std	Y+10, r24	; 0x0a
  Probes.Rl_3 = eeprom_read_byte(&Rl_table[Probe3]);
    2fe6:	10 e0       	ldi	r17, 0x00	; 0
    2fe8:	c8 01       	movw	r24, r16
    2fea:	8a 5f       	subi	r24, 0xFA	; 250
    2fec:	9f 4f       	sbci	r25, 0xFF	; 255
    2fee:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <eeprom_read_byte>
    2ff2:	8f 83       	std	Y+7, r24	; 0x07
  Probes.Rh_3 = Probes.Rl_3 + Probes.Rl_3;
    2ff4:	88 0f       	add	r24, r24
    2ff6:	88 87       	std	Y+8, r24	; 0x08
  Probes.ADC_3 = eeprom_read_byte(&ADC_table[Probe3]);
    2ff8:	c8 01       	movw	r24, r16
    2ffa:	80 50       	subi	r24, 0x00	; 0
    2ffc:	90 40       	sbci	r25, 0x00	; 0
    2ffe:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <eeprom_read_byte>
    3002:	8b 87       	std	Y+11, r24	; 0x0b
}
    3004:	df 91       	pop	r29
    3006:	cf 91       	pop	r28
    3008:	1f 91       	pop	r17
    300a:	0f 91       	pop	r16
    300c:	ff 90       	pop	r15
    300e:	ef 90       	pop	r14
    3010:	df 90       	pop	r13
    3012:	cf 90       	pop	r12
    3014:	08 95       	ret

00003016 <ShortedProbes>:
 *  - 0 if not shorted
 *  - 1 if shorted
 */

uint8_t ShortedProbes(uint8_t Probe1, uint8_t Probe2)
{
    3016:	0f 93       	push	r16
    3018:	1f 93       	push	r17
    301a:	cf 93       	push	r28
    301c:	df 93       	push	r29
    301e:	08 2f       	mov	r16, r24
    3020:	16 2f       	mov	r17, r22
   *  - Probe1: Rl pull-up
   *  - Probe2: Rl pull-down
   *  - third probe: HiZ
   */

  R_PORT = eeprom_read_byte(&Rl_table[Probe1]);
    3022:	c8 2f       	mov	r28, r24
    3024:	d0 e0       	ldi	r29, 0x00	; 0
    3026:	ca 5f       	subi	r28, 0xFA	; 250
    3028:	df 4f       	sbci	r29, 0xFF	; 255
    302a:	ce 01       	movw	r24, r28
    302c:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <eeprom_read_byte>
    3030:	85 b9       	out	0x05, r24	; 5
  R_DDR = eeprom_read_byte(&Rl_table[Probe1]) | eeprom_read_byte(&Rl_table[Probe2]);
    3032:	ce 01       	movw	r24, r28
    3034:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <eeprom_read_byte>
    3038:	c8 2f       	mov	r28, r24
    303a:	81 2f       	mov	r24, r17
    303c:	90 e0       	ldi	r25, 0x00	; 0
    303e:	8a 5f       	subi	r24, 0xFA	; 250
    3040:	9f 4f       	sbci	r25, 0xFF	; 255
    3042:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <eeprom_read_byte>
    3046:	8c 2b       	or	r24, r28
    3048:	84 b9       	out	0x04, r24	; 4

  /* read voltages */
  U1 = ReadU(Probe1);
    304a:	80 2f       	mov	r24, r16
    304c:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    3050:	ec 01       	movw	r28, r24
  U2 = ReadU(Probe2);
    3052:	81 2f       	mov	r24, r17
    3054:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    3058:	bc 01       	movw	r22, r24
  /*
   *  We expect both probe voltages to be about the same and
   *  to be half of Vcc (allowed difference +/- 30mV).
   */

  Min = (Config.Vcc / 2) - 30;     /* lower voltage */
    305a:	20 91 95 01 	lds	r18, 0x0195
    305e:	30 91 96 01 	lds	r19, 0x0196
    3062:	36 95       	lsr	r19
    3064:	27 95       	ror	r18
    3066:	a9 01       	movw	r20, r18
    3068:	4e 51       	subi	r20, 0x1E	; 30
    306a:	51 09       	sbc	r21, r1
  Max = (Config.Vcc / 2) + 30;     /* upper voltage */

  if ((U1 > Min) && (U1 < Max))
    306c:	4c 17       	cp	r20, r28
    306e:	5d 07       	cpc	r21, r29
    3070:	70 f4       	brcc	.+28     	; 0x308e <ShortedProbes+0x78>
   *  We expect both probe voltages to be about the same and
   *  to be half of Vcc (allowed difference +/- 30mV).
   */

  Min = (Config.Vcc / 2) - 30;     /* lower voltage */
  Max = (Config.Vcc / 2) + 30;     /* upper voltage */
    3072:	22 5e       	subi	r18, 0xE2	; 226
    3074:	3f 4f       	sbci	r19, 0xFF	; 255

  if ((U1 > Min) && (U1 < Max))
    3076:	c2 17       	cp	r28, r18
    3078:	d3 07       	cpc	r29, r19
    307a:	58 f4       	brcc	.+22     	; 0x3092 <ShortedProbes+0x7c>
  { 
    if ((U2 > Min) && (U2 < Max))
    307c:	48 17       	cp	r20, r24
    307e:	59 07       	cpc	r21, r25
    3080:	50 f4       	brcc	.+20     	; 0x3096 <ShortedProbes+0x80>
    3082:	81 e0       	ldi	r24, 0x01	; 1
    3084:	62 17       	cp	r22, r18
    3086:	73 07       	cpc	r23, r19
    3088:	38 f0       	brcs	.+14     	; 0x3098 <ShortedProbes+0x82>
    308a:	80 e0       	ldi	r24, 0x00	; 0
    308c:	05 c0       	rjmp	.+10     	; 0x3098 <ShortedProbes+0x82>
 *  - 1 if shorted
 */

uint8_t ShortedProbes(uint8_t Probe1, uint8_t Probe2)
{
  uint8_t           Flag = 0;      /* return value */
    308e:	80 e0       	ldi	r24, 0x00	; 0
    3090:	03 c0       	rjmp	.+6      	; 0x3098 <ShortedProbes+0x82>
    3092:	80 e0       	ldi	r24, 0x00	; 0
    3094:	01 c0       	rjmp	.+2      	; 0x3098 <ShortedProbes+0x82>
    3096:	80 e0       	ldi	r24, 0x00	; 0
      Flag = 1;
    }    
  }

  /* reset port */
  R_DDR = 0;
    3098:	14 b8       	out	0x04, r1	; 4

  return Flag;
}
    309a:	df 91       	pop	r29
    309c:	cf 91       	pop	r28
    309e:	1f 91       	pop	r17
    30a0:	0f 91       	pop	r16
    30a2:	08 95       	ret

000030a4 <AllProbesShorted>:
 *  - 0 if no probes are short-circuited
 *  - number of probe pairs short-circuited (3 = all)
 */

uint8_t AllProbesShorted(void)
{
    30a4:	cf 93       	push	r28
  uint8_t           Flag = 0;      /* return value */

  /* check all possible combinations */
  Flag = ShortedProbes(TP1, TP2);
    30a6:	61 e0       	ldi	r22, 0x01	; 1
    30a8:	80 e0       	ldi	r24, 0x00	; 0
    30aa:	0e 94 0b 18 	call	0x3016	; 0x3016 <ShortedProbes>
    30ae:	c8 2f       	mov	r28, r24
  Flag += ShortedProbes(TP1, TP3);
    30b0:	62 e0       	ldi	r22, 0x02	; 2
    30b2:	80 e0       	ldi	r24, 0x00	; 0
    30b4:	0e 94 0b 18 	call	0x3016	; 0x3016 <ShortedProbes>
    30b8:	c8 0f       	add	r28, r24
  Flag += ShortedProbes(TP2, TP3);
    30ba:	62 e0       	ldi	r22, 0x02	; 2
    30bc:	81 e0       	ldi	r24, 0x01	; 1
    30be:	0e 94 0b 18 	call	0x3016	; 0x3016 <ShortedProbes>

  return Flag;  
}
    30c2:	8c 0f       	add	r24, r28
    30c4:	cf 91       	pop	r28
    30c6:	08 95       	ret

000030c8 <DischargeProbes>:
 *  - detect batteries
 *  - sometimes large caps are detected as a battery
 */

void DischargeProbes(void)
{
    30c8:	5f 92       	push	r5
    30ca:	6f 92       	push	r6
    30cc:	7f 92       	push	r7
    30ce:	8f 92       	push	r8
    30d0:	9f 92       	push	r9
    30d2:	af 92       	push	r10
    30d4:	bf 92       	push	r11
    30d6:	cf 92       	push	r12
    30d8:	df 92       	push	r13
    30da:	ef 92       	push	r14
    30dc:	ff 92       	push	r15
    30de:	0f 93       	push	r16
    30e0:	1f 93       	push	r17
    30e2:	cf 93       	push	r28
    30e4:	df 93       	push	r29
    30e6:	00 d0       	rcall	.+0      	; 0x30e8 <DischargeProbes+0x20>
    30e8:	00 d0       	rcall	.+0      	; 0x30ea <DischargeProbes+0x22>
    30ea:	00 d0       	rcall	.+0      	; 0x30ec <DischargeProbes+0x24>
    30ec:	cd b7       	in	r28, 0x3d	; 61
    30ee:	de b7       	in	r29, 0x3e	; 62
  /*
   *  set probes to a save discharge mode (pull-down via Rh) 
   */

  /* set ADC port to HiZ input */
  ADC_DDR = 0;
    30f0:	17 b8       	out	0x07, r1	; 7
  ADC_PORT = 0;
    30f2:	18 b8       	out	0x08, r1	; 8

  /* all probe pins: Rh and Rl pull-down */
  R_PORT = 0;
    30f4:	15 b8       	out	0x05, r1	; 5
  R_DDR = (2 << (TP1 * 2)) | (2 << (TP2 * 2)) | (2 << (TP3 * 2));
    30f6:	8a e2       	ldi	r24, 0x2A	; 42
    30f8:	84 b9       	out	0x04, r24	; 4
  R_DDR |= (1 << (TP1 * 2)) | (1 << (TP2 * 2)) | (1 << (TP3 * 2));
    30fa:	84 b1       	in	r24, 0x04	; 4
    30fc:	85 61       	ori	r24, 0x15	; 21
    30fe:	84 b9       	out	0x04, r24	; 4

  /* get current voltages */
  U_old[0] = ReadU(TP1);
    3100:	80 e0       	ldi	r24, 0x00	; 0
    3102:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    3106:	9a 83       	std	Y+2, r25	; 0x02
    3108:	89 83       	std	Y+1, r24	; 0x01
  U_old[1] = ReadU(TP2);
    310a:	81 e0       	ldi	r24, 0x01	; 1
    310c:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    3110:	9c 83       	std	Y+4, r25	; 0x04
    3112:	8b 83       	std	Y+3, r24	; 0x03
  U_old[2] = ReadU(TP3);
    3114:	82 e0       	ldi	r24, 0x02	; 2
    3116:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    311a:	9e 83       	std	Y+6, r25	; 0x06
    311c:	8d 83       	std	Y+5, r24	; 0x05
   *    maybe never :-)
   */

  Counter = 1;
  ID = 2;
  DischargeMask = 0;
    311e:	00 e0       	ldi	r16, 0x00	; 0
   *  - A very large cap will discharge too slowly and an external voltage
   *    maybe never :-)
   */

  Counter = 1;
  ID = 2;
    3120:	12 e0       	ldi	r17, 0x02	; 2
 */

void DischargeProbes(void)
{
  uint8_t           Counter;            /* loop control */
  uint8_t           Limit = 40;         /* sliding timeout (2s) */
    3122:	0f 2e       	mov	r0, r31
    3124:	f8 e2       	ldi	r31, 0x28	; 40
    3126:	af 2e       	mov	r10, r31
    3128:	f0 2d       	mov	r31, r0
   *    large caps.
   *  - A very large cap will discharge too slowly and an external voltage
   *    maybe never :-)
   */

  Counter = 1;
    312a:	bb 24       	eor	r11, r11
    312c:	b3 94       	inc	r11
  DischargeMask = 0;

  while (Counter > 0)
  {
    ID++;                               /* next probe */
    if (ID > 2) ID = 0;                 /* start with probe #1 again */
    312e:	71 2c       	mov	r7, r1
      Counter++;              /* increase no-changes counter */
    }

    if (U_c <= CAP_DISCHARGED)          /* seems to be discharged */
    {
      DischargeMask |= (1 << ID);       /* set flag */
    3130:	cc 24       	eor	r12, r12
    3132:	c3 94       	inc	r12
    3134:	d1 2c       	mov	r13, r1
      {
        /* increase timeout while preventing overflow */
        if (Limit < (255 - 20)) Limit += 20;
      }

      Counter = 1;                      /* reset no-changes counter */
    3136:	66 24       	eor	r6, r6
    3138:	63 94       	inc	r6
  ID = 2;
  DischargeMask = 0;

  while (Counter > 0)
  {
    ID++;                               /* next probe */
    313a:	1f 5f       	subi	r17, 0xFF	; 255
    if (ID > 2) ID = 0;                 /* start with probe #1 again */
    313c:	13 30       	cpi	r17, 0x03	; 3
    313e:	08 f0       	brcs	.+2      	; 0x3142 <DischargeProbes+0x7a>
    3140:	17 2d       	mov	r17, r7

    if (DischargeMask & (1 << ID))      /* skip discharged probe */
    3142:	e1 2e       	mov	r14, r17
    3144:	f1 2c       	mov	r15, r1
    3146:	20 2f       	mov	r18, r16
    3148:	30 e0       	ldi	r19, 0x00	; 0
    314a:	01 2e       	mov	r0, r17
    314c:	02 c0       	rjmp	.+4      	; 0x3152 <DischargeProbes+0x8a>
    314e:	35 95       	asr	r19
    3150:	27 95       	ror	r18
    3152:	0a 94       	dec	r0
    3154:	e2 f7       	brpl	.-8      	; 0x314e <DischargeProbes+0x86>
    3156:	20 fd       	sbrc	r18, 0
    3158:	65 c0       	rjmp	.+202    	; 0x3224 <DischargeProbes+0x15c>
      continue;

    U_c = ReadU(ID);                    /* get voltage of probe */
    315a:	81 2f       	mov	r24, r17
    315c:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    3160:	4c 01       	movw	r8, r24

    if (U_c < U_old[ID])                /* voltage decreased */
    3162:	f7 01       	movw	r30, r14
    3164:	ee 0f       	add	r30, r30
    3166:	ff 1f       	adc	r31, r31
    3168:	81 e0       	ldi	r24, 0x01	; 1
    316a:	90 e0       	ldi	r25, 0x00	; 0
    316c:	8c 0f       	add	r24, r28
    316e:	9d 1f       	adc	r25, r29
    3170:	e8 0f       	add	r30, r24
    3172:	f9 1f       	adc	r31, r25
    3174:	80 81       	ld	r24, Z
    3176:	91 81       	ldd	r25, Z+1	; 0x01
    3178:	88 16       	cp	r8, r24
    317a:	99 06       	cpc	r9, r25
    317c:	c0 f4       	brcc	.+48     	; 0x31ae <DischargeProbes+0xe6>
    {
      U_old[ID] = U_c;                  /* update old value */
    317e:	f7 01       	movw	r30, r14
    3180:	ee 0f       	add	r30, r30
    3182:	ff 1f       	adc	r31, r31
    3184:	81 e0       	ldi	r24, 0x01	; 1
    3186:	90 e0       	ldi	r25, 0x00	; 0
    3188:	8c 0f       	add	r24, r28
    318a:	9d 1f       	adc	r25, r29
    318c:	e8 0f       	add	r30, r24
    318e:	f9 1f       	adc	r31, r25
    3190:	91 82       	std	Z+1, r9	; 0x01
    3192:	80 82       	st	Z, r8

      /* adapt timeout based on discharge rate */
      if ((Limit - Counter) < 20)
    3194:	8a 2d       	mov	r24, r10
    3196:	90 e0       	ldi	r25, 0x00	; 0
    3198:	8b 19       	sub	r24, r11
    319a:	91 09       	sbc	r25, r1
    319c:	44 97       	sbiw	r24, 0x14	; 20
    319e:	a4 f4       	brge	.+40     	; 0x31c8 <DischargeProbes+0x100>
      {
        /* increase timeout while preventing overflow */
        if (Limit < (255 - 20)) Limit += 20;
    31a0:	9a ee       	ldi	r25, 0xEA	; 234
    31a2:	9a 15       	cp	r25, r10
    31a4:	98 f0       	brcs	.+38     	; 0x31cc <DischargeProbes+0x104>
    31a6:	84 e1       	ldi	r24, 0x14	; 20
    31a8:	a8 0e       	add	r10, r24
      }

      Counter = 1;                      /* reset no-changes counter */
    31aa:	b6 2c       	mov	r11, r6
    31ac:	10 c0       	rjmp	.+32     	; 0x31ce <DischargeProbes+0x106>
    }
    else                                /* voltage not decreased */
    {
      /* increase limit if we start at a low voltage */
      if ((U_c < 10) && (Limit <= 40)) Limit = 80;
    31ae:	9a e0       	ldi	r25, 0x0A	; 10
    31b0:	89 16       	cp	r8, r25
    31b2:	91 04       	cpc	r9, r1
    31b4:	38 f4       	brcc	.+14     	; 0x31c4 <DischargeProbes+0xfc>
    31b6:	88 e2       	ldi	r24, 0x28	; 40
    31b8:	8a 15       	cp	r24, r10
    31ba:	20 f0       	brcs	.+8      	; 0x31c4 <DischargeProbes+0xfc>
    31bc:	0f 2e       	mov	r0, r31
    31be:	f0 e5       	ldi	r31, 0x50	; 80
    31c0:	af 2e       	mov	r10, r31
    31c2:	f0 2d       	mov	r31, r0

      Counter++;              /* increase no-changes counter */
    31c4:	b3 94       	inc	r11
    31c6:	03 c0       	rjmp	.+6      	; 0x31ce <DischargeProbes+0x106>
      {
        /* increase timeout while preventing overflow */
        if (Limit < (255 - 20)) Limit += 20;
      }

      Counter = 1;                      /* reset no-changes counter */
    31c8:	b6 2c       	mov	r11, r6
    31ca:	01 c0       	rjmp	.+2      	; 0x31ce <DischargeProbes+0x106>
    31cc:	b6 2c       	mov	r11, r6
      if ((U_c < 10) && (Limit <= 40)) Limit = 80;

      Counter++;              /* increase no-changes counter */
    }

    if (U_c <= CAP_DISCHARGED)          /* seems to be discharged */
    31ce:	93 e0       	ldi	r25, 0x03	; 3
    31d0:	89 16       	cp	r8, r25
    31d2:	91 04       	cpc	r9, r1
    31d4:	40 f4       	brcc	.+16     	; 0x31e6 <DischargeProbes+0x11e>
    {
      DischargeMask |= (1 << ID);       /* set flag */
    31d6:	c6 01       	movw	r24, r12
    31d8:	02 c0       	rjmp	.+4      	; 0x31de <DischargeProbes+0x116>
    31da:	88 0f       	add	r24, r24
    31dc:	99 1f       	adc	r25, r25
    31de:	ea 94       	dec	r14
    31e0:	e2 f7       	brpl	.-8      	; 0x31da <DischargeProbes+0x112>
    31e2:	08 2b       	or	r16, r24
    31e4:	0d c0       	rjmp	.+26     	; 0x3200 <DischargeProbes+0x138>
    }
    else if (U_c < 800)                 /* extra pull-down */
    31e6:	80 e2       	ldi	r24, 0x20	; 32
    31e8:	88 16       	cp	r8, r24
    31ea:	83 e0       	ldi	r24, 0x03	; 3
    31ec:	98 06       	cpc	r9, r24
    31ee:	40 f4       	brcc	.+16     	; 0x3200 <DischargeProbes+0x138>
    {
      /* it's save now to pull-down probe pin directly */
      ADC_DDR |= eeprom_read_byte(&ADC_table[ID]);
    31f0:	57 b0       	in	r5, 0x07	; 7
    31f2:	c7 01       	movw	r24, r14
    31f4:	80 50       	subi	r24, 0x00	; 0
    31f6:	90 40       	sbci	r25, 0x00	; 0
    31f8:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <eeprom_read_byte>
    31fc:	85 29       	or	r24, r5
    31fe:	87 b9       	out	0x07, r24	; 7
    }

    if (DischargeMask == 0b00000111)    /* all probes discharged */
    3200:	07 30       	cpi	r16, 0x07	; 7
    3202:	91 f0       	breq	.+36     	; 0x3228 <DischargeProbes+0x160>
    {
      Counter = 0;                        /* end loop */
    }
    else if (Counter > Limit)             /* no decrease for some time */
    3204:	ab 14       	cp	r10, r11
    3206:	48 f4       	brcc	.+18     	; 0x321a <DischargeProbes+0x152>
    {
      /* might be a battery or a super cap */
      Check.Found = COMP_ERROR;           /* report error */
    3208:	e0 e0       	ldi	r30, 0x00	; 0
    320a:	f1 e0       	ldi	r31, 0x01	; 1
    320c:	81 e0       	ldi	r24, 0x01	; 1
    320e:	81 83       	std	Z+1, r24	; 0x01
      Check.Type = TYPE_DISCHARGE;        /* discharge problem */
    3210:	82 83       	std	Z+2, r24	; 0x02
      Check.Probe = ID;                   /* save probe */
    3212:	15 83       	std	Z+5, r17	; 0x05
      Check.U = U_c;                      /* save voltage */
    3214:	97 82       	std	Z+7, r9	; 0x07
    3216:	86 82       	std	Z+6, r8	; 0x06
    3218:	07 c0       	rjmp	.+14     	; 0x3228 <DischargeProbes+0x160>
      Counter = 0;                        /* end loop */
    }
    else                                /* go for another round */
    {
      wdt_reset();                        /* reset watchdog */
    321a:	a8 95       	wdr
      MilliSleep(50);                     /* wait for 50ms */
    321c:	82 e3       	ldi	r24, 0x32	; 50
    321e:	90 e0       	ldi	r25, 0x00	; 0
    3220:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>

  Counter = 1;
  ID = 2;
  DischargeMask = 0;

  while (Counter > 0)
    3224:	b1 10       	cpse	r11, r1
    3226:	89 cf       	rjmp	.-238    	; 0x313a <DischargeProbes+0x72>
      MilliSleep(50);                     /* wait for 50ms */
    }
  }

  /* reset probes */
  R_DDR = 0;                       /* set resistor port to input mode */
    3228:	14 b8       	out	0x04, r1	; 4
  ADC_DDR = 0;                     /* set ADC port to input mode */
    322a:	17 b8       	out	0x07, r1	; 7
}
    322c:	26 96       	adiw	r28, 0x06	; 6
    322e:	0f b6       	in	r0, 0x3f	; 63
    3230:	f8 94       	cli
    3232:	de bf       	out	0x3e, r29	; 62
    3234:	0f be       	out	0x3f, r0	; 63
    3236:	cd bf       	out	0x3d, r28	; 61
    3238:	df 91       	pop	r29
    323a:	cf 91       	pop	r28
    323c:	1f 91       	pop	r17
    323e:	0f 91       	pop	r16
    3240:	ff 90       	pop	r15
    3242:	ef 90       	pop	r14
    3244:	df 90       	pop	r13
    3246:	cf 90       	pop	r12
    3248:	bf 90       	pop	r11
    324a:	af 90       	pop	r10
    324c:	9f 90       	pop	r9
    324e:	8f 90       	pop	r8
    3250:	7f 90       	pop	r7
    3252:	6f 90       	pop	r6
    3254:	5f 90       	pop	r5
    3256:	08 95       	ret

00003258 <PullProbe>:
 *    0b00000100 = 1ms
 *    0b00001000 = 10ms
 */

void PullProbe(uint8_t Mask, uint8_t Mode)
{
    3258:	cf 93       	push	r28
    325a:	c8 2f       	mov	r28, r24
  /* set pull mode */
  if (Mode & FLAG_PULLUP) R_PORT |= Mask;    /* pull-up */
    325c:	60 ff       	sbrs	r22, 0
    325e:	04 c0       	rjmp	.+8      	; 0x3268 <PullProbe+0x10>
    3260:	85 b1       	in	r24, 0x05	; 5
    3262:	8c 2b       	or	r24, r28
    3264:	85 b9       	out	0x05, r24	; 5
    3266:	05 c0       	rjmp	.+10     	; 0x3272 <PullProbe+0x1a>
  else R_PORT &= ~Mask;                      /* pull-down */
    3268:	85 b1       	in	r24, 0x05	; 5
    326a:	9c 2f       	mov	r25, r28
    326c:	90 95       	com	r25
    326e:	89 23       	and	r24, r25
    3270:	85 b9       	out	0x05, r24	; 5
  R_DDR |= Mask;                             /* enable pulling */
    3272:	84 b1       	in	r24, 0x04	; 4
    3274:	8c 2b       	or	r24, r28
    3276:	84 b9       	out	0x04, r24	; 4

  if (Mode & FLAG_1MS) wait1ms();            /* wait 1ms */
    3278:	63 ff       	sbrs	r22, 3
    327a:	03 c0       	rjmp	.+6      	; 0x3282 <PullProbe+0x2a>
    327c:	0e 94 7f 00 	call	0xfe	; 0xfe <wait1ms>
    3280:	02 c0       	rjmp	.+4      	; 0x3286 <PullProbe+0x2e>
  else wait10ms();                           /* wait 10ms */
    3282:	0e 94 7a 00 	call	0xf4	; 0xf4 <wait10ms>

  /* reset pulling */
  R_DDR &= ~Mask;                       /* set to HiZ mode */
    3286:	84 b1       	in	r24, 0x04	; 4
    3288:	c0 95       	com	r28
    328a:	8c 23       	and	r24, r28
    328c:	84 b9       	out	0x04, r24	; 4
  R_PORT &= ~Mask;                      /* set 0 */
    328e:	85 b1       	in	r24, 0x05	; 5
    3290:	c8 23       	and	r28, r24
    3292:	c5 b9       	out	0x05, r28	; 5
}
    3294:	cf 91       	pop	r28
    3296:	08 95       	ret

00003298 <GetFactor>:
 *  returns:
 *  - multiplicator/factor
 */

uint16_t GetFactor(uint16_t U_in, uint8_t ID)
{
    3298:	df 92       	push	r13
    329a:	ef 92       	push	r14
    329c:	ff 92       	push	r15
    329e:	0f 93       	push	r16
    32a0:	1f 93       	push	r17
    32a2:	cf 93       	push	r28
    32a4:	df 93       	push	r29

  /*
   *  setup table specific stuff
   */

  if (ID == TABLE_SMALL_CAP)
    32a6:	61 30       	cpi	r22, 0x01	; 1
    32a8:	e9 f1       	breq	.+122    	; 0x3324 <GetFactor+0x8c>
    TabStart = 1000;               /* table starts at 1000mV */
    TabStep = 50;                  /* 50mV steps between entries */
    TabIndex = 7;                  /* entries in table - 2 */
    Table = (uint16_t *)&SmallCap_table[0];    /* pointer to table start */
  }
  else if (ID == TABLE_LARGE_CAP)
    32aa:	62 30       	cpi	r22, 0x02	; 2
    32ac:	09 f4       	brne	.+2      	; 0x32b0 <GetFactor+0x18>
    32ae:	43 c0       	rjmp	.+134    	; 0x3336 <GetFactor+0x9e>
    TabStep = 25;                  /* 25mV steps between entries */
    TabIndex = 42;                 /* entries in table - 2 */
    Table = (uint16_t *)&LargeCap_table[0];    /* pointer to table start */
  }
  #ifdef SW_INDUCTOR
  else if (ID == TABLE_INDUCTOR)
    32b0:	63 30       	cpi	r22, 0x03	; 3
    32b2:	09 f4       	brne	.+2      	; 0x32b6 <GetFactor+0x1e>
    32b4:	49 c0       	rjmp	.+146    	; 0x3348 <GetFactor+0xb0>
    Table = (uint16_t *)&Inductor_table[0];    /* pointer to table start */
  }
  #endif
  else
  {
    return 0;
    32b6:	80 e0       	ldi	r24, 0x00	; 0
    32b8:	90 e0       	ldi	r25, 0x00	; 0
    32ba:	53 c0       	rjmp	.+166    	; 0x3362 <GetFactor+0xca>
  /*
   *  We interpolate the table values corresponding to the given voltage/ratio.
   */

  /* difference to start of table */
  if (U_in >= TabStart) U_Diff = U_in - TabStart;  
    32bc:	84 1b       	sub	r24, r20
    32be:	95 0b       	sbc	r25, r21
  else U_Diff = 0;

  /* calculate table index */
  Index = U_Diff / TabStep;             /* index (position in table) */
    32c0:	b8 01       	movw	r22, r16
    32c2:	0e 94 18 28 	call	0x5030	; 0x5030 <__udivmodhi4>
  Diff = U_Diff % TabStep;              /* difference to index */
  Diff = TabStep - Diff;                /* difference to next entry */
    32c6:	d0 2e       	mov	r13, r16
    32c8:	d8 1a       	sub	r13, r24

  /* prevent index overflow */
  if (Index > TabIndex) Index = TabIndex;
    32ca:	cb 01       	movw	r24, r22
    32cc:	99 27       	eor	r25, r25
    32ce:	c8 17       	cp	r28, r24
    32d0:	d9 07       	cpc	r29, r25
    32d2:	10 f0       	brcs	.+4      	; 0x32d8 <GetFactor+0x40>
  /* difference to start of table */
  if (U_in >= TabStart) U_Diff = U_in - TabStart;  
  else U_Diff = 0;

  /* calculate table index */
  Index = U_Diff / TabStep;             /* index (position in table) */
    32d4:	26 2f       	mov	r18, r22
    32d6:	01 c0       	rjmp	.+2      	; 0x32da <GetFactor+0x42>
  Diff = U_Diff % TabStep;              /* difference to index */
  Diff = TabStep - Diff;                /* difference to next entry */

  /* prevent index overflow */
  if (Index > TabIndex) Index = TabIndex;
    32d8:	2c 2f       	mov	r18, r28

  /* get values for index and next entry */
  Table += Index;                       /* advance to index */
    32da:	c2 2f       	mov	r28, r18
    32dc:	d0 e0       	ldi	r29, 0x00	; 0
    32de:	cc 0f       	add	r28, r28
    32e0:	dd 1f       	adc	r29, r29
    32e2:	ce 0f       	add	r28, r30
    32e4:	df 1f       	adc	r29, r31
  Fact1 = MEM_read_word(Table);
    32e6:	ce 01       	movw	r24, r28
    32e8:	0e 94 da 28 	call	0x51b4	; 0x51b4 <eeprom_read_word>
    32ec:	7c 01       	movw	r14, r24
  Table++;                              /* next entry */
  Fact2 = MEM_read_word(Table);
    32ee:	ce 01       	movw	r24, r28
    32f0:	02 96       	adiw	r24, 0x02	; 2
    32f2:	0e 94 da 28 	call	0x51b4	; 0x51b4 <eeprom_read_word>
    32f6:	9c 01       	movw	r18, r24

  /* interpolate values based on the difference */
  Factor = Fact1 - Fact2;
    32f8:	e8 1a       	sub	r14, r24
    32fa:	f9 0a       	sbc	r15, r25
  Factor *= Diff;
    32fc:	de 9c       	mul	r13, r14
    32fe:	a0 01       	movw	r20, r0
    3300:	df 9c       	mul	r13, r15
    3302:	50 0d       	add	r21, r0
    3304:	11 24       	eor	r1, r1
  Factor += TabStep / 2;
    3306:	c8 01       	movw	r24, r16
    3308:	96 95       	lsr	r25
    330a:	87 95       	ror	r24
    330c:	84 0f       	add	r24, r20
    330e:	95 1f       	adc	r25, r21
  Factor /= TabStep;
    3310:	b8 01       	movw	r22, r16
    3312:	0e 94 18 28 	call	0x5030	; 0x5030 <__udivmodhi4>
  Factor += Fact2;
    3316:	cb 01       	movw	r24, r22
    3318:	82 0f       	add	r24, r18
    331a:	93 1f       	adc	r25, r19

  return Factor;
    331c:	22 c0       	rjmp	.+68     	; 0x3362 <GetFactor+0xca>
  /* difference to start of table */
  if (U_in >= TabStart) U_Diff = U_in - TabStart;  
  else U_Diff = 0;

  /* calculate table index */
  Index = U_Diff / TabStep;             /* index (position in table) */
    331e:	20 e0       	ldi	r18, 0x00	; 0
  Diff = U_Diff % TabStep;              /* difference to index */
  Diff = TabStep - Diff;                /* difference to next entry */
    3320:	d0 2e       	mov	r13, r16
    3322:	db cf       	rjmp	.-74     	; 0x32da <GetFactor+0x42>
  if (ID == TABLE_SMALL_CAP)
  {
    TabStart = 1000;               /* table starts at 1000mV */
    TabStep = 50;                  /* 50mV steps between entries */
    TabIndex = 7;                  /* entries in table - 2 */
    Table = (uint16_t *)&SmallCap_table[0];    /* pointer to table start */
    3324:	e9 e5       	ldi	r30, 0x59	; 89
    3326:	f0 e0       	ldi	r31, 0x00	; 0

  if (ID == TABLE_SMALL_CAP)
  {
    TabStart = 1000;               /* table starts at 1000mV */
    TabStep = 50;                  /* 50mV steps between entries */
    TabIndex = 7;                  /* entries in table - 2 */
    3328:	c7 e0       	ldi	r28, 0x07	; 7
    332a:	d0 e0       	ldi	r29, 0x00	; 0
   */

  if (ID == TABLE_SMALL_CAP)
  {
    TabStart = 1000;               /* table starts at 1000mV */
    TabStep = 50;                  /* 50mV steps between entries */
    332c:	02 e3       	ldi	r16, 0x32	; 50
    332e:	10 e0       	ldi	r17, 0x00	; 0
   *  setup table specific stuff
   */

  if (ID == TABLE_SMALL_CAP)
  {
    TabStart = 1000;               /* table starts at 1000mV */
    3330:	48 ee       	ldi	r20, 0xE8	; 232
    3332:	53 e0       	ldi	r21, 0x03	; 3
    3334:	11 c0       	rjmp	.+34     	; 0x3358 <GetFactor+0xc0>
  else if (ID == TABLE_LARGE_CAP)
  {
    TabStart = 300;                /* table starts at 1000mV */
    TabStep = 25;                  /* 25mV steps between entries */
    TabIndex = 42;                 /* entries in table - 2 */
    Table = (uint16_t *)&LargeCap_table[0];    /* pointer to table start */
    3336:	eb e6       	ldi	r30, 0x6B	; 107
    3338:	f0 e0       	ldi	r31, 0x00	; 0
  }
  else if (ID == TABLE_LARGE_CAP)
  {
    TabStart = 300;                /* table starts at 1000mV */
    TabStep = 25;                  /* 25mV steps between entries */
    TabIndex = 42;                 /* entries in table - 2 */
    333a:	ca e2       	ldi	r28, 0x2A	; 42
    333c:	d0 e0       	ldi	r29, 0x00	; 0
    Table = (uint16_t *)&SmallCap_table[0];    /* pointer to table start */
  }
  else if (ID == TABLE_LARGE_CAP)
  {
    TabStart = 300;                /* table starts at 1000mV */
    TabStep = 25;                  /* 25mV steps between entries */
    333e:	09 e1       	ldi	r16, 0x19	; 25
    3340:	10 e0       	ldi	r17, 0x00	; 0
    TabIndex = 7;                  /* entries in table - 2 */
    Table = (uint16_t *)&SmallCap_table[0];    /* pointer to table start */
  }
  else if (ID == TABLE_LARGE_CAP)
  {
    TabStart = 300;                /* table starts at 1000mV */
    3342:	4c e2       	ldi	r20, 0x2C	; 44
    3344:	51 e0       	ldi	r21, 0x01	; 1
    3346:	08 c0       	rjmp	.+16     	; 0x3358 <GetFactor+0xc0>
  else if (ID == TABLE_INDUCTOR)
  {
    TabStart = 200;                /* table starts at 200 */
    TabStep = 25;                  /* steps between entries */
    TabIndex = 30;                 /* entries in table - 2 */
    Table = (uint16_t *)&Inductor_table[0];    /* pointer to table start */
    3348:	e9 e0       	ldi	r30, 0x09	; 9
    334a:	f0 e0       	ldi	r31, 0x00	; 0
  #ifdef SW_INDUCTOR
  else if (ID == TABLE_INDUCTOR)
  {
    TabStart = 200;                /* table starts at 200 */
    TabStep = 25;                  /* steps between entries */
    TabIndex = 30;                 /* entries in table - 2 */
    334c:	ce e1       	ldi	r28, 0x1E	; 30
    334e:	d0 e0       	ldi	r29, 0x00	; 0
  }
  #ifdef SW_INDUCTOR
  else if (ID == TABLE_INDUCTOR)
  {
    TabStart = 200;                /* table starts at 200 */
    TabStep = 25;                  /* steps between entries */
    3350:	09 e1       	ldi	r16, 0x19	; 25
    3352:	10 e0       	ldi	r17, 0x00	; 0
    Table = (uint16_t *)&LargeCap_table[0];    /* pointer to table start */
  }
  #ifdef SW_INDUCTOR
  else if (ID == TABLE_INDUCTOR)
  {
    TabStart = 200;                /* table starts at 200 */
    3354:	48 ec       	ldi	r20, 0xC8	; 200
    3356:	50 e0       	ldi	r21, 0x00	; 0
  /*
   *  We interpolate the table values corresponding to the given voltage/ratio.
   */

  /* difference to start of table */
  if (U_in >= TabStart) U_Diff = U_in - TabStart;  
    3358:	84 17       	cp	r24, r20
    335a:	95 07       	cpc	r25, r21
    335c:	08 f0       	brcs	.+2      	; 0x3360 <GetFactor+0xc8>
    335e:	ae cf       	rjmp	.-164    	; 0x32bc <GetFactor+0x24>
    3360:	de cf       	rjmp	.-68     	; 0x331e <GetFactor+0x86>
  Factor += TabStep / 2;
  Factor /= TabStep;
  Factor += Fact2;

  return Factor;
}
    3362:	df 91       	pop	r29
    3364:	cf 91       	pop	r28
    3366:	1f 91       	pop	r17
    3368:	0f 91       	pop	r16
    336a:	ff 90       	pop	r15
    336c:	ef 90       	pop	r14
    336e:	df 90       	pop	r13
    3370:	08 95       	ret

00003372 <CheckProbes>:
 *  - Probe2: ID of probe to be pulled down [0-2]
 *  - Probe3: ID of probe to be in HiZ mode [0-2]
 */

void CheckProbes(uint8_t Probe1, uint8_t Probe2, uint8_t Probe3)
{
    3372:	ef 92       	push	r14
    3374:	ff 92       	push	r15
    3376:	0f 93       	push	r16
    3378:	1f 93       	push	r17
    337a:	cf 93       	push	r28
    337c:	df 93       	push	r29
  uint8_t           Flag;          /* temporary value */
  uint16_t          U_Rl;          /* voltage across Rl (load) */
  uint16_t          U_1;           /* voltage #1 */

  /* init */
  if (Check.Found == COMP_ERROR) return;   /* skip check on any error */
    337e:	90 91 01 01 	lds	r25, 0x0101
    3382:	91 30       	cpi	r25, 0x01	; 1
    3384:	09 f4       	brne	.+2      	; 0x3388 <CheckProbes+0x16>
    3386:	8a c0       	rjmp	.+276    	; 0x349c <CheckProbes+0x12a>
    3388:	06 2f       	mov	r16, r22
    338a:	18 2f       	mov	r17, r24
  wdt_reset();                             /* reset watchdog */
    338c:	a8 95       	wdr
  UpdateProbes(Probe1, Probe2, Probe3);    /* update bitmasks */
    338e:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <UpdateProbes>
   *  In case of a FET we have to take care about the gate charge based on
   *  the channel type.
   */

  /* set probes: Gnd -- Rl -- probe-2 / probe-1 -- Vcc */
  R_PORT = 0;                      /* set resistor port to Gnd */
    3392:	15 b8       	out	0x05, r1	; 5
  R_DDR = Probes.Rl_2;             /* pull down probe-2 via Rl */
    3394:	cd e7       	ldi	r28, 0x7D	; 125
    3396:	d1 e0       	ldi	r29, 0x01	; 1
    3398:	8d 81       	ldd	r24, Y+5	; 0x05
    339a:	84 b9       	out	0x04, r24	; 4
  ADC_DDR = Probes.ADC_1;          /* set probe-1 to output */
    339c:	99 85       	ldd	r25, Y+9	; 0x09
    339e:	97 b9       	out	0x07, r25	; 7
  ADC_PORT = Probes.ADC_1;         /* pull-up probe-1 directly */
    33a0:	98 b9       	out	0x08, r25	; 8
  /*
   *  For a possible n channel FET we pull down the gate for a few ms,
   *  assuming: probe-1 = D / probe-2 = S / probe-3 = G
   */

  PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLDOWN);   /* discharge gate via Rl */
    33a2:	60 e1       	ldi	r22, 0x10	; 16
    33a4:	8f 81       	ldd	r24, Y+7	; 0x07
    33a6:	0e 94 2c 19 	call	0x3258	; 0x3258 <PullProbe>
  U_Rl = ReadU_5ms(Probes.Pin_2);                    /* get voltage at Rl */
    33aa:	89 81       	ldd	r24, Y+1	; 0x01
    33ac:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
    33b0:	ec 01       	movw	r28, r24
  /*
   *  If we got conduction we could have a p channel FET. For any
   *  other part U_Rl will be the same.
   */
 
  if (U_Rl >= 977)               /* > 1.4mA */
    33b2:	81 3d       	cpi	r24, 0xD1	; 209
    33b4:	93 40       	sbci	r25, 0x03	; 3
    33b6:	08 f4       	brcc	.+2      	; 0x33ba <CheckProbes+0x48>
    33b8:	6b c0       	rjmp	.+214    	; 0x3490 <CheckProbes+0x11e>
    /*
     *  For a possible p channel FET we pull up the gate for a few ms,
     *  assuming: probe-1 = S / probe-2 = D / probe-3 = G
     */

    PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLUP);   /* discharge gate via Rl */
    33ba:	cd e7       	ldi	r28, 0x7D	; 125
    33bc:	d1 e0       	ldi	r29, 0x01	; 1
    33be:	61 e1       	ldi	r22, 0x11	; 17
    33c0:	8f 81       	ldd	r24, Y+7	; 0x07
    33c2:	0e 94 2c 19 	call	0x3258	; 0x3258 <PullProbe>
    U_Rl = ReadU_5ms(Probes.Pin_2);                    /* get voltage at Rl */
    33c6:	89 81       	ldd	r24, Y+1	; 0x01
    33c8:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
    33cc:	ec 01       	movw	r28, r24
   *
   *  Other possibilities:
   *  - diode or resistor
   */

  if (U_Rl > 490)         /* > 700킕 (was 92mV/130킕) */
    33ce:	cb 3e       	cpi	r28, 0xEB	; 235
    33d0:	81 e0       	ldi	r24, 0x01	; 1
    33d2:	d8 07       	cpc	r29, r24
    33d4:	10 f0       	brcs	.+4      	; 0x33da <CheckProbes+0x68>
  {
    CheckDepletionModeFET();
    33d6:	0e 94 09 23 	call	0x4612	; 0x4612 <CheckDepletionModeFET>
   *  - enhancement mode FET
   *  - Thyristor or Triac
   *  or a large resistor
   */

  if (U_Rl < 977)         /* load current < 1.4mA (resistance > 3k) */
    33da:	c1 3d       	cpi	r28, 0xD1	; 209
    33dc:	e3 e0       	ldi	r30, 0x03	; 3
    33de:	de 07       	cpc	r29, r30
    33e0:	08 f0       	brcs	.+2      	; 0x33e4 <CheckProbes+0x72>
    33e2:	3f c0       	rjmp	.+126    	; 0x3462 <CheckProbes+0xf0>
     *  check for:
     *  - PNP BJT (common emitter circuit)
     *  - p-channel MOSFET (low side switching circuit)
     */

    if (Check.Done == 0)           /* not sure yet */
    33e4:	80 91 00 01 	lds	r24, 0x0100
    33e8:	81 11       	cpse	r24, r1
    33ea:	3d c0       	rjmp	.+122    	; 0x3466 <CheckProbes+0xf4>
    {
      /* we assume: probe-1 = E / probe-2 = C / probe-3 = B */
      /* set probes: Gnd -- Rl - probe-2 / probe-1 -- Vcc */
      R_DDR = Probes.Rl_2;                /* enable Rl for probe-2 */
    33ec:	0f 2e       	mov	r0, r31
    33ee:	fd e7       	ldi	r31, 0x7D	; 125
    33f0:	ef 2e       	mov	r14, r31
    33f2:	f1 e0       	ldi	r31, 0x01	; 1
    33f4:	ff 2e       	mov	r15, r31
    33f6:	f0 2d       	mov	r31, r0
    33f8:	f7 01       	movw	r30, r14
    33fa:	85 81       	ldd	r24, Z+5	; 0x05
    33fc:	84 b9       	out	0x04, r24	; 4
      R_PORT = 0;                         /* pull down collector via Rl */
    33fe:	15 b8       	out	0x05, r1	; 5
      ADC_DDR = Probes.ADC_1;             /* set probe 1 to output */
    3400:	81 85       	ldd	r24, Z+9	; 0x09
    3402:	87 b9       	out	0x07, r24	; 7
      ADC_PORT = Probes.ADC_1;            /* pull up emitter directly */
    3404:	88 b9       	out	0x08, r24	; 8
      wait5ms();
    3406:	0e 94 7b 00 	call	0xf6	; 0xf6 <wait5ms>
      R_DDR = Probes.Rl_2 | Probes.Rl_3;  /* pull down base via Rl */
    340a:	f7 01       	movw	r30, r14
    340c:	97 81       	ldd	r25, Z+7	; 0x07
    340e:	85 81       	ldd	r24, Z+5	; 0x05
    3410:	89 2b       	or	r24, r25
    3412:	84 b9       	out	0x04, r24	; 4
      U_1 = ReadU_5ms(Probe2);            /* get voltage at collector */ 
    3414:	80 2f       	mov	r24, r16
    3416:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
 
      /*
       *  If DUT is conducting we might have a PNP BJT or p-channel FET.
       */

      if (U_1 > 3422)                   /* detected current > 4.8mA */
    341a:	8f 35       	cpi	r24, 0x5F	; 95
    341c:	9d 40       	sbci	r25, 0x0D	; 13
    341e:	20 f0       	brcs	.+8      	; 0x3428 <CheckProbes+0xb6>
      {
        /* distinguish PNP BJT from p-channel MOSFET */
        CheckBJTorEnhModeMOSFET(TYPE_PNP, U_Rl);
    3420:	be 01       	movw	r22, r28
    3422:	82 e0       	ldi	r24, 0x02	; 2
    3424:	0e 94 cf 21 	call	0x439e	; 0x439e <CheckBJTorEnhModeMOSFET>
     *  - NPN BJT (common emitter circuit)
     *  - Thyristor and Triac
     *  - n-channel MOSFET (high side switching circuit)
     */

    if (Check.Done == 0)           /* not sure yet */
    3428:	80 91 00 01 	lds	r24, 0x0100
    342c:	81 11       	cpse	r24, r1
    342e:	1b c0       	rjmp	.+54     	; 0x3466 <CheckProbes+0xf4>
    {
      /* we assume: probe-1 = C / probe-2 = E / probe-3 = B */
      /* set probes: Gnd -- probe-2 / probe-1 -- Rl -- Vcc */
      ADC_DDR = Probes.ADC_2;                /* set probe-2 to output mode */
    3430:	ed e7       	ldi	r30, 0x7D	; 125
    3432:	f1 e0       	ldi	r31, 0x01	; 1
    3434:	82 85       	ldd	r24, Z+10	; 0x0a
    3436:	87 b9       	out	0x07, r24	; 7
      ADC_PORT = 0;                          /* pull down probe-2 directly */
    3438:	18 b8       	out	0x08, r1	; 8
      R_DDR = Probes.Rl_1 | Probes.Rl_3;     /* select Rl for probe-1 & Rl for probe-3 */
    343a:	97 81       	ldd	r25, Z+7	; 0x07
    343c:	83 81       	ldd	r24, Z+3	; 0x03
    343e:	89 2b       	or	r24, r25
    3440:	84 b9       	out	0x04, r24	; 4
      R_PORT = Probes.Rl_1 | Probes.Rl_3;    /* pull up collector & base via Rl */
    3442:	85 b9       	out	0x05, r24	; 5
      U_1 = ReadU_5ms(Probe1);               /* get voltage at collector */
    3444:	81 2f       	mov	r24, r17
    3446:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
      /*
       *  If DUT is conducting we might have a NPN BJT, something similar or
       *  a n-channel MOSFET.
       */

      if (U_1 < 1600)                   /* detected current > 4.8mA */
    344a:	80 34       	cpi	r24, 0x40	; 64
    344c:	96 40       	sbci	r25, 0x06	; 6
    344e:	58 f4       	brcc	.+22     	; 0x3466 <CheckProbes+0xf4>
      {
        /* first check for thyristor and triac */
        Flag = CheckThyristorTriac();
    3450:	0e 94 eb 23 	call	0x47d6	; 0x47d6 <CheckThyristorTriac>

        if (Flag == 0)                 /* no thyristor or triac */
    3454:	81 11       	cpse	r24, r1
    3456:	07 c0       	rjmp	.+14     	; 0x3466 <CheckProbes+0xf4>
        {
          /* we might got a NPN BJT or a n-channel MOSFET. */
          CheckBJTorEnhModeMOSFET(TYPE_NPN, U_Rl);
    3458:	be 01       	movw	r22, r28
    345a:	81 e0       	ldi	r24, 0x01	; 1
    345c:	0e 94 cf 21 	call	0x439e	; 0x439e <CheckBJTorEnhModeMOSFET>
    3460:	02 c0       	rjmp	.+4      	; 0x3466 <CheckProbes+0xf4>
    /*
     *  We check for a diode even if we already found a component to get Vf, 
     *  since there could be a body/protection diode of a transistor.
     */

    CheckDiode();
    3462:	0e 94 2f 20 	call	0x405e	; 0x405e <CheckDiode>

  /*
   *  Check for a resistor.
   */

  if ((Check.Found == COMP_NONE) ||
    3466:	80 91 01 01 	lds	r24, 0x0101
    346a:	88 23       	and	r24, r24
    346c:	11 f0       	breq	.+4      	; 0x3472 <CheckProbes+0x100>
    346e:	8a 30       	cpi	r24, 0x0A	; 10
    3470:	19 f4       	brne	.+6      	; 0x3478 <CheckProbes+0x106>
      (Check.Found == COMP_RESISTOR))
  {
    CheckResistor();
    3472:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <CheckResistor>
    3476:	07 c0       	rjmp	.+14     	; 0x3486 <CheckProbes+0x114>
   */

  else
  {
    /* verify a MOSFET */
    if ((Check.Found == COMP_FET) && (Check.Type & TYPE_MOSFET))
    3478:	86 31       	cpi	r24, 0x16	; 22
    347a:	29 f4       	brne	.+10     	; 0x3486 <CheckProbes+0x114>
    347c:	80 91 02 01 	lds	r24, 0x0102
    3480:	84 fd       	sbrc	r24, 4
      VerifyMOSFET();
    3482:	0e 94 a2 21 	call	0x4344	; 0x4344 <VerifyMOSFET>
  }


  /* clean up */
  ADC_DDR = 0;           /* set ADC port to HiZ mode */
    3486:	17 b8       	out	0x07, r1	; 7
  ADC_PORT = 0;          /* set ADC port low */
    3488:	18 b8       	out	0x08, r1	; 8
  R_DDR = 0;             /* set resistor port to HiZ mode */
    348a:	14 b8       	out	0x04, r1	; 4
  R_PORT = 0;            /* set resistor port low */
    348c:	15 b8       	out	0x05, r1	; 5
    348e:	06 c0       	rjmp	.+12     	; 0x349c <CheckProbes+0x12a>
   *
   *  Other possibilities:
   *  - diode or resistor
   */

  if (U_Rl > 490)         /* > 700킕 (was 92mV/130킕) */
    3490:	cb 3e       	cpi	r28, 0xEB	; 235
    3492:	81 e0       	ldi	r24, 0x01	; 1
    3494:	d8 07       	cpc	r29, r24
    3496:	08 f4       	brcc	.+2      	; 0x349a <CheckProbes+0x128>
    3498:	a5 cf       	rjmp	.-182    	; 0x33e4 <CheckProbes+0x72>
    349a:	9d cf       	rjmp	.-198    	; 0x33d6 <CheckProbes+0x64>
  /* clean up */
  ADC_DDR = 0;           /* set ADC port to HiZ mode */
  ADC_PORT = 0;          /* set ADC port low */
  R_DDR = 0;             /* set resistor port to HiZ mode */
  R_PORT = 0;            /* set resistor port low */
}
    349c:	df 91       	pop	r29
    349e:	cf 91       	pop	r28
    34a0:	1f 91       	pop	r17
    34a2:	0f 91       	pop	r16
    34a4:	ff 90       	pop	r15
    34a6:	ef 90       	pop	r14
    34a8:	08 95       	ret

000034aa <SmallResistor>:
 *  returns:
 *  - resistance in 0.01 Ohm
 */

uint16_t SmallResistor(uint8_t ZeroFlag)
{
    34aa:	2f 92       	push	r2
    34ac:	3f 92       	push	r3
    34ae:	4f 92       	push	r4
    34b0:	5f 92       	push	r5
    34b2:	6f 92       	push	r6
    34b4:	7f 92       	push	r7
    34b6:	8f 92       	push	r8
    34b8:	9f 92       	push	r9
    34ba:	af 92       	push	r10
    34bc:	bf 92       	push	r11
    34be:	cf 92       	push	r12
    34c0:	df 92       	push	r13
    34c2:	ef 92       	push	r14
    34c4:	ff 92       	push	r15
    34c6:	0f 93       	push	r16
    34c8:	1f 93       	push	r17
    34ca:	cf 93       	push	r28
    34cc:	df 93       	push	r29
    34ce:	00 d0       	rcall	.+0      	; 0x34d0 <SmallResistor+0x26>
    34d0:	00 d0       	rcall	.+0      	; 0x34d2 <SmallResistor+0x28>
    34d2:	1f 92       	push	r1
    34d4:	cd b7       	in	r28, 0x3d	; 61
    34d6:	de b7       	in	r29, 0x3e	; 62
    34d8:	8d 83       	std	Y+5, r24	; 0x05
  uint8_t           Counter;       /* sample counter */
  uint32_t          Value;         /* ADC sample value */
  uint32_t          Value1 = 0;    /* U_Rl temp. value */
  uint32_t          Value2 = 0;    /* U_R_i_L temp. value */

  DischargeProbes();                    /* try to discharge probes */
    34da:	0e 94 64 18 	call	0x30c8	; 0x30c8 <DischargeProbes>
  if (Check.Found == COMP_ERROR) return R;   /* skip on error */
    34de:	80 91 01 01 	lds	r24, 0x0101
    34e2:	81 30       	cpi	r24, 0x01	; 1
    34e4:	09 f4       	brne	.+2      	; 0x34e8 <SmallResistor+0x3e>
    34e6:	e1 c0       	rjmp	.+450    	; 0x36aa <SmallResistor+0x200>
   *  - repeat that for the low side of the DUT
   */

  /* pulse on: GND -- probe 2 / probe 1 -- Rl -- 5V */
  /* pulse off: GND -- probe 2 / probe 1 -- Rl -- GND */
  ADC_PORT = 0;                         /* set ADC port to low */
    34e8:	18 b8       	out	0x08, r1	; 8
  ADC_DDR = Probes.ADC_2;               /* pull-down probe 2 directly */
    34ea:	ed e7       	ldi	r30, 0x7D	; 125
    34ec:	f1 e0       	ldi	r31, 0x01	; 1
    34ee:	82 85       	ldd	r24, Z+10	; 0x0a
    34f0:	87 b9       	out	0x07, r24	; 7
  R_PORT = 0;                           /* low by default */
    34f2:	15 b8       	out	0x05, r1	; 5
  R_DDR = Probes.Rl_1;                  /* enable resistor */
    34f4:	83 81       	ldd	r24, Z+3	; 0x03
    34f6:	84 b9       	out	0x04, r24	; 4
  uint16_t          R = 0;         /* return value */
  uint8_t           Probe;         /* probe ID */
  uint8_t           Mode;          /* measurement mode */
  uint8_t           Counter;       /* sample counter */
  uint32_t          Value;         /* ADC sample value */
  uint32_t          Value1 = 0;    /* U_Rl temp. value */
    34f8:	41 2c       	mov	r4, r1
    34fa:	51 2c       	mov	r5, r1
    34fc:	32 01       	movw	r6, r4

  /*
   *   measurement loop
   */

  Mode = MODE_HIGH;
    34fe:	81 e0       	ldi	r24, 0x01	; 1

  while (Mode > 0)
  {
    /* setup measurement */
    if (Mode & MODE_HIGH) Probe = Probes.Pin_1;
    else Probe = Probes.Pin_2;
    3500:	8f 01       	movw	r16, r30
    Counter = 0;              /* reset loop counter */
    Value = 0;                /* reset sample value */

    /* set ADC to use bandgap reference and run a dummy conversion */
    Probe |= (1 << REFS0) | (1 << REFS1);
    ADMUX = Probe;                   /* set input channel and U reference */
    3502:	0f 2e       	mov	r0, r31
    3504:	fc e7       	ldi	r31, 0x7C	; 124
    3506:	cf 2e       	mov	r12, r31
    3508:	d1 2c       	mov	r13, r1
    350a:	f0 2d       	mov	r31, r0
    350c:	81 2c       	mov	r8, r1
      R_PORT = 0;
      ADC_DDR = Probes.ADC_2 | Probes.ADC_1;

      /* get ADC reading (about 100탎) */
      while (ADCSRA & (1 << ADSC));     /* wait until conversion is done */
      Value += ADCW;                    /* add ADC reading */
    350e:	0f 2e       	mov	r0, r31
    3510:	f8 e7       	ldi	r31, 0x78	; 120
    3512:	af 2e       	mov	r10, r31
    3514:	b1 2c       	mov	r11, r1
    3516:	f0 2d       	mov	r31, r0

      Counter++;                        /* next round */
    }

    /* convert ADC reading to voltage */
    Value *= Config.Bandgap;
    3518:	0f 2e       	mov	r0, r31
    351a:	fe e8       	ldi	r31, 0x8E	; 142
    351c:	2f 2e       	mov	r2, r31
    351e:	f1 e0       	ldi	r31, 0x01	; 1
    3520:	3f 2e       	mov	r3, r31
    3522:	f0 2d       	mov	r31, r0
    Value /= 10;                   /* de-sample to 0.1mV */

    /* loop control */
    if (Mode & MODE_HIGH)          /* probe #1 / Rl */
    {
      Mode = MODE_LOW;             /* switch to low side */
    3524:	68 94       	set
    3526:	99 24       	eor	r9, r9
    3528:	91 f8       	bld	r9, 1
    352a:	49 82       	std	Y+1, r4	; 0x01
    352c:	5a 82       	std	Y+2, r5	; 0x02
    352e:	6b 82       	std	Y+3, r6	; 0x03
    3530:	7c 82       	std	Y+4, r7	; 0x04
    3532:	04 c0       	rjmp	.+8      	; 0x353c <SmallResistor+0x92>
    }

    /* convert ADC reading to voltage */
    Value *= Config.Bandgap;
    Value /= 1024;                 /* / 1024 for 10bit ADC */
    Value /= 10;                   /* de-sample to 0.1mV */
    3534:	29 83       	std	Y+1, r18	; 0x01
    3536:	3a 83       	std	Y+2, r19	; 0x02
    3538:	4b 83       	std	Y+3, r20	; 0x03
    353a:	5c 83       	std	Y+4, r21	; 0x04
  Mode = MODE_HIGH;

  while (Mode > 0)
  {
    /* setup measurement */
    if (Mode & MODE_HIGH) Probe = Probes.Pin_1;
    353c:	68 2f       	mov	r22, r24
    353e:	61 70       	andi	r22, 0x01	; 1
    3540:	e6 2e       	mov	r14, r22
    3542:	80 ff       	sbrs	r24, 0
    3544:	03 c0       	rjmp	.+6      	; 0x354c <SmallResistor+0xa2>
    3546:	f8 01       	movw	r30, r16
    3548:	80 81       	ld	r24, Z
    354a:	02 c0       	rjmp	.+4      	; 0x3550 <SmallResistor+0xa6>
    else Probe = Probes.Pin_2;
    354c:	f8 01       	movw	r30, r16
    354e:	81 81       	ldd	r24, Z+1	; 0x01

    wdt_reset();              /* reset watchdog */
    3550:	a8 95       	wdr
    Counter = 0;              /* reset loop counter */
    Value = 0;                /* reset sample value */

    /* set ADC to use bandgap reference and run a dummy conversion */
    Probe |= (1 << REFS0) | (1 << REFS1);
    3552:	80 6c       	ori	r24, 0xC0	; 192
    ADMUX = Probe;                   /* set input channel and U reference */
    3554:	f6 01       	movw	r30, r12
    3556:	80 83       	st	Z, r24
    wait100us();                     /* time for voltage stabilization */
    3558:	0e 94 84 00 	call	0x108	; 0x108 <wait100us>
    ADCSRA |= (1 << ADSC);           /* start conversion */
    355c:	ea e7       	ldi	r30, 0x7A	; 122
    355e:	f0 e0       	ldi	r31, 0x00	; 0
    3560:	80 81       	ld	r24, Z
    3562:	80 64       	ori	r24, 0x40	; 64
    3564:	80 83       	st	Z, r24
    while (ADCSRA & (1 << ADSC));    /* wait until conversion is done */
    3566:	ea e7       	ldi	r30, 0x7A	; 122
    3568:	f0 e0       	ldi	r31, 0x00	; 0
    356a:	80 81       	ld	r24, Z
    356c:	86 fd       	sbrc	r24, 6
    356e:	fb cf       	rjmp	.-10     	; 0x3566 <SmallResistor+0xbc>
    3570:	0f 2e       	mov	r0, r31
    3572:	f4 e6       	ldi	r31, 0x64	; 100
    3574:	ff 2e       	mov	r15, r31
    3576:	f0 2d       	mov	r31, r0
    3578:	41 2c       	mov	r4, r1
    357a:	51 2c       	mov	r5, r1
    357c:	61 2c       	mov	r6, r1
    357e:	78 2c       	mov	r7, r8
     */

    while (Counter < 100)
    {
      /* create short pulse */
      ADC_DDR = Probes.ADC_2;           /* pull-down probe-2 directly */
    3580:	f8 01       	movw	r30, r16
    3582:	82 85       	ldd	r24, Z+10	; 0x0a
    3584:	87 b9       	out	0x07, r24	; 7
      R_PORT = Probes.Rl_1;
    3586:	83 81       	ldd	r24, Z+3	; 0x03
    3588:	85 b9       	out	0x05, r24	; 5

      /* start ADC conversion */
      /* ADC performs S&H after 1.5 ADC cycles (12탎) */
      ADCSRA |= (1 << ADSC);            /* start conversion */
    358a:	ea e7       	ldi	r30, 0x7A	; 122
    358c:	f0 e0       	ldi	r31, 0x00	; 0
    358e:	80 81       	ld	r24, Z
    3590:	80 64       	ori	r24, 0x40	; 64
    3592:	80 83       	st	Z, r24

      /* wait 20탎 to allow the ADC to do it's job (S&H) */
      wait20us();
    3594:	0e 94 88 00 	call	0x110	; 0x110 <wait20us>

      /* stop pulse */
      R_PORT = 0;
    3598:	15 b8       	out	0x05, r1	; 5
      ADC_DDR = Probes.ADC_2 | Probes.ADC_1;
    359a:	f8 01       	movw	r30, r16
    359c:	91 85       	ldd	r25, Z+9	; 0x09
    359e:	82 85       	ldd	r24, Z+10	; 0x0a
    35a0:	89 2b       	or	r24, r25
    35a2:	87 b9       	out	0x07, r24	; 7

      /* get ADC reading (about 100탎) */
      while (ADCSRA & (1 << ADSC));     /* wait until conversion is done */
    35a4:	ea e7       	ldi	r30, 0x7A	; 122
    35a6:	f0 e0       	ldi	r31, 0x00	; 0
    35a8:	80 81       	ld	r24, Z
    35aa:	86 fd       	sbrc	r24, 6
    35ac:	fb cf       	rjmp	.-10     	; 0x35a4 <SmallResistor+0xfa>
      Value += ADCW;                    /* add ADC reading */
    35ae:	f5 01       	movw	r30, r10
    35b0:	80 81       	ld	r24, Z
    35b2:	91 81       	ldd	r25, Z+1	; 0x01
    35b4:	48 0e       	add	r4, r24
    35b6:	59 1e       	adc	r5, r25
    35b8:	61 1c       	adc	r6, r1
    35ba:	71 1c       	adc	r7, r1

      /* wait */
      wait400us();
    35bc:	0e 94 81 00 	call	0x102	; 0x102 <wait400us>
      wait500us();
    35c0:	0e 94 80 00 	call	0x100	; 0x100 <wait500us>
    35c4:	fa 94       	dec	r15

    /*
     *  measurement loop (about 1ms per cycle)
     */

    while (Counter < 100)
    35c6:	f1 10       	cpse	r15, r1
    35c8:	db cf       	rjmp	.-74     	; 0x3580 <SmallResistor+0xd6>

      Counter++;                        /* next round */
    }

    /* convert ADC reading to voltage */
    Value *= Config.Bandgap;
    35ca:	f1 01       	movw	r30, r2
    35cc:	a5 81       	ldd	r26, Z+5	; 0x05
    35ce:	b6 81       	ldd	r27, Z+6	; 0x06
    35d0:	a3 01       	movw	r20, r6
    35d2:	92 01       	movw	r18, r4
    35d4:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
    Value /= 1024;                 /* / 1024 for 10bit ADC */
    35d8:	05 2e       	mov	r0, r21
    35da:	5a e0       	ldi	r21, 0x0A	; 10
    35dc:	96 95       	lsr	r25
    35de:	87 95       	ror	r24
    35e0:	77 95       	ror	r23
    35e2:	67 95       	ror	r22
    35e4:	5a 95       	dec	r21
    35e6:	d1 f7       	brne	.-12     	; 0x35dc <SmallResistor+0x132>
    35e8:	50 2d       	mov	r21, r0
    Value /= 10;                   /* de-sample to 0.1mV */
    35ea:	2a e0       	ldi	r18, 0x0A	; 10
    35ec:	30 e0       	ldi	r19, 0x00	; 0
    35ee:	40 e0       	ldi	r20, 0x00	; 0
    35f0:	50 e0       	ldi	r21, 0x00	; 0
    35f2:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    35f6:	42 2e       	mov	r4, r18
    35f8:	53 2e       	mov	r5, r19
    35fa:	64 2e       	mov	r6, r20
    35fc:	75 2e       	mov	r7, r21

    /* loop control */
    if (Mode & MODE_HIGH)          /* probe #1 / Rl */
    {
      Mode = MODE_LOW;             /* switch to low side */
    35fe:	89 2d       	mov	r24, r9
    Value *= Config.Bandgap;
    Value /= 1024;                 /* / 1024 for 10bit ADC */
    Value /= 10;                   /* de-sample to 0.1mV */

    /* loop control */
    if (Mode & MODE_HIGH)          /* probe #1 / Rl */
    3600:	e1 10       	cpse	r14, r1
    3602:	98 cf       	rjmp	.-208    	; 0x3534 <SmallResistor+0x8a>
    3604:	55 c0       	rjmp	.+170    	; 0x36b0 <SmallResistor+0x206>
   */

  if (Value1 > Value2)             /* sanity check */
  {
    /* I = U/R = (5V - U_Rl)/(Rl + R_i_H) */
    Value = 10UL * Config.Vcc;               /* in 0.1 mV */
    3606:	ee e8       	ldi	r30, 0x8E	; 142
    3608:	f1 e0       	ldi	r31, 0x01	; 1
    360a:	87 81       	ldd	r24, Z+7	; 0x07
    360c:	90 85       	ldd	r25, Z+8	; 0x08
    360e:	a0 e0       	ldi	r26, 0x00	; 0
    3610:	b0 e0       	ldi	r27, 0x00	; 0
    3612:	88 0f       	add	r24, r24
    3614:	99 1f       	adc	r25, r25
    3616:	aa 1f       	adc	r26, r26
    3618:	bb 1f       	adc	r27, r27
    361a:	ac 01       	movw	r20, r24
    361c:	bd 01       	movw	r22, r26
    361e:	44 0f       	add	r20, r20
    3620:	55 1f       	adc	r21, r21
    3622:	66 1f       	adc	r22, r22
    3624:	77 1f       	adc	r23, r23
    3626:	44 0f       	add	r20, r20
    3628:	55 1f       	adc	r21, r21
    362a:	66 1f       	adc	r22, r22
    362c:	77 1f       	adc	r23, r23
    362e:	84 0f       	add	r24, r20
    3630:	95 1f       	adc	r25, r21
    3632:	a6 1f       	adc	r26, r22
    3634:	b7 1f       	adc	r27, r23
    Value -= Value1;
    3636:	9c 01       	movw	r18, r24
    3638:	ad 01       	movw	r20, r26
    363a:	24 19       	sub	r18, r4
    363c:	35 09       	sbc	r19, r5
    363e:	46 09       	sbc	r20, r6
    3640:	57 09       	sbc	r21, r7
    Value *= 1000;                           /* scale to 킕 */
    3642:	a8 ee       	ldi	r26, 0xE8	; 232
    3644:	b3 e0       	ldi	r27, 0x03	; 3
    3646:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
    364a:	4b 01       	movw	r8, r22
    364c:	5c 01       	movw	r10, r24
    Value /= ((R_LOW * 10) + Config.RiH);    /* in 0.1 Ohms */

    /* U = U_Rl - U_R_i_L = U_Rl - (R_i_L * I) */
    /* U = U_probe1 - U_probe2 */
    Value1 -= Value2;                        /* in 0.1 mV */
    364e:	a3 01       	movw	r20, r6
    3650:	92 01       	movw	r18, r4
    3652:	2c 19       	sub	r18, r12
    3654:	3d 09       	sbc	r19, r13
    3656:	4e 09       	sbc	r20, r14
    3658:	5f 09       	sbc	r21, r15
    Value1 *= 10000;                         /* scale to 0.01 킮 */
    365a:	a0 e1       	ldi	r26, 0x10	; 16
    365c:	b7 e2       	ldi	r27, 0x27	; 39
    365e:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
    3662:	6b 01       	movw	r12, r22
    3664:	7c 01       	movw	r14, r24
  {
    /* I = U/R = (5V - U_Rl)/(Rl + R_i_H) */
    Value = 10UL * Config.Vcc;               /* in 0.1 mV */
    Value -= Value1;
    Value *= 1000;                           /* scale to 킕 */
    Value /= ((R_LOW * 10) + Config.RiH);    /* in 0.1 Ohms */
    3666:	23 85       	ldd	r18, Z+11	; 0x0b
    3668:	34 85       	ldd	r19, Z+12	; 0x0c
    366a:	20 57       	subi	r18, 0x70	; 112
    366c:	35 4e       	sbci	r19, 0xE5	; 229
    366e:	40 e0       	ldi	r20, 0x00	; 0
    3670:	50 e0       	ldi	r21, 0x00	; 0
    3672:	c5 01       	movw	r24, r10
    3674:	b4 01       	movw	r22, r8
    3676:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    /* U = U_probe1 - U_probe2 */
    Value1 -= Value2;                        /* in 0.1 mV */
    Value1 *= 10000;                         /* scale to 0.01 킮 */

    /* R = U/I (including R of probe leads) */
    Value1 /= Value;                         /* in 0.01 Ohms */
    367a:	c7 01       	movw	r24, r14
    367c:	b6 01       	movw	r22, r12
    367e:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    R = (uint16_t)Value1;                    /* copy result */
    3682:	c9 01       	movw	r24, r18

    if (ZeroFlag == 1)        /* auto-zero */
    3684:	fd 81       	ldd	r31, Y+5	; 0x05
    3686:	f1 30       	cpi	r31, 0x01	; 1
    3688:	61 f4       	brne	.+24     	; 0x36a2 <SmallResistor+0x1f8>
    {
      if (R > Config.RZero) R -= Config.RZero;
    368a:	60 91 9b 01 	lds	r22, 0x019B
    368e:	70 91 9c 01 	lds	r23, 0x019C
    3692:	62 17       	cp	r22, r18
    3694:	73 07       	cpc	r23, r19
    3696:	18 f4       	brcc	.+6      	; 0x369e <SmallResistor+0x1f4>
    3698:	86 1b       	sub	r24, r22
    369a:	97 0b       	sbc	r25, r23
    369c:	02 c0       	rjmp	.+4      	; 0x36a2 <SmallResistor+0x1f8>
      else R = 0;
    369e:	80 e0       	ldi	r24, 0x00	; 0
    36a0:	90 e0       	ldi	r25, 0x00	; 0

#undef MODE_LOW
#undef MODE_HIGH

  /* update Uref flag for next ADC run */
  Config.RefFlag = (1 << REFS1);        /* set REFS1 bit flag */
    36a2:	20 e8       	ldi	r18, 0x80	; 128
    36a4:	20 93 92 01 	sts	0x0192, r18

  return R;
    36a8:	12 c0       	rjmp	.+36     	; 0x36ce <SmallResistor+0x224>
  uint32_t          Value;         /* ADC sample value */
  uint32_t          Value1 = 0;    /* U_Rl temp. value */
  uint32_t          Value2 = 0;    /* U_R_i_L temp. value */

  DischargeProbes();                    /* try to discharge probes */
  if (Check.Found == COMP_ERROR) return R;   /* skip on error */
    36aa:	80 e0       	ldi	r24, 0x00	; 0
    36ac:	90 e0       	ldi	r25, 0x00	; 0
    36ae:	0f c0       	rjmp	.+30     	; 0x36ce <SmallResistor+0x224>
    36b0:	73 01       	movw	r14, r6
    36b2:	62 01       	movw	r12, r4
    36b4:	49 80       	ldd	r4, Y+1	; 0x01
    36b6:	5a 80       	ldd	r5, Y+2	; 0x02
    36b8:	6b 80       	ldd	r6, Y+3	; 0x03
    36ba:	7c 80       	ldd	r7, Y+4	; 0x04

  /*
   *  process measurement
   */

  if (Value1 > Value2)             /* sanity check */
    36bc:	c4 14       	cp	r12, r4
    36be:	d5 04       	cpc	r13, r5
    36c0:	e6 04       	cpc	r14, r6
    36c2:	f7 04       	cpc	r15, r7
    36c4:	08 f4       	brcc	.+2      	; 0x36c8 <SmallResistor+0x21e>
    36c6:	9f cf       	rjmp	.-194    	; 0x3606 <SmallResistor+0x15c>
 *  - resistance in 0.01 Ohm
 */

uint16_t SmallResistor(uint8_t ZeroFlag)
{
  uint16_t          R = 0;         /* return value */
    36c8:	80 e0       	ldi	r24, 0x00	; 0
    36ca:	90 e0       	ldi	r25, 0x00	; 0
    36cc:	ea cf       	rjmp	.-44     	; 0x36a2 <SmallResistor+0x1f8>

  /* update Uref flag for next ADC run */
  Config.RefFlag = (1 << REFS1);        /* set REFS1 bit flag */

  return R;
}
    36ce:	0f 90       	pop	r0
    36d0:	0f 90       	pop	r0
    36d2:	0f 90       	pop	r0
    36d4:	0f 90       	pop	r0
    36d6:	0f 90       	pop	r0
    36d8:	df 91       	pop	r29
    36da:	cf 91       	pop	r28
    36dc:	1f 91       	pop	r17
    36de:	0f 91       	pop	r16
    36e0:	ff 90       	pop	r15
    36e2:	ef 90       	pop	r14
    36e4:	df 90       	pop	r13
    36e6:	cf 90       	pop	r12
    36e8:	bf 90       	pop	r11
    36ea:	af 90       	pop	r10
    36ec:	9f 90       	pop	r9
    36ee:	8f 90       	pop	r8
    36f0:	7f 90       	pop	r7
    36f2:	6f 90       	pop	r6
    36f4:	5f 90       	pop	r5
    36f6:	4f 90       	pop	r4
    36f8:	3f 90       	pop	r3
    36fa:	2f 90       	pop	r2
    36fc:	08 95       	ret

000036fe <CheckResistor>:
/*
 *  check for resistor
 */

void CheckResistor(void)
{
    36fe:	2f 92       	push	r2
    3700:	3f 92       	push	r3
    3702:	4f 92       	push	r4
    3704:	5f 92       	push	r5
    3706:	6f 92       	push	r6
    3708:	7f 92       	push	r7
    370a:	8f 92       	push	r8
    370c:	9f 92       	push	r9
    370e:	af 92       	push	r10
    3710:	bf 92       	push	r11
    3712:	cf 92       	push	r12
    3714:	df 92       	push	r13
    3716:	ef 92       	push	r14
    3718:	ff 92       	push	r15
    371a:	0f 93       	push	r16
    371c:	1f 93       	push	r17
    371e:	cf 93       	push	r28
    3720:	df 93       	push	r29
    3722:	cd b7       	in	r28, 0x3d	; 61
    3724:	de b7       	in	r29, 0x3e	; 62
    3726:	62 97       	sbiw	r28, 0x12	; 18
    3728:	0f b6       	in	r0, 0x3f	; 63
    372a:	f8 94       	cli
    372c:	de bf       	out	0x3e, r29	; 62
    372e:	0f be       	out	0x3f, r0	; 63
    3730:	cd bf       	out	0x3d, r28	; 61
  uint16_t          U_Ri_H;        /* voltage at Ri oulled up */
  uint16_t          U_Ri_L;        /* voltage at Ri pulled down */
  uint16_t          U_Rh_H;        /* voltage at Rh pulled up */
  uint16_t          U_Rh_L;        /* voltage ar Rh pulled down */

  wdt_reset();                     /* reset watchdog */
    3732:	a8 95       	wdr
  /* 
   *  Charge possible capacitor and get voltages for Rl pulled up.
   */

  /*  set probes: Gnd -- probe-2 / probe-1 -- Rl -- Vcc */
  ADC_PORT = 0;                         /* set ADC port to low */
    3734:	18 b8       	out	0x08, r1	; 8
  ADC_DDR = Probes.ADC_2;               /* pull down probe-2 directly */
    3736:	0d e7       	ldi	r16, 0x7D	; 125
    3738:	11 e0       	ldi	r17, 0x01	; 1
    373a:	d8 01       	movw	r26, r16
    373c:	1a 96       	adiw	r26, 0x0a	; 10
    373e:	8c 91       	ld	r24, X
    3740:	1a 97       	sbiw	r26, 0x0a	; 10
    3742:	87 b9       	out	0x07, r24	; 7
  R_DDR = Probes.Rl_1;                  /* enable Rl for probe-1 */
    3744:	13 96       	adiw	r26, 0x03	; 3
    3746:	8c 91       	ld	r24, X
    3748:	13 97       	sbiw	r26, 0x03	; 3
    374a:	84 b9       	out	0x04, r24	; 4
  R_PORT = Probes.Rl_1;                 /* pull up probe-1 via Rl */
    374c:	85 b9       	out	0x05, r24	; 5
  U_Ri_L = ReadU_5ms(Probes.Pin_2);     /* get voltage at internal R of MCU */
    374e:	11 96       	adiw	r26, 0x01	; 1
    3750:	8c 91       	ld	r24, X
    3752:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
    3756:	5c 01       	movw	r10, r24
  U_Rl_H = ReadU(Probes.Pin_1);         /* get voltage at Rl pulled up */
    3758:	f8 01       	movw	r30, r16
    375a:	80 81       	ld	r24, Z
    375c:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    3760:	6c 01       	movw	r12, r24
  /*
   *  discharge possible capacitor
   */

  /* set probes: Gnd -- probe-2 / Gnd -- Rh -- probe-1 */
  R_PORT = 0;                           /* set resistor port low */
    3762:	15 b8       	out	0x05, r1	; 5
  R_DDR = Probes.Rh_1;                  /* pull down probe-1 via Rh */
    3764:	d8 01       	movw	r26, r16
    3766:	14 96       	adiw	r26, 0x04	; 4
    3768:	9c 91       	ld	r25, X
    376a:	14 97       	sbiw	r26, 0x04	; 4
    376c:	94 b9       	out	0x04, r25	; 4
  U_Rh_L = ReadU_5ms(Probes.Pin_1);     /* get voltage at probe 1 */
    376e:	8c 91       	ld	r24, X
    3770:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>

  /* we got a resistor if the voltage is near Gnd */
  if (U_Rh_L <= 20)
    3774:	45 97       	sbiw	r24, 0x15	; 21
    3776:	08 f0       	brcs	.+2      	; 0x377a <CheckResistor+0x7c>
    3778:	94 c2       	rjmp	.+1320   	; 0x3ca2 <CheckResistor+0x5a4>
    /*
     *  get voltage at Rh pulled up
     */

    /* set probes: Gnd -- probe-2 / probe-1 -- Rh -- Vcc */
    R_PORT = Probes.Rh_1;                    /* pull up probe-1 via Rh */
    377a:	f8 01       	movw	r30, r16
    377c:	84 81       	ldd	r24, Z+4	; 0x04
    377e:	85 b9       	out	0x05, r24	; 5
    U_Rh_H = ReadU_5ms(Probes.Pin_1);        /* get voltage at Rh pulled up */
    3780:	80 81       	ld	r24, Z
    3782:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
    3786:	3c 01       	movw	r6, r24
    /*
     *  get voltage at Rl pulled down and Rh pulled down
     */

    /* set probes: Gnd -- Rl -- probe-2 / probe-1 -- Vcc */
    ADC_DDR = Probes.ADC_1;                  /* set probe-1 to output */
    3788:	d8 01       	movw	r26, r16
    378a:	19 96       	adiw	r26, 0x09	; 9
    378c:	9c 91       	ld	r25, X
    378e:	19 97       	sbiw	r26, 0x09	; 9
    3790:	97 b9       	out	0x07, r25	; 7
    ADC_PORT = Probes.ADC_1;                 /* pull up probe-1 directly */
    3792:	98 b9       	out	0x08, r25	; 8
    R_PORT = 0;                              /* set resistor port to low */ 
    3794:	15 b8       	out	0x05, r1	; 5
    R_DDR = Probes.Rl_2;                     /* pull down probe-2 via Rl */
    3796:	15 96       	adiw	r26, 0x05	; 5
    3798:	8c 91       	ld	r24, X
    379a:	15 97       	sbiw	r26, 0x05	; 5
    379c:	84 b9       	out	0x04, r24	; 4
    U_Ri_H = ReadU_5ms(Probes.Pin_1);        /* get voltage at internal R of MCU */
    379e:	8c 91       	ld	r24, X
    37a0:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
    37a4:	1c 01       	movw	r2, r24
    U_Rl_L = ReadU(Probes.Pin_2);            /* get voltage at Rl pulled down */
    37a6:	f8 01       	movw	r30, r16
    37a8:	81 81       	ldd	r24, Z+1	; 0x01
    37aa:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    37ae:	2c 01       	movw	r4, r24

    /* set probes: Gnd -- Rh -- probe-2 / probe-1 -- Vcc */
    R_DDR = Probes.Rh_2;                /* pull down probe-2 via Rh */
    37b0:	d8 01       	movw	r26, r16
    37b2:	16 96       	adiw	r26, 0x06	; 6
    37b4:	8c 91       	ld	r24, X
    37b6:	16 97       	sbiw	r26, 0x06	; 6
    37b8:	84 b9       	out	0x04, r24	; 4
    U_Rh_L = ReadU_5ms(Probes.Pin_2);   /* get voltage at Rh pulled down */
    37ba:	11 96       	adiw	r26, 0x01	; 1
    37bc:	8c 91       	ld	r24, X
    37be:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
    37c2:	7c 01       	movw	r14, r24

    /* if voltage breakdown is sufficient */
    if ((U_Rl_H >= 4400) || (U_Rh_H <= 97))   /* R >= 5.1k or R < 9.3k */
    37c4:	b0 e3       	ldi	r27, 0x30	; 48
    37c6:	cb 16       	cp	r12, r27
    37c8:	b1 e1       	ldi	r27, 0x11	; 17
    37ca:	db 06       	cpc	r13, r27
    37cc:	28 f4       	brcc	.+10     	; 0x37d8 <CheckResistor+0xda>
    37ce:	e2 e6       	ldi	r30, 0x62	; 98
    37d0:	6e 16       	cp	r6, r30
    37d2:	71 04       	cpc	r7, r1
    37d4:	08 f0       	brcs	.+2      	; 0x37d8 <CheckResistor+0xda>
    37d6:	65 c2       	rjmp	.+1226   	; 0x3ca2 <CheckResistor+0x5a4>
    {
      if (U_Rh_H < 4972)            /* R < 83.4M & prevent division by zero */
    37d8:	fc e6       	ldi	r31, 0x6C	; 108
    37da:	6f 16       	cp	r6, r31
    37dc:	f3 e1       	ldi	r31, 0x13	; 19
    37de:	7f 06       	cpc	r7, r31
    37e0:	08 f0       	brcs	.+2      	; 0x37e4 <CheckResistor+0xe6>
    37e2:	5f c2       	rjmp	.+1214   	; 0x3ca2 <CheckResistor+0x5a4>
        /* voltage breaks down with low test current and it is not nearly 
           shorted => resistor */

        Value = 0;                      /* reset value of resistor */

        if (U_Rl_L < 169)               /* R > 19.5k */
    37e4:	29 ea       	ldi	r18, 0xA9	; 169
    37e6:	42 16       	cp	r4, r18
    37e8:	51 04       	cpc	r5, r1
    37ea:	08 f0       	brcs	.+2      	; 0x37ee <CheckResistor+0xf0>
    37ec:	84 c0       	rjmp	.+264    	; 0x38f6 <CheckResistor+0x1f8>
          /*
           *  use measurements done with Rh
           */

          /* resistor is less than 60MOhm */
          if (U_Rh_L >= 38)        /* R < 61.4M & prevent division by zero */
    37ee:	36 e2       	ldi	r19, 0x26	; 38
    37f0:	e3 16       	cp	r14, r19
    37f2:	f1 04       	cpc	r15, r1
    37f4:	08 f4       	brcc	.+2      	; 0x37f8 <CheckResistor+0xfa>
    37f6:	55 c2       	rjmp	.+1194   	; 0x3ca2 <CheckResistor+0x5a4>
             *  Or via voltage divider:
             *  R = Rh * (U_dut / U_Rh)
             *    = Rh * (U_Rh_H / (Vcc - U_Rh_H))
             */

            Value1 = R_HIGH * U_Rh_H;
    37f8:	d3 01       	movw	r26, r6
    37fa:	20 ef       	ldi	r18, 0xF0	; 240
    37fc:	3b e2       	ldi	r19, 0x2B	; 43
    37fe:	47 e0       	ldi	r20, 0x07	; 7
    3800:	50 e0       	ldi	r21, 0x00	; 0
    3802:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
            Value1 /= (Config.Vcc - U_Rh_H);
    3806:	c0 90 95 01 	lds	r12, 0x0195
    380a:	d0 90 96 01 	lds	r13, 0x0196
    380e:	96 01       	movw	r18, r12
    3810:	26 19       	sub	r18, r6
    3812:	37 09       	sbc	r19, r7
    3814:	40 e0       	ldi	r20, 0x00	; 0
    3816:	50 e0       	ldi	r21, 0x00	; 0
    3818:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    381c:	49 01       	movw	r8, r18
    381e:	5a 01       	movw	r10, r20
             *  Or via voltage divider:
             *  R = Rh * (U_R / U_Rh)
             *    = Rh * ((Vcc - U_Rh_L) / U_Rh_L)
             */

            Value2 = R_HIGH * (Config.Vcc - U_Rh_L);
    3820:	d6 01       	movw	r26, r12
    3822:	ae 19       	sub	r26, r14
    3824:	bf 09       	sbc	r27, r15
    3826:	20 ef       	ldi	r18, 0xF0	; 240
    3828:	3b e2       	ldi	r19, 0x2B	; 43
    382a:	47 e0       	ldi	r20, 0x07	; 7
    382c:	50 e0       	ldi	r21, 0x00	; 0
    382e:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
            Value2 /= U_Rh_L;
    3832:	87 01       	movw	r16, r14
    3834:	20 e0       	ldi	r18, 0x00	; 0
    3836:	30 e0       	ldi	r19, 0x00	; 0
    3838:	a9 01       	movw	r20, r18
    383a:	98 01       	movw	r18, r16
    383c:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
             *  calculate weighted average of both measurements
             *  - Voltages below the bandgap reference got a higher resolution
             *    (1.1mV instead of 4.9mV).
             */

            if (U_Rh_H < 990)           /* below bandgap reference */
    3840:	8e ed       	ldi	r24, 0xDE	; 222
    3842:	68 16       	cp	r6, r24
    3844:	83 e0       	ldi	r24, 0x03	; 3
    3846:	78 06       	cpc	r7, r24
    3848:	a8 f4       	brcc	.+42     	; 0x3874 <CheckResistor+0x176>
            {
              /* weighted average for U_Rh_H */
              Value = (Value1 * 4);
    384a:	88 0c       	add	r8, r8
    384c:	99 1c       	adc	r9, r9
    384e:	aa 1c       	adc	r10, r10
    3850:	bb 1c       	adc	r11, r11
    3852:	88 0c       	add	r8, r8
    3854:	99 1c       	adc	r9, r9
    3856:	aa 1c       	adc	r10, r10
    3858:	bb 1c       	adc	r11, r11
              Value += Value2;
    385a:	c5 01       	movw	r24, r10
    385c:	b4 01       	movw	r22, r8
    385e:	62 0f       	add	r22, r18
    3860:	73 1f       	adc	r23, r19
    3862:	84 1f       	adc	r24, r20
    3864:	95 1f       	adc	r25, r21
              Value /= 5;
    3866:	25 e0       	ldi	r18, 0x05	; 5
    3868:	30 e0       	ldi	r19, 0x00	; 0
    386a:	40 e0       	ldi	r20, 0x00	; 0
    386c:	50 e0       	ldi	r21, 0x00	; 0
    386e:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    3872:	28 c0       	rjmp	.+80     	; 0x38c4 <CheckResistor+0x1c6>
            }
            else if (U_Rh_L < 990)      /* below bandgap reference */
    3874:	9e ed       	ldi	r25, 0xDE	; 222
    3876:	e9 16       	cp	r14, r25
    3878:	93 e0       	ldi	r25, 0x03	; 3
    387a:	f9 06       	cpc	r15, r25
    387c:	b8 f4       	brcc	.+46     	; 0x38ac <CheckResistor+0x1ae>
            {
              /* weighted average for U_Rh_L */
              Value = (Value2 * 4);
    387e:	da 01       	movw	r26, r20
    3880:	c9 01       	movw	r24, r18
    3882:	88 0f       	add	r24, r24
    3884:	99 1f       	adc	r25, r25
    3886:	aa 1f       	adc	r26, r26
    3888:	bb 1f       	adc	r27, r27
    388a:	88 0f       	add	r24, r24
    388c:	99 1f       	adc	r25, r25
    388e:	aa 1f       	adc	r26, r26
    3890:	bb 1f       	adc	r27, r27
              Value += Value1;
    3892:	bc 01       	movw	r22, r24
    3894:	cd 01       	movw	r24, r26
    3896:	68 0d       	add	r22, r8
    3898:	79 1d       	adc	r23, r9
    389a:	8a 1d       	adc	r24, r10
    389c:	9b 1d       	adc	r25, r11
              Value /= 5;
    389e:	25 e0       	ldi	r18, 0x05	; 5
    38a0:	30 e0       	ldi	r19, 0x00	; 0
    38a2:	40 e0       	ldi	r20, 0x00	; 0
    38a4:	50 e0       	ldi	r21, 0x00	; 0
    38a6:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    38aa:	0c c0       	rjmp	.+24     	; 0x38c4 <CheckResistor+0x1c6>
            }
            else                        /* higher than bandgap reference */
            {
              /* classic average */
              Value = (Value1 + Value2) / 2;
    38ac:	da 01       	movw	r26, r20
    38ae:	c9 01       	movw	r24, r18
    38b0:	88 0d       	add	r24, r8
    38b2:	99 1d       	adc	r25, r9
    38b4:	aa 1d       	adc	r26, r10
    38b6:	bb 1d       	adc	r27, r11
    38b8:	9c 01       	movw	r18, r24
    38ba:	ad 01       	movw	r20, r26
    38bc:	56 95       	lsr	r21
    38be:	47 95       	ror	r20
    38c0:	37 95       	ror	r19
    38c2:	27 95       	ror	r18
            }

            Value += RH_OFFSET;         /* add offset value for Rh */
    38c4:	da 01       	movw	r26, r20
    38c6:	c9 01       	movw	r24, r18
    38c8:	84 54       	subi	r24, 0x44	; 68
    38ca:	9d 4f       	sbci	r25, 0xFD	; 253
    38cc:	af 4f       	sbci	r26, 0xFF	; 255
    38ce:	bf 4f       	sbci	r27, 0xFF	; 255
            Value *= 10;                /* upscale to 0.1 Ohms */
    38d0:	88 0f       	add	r24, r24
    38d2:	99 1f       	adc	r25, r25
    38d4:	aa 1f       	adc	r26, r26
    38d6:	bb 1f       	adc	r27, r27
    38d8:	4c 01       	movw	r8, r24
    38da:	5d 01       	movw	r10, r26
    38dc:	88 0c       	add	r8, r8
    38de:	99 1c       	adc	r9, r9
    38e0:	aa 1c       	adc	r10, r10
    38e2:	bb 1c       	adc	r11, r11
    38e4:	88 0c       	add	r8, r8
    38e6:	99 1c       	adc	r9, r9
    38e8:	aa 1c       	adc	r10, r10
    38ea:	bb 1c       	adc	r11, r11
    38ec:	88 0e       	add	r8, r24
    38ee:	99 1e       	adc	r9, r25
    38f0:	aa 1e       	adc	r10, r26
    38f2:	bb 1e       	adc	r11, r27
    38f4:	8c c0       	rjmp	.+280    	; 0x3a0e <CheckResistor+0x310>
           *  use measurements done with Rl
           */

          /* voltages below and above DUT match voltage divider */
          /* voltage below DUT can't be higher than above DUT */
          if ((U_Rl_H >= U_Ri_L) && (U_Ri_H >= U_Rl_L))
    38f6:	ca 14       	cp	r12, r10
    38f8:	db 04       	cpc	r13, r11
    38fa:	08 f4       	brcc	.+2      	; 0x38fe <CheckResistor+0x200>
    38fc:	7a c0       	rjmp	.+244    	; 0x39f2 <CheckResistor+0x2f4>
    38fe:	24 14       	cp	r2, r4
    3900:	35 04       	cpc	r3, r5
    3902:	08 f4       	brcc	.+2      	; 0x3906 <CheckResistor+0x208>
    3904:	76 c0       	rjmp	.+236    	; 0x39f2 <CheckResistor+0x2f4>
             *  Or via voltage divider:
             *  R = (Rl + RiH) * (U_R_RiL / U_Rl_RiH) - RiL
             *    = (Rl + RiH) * (U_R_RiL / (Vcc - U_dut_RiL)) - RiL
             */

            if (U_Rl_H == Config.Vcc) U_Rl_H = Config.Vcc - 1;   /* prevent division by zero */
    3906:	40 91 95 01 	lds	r20, 0x0195
    390a:	50 91 96 01 	lds	r21, 0x0196
    390e:	4c 15       	cp	r20, r12
    3910:	5d 05       	cpc	r21, r13
    3912:	21 f4       	brne	.+8      	; 0x391c <CheckResistor+0x21e>
    3914:	6a 01       	movw	r12, r20
    3916:	a1 e0       	ldi	r26, 0x01	; 1
    3918:	ca 1a       	sub	r12, r26
    391a:	d1 08       	sbc	r13, r1
            Value1 = (R_LOW * 10) + Config.RiH;        /* Rl + RiH in 0.1 Ohm */
    391c:	0e e8       	ldi	r16, 0x8E	; 142
    391e:	11 e0       	ldi	r17, 0x01	; 1
    3920:	f8 01       	movw	r30, r16
    3922:	23 85       	ldd	r18, Z+11	; 0x0b
    3924:	34 85       	ldd	r19, Z+12	; 0x0c
    3926:	20 57       	subi	r18, 0x70	; 112
    3928:	35 4e       	sbci	r19, 0xE5	; 229
            Value1 *= (U_Rl_H - U_Ri_L);
    392a:	d6 01       	movw	r26, r12
    392c:	aa 19       	sub	r26, r10
    392e:	bb 09       	sbc	r27, r11
    3930:	0e 94 87 28 	call	0x510e	; 0x510e <__umulhisi3>
            Value1 /= (Config.Vcc - U_Rl_H);
    3934:	9a 01       	movw	r18, r20
    3936:	2c 19       	sub	r18, r12
    3938:	3d 09       	sbc	r19, r13
    393a:	40 e0       	ldi	r20, 0x00	; 0
    393c:	50 e0       	ldi	r21, 0x00	; 0
    393e:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    3942:	49 01       	movw	r8, r18
    3944:	5a 01       	movw	r10, r20
             *  Or via voltage divider:
             *  R = (Rl + RiL) * (U_R_RiH / U_Rl_RiL) - RiH
             *    = (Rl + RiL) * ((Vcc - U_Rl_RiL) / U_Rl_RiL) - RiH
             */

            Value2 = (R_LOW * 10) + Config.RiL;   /* Rl + RiL in 0.1 Ohms */
    3946:	d8 01       	movw	r26, r16
    3948:	19 96       	adiw	r26, 0x09	; 9
    394a:	2d 91       	ld	r18, X+
    394c:	3c 91       	ld	r19, X
    394e:	1a 97       	sbiw	r26, 0x0a	; 10
    3950:	20 57       	subi	r18, 0x70	; 112
    3952:	35 4e       	sbci	r19, 0xE5	; 229
            Value2 *= (U_Ri_H - U_Rl_L);
    3954:	d1 01       	movw	r26, r2
    3956:	a4 19       	sub	r26, r4
    3958:	b5 09       	sbc	r27, r5
    395a:	0e 94 87 28 	call	0x510e	; 0x510e <__umulhisi3>
            Value2 /= U_Rl_L;
    395e:	82 01       	movw	r16, r4
    3960:	20 e0       	ldi	r18, 0x00	; 0
    3962:	30 e0       	ldi	r19, 0x00	; 0
    3964:	a9 01       	movw	r20, r18
    3966:	98 01       	movw	r18, r16
    3968:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
             *  calculate weighted average of both measurements
             *  - Voltages below the bandgap reference got a higher resolution
             *    (1.1mV instead of 4.9mV).
             */

            if (U_Rl_H < 990)           /* below bandgap reference */
    396c:	be ed       	ldi	r27, 0xDE	; 222
    396e:	cb 16       	cp	r12, r27
    3970:	b3 e0       	ldi	r27, 0x03	; 3
    3972:	db 06       	cpc	r13, r27
    3974:	b8 f4       	brcc	.+46     	; 0x39a4 <CheckResistor+0x2a6>
            {
              /* weighted average for U_Rh_H */
              Value = (Value1 * 4);
    3976:	88 0c       	add	r8, r8
    3978:	99 1c       	adc	r9, r9
    397a:	aa 1c       	adc	r10, r10
    397c:	bb 1c       	adc	r11, r11
    397e:	88 0c       	add	r8, r8
    3980:	99 1c       	adc	r9, r9
    3982:	aa 1c       	adc	r10, r10
    3984:	bb 1c       	adc	r11, r11
              Value += Value2;
    3986:	c5 01       	movw	r24, r10
    3988:	b4 01       	movw	r22, r8
    398a:	62 0f       	add	r22, r18
    398c:	73 1f       	adc	r23, r19
    398e:	84 1f       	adc	r24, r20
    3990:	95 1f       	adc	r25, r21
              Value /= 5;
    3992:	25 e0       	ldi	r18, 0x05	; 5
    3994:	30 e0       	ldi	r19, 0x00	; 0
    3996:	40 e0       	ldi	r20, 0x00	; 0
    3998:	50 e0       	ldi	r21, 0x00	; 0
    399a:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    399e:	49 01       	movw	r8, r18
    39a0:	5a 01       	movw	r10, r20
    39a2:	35 c0       	rjmp	.+106    	; 0x3a0e <CheckResistor+0x310>
            }
            else if (U_Rl_L < 990)      /* below bandgap reference */
    39a4:	ee ed       	ldi	r30, 0xDE	; 222
    39a6:	4e 16       	cp	r4, r30
    39a8:	e3 e0       	ldi	r30, 0x03	; 3
    39aa:	5e 06       	cpc	r5, r30
    39ac:	c8 f4       	brcc	.+50     	; 0x39e0 <CheckResistor+0x2e2>
            {
              /* weighted average for U_Rh_L */
              Value = (Value2 * 4);
    39ae:	da 01       	movw	r26, r20
    39b0:	c9 01       	movw	r24, r18
    39b2:	88 0f       	add	r24, r24
    39b4:	99 1f       	adc	r25, r25
    39b6:	aa 1f       	adc	r26, r26
    39b8:	bb 1f       	adc	r27, r27
    39ba:	88 0f       	add	r24, r24
    39bc:	99 1f       	adc	r25, r25
    39be:	aa 1f       	adc	r26, r26
    39c0:	bb 1f       	adc	r27, r27
              Value += Value1;
    39c2:	bc 01       	movw	r22, r24
    39c4:	cd 01       	movw	r24, r26
    39c6:	68 0d       	add	r22, r8
    39c8:	79 1d       	adc	r23, r9
    39ca:	8a 1d       	adc	r24, r10
    39cc:	9b 1d       	adc	r25, r11
              Value /= 5;
    39ce:	25 e0       	ldi	r18, 0x05	; 5
    39d0:	30 e0       	ldi	r19, 0x00	; 0
    39d2:	40 e0       	ldi	r20, 0x00	; 0
    39d4:	50 e0       	ldi	r21, 0x00	; 0
    39d6:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    39da:	49 01       	movw	r8, r18
    39dc:	5a 01       	movw	r10, r20
    39de:	17 c0       	rjmp	.+46     	; 0x3a0e <CheckResistor+0x310>
            }
            else                        /* higher than bandgap reference */
            {
              /* classic average */
              Value = (Value1 + Value2) / 2;
    39e0:	82 0e       	add	r8, r18
    39e2:	93 1e       	adc	r9, r19
    39e4:	a4 1e       	adc	r10, r20
    39e6:	b5 1e       	adc	r11, r21
    39e8:	b6 94       	lsr	r11
    39ea:	a7 94       	ror	r10
    39ec:	97 94       	ror	r9
    39ee:	87 94       	ror	r8
    39f0:	0e c0       	rjmp	.+28     	; 0x3a0e <CheckResistor+0x310>
            }
          }
          else      /* may happen for very low resistances */
          {
            if (U_Rl_L > 4750) Value = 1;    /* U_Rl_L: R < 15 Ohms */
    39f2:	31 e0       	ldi	r19, 0x01	; 1
    39f4:	20 e0       	ldi	r18, 0x00	; 0
    39f6:	90 e0       	ldi	r25, 0x00	; 0
    39f8:	80 e0       	ldi	r24, 0x00	; 0
    39fa:	ff e8       	ldi	r31, 0x8F	; 143
    39fc:	4f 16       	cp	r4, r31
    39fe:	f2 e1       	ldi	r31, 0x12	; 18
    3a00:	5f 06       	cpc	r5, r31
    3a02:	08 f4       	brcc	.+2      	; 0x3a06 <CheckResistor+0x308>
    3a04:	30 e0       	ldi	r19, 0x00	; 0
              /* classic average */
              Value = (Value1 + Value2) / 2;
            }

            Value += RH_OFFSET;         /* add offset value for Rh */
            Value *= 10;                /* upscale to 0.1 Ohms */
    3a06:	83 2e       	mov	r8, r19
    3a08:	92 2e       	mov	r9, r18
    3a0a:	a9 2e       	mov	r10, r25
    3a0c:	b8 2e       	mov	r11, r24

        /*
         *  process results of the resistance measurement
         */

        if (Value > 0)             /* valid resistor */
    3a0e:	81 14       	cp	r8, r1
    3a10:	91 04       	cpc	r9, r1
    3a12:	a1 04       	cpc	r10, r1
    3a14:	b1 04       	cpc	r11, r1
    3a16:	09 f4       	brne	.+2      	; 0x3a1a <CheckResistor+0x31c>
    3a18:	44 c1       	rjmp	.+648    	; 0x3ca2 <CheckResistor+0x5a4>

          /*
           *  meassure small resistor <10 Ohm with special method
           */

          if (Value < 100UL)
    3a1a:	24 e6       	ldi	r18, 0x64	; 100
    3a1c:	82 16       	cp	r8, r18
    3a1e:	91 04       	cpc	r9, r1
    3a20:	a1 04       	cpc	r10, r1
    3a22:	b1 04       	cpc	r11, r1
    3a24:	48 f5       	brcc	.+82     	; 0x3a78 <CheckResistor+0x37a>
          {
            /* run low resistance measurement (in 0.01 Ohms) */
            Value2 = (uint32_t)SmallResistor(1);
    3a26:	81 e0       	ldi	r24, 0x01	; 1
    3a28:	0e 94 55 1a 	call	0x34aa	; 0x34aa <SmallResistor>
    3a2c:	a0 e0       	ldi	r26, 0x00	; 0
    3a2e:	b0 e0       	ldi	r27, 0x00	; 0

            /* check for valid result */
            Value1 = Value * 2;         /* allow 100% tolerance */       
            Value1 *= 10;               /* re-scale to 0.01 Ohms */     
    3a30:	95 01       	movw	r18, r10
    3a32:	84 01       	movw	r16, r8
    3a34:	00 0f       	add	r16, r16
    3a36:	11 1f       	adc	r17, r17
    3a38:	22 1f       	adc	r18, r18
    3a3a:	33 1f       	adc	r19, r19
    3a3c:	00 0f       	add	r16, r16
    3a3e:	11 1f       	adc	r17, r17
    3a40:	22 1f       	adc	r18, r18
    3a42:	33 1f       	adc	r19, r19
    3a44:	b9 01       	movw	r22, r18
    3a46:	a8 01       	movw	r20, r16
    3a48:	44 0f       	add	r20, r20
    3a4a:	55 1f       	adc	r21, r21
    3a4c:	66 1f       	adc	r22, r22
    3a4e:	77 1f       	adc	r23, r23
    3a50:	44 0f       	add	r20, r20
    3a52:	55 1f       	adc	r21, r21
    3a54:	66 1f       	adc	r22, r22
    3a56:	77 1f       	adc	r23, r23
    3a58:	40 0f       	add	r20, r16
    3a5a:	51 1f       	adc	r21, r17
    3a5c:	62 1f       	adc	r22, r18
    3a5e:	73 1f       	adc	r23, r19

            if (Value1 > Value2)        /* got expected value */
    3a60:	84 17       	cp	r24, r20
    3a62:	95 07       	cpc	r25, r21
    3a64:	a6 07       	cpc	r26, r22
    3a66:	b7 07       	cpc	r27, r23
    3a68:	50 f4       	brcc	.+20     	; 0x3a7e <CheckResistor+0x380>
            {
              Value = Value2;           /* update data */
    3a6a:	4c 01       	movw	r8, r24
    3a6c:	5d 01       	movw	r10, r26
              Scale = -2;               /* 0.01 Ohm */
    3a6e:	0f 2e       	mov	r0, r31
    3a70:	fe ef       	ldi	r31, 0xFE	; 254
    3a72:	ff 2e       	mov	r15, r31
    3a74:	f0 2d       	mov	r31, r0
    3a76:	05 c0       	rjmp	.+10     	; 0x3a82 <CheckResistor+0x384>
         *  process results of the resistance measurement
         */

        if (Value > 0)             /* valid resistor */
        {
          Scale = -1;              /* 0.1 Ohm by default */
    3a78:	ff 24       	eor	r15, r15
    3a7a:	fa 94       	dec	r15
    3a7c:	02 c0       	rjmp	.+4      	; 0x3a82 <CheckResistor+0x384>
    3a7e:	ff 24       	eor	r15, r15
    3a80:	fa 94       	dec	r15
              {
                Temp = Value / 2;            /* 50% */
              }
              else                                     /* >= 2 Ohm */
              {
                Temp = Value / 20;           /* 5% */
    3a82:	c5 01       	movw	r24, r10
    3a84:	b4 01       	movw	r22, r8
    3a86:	24 e1       	ldi	r18, 0x14	; 20
    3a88:	30 e0       	ldi	r19, 0x00	; 0
    3a8a:	40 e0       	ldi	r20, 0x00	; 0
    3a8c:	50 e0       	ldi	r21, 0x00	; 0
    3a8e:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>

              /* special case for very low resistance */
              if (CmpValue(Value, Scale, 1, -1) == -1)   /* < 0.1 Ohm */
              {
                Value1 = 0;                  /* 0 */
                Value2 = Value * 5;          /* 500% */
    3a92:	d5 01       	movw	r26, r10
    3a94:	c4 01       	movw	r24, r8
    3a96:	88 0f       	add	r24, r24
    3a98:	99 1f       	adc	r25, r25
    3a9a:	aa 1f       	adc	r26, r26
    3a9c:	bb 1f       	adc	r27, r27
    3a9e:	88 0f       	add	r24, r24
    3aa0:	99 1f       	adc	r25, r25
    3aa2:	aa 1f       	adc	r26, r26
    3aa4:	bb 1f       	adc	r27, r27
    3aa6:	2c 01       	movw	r4, r24
    3aa8:	3d 01       	movw	r6, r26
    3aaa:	48 0c       	add	r4, r8
    3aac:	59 1c       	adc	r5, r9
    3aae:	6a 1c       	adc	r6, r10
    3ab0:	7b 1c       	adc	r7, r11

          /*
           *  check for measurement in reversed direction
           */

          n = 0;
    3ab2:	80 e0       	ldi	r24, 0x00	; 0
          while (n < Check.Resistors)           /* loop through resistors */
    3ab4:	0f 2e       	mov	r0, r31
    3ab6:	f0 e0       	ldi	r31, 0x00	; 0
    3ab8:	2f 2e       	mov	r2, r31
    3aba:	f1 e0       	ldi	r31, 0x01	; 1
    3abc:	3f 2e       	mov	r3, r31
    3abe:	f0 2d       	mov	r31, r0
          {
            Resistor = &Resistors[n];           /* pointer to element */

            if ((Resistor->A == Probes.Pin_1) && (Resistor->B == Probes.Pin_2))
    3ac0:	0f 2e       	mov	r0, r31
    3ac2:	fd e7       	ldi	r31, 0x7D	; 125
    3ac4:	cf 2e       	mov	r12, r31
    3ac6:	f1 e0       	ldi	r31, 0x01	; 1
    3ac8:	df 2e       	mov	r13, r31
    3aca:	f0 2d       	mov	r31, r0

              /* special case for very low resistance */
              if (CmpValue(Value, Scale, 1, -1) == -1)   /* < 0.1 Ohm */
              {
                Value1 = 0;                  /* 0 */
                Value2 = Value * 5;          /* 500% */
    3acc:	4d 86       	std	Y+13, r4	; 0x0d
    3ace:	5e 86       	std	Y+14, r5	; 0x0e
    3ad0:	6f 86       	std	Y+15, r6	; 0x0f
    3ad2:	78 8a       	std	Y+16, r7	; 0x10
              {
                Temp = Value / 2;            /* 50% */
              }
              else                                     /* >= 2 Ohm */
              {
                Temp = Value / 20;           /* 5% */
    3ad4:	2d 83       	std	Y+5, r18	; 0x05
    3ad6:	3e 83       	std	Y+6, r19	; 0x06
    3ad8:	4f 83       	std	Y+7, r20	; 0x07
    3ada:	58 87       	std	Y+8, r21	; 0x08
               */

              /* set lower and upper tolerance limits */
              if (CmpValue(Value, Scale, 2, 0) == -1)  /* < 2 Ohm */
              {
                Temp = Value / 2;            /* 50% */
    3adc:	a5 01       	movw	r20, r10
    3ade:	94 01       	movw	r18, r8
    3ae0:	56 95       	lsr	r21
    3ae2:	47 95       	ror	r20
    3ae4:	37 95       	ror	r19
    3ae6:	27 95       	ror	r18
    3ae8:	29 87       	std	Y+9, r18	; 0x09
    3aea:	3a 87       	std	Y+10, r19	; 0x0a
    3aec:	4b 87       	std	Y+11, r20	; 0x0b
    3aee:	5c 87       	std	Y+12, r21	; 0x0c
          /*
           *  check for measurement in reversed direction
           */

          n = 0;
          while (n < Check.Resistors)           /* loop through resistors */
    3af0:	b8 c0       	rjmp	.+368    	; 0x3c62 <CheckResistor+0x564>
          {
            Resistor = &Resistors[n];           /* pointer to element */

            if ((Resistor->A == Probes.Pin_1) && (Resistor->B == Probes.Pin_2))
    3af2:	48 2f       	mov	r20, r24
    3af4:	50 e0       	ldi	r21, 0x00	; 0
    3af6:	5a 8b       	std	Y+18, r21	; 0x12
    3af8:	49 8b       	std	Y+17, r20	; 0x11
    3afa:	57 e0       	ldi	r21, 0x07	; 7
    3afc:	85 9f       	mul	r24, r21
    3afe:	f0 01       	movw	r30, r0
    3b00:	11 24       	eor	r1, r1
    3b02:	e8 5f       	subi	r30, 0xF8	; 248
    3b04:	fe 4f       	sbci	r31, 0xFE	; 254
    3b06:	20 81       	ld	r18, Z
    3b08:	d6 01       	movw	r26, r12
    3b0a:	9c 91       	ld	r25, X
    3b0c:	29 13       	cpse	r18, r25
    3b0e:	a4 c0       	rjmp	.+328    	; 0x3c58 <CheckResistor+0x55a>
    3b10:	e9 89       	ldd	r30, Y+17	; 0x11
    3b12:	fa 89       	ldd	r31, Y+18	; 0x12
    3b14:	ee 0f       	add	r30, r30
    3b16:	ff 1f       	adc	r31, r31
    3b18:	ee 0f       	add	r30, r30
    3b1a:	ff 1f       	adc	r31, r31
    3b1c:	ee 0f       	add	r30, r30
    3b1e:	ff 1f       	adc	r31, r31
    3b20:	29 89       	ldd	r18, Y+17	; 0x11
    3b22:	3a 89       	ldd	r19, Y+18	; 0x12
    3b24:	e2 1b       	sub	r30, r18
    3b26:	f3 0b       	sbc	r31, r19
    3b28:	e8 5f       	subi	r30, 0xF8	; 248
    3b2a:	fe 4f       	sbci	r31, 0xFE	; 254
    3b2c:	21 81       	ldd	r18, Z+1	; 0x01
    3b2e:	11 96       	adiw	r26, 0x01	; 1
    3b30:	9c 91       	ld	r25, X
    3b32:	29 13       	cpse	r18, r25
    3b34:	91 c0       	rjmp	.+290    	; 0x3c58 <CheckResistor+0x55a>
              /*
               *  check if the reversed measurement is within a specific tolerance
               */

              /* set lower and upper tolerance limits */
              if (CmpValue(Value, Scale, 2, 0) == -1)  /* < 2 Ohm */
    3b36:	e1 2c       	mov	r14, r1
    3b38:	02 e0       	ldi	r16, 0x02	; 2
    3b3a:	10 e0       	ldi	r17, 0x00	; 0
    3b3c:	20 e0       	ldi	r18, 0x00	; 0
    3b3e:	30 e0       	ldi	r19, 0x00	; 0
    3b40:	4f 2d       	mov	r20, r15
    3b42:	c5 01       	movw	r24, r10
    3b44:	b4 01       	movw	r22, r8
    3b46:	0e 94 a6 24 	call	0x494c	; 0x494c <CmpValue>
    3b4a:	8f 3f       	cpi	r24, 0xFF	; 255
    3b4c:	49 f4       	brne	.+18     	; 0x3b60 <CheckResistor+0x462>
              {
                Temp = Value / 2;            /* 50% */
    3b4e:	89 85       	ldd	r24, Y+9	; 0x09
    3b50:	9a 85       	ldd	r25, Y+10	; 0x0a
    3b52:	ab 85       	ldd	r26, Y+11	; 0x0b
    3b54:	bc 85       	ldd	r27, Y+12	; 0x0c
    3b56:	89 83       	std	Y+1, r24	; 0x01
    3b58:	9a 83       	std	Y+2, r25	; 0x02
    3b5a:	ab 83       	std	Y+3, r26	; 0x03
    3b5c:	bc 83       	std	Y+4, r27	; 0x04
    3b5e:	08 c0       	rjmp	.+16     	; 0x3b70 <CheckResistor+0x472>
              }
              else                                     /* >= 2 Ohm */
              {
                Temp = Value / 20;           /* 5% */
    3b60:	9d 81       	ldd	r25, Y+5	; 0x05
    3b62:	99 83       	std	Y+1, r25	; 0x01
    3b64:	ae 81       	ldd	r26, Y+6	; 0x06
    3b66:	aa 83       	std	Y+2, r26	; 0x02
    3b68:	bf 81       	ldd	r27, Y+7	; 0x07
    3b6a:	bb 83       	std	Y+3, r27	; 0x03
    3b6c:	e8 85       	ldd	r30, Y+8	; 0x08
    3b6e:	ec 83       	std	Y+4, r30	; 0x04

              Value1 = Value - Temp;         /* 95% or 50% */
              Value2 = Value + Temp;         /* 105% or 150% */

              /* special case for very low resistance */
              if (CmpValue(Value, Scale, 1, -1) == -1)   /* < 0.1 Ohm */
    3b70:	ee 24       	eor	r14, r14
    3b72:	ea 94       	dec	r14
    3b74:	01 e0       	ldi	r16, 0x01	; 1
    3b76:	10 e0       	ldi	r17, 0x00	; 0
    3b78:	20 e0       	ldi	r18, 0x00	; 0
    3b7a:	30 e0       	ldi	r19, 0x00	; 0
    3b7c:	4f 2d       	mov	r20, r15
    3b7e:	c5 01       	movw	r24, r10
    3b80:	b4 01       	movw	r22, r8
    3b82:	0e 94 a6 24 	call	0x494c	; 0x494c <CmpValue>
    3b86:	8f 3f       	cpi	r24, 0xFF	; 255
    3b88:	99 f0       	breq	.+38     	; 0x3bb0 <CheckResistor+0x4b2>
              else                                     /* >= 2 Ohm */
              {
                Temp = Value / 20;           /* 5% */
              }

              Value1 = Value - Temp;         /* 95% or 50% */
    3b8a:	95 01       	movw	r18, r10
    3b8c:	84 01       	movw	r16, r8
    3b8e:	89 81       	ldd	r24, Y+1	; 0x01
    3b90:	9a 81       	ldd	r25, Y+2	; 0x02
    3b92:	ab 81       	ldd	r26, Y+3	; 0x03
    3b94:	bc 81       	ldd	r27, Y+4	; 0x04
    3b96:	08 1b       	sub	r16, r24
    3b98:	19 0b       	sbc	r17, r25
    3b9a:	2a 0b       	sbc	r18, r26
    3b9c:	3b 0b       	sbc	r19, r27
              Value2 = Value + Temp;         /* 105% or 150% */
    3b9e:	88 0d       	add	r24, r8
    3ba0:	99 1d       	adc	r25, r9
    3ba2:	aa 1d       	adc	r26, r10
    3ba4:	bb 1d       	adc	r27, r11
    3ba6:	89 83       	std	Y+1, r24	; 0x01
    3ba8:	9a 83       	std	Y+2, r25	; 0x02
    3baa:	ab 83       	std	Y+3, r26	; 0x03
    3bac:	bc 83       	std	Y+4, r27	; 0x04
    3bae:	1b c0       	rjmp	.+54     	; 0x3be6 <CheckResistor+0x4e8>
              /* special case for very low resistance */
              if (CmpValue(Value, Scale, 1, -1) == -1)   /* < 0.1 Ohm */
              {
                Value1 = 0;                  /* 0 */
                Value2 = Value * 5;          /* 500% */
                if (Value2 == 0) Value2 = 5;   /* special case */
    3bb0:	41 14       	cp	r4, r1
    3bb2:	51 04       	cpc	r5, r1
    3bb4:	61 04       	cpc	r6, r1
    3bb6:	71 04       	cpc	r7, r1
    3bb8:	51 f4       	brne	.+20     	; 0x3bce <CheckResistor+0x4d0>
    3bba:	95 e0       	ldi	r25, 0x05	; 5
    3bbc:	99 83       	std	Y+1, r25	; 0x01
    3bbe:	1a 82       	std	Y+2, r1	; 0x02
    3bc0:	1b 82       	std	Y+3, r1	; 0x03
    3bc2:	1c 82       	std	Y+4, r1	; 0x04
              Value2 = Value + Temp;         /* 105% or 150% */

              /* special case for very low resistance */
              if (CmpValue(Value, Scale, 1, -1) == -1)   /* < 0.1 Ohm */
              {
                Value1 = 0;                  /* 0 */
    3bc4:	00 e0       	ldi	r16, 0x00	; 0
    3bc6:	10 e0       	ldi	r17, 0x00	; 0
    3bc8:	20 e0       	ldi	r18, 0x00	; 0
    3bca:	30 e0       	ldi	r19, 0x00	; 0
    3bcc:	0c c0       	rjmp	.+24     	; 0x3be6 <CheckResistor+0x4e8>
                Value2 = Value * 5;          /* 500% */
    3bce:	ad 85       	ldd	r26, Y+13	; 0x0d
    3bd0:	a9 83       	std	Y+1, r26	; 0x01
    3bd2:	be 85       	ldd	r27, Y+14	; 0x0e
    3bd4:	ba 83       	std	Y+2, r27	; 0x02
    3bd6:	ef 85       	ldd	r30, Y+15	; 0x0f
    3bd8:	eb 83       	std	Y+3, r30	; 0x03
    3bda:	f8 89       	ldd	r31, Y+16	; 0x10
    3bdc:	fc 83       	std	Y+4, r31	; 0x04
              Value2 = Value + Temp;         /* 105% or 150% */

              /* special case for very low resistance */
              if (CmpValue(Value, Scale, 1, -1) == -1)   /* < 0.1 Ohm */
              {
                Value1 = 0;                  /* 0 */
    3bde:	00 e0       	ldi	r16, 0x00	; 0
    3be0:	10 e0       	ldi	r17, 0x00	; 0
    3be2:	20 e0       	ldi	r18, 0x00	; 0
    3be4:	30 e0       	ldi	r19, 0x00	; 0
                Value2 = Value * 5;          /* 500% */
                if (Value2 == 0) Value2 = 5;   /* special case */
              }

              /* check if value matches given tolerance */
              if ((CmpValue(Resistor->Value, Resistor->Scale, Value1, Scale) >= 0) &&
    3be6:	e9 89       	ldd	r30, Y+17	; 0x11
    3be8:	fa 89       	ldd	r31, Y+18	; 0x12
    3bea:	ee 0f       	add	r30, r30
    3bec:	ff 1f       	adc	r31, r31
    3bee:	ee 0f       	add	r30, r30
    3bf0:	ff 1f       	adc	r31, r31
    3bf2:	ee 0f       	add	r30, r30
    3bf4:	ff 1f       	adc	r31, r31
    3bf6:	49 89       	ldd	r20, Y+17	; 0x11
    3bf8:	5a 89       	ldd	r21, Y+18	; 0x12
    3bfa:	e4 1b       	sub	r30, r20
    3bfc:	f5 0b       	sbc	r31, r21
    3bfe:	e8 5f       	subi	r30, 0xF8	; 248
    3c00:	fe 4f       	sbci	r31, 0xFE	; 254
    3c02:	63 81       	ldd	r22, Z+3	; 0x03
    3c04:	74 81       	ldd	r23, Z+4	; 0x04
    3c06:	85 81       	ldd	r24, Z+5	; 0x05
    3c08:	96 81       	ldd	r25, Z+6	; 0x06
    3c0a:	ef 2c       	mov	r14, r15
    3c0c:	42 81       	ldd	r20, Z+2	; 0x02
    3c0e:	0e 94 a6 24 	call	0x494c	; 0x494c <CmpValue>
    3c12:	88 23       	and	r24, r24
    3c14:	1c f1       	brlt	.+70     	; 0x3c5c <CheckResistor+0x55e>
                  (CmpValue(Resistor->Value, Resistor->Scale, Value2, Scale) <= 0))
    3c16:	e9 89       	ldd	r30, Y+17	; 0x11
    3c18:	fa 89       	ldd	r31, Y+18	; 0x12
    3c1a:	ee 0f       	add	r30, r30
    3c1c:	ff 1f       	adc	r31, r31
    3c1e:	ee 0f       	add	r30, r30
    3c20:	ff 1f       	adc	r31, r31
    3c22:	ee 0f       	add	r30, r30
    3c24:	ff 1f       	adc	r31, r31
    3c26:	89 89       	ldd	r24, Y+17	; 0x11
    3c28:	9a 89       	ldd	r25, Y+18	; 0x12
    3c2a:	e8 1b       	sub	r30, r24
    3c2c:	f9 0b       	sbc	r31, r25
    3c2e:	e8 5f       	subi	r30, 0xF8	; 248
    3c30:	fe 4f       	sbci	r31, 0xFE	; 254
    3c32:	63 81       	ldd	r22, Z+3	; 0x03
    3c34:	74 81       	ldd	r23, Z+4	; 0x04
    3c36:	85 81       	ldd	r24, Z+5	; 0x05
    3c38:	96 81       	ldd	r25, Z+6	; 0x06
    3c3a:	09 81       	ldd	r16, Y+1	; 0x01
    3c3c:	1a 81       	ldd	r17, Y+2	; 0x02
    3c3e:	2b 81       	ldd	r18, Y+3	; 0x03
    3c40:	3c 81       	ldd	r19, Y+4	; 0x04
    3c42:	42 81       	ldd	r20, Z+2	; 0x02
    3c44:	0e 94 a6 24 	call	0x494c	; 0x494c <CmpValue>
                Value2 = Value * 5;          /* 500% */
                if (Value2 == 0) Value2 = 5;   /* special case */
              }

              /* check if value matches given tolerance */
              if ((CmpValue(Resistor->Value, Resistor->Scale, Value1, Scale) >= 0) &&
    3c48:	18 16       	cp	r1, r24
    3c4a:	54 f0       	brlt	.+20     	; 0x3c60 <CheckResistor+0x562>
                  (CmpValue(Resistor->Value, Resistor->Scale, Value2, Scale) <= 0))
              {
                n = 100;                     /* end loop and signal match */
                Check.Found = COMP_RESISTOR;
    3c4c:	ea e0       	ldi	r30, 0x0A	; 10
    3c4e:	d1 01       	movw	r26, r2
    3c50:	11 96       	adiw	r26, 0x01	; 1
    3c52:	ec 93       	st	X, r30

              /* check if value matches given tolerance */
              if ((CmpValue(Resistor->Value, Resistor->Scale, Value1, Scale) >= 0) &&
                  (CmpValue(Resistor->Value, Resistor->Scale, Value2, Scale) <= 0))
              {
                n = 100;                     /* end loop and signal match */
    3c54:	84 e6       	ldi	r24, 0x64	; 100
                Check.Found = COMP_RESISTOR;
    3c56:	05 c0       	rjmp	.+10     	; 0x3c62 <CheckResistor+0x564>
                n = 200;                     /* end loop and signal mis-match */
              }
            }
            else                           /* no match */
            {
              n++;                          /* next one */
    3c58:	8f 5f       	subi	r24, 0xFF	; 255
    3c5a:	03 c0       	rjmp	.+6      	; 0x3c62 <CheckResistor+0x564>
                n = 100;                     /* end loop and signal match */
                Check.Found = COMP_RESISTOR;
              }
              else                 /* no match */
              {
                n = 200;                     /* end loop and signal mis-match */
    3c5c:	88 ec       	ldi	r24, 0xC8	; 200
    3c5e:	01 c0       	rjmp	.+2      	; 0x3c62 <CheckResistor+0x564>
    3c60:	88 ec       	ldi	r24, 0xC8	; 200
          /*
           *  check for measurement in reversed direction
           */

          n = 0;
          while (n < Check.Resistors)           /* loop through resistors */
    3c62:	d1 01       	movw	r26, r2
    3c64:	13 96       	adiw	r26, 0x03	; 3
    3c66:	9c 91       	ld	r25, X
    3c68:	89 17       	cp	r24, r25
    3c6a:	08 f4       	brcc	.+2      	; 0x3c6e <CheckResistor+0x570>
    3c6c:	42 cf       	rjmp	.-380    	; 0x3af2 <CheckResistor+0x3f4>

          /*
           *  we got a new resistor
           */

          if (n != 100)            /* not a known resistor */
    3c6e:	84 36       	cpi	r24, 0x64	; 100
    3c70:	c1 f0       	breq	.+48     	; 0x3ca2 <CheckResistor+0x5a4>
          {
            if (Check.Resistors < 3)              /* prevent array overflow */
    3c72:	93 30       	cpi	r25, 0x03	; 3
    3c74:	b0 f4       	brcc	.+44     	; 0x3ca2 <CheckResistor+0x5a4>
            {
              /* save data */
              Resistor = &Resistors[Check.Resistors];  /* unused dataset */
              Resistor->A = Probes.Pin_2;              /* pin facing Gnd */
    3c76:	b7 e0       	ldi	r27, 0x07	; 7
    3c78:	9b 9f       	mul	r25, r27
    3c7a:	f0 01       	movw	r30, r0
    3c7c:	11 24       	eor	r1, r1
    3c7e:	e8 5f       	subi	r30, 0xF8	; 248
    3c80:	fe 4f       	sbci	r31, 0xFE	; 254
    3c82:	ad e7       	ldi	r26, 0x7D	; 125
    3c84:	b1 e0       	ldi	r27, 0x01	; 1
    3c86:	11 96       	adiw	r26, 0x01	; 1
    3c88:	8c 91       	ld	r24, X
    3c8a:	11 97       	sbiw	r26, 0x01	; 1
    3c8c:	80 83       	st	Z, r24
              Resistor->B = Probes.Pin_1;              /* pin facing Vcc */
    3c8e:	8c 91       	ld	r24, X
    3c90:	81 83       	std	Z+1, r24	; 0x01
              Resistor->Value = Value;
    3c92:	83 82       	std	Z+3, r8	; 0x03
    3c94:	94 82       	std	Z+4, r9	; 0x04
    3c96:	a5 82       	std	Z+5, r10	; 0x05
    3c98:	b6 82       	std	Z+6, r11	; 0x06
              Resistor->Scale = Scale;
    3c9a:	f2 82       	std	Z+2, r15	; 0x02
              Check.Resistors++;                       /* another one found */
    3c9c:	9f 5f       	subi	r25, 0xFF	; 255
    3c9e:	90 93 03 01 	sts	0x0103, r25
          }
        }
      }
    }
  }
}
    3ca2:	62 96       	adiw	r28, 0x12	; 18
    3ca4:	0f b6       	in	r0, 0x3f	; 63
    3ca6:	f8 94       	cli
    3ca8:	de bf       	out	0x3e, r29	; 62
    3caa:	0f be       	out	0x3f, r0	; 63
    3cac:	cd bf       	out	0x3d, r28	; 61
    3cae:	df 91       	pop	r29
    3cb0:	cf 91       	pop	r28
    3cb2:	1f 91       	pop	r17
    3cb4:	0f 91       	pop	r16
    3cb6:	ff 90       	pop	r15
    3cb8:	ef 90       	pop	r14
    3cba:	df 90       	pop	r13
    3cbc:	cf 90       	pop	r12
    3cbe:	bf 90       	pop	r11
    3cc0:	af 90       	pop	r10
    3cc2:	9f 90       	pop	r9
    3cc4:	8f 90       	pop	r8
    3cc6:	7f 90       	pop	r7
    3cc8:	6f 90       	pop	r6
    3cca:	5f 90       	pop	r5
    3ccc:	4f 90       	pop	r4
    3cce:	3f 90       	pop	r3
    3cd0:	2f 90       	pop	r2
    3cd2:	08 95       	ret

00003cd4 <CheckSingleResistor>:
 *  - HighPin = pin facing Vcc
 *  - LowPin = pin facing Gnd
 */

uint8_t CheckSingleResistor(uint8_t HighPin, uint8_t LowPin)
{
    3cd4:	cf 93       	push	r28
    3cd6:	df 93       	push	r29
  uint8_t                Flag = 0;      /* return value */

  /* check for a specific resistor */
  Check.Resistors = 0;                  /* reset counter */
    3cd8:	c0 e0       	ldi	r28, 0x00	; 0
    3cda:	d1 e0       	ldi	r29, 0x01	; 1
    3cdc:	1b 82       	std	Y+3, r1	; 0x03
  UpdateProbes(HighPin, LowPin, 0);     /* set probes */
    3cde:	40 e0       	ldi	r20, 0x00	; 0
    3ce0:	0e 94 c5 17 	call	0x2f8a	; 0x2f8a <UpdateProbes>
  CheckResistor();                      /* check for resistor */
    3ce4:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <CheckResistor>

  if (Check.Resistors == 1)             /* found resistor */
    3ce8:	81 e0       	ldi	r24, 0x01	; 1
    3cea:	9b 81       	ldd	r25, Y+3	; 0x03
    3cec:	91 30       	cpi	r25, 0x01	; 1
    3cee:	09 f0       	breq	.+2      	; 0x3cf2 <CheckSingleResistor+0x1e>
    3cf0:	80 e0       	ldi	r24, 0x00	; 0
  {
    Flag = 1;            /* signal detected resistor */
  }

  return Flag;
}
    3cf2:	df 91       	pop	r29
    3cf4:	cf 91       	pop	r28
    3cf6:	08 95       	ret

00003cf8 <Get_hFE_C>:
 *  returns:
 *  - hFE
 */

uint32_t Get_hFE_C(uint8_t Type)
{
    3cf8:	cf 92       	push	r12
    3cfa:	df 92       	push	r13
    3cfc:	ef 92       	push	r14
    3cfe:	ff 92       	push	r15
    3d00:	0f 93       	push	r16
    3d02:	1f 93       	push	r17
    3d04:	cf 93       	push	r28
    3d06:	df 93       	push	r29

  /*
   *  setup probes and get voltages
   */

  if (Type == TYPE_NPN)            /* NPN */
    3d08:	81 30       	cpi	r24, 0x01	; 1
    3d0a:	e1 f4       	brne	.+56     	; 0x3d44 <Get_hFE_C+0x4c>
  {
    /* we assume: probe-1 = C / probe-2 = E / probe-3 = B */
    /* set probes: Gnd -- Rl -- probe-2 / probe-1 -- Vcc */
    ADC_DDR = Probes.ADC_1;             /* set probe 1 to output */
    3d0c:	cd e7       	ldi	r28, 0x7D	; 125
    3d0e:	d1 e0       	ldi	r29, 0x01	; 1
    3d10:	89 85       	ldd	r24, Y+9	; 0x09
    3d12:	87 b9       	out	0x07, r24	; 7
    ADC_PORT = Probes.ADC_1;            /* pull up collector directly */
    3d14:	88 b9       	out	0x08, r24	; 8
    R_DDR = Probes.Rl_2 | Probes.Rl_3;  /* select Rl for probe-2 & Rl for probe-3 */
    3d16:	9f 81       	ldd	r25, Y+7	; 0x07
    3d18:	8d 81       	ldd	r24, Y+5	; 0x05
    3d1a:	89 2b       	or	r24, r25
    3d1c:	84 b9       	out	0x04, r24	; 4
    R_PORT = Probes.Rl_3;               /* pull up base via Rl */
    3d1e:	95 b9       	out	0x05, r25	; 5

    U_R_e = ReadU_5ms(Probes.Pin_2);              /* U_R_e = U_e */
    3d20:	89 81       	ldd	r24, Y+1	; 0x01
    3d22:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
    3d26:	8c 01       	movw	r16, r24
    U_R_b = Config.Vcc - ReadU(Probes.Pin_3);     /* U_R_b = Vcc - U_b */
    3d28:	e0 90 95 01 	lds	r14, 0x0195
    3d2c:	f0 90 96 01 	lds	r15, 0x0196
    3d30:	8a 81       	ldd	r24, Y+2	; 0x02
    3d32:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    3d36:	b7 01       	movw	r22, r14
    3d38:	68 1b       	sub	r22, r24
    3d3a:	79 0b       	sbc	r23, r25

    U_R_e = Config.Vcc - ReadU_5ms(Probes.Pin_1); /* U_R_e = Vcc - U_e */
    U_R_b = ReadU(Probes.Pin_3);                  /* U_R_b = U_b */
  }

  if (U_R_b < 10)             /* I_b < 14킕 -> Darlington */
    3d3c:	6a 30       	cpi	r22, 0x0A	; 10
    3d3e:	71 05       	cpc	r23, r1
    3d40:	e0 f0       	brcs	.+56     	; 0x3d7a <Get_hFE_C+0x82>
    3d42:	8c c0       	rjmp	.+280    	; 0x3e5c <Get_hFE_C+0x164>
  }
  else                             /* PNP */
  {
    /* we assume: probe-1 = E / probe-2 = C / probe-3 = B */
    /* set probes: Gnd -- probe-2 / probe-1 -- Rl -- Vcc */
    ADC_PORT = 0;                       /* set ADC port low */
    3d44:	18 b8       	out	0x08, r1	; 8
    ADC_DDR = Probes.ADC_2;             /* pull down collector directly */
    3d46:	cd e7       	ldi	r28, 0x7D	; 125
    3d48:	d1 e0       	ldi	r29, 0x01	; 1
    3d4a:	8a 85       	ldd	r24, Y+10	; 0x0a
    3d4c:	87 b9       	out	0x07, r24	; 7
    R_PORT = Probes.Rl_1;               /* pull up emitter via Rl */
    3d4e:	8b 81       	ldd	r24, Y+3	; 0x03
    3d50:	85 b9       	out	0x05, r24	; 5
    R_DDR = Probes.Rl_1 | Probes.Rl_3;  /* pull down base via Rl */
    3d52:	9f 81       	ldd	r25, Y+7	; 0x07
    3d54:	89 2b       	or	r24, r25
    3d56:	84 b9       	out	0x04, r24	; 4

    U_R_e = Config.Vcc - ReadU_5ms(Probes.Pin_1); /* U_R_e = Vcc - U_e */
    3d58:	00 91 95 01 	lds	r16, 0x0195
    3d5c:	10 91 96 01 	lds	r17, 0x0196
    3d60:	88 81       	ld	r24, Y
    3d62:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
    3d66:	7c 01       	movw	r14, r24
    U_R_b = ReadU(Probes.Pin_3);                  /* U_R_b = U_b */
    3d68:	8a 81       	ldd	r24, Y+2	; 0x02
    3d6a:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    3d6e:	bc 01       	movw	r22, r24
  }

  if (U_R_b < 10)             /* I_b < 14킕 -> Darlington */
    3d70:	0a 97       	sbiw	r24, 0x0a	; 10
    3d72:	28 f1       	brcs	.+74     	; 0x3dbe <Get_hFE_C+0xc6>
    ADC_PORT = 0;                       /* set ADC port low */
    ADC_DDR = Probes.ADC_2;             /* pull down collector directly */
    R_PORT = Probes.Rl_1;               /* pull up emitter via Rl */
    R_DDR = Probes.Rl_1 | Probes.Rl_3;  /* pull down base via Rl */

    U_R_e = Config.Vcc - ReadU_5ms(Probes.Pin_1); /* U_R_e = Vcc - U_e */
    3d74:	0e 19       	sub	r16, r14
    3d76:	1f 09       	sbc	r17, r15
    3d78:	71 c0       	rjmp	.+226    	; 0x3e5c <Get_hFE_C+0x164>
  if (U_R_b < 10)             /* I_b < 14킕 -> Darlington */
  {
    /* change base resistor from Rl to Rh and measure again */
    if (Type == TYPE_NPN)            /* NPN */
    {    
      R_DDR = Probes.Rl_2 | Probes.Rh_3;     /* select Rl for probe-2 & Rh for probe-3 */
    3d7a:	cd e7       	ldi	r28, 0x7D	; 125
    3d7c:	d1 e0       	ldi	r29, 0x01	; 1
    3d7e:	98 85       	ldd	r25, Y+8	; 0x08
    3d80:	8d 81       	ldd	r24, Y+5	; 0x05
    3d82:	89 2b       	or	r24, r25
    3d84:	84 b9       	out	0x04, r24	; 4
      R_PORT = Probes.Rh_3;                  /* pull up base via Rh */
    3d86:	95 b9       	out	0x05, r25	; 5

      U_R_e = ReadU_5ms(Probes.Pin_2);            /* U_R_e = U_e */
    3d88:	89 81       	ldd	r24, Y+1	; 0x01
    3d8a:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
    3d8e:	8c 01       	movw	r16, r24
      U_R_b = Config.Vcc - ReadU(Probes.Pin_3);   /* U_R_b = Vcc - U_b */
    3d90:	0f 2e       	mov	r0, r31
    3d92:	fe e8       	ldi	r31, 0x8E	; 142
    3d94:	ef 2e       	mov	r14, r31
    3d96:	f1 e0       	ldi	r31, 0x01	; 1
    3d98:	ff 2e       	mov	r15, r31
    3d9a:	f0 2d       	mov	r31, r0
    3d9c:	d7 01       	movw	r26, r14
    3d9e:	17 96       	adiw	r26, 0x07	; 7
    3da0:	cd 90       	ld	r12, X+
    3da2:	dc 90       	ld	r13, X
    3da4:	18 97       	sbiw	r26, 0x08	; 8
    3da6:	8a 81       	ldd	r24, Y+2	; 0x02
    3da8:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    3dac:	f6 01       	movw	r30, r12
    3dae:	e8 1b       	sub	r30, r24
    3db0:	f9 0b       	sbc	r31, r25

      Ri = Config.RiL;                       /* get internal resistor */
    3db2:	d7 01       	movw	r26, r14
    3db4:	19 96       	adiw	r26, 0x09	; 9
    3db6:	cd 91       	ld	r28, X+
    3db8:	dc 91       	ld	r29, X
    3dba:	1a 97       	sbiw	r26, 0x0a	; 10
    3dbc:	1d c0       	rjmp	.+58     	; 0x3df8 <Get_hFE_C+0x100>
    }
    else                             /* PNP */
    {
      R_DDR = Probes.Rl_1 | Probes.Rh_3;     /* pull down base via Rh */
    3dbe:	cd e7       	ldi	r28, 0x7D	; 125
    3dc0:	d1 e0       	ldi	r29, 0x01	; 1
    3dc2:	98 85       	ldd	r25, Y+8	; 0x08
    3dc4:	8b 81       	ldd	r24, Y+3	; 0x03
    3dc6:	89 2b       	or	r24, r25
    3dc8:	84 b9       	out	0x04, r24	; 4

      U_R_e = Config.Vcc - ReadU_5ms(Probes.Pin_1);    /* U_R_e = Vcc - U_e */
    3dca:	0f 2e       	mov	r0, r31
    3dcc:	fe e8       	ldi	r31, 0x8E	; 142
    3dce:	ef 2e       	mov	r14, r31
    3dd0:	f1 e0       	ldi	r31, 0x01	; 1
    3dd2:	ff 2e       	mov	r15, r31
    3dd4:	f0 2d       	mov	r31, r0
    3dd6:	f7 01       	movw	r30, r14
    3dd8:	07 81       	ldd	r16, Z+7	; 0x07
    3dda:	10 85       	ldd	r17, Z+8	; 0x08
    3ddc:	88 81       	ld	r24, Y
    3dde:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
    3de2:	08 1b       	sub	r16, r24
    3de4:	19 0b       	sbc	r17, r25
      U_R_b = ReadU(Probes.Pin_3);                     /* U_R_b = U_b */
    3de6:	8a 81       	ldd	r24, Y+2	; 0x02
    3de8:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    3dec:	fc 01       	movw	r30, r24

      Ri = Config.RiH;                       /* get internal resistor */
    3dee:	d7 01       	movw	r26, r14
    3df0:	1b 96       	adiw	r26, 0x0b	; 11
    3df2:	cd 91       	ld	r28, X+
    3df4:	dc 91       	ld	r29, X
    3df6:	1c 97       	sbiw	r26, 0x0c	; 12
     *  hFE = I_e / I_b
     *      = (U_R_e / R_e) / (U_R_b / R_b)
     *      = (U_R_e * R_b) / (U_R_b * R_e)
     */

    if (U_R_b < 1) U_R_b = 1;                /* prevent division by zero */
    3df8:	30 97       	sbiw	r30, 0x00	; 0
    3dfa:	11 f4       	brne	.+4      	; 0x3e00 <Get_hFE_C+0x108>
    3dfc:	e1 e0       	ldi	r30, 0x01	; 1
    3dfe:	f0 e0       	ldi	r31, 0x00	; 0
    hFE =  U_R_e * R_HIGH;                   /* U_R_e * R_b */
    3e00:	d8 01       	movw	r26, r16
    3e02:	20 ef       	ldi	r18, 0xF0	; 240
    3e04:	3b e2       	ldi	r19, 0x2B	; 43
    3e06:	47 e0       	ldi	r20, 0x07	; 7
    3e08:	50 e0       	ldi	r21, 0x00	; 0
    3e0a:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
    hFE /= U_R_b;                            /* / U_R_b */
    3e0e:	9f 01       	movw	r18, r30
    3e10:	40 e0       	ldi	r20, 0x00	; 0
    3e12:	50 e0       	ldi	r21, 0x00	; 0
    3e14:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    hFE *= 10;                               /* upscale to 0.1 */
    3e18:	ba 01       	movw	r22, r20
    3e1a:	a9 01       	movw	r20, r18
    3e1c:	44 0f       	add	r20, r20
    3e1e:	55 1f       	adc	r21, r21
    3e20:	66 1f       	adc	r22, r22
    3e22:	77 1f       	adc	r23, r23
    3e24:	db 01       	movw	r26, r22
    3e26:	ca 01       	movw	r24, r20
    3e28:	88 0f       	add	r24, r24
    3e2a:	99 1f       	adc	r25, r25
    3e2c:	aa 1f       	adc	r26, r26
    3e2e:	bb 1f       	adc	r27, r27
    3e30:	88 0f       	add	r24, r24
    3e32:	99 1f       	adc	r25, r25
    3e34:	aa 1f       	adc	r26, r26
    3e36:	bb 1f       	adc	r27, r27
    3e38:	8a 01       	movw	r16, r20
    3e3a:	9b 01       	movw	r18, r22
    3e3c:	08 0f       	add	r16, r24
    3e3e:	19 1f       	adc	r17, r25
    3e40:	2a 1f       	adc	r18, r26
    3e42:	3b 1f       	adc	r19, r27
    3e44:	c9 01       	movw	r24, r18
    3e46:	b8 01       	movw	r22, r16
    hFE /= (R_LOW * 10) + Ri;                /* / R_e in 0.1 Ohm */
    3e48:	9e 01       	movw	r18, r28
    3e4a:	20 57       	subi	r18, 0x70	; 112
    3e4c:	35 4e       	sbci	r19, 0xE5	; 229
    3e4e:	40 e0       	ldi	r20, 0x00	; 0
    3e50:	50 e0       	ldi	r21, 0x00	; 0
    3e52:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    3e56:	ca 01       	movw	r24, r20
    3e58:	b9 01       	movw	r22, r18
    3e5a:	07 c0       	rjmp	.+14     	; 0x3e6a <Get_hFE_C+0x172>
     *  Both resistors are the same (R_e = R_b): 
     *  - hFE = ((U_R_e / R_e) - (U_R_b / R_b)) / (U_R_b / R_b)
     *  -     = (U_R_e - U_R_b) / U_R_b 
     */

    hFE = (uint32_t)((U_R_e - U_R_b) / U_R_b);
    3e5c:	c8 01       	movw	r24, r16
    3e5e:	86 1b       	sub	r24, r22
    3e60:	97 0b       	sbc	r25, r23
    3e62:	0e 94 18 28 	call	0x5030	; 0x5030 <__udivmodhi4>
    3e66:	80 e0       	ldi	r24, 0x00	; 0
    3e68:	90 e0       	ldi	r25, 0x00	; 0
  }

  return hFE;
}
    3e6a:	df 91       	pop	r29
    3e6c:	cf 91       	pop	r28
    3e6e:	1f 91       	pop	r17
    3e70:	0f 91       	pop	r16
    3e72:	ff 90       	pop	r15
    3e74:	ef 90       	pop	r14
    3e76:	df 90       	pop	r13
    3e78:	cf 90       	pop	r12
    3e7a:	08 95       	ret

00003e7c <GetGateThreshold>:
 *  requires:
 *  - Type: n-channel or p-channel
 */

void GetGateThreshold(uint8_t Type)
{
    3e7c:	3f 92       	push	r3
    3e7e:	4f 92       	push	r4
    3e80:	5f 92       	push	r5
    3e82:	6f 92       	push	r6
    3e84:	7f 92       	push	r7
    3e86:	8f 92       	push	r8
    3e88:	9f 92       	push	r9
    3e8a:	af 92       	push	r10
    3e8c:	bf 92       	push	r11
    3e8e:	cf 92       	push	r12
    3e90:	df 92       	push	r13
    3e92:	ef 92       	push	r14
    3e94:	ff 92       	push	r15
    3e96:	0f 93       	push	r16
    3e98:	1f 93       	push	r17
    3e9a:	cf 93       	push	r28
    3e9c:	df 93       	push	r29

  /*
   *  init variables
   */

  if (Type & TYPE_N_CHANNEL)       /* n-channel */
    3e9e:	28 2f       	mov	r18, r24
    3ea0:	21 70       	andi	r18, 0x01	; 1
    3ea2:	52 2e       	mov	r5, r18
    3ea4:	80 ff       	sbrs	r24, 0
    3ea6:	08 c0       	rjmp	.+16     	; 0x3eb8 <GetGateThreshold+0x3c>
  {
    /* we assume: probe-1 = D / probe-2 = S / probe-3 = G */
    /* probe-2 is still pulled down directly */
    /* probe-1 is still pulled up via Rl */

    Drain_Rl =  Probes.Rl_1;
    3ea8:	ed e7       	ldi	r30, 0x7D	; 125
    3eaa:	f1 e0       	ldi	r31, 0x01	; 1
    3eac:	43 80       	ldd	r4, Z+3	; 0x03
    Drain_ADC = Probes.ADC_1;
    3eae:	81 85       	ldd	r24, Z+9	; 0x09
    PullMode = FLAG_10MS | FLAG_PULLDOWN;
    3eb0:	68 94       	set
    3eb2:	33 24       	eor	r3, r3
    3eb4:	34 f8       	bld	r3, 4
    3eb6:	08 c0       	rjmp	.+16     	; 0x3ec8 <GetGateThreshold+0x4c>
  {
    /* we assume: probe-1 = S / probe-2 = D / probe-3 = G */
    /* probe-2 is still pulled down via Rl */
    /* probe-1 is still pulled up directly */

    Drain_Rl =  Probes.Rl_2;
    3eb8:	ed e7       	ldi	r30, 0x7D	; 125
    3eba:	f1 e0       	ldi	r31, 0x01	; 1
    3ebc:	45 80       	ldd	r4, Z+5	; 0x05
    Drain_ADC = Probes.ADC_2;
    3ebe:	82 85       	ldd	r24, Z+10	; 0x0a
    PullMode = FLAG_10MS | FLAG_PULLUP;
    3ec0:	0f 2e       	mov	r0, r31
    3ec2:	f1 e1       	ldi	r31, 0x11	; 17
    3ec4:	3f 2e       	mov	r3, r31
    3ec6:	f0 2d       	mov	r31, r0
  /*
   *  For low reaction times we use the ADC directly.
   */

  /* sanitize bit mask for drain to prevent a never-ending loop */ 
  Drain_ADC &= 0b00000111;              /* drain */
    3ec8:	87 70       	andi	r24, 0x07	; 7
    3eca:	78 2e       	mov	r7, r24
  ADMUX = Probes.Pin_3 | (1 << REFS0);  /* select probe-3 for ADC input */
    3ecc:	80 91 7f 01 	lds	r24, 0x017F
    3ed0:	80 64       	ori	r24, 0x40	; 64
    3ed2:	80 93 7c 00 	sts	0x007C, r24
    3ed6:	0f 2e       	mov	r0, r31
    3ed8:	fa e0       	ldi	r31, 0x0A	; 10
    3eda:	6f 2e       	mov	r6, r31
    3edc:	f0 2d       	mov	r31, r0
 *  - Type: n-channel or p-channel
 */

void GetGateThreshold(uint8_t Type)
{
  int32_t           Ugs = 0;       /* gate threshold voltage / Vth */
    3ede:	81 2c       	mov	r8, r1
    3ee0:	91 2c       	mov	r9, r1
    3ee2:	54 01       	movw	r10, r8
  for (Counter = 0; Counter < 10; Counter++) 
  {
    wdt_reset();                         /* reset watchdog */

    /* discharge gate via Rl for 10 ms */
    PullProbe(Probes.Rl_3, PullMode);
    3ee4:	0d e7       	ldi	r16, 0x7D	; 125
    3ee6:	11 e0       	ldi	r17, 0x01	; 1
    }

    R_DDR = Drain_Rl;                   /* set probe-3 to HiZ mode */

    /* get voltage of gate */
    ADCSRA |= (1 << ADSC);              /* start ADC conversion */
    3ee8:	ca e7       	ldi	r28, 0x7A	; 122
    3eea:	d0 e0       	ldi	r29, 0x00	; 0
    {
      Ugs += ADCW;                        /* Ugs = U_g */
    }
    else                                /* p-channel */
    {
      Ugs -= (1023 - ADCW);               /* Ugs = - (Vcc - U_g) */
    3eec:	0f 2e       	mov	r0, r31
    3eee:	f8 e7       	ldi	r31, 0x78	; 120
    3ef0:	ef 2e       	mov	r14, r31
    3ef2:	f1 2c       	mov	r15, r1
    3ef4:	f0 2d       	mov	r31, r0
    3ef6:	0f 2e       	mov	r0, r31
    3ef8:	cc 24       	eor	r12, r12
    3efa:	ca 94       	dec	r12
    3efc:	f3 e0       	ldi	r31, 0x03	; 3
    3efe:	df 2e       	mov	r13, r31
    3f00:	f0 2d       	mov	r31, r0
  ADMUX = Probes.Pin_3 | (1 << REFS0);  /* select probe-3 for ADC input */

  /* sample 10 times */
  for (Counter = 0; Counter < 10; Counter++) 
  {
    wdt_reset();                         /* reset watchdog */
    3f02:	a8 95       	wdr

    /* discharge gate via Rl for 10 ms */
    PullProbe(Probes.Rl_3, PullMode);
    3f04:	63 2d       	mov	r22, r3
    3f06:	f8 01       	movw	r30, r16
    3f08:	87 81       	ldd	r24, Z+7	; 0x07
    3f0a:	0e 94 2c 19 	call	0x3258	; 0x3258 <PullProbe>

    /* pull up/down gate via Rh to slowly charge gate */
    R_DDR = Drain_Rl | Probes.Rh_3;
    3f0e:	f8 01       	movw	r30, r16
    3f10:	80 85       	ldd	r24, Z+8	; 0x08
    3f12:	84 29       	or	r24, r4
    3f14:	84 b9       	out	0x04, r24	; 4

    /* wait until FET conducts */
    if (Type & TYPE_N_CHANNEL)          /* n-channel */
    3f16:	55 20       	and	r5, r5
    3f18:	21 f0       	breq	.+8      	; 0x3f22 <GetGateThreshold+0xa6>
    {
      /* FET conducts when the voltage at drain reaches low level */
      while (ADC_PIN & Drain_ADC);
    3f1a:	86 b1       	in	r24, 0x06	; 6
    3f1c:	87 21       	and	r24, r7
    3f1e:	e9 f7       	brne	.-6      	; 0x3f1a <GetGateThreshold+0x9e>
    3f20:	03 c0       	rjmp	.+6      	; 0x3f28 <GetGateThreshold+0xac>
    }
    else                                /* p-channel */
    {
      /* FET conducts when the voltage at drain reaches high level */
      while (!(ADC_PIN & Drain_ADC));             
    3f22:	86 b1       	in	r24, 0x06	; 6
    3f24:	87 21       	and	r24, r7
    3f26:	e9 f3       	breq	.-6      	; 0x3f22 <GetGateThreshold+0xa6>
    }

    R_DDR = Drain_Rl;                   /* set probe-3 to HiZ mode */
    3f28:	44 b8       	out	0x04, r4	; 4

    /* get voltage of gate */
    ADCSRA |= (1 << ADSC);              /* start ADC conversion */
    3f2a:	88 81       	ld	r24, Y
    3f2c:	80 64       	ori	r24, 0x40	; 64
    3f2e:	88 83       	st	Y, r24
    while (ADCSRA & (1 << ADSC));       /* wait until conversion is done */
    3f30:	88 81       	ld	r24, Y
    3f32:	86 fd       	sbrc	r24, 6
    3f34:	fd cf       	rjmp	.-6      	; 0x3f30 <GetGateThreshold+0xb4>

    /* add ADC reading */
    if (Type & TYPE_N_CHANNEL)          /* n-channel */
    3f36:	55 20       	and	r5, r5
    3f38:	41 f0       	breq	.+16     	; 0x3f4a <GetGateThreshold+0xce>
    {
      Ugs += ADCW;                        /* Ugs = U_g */
    3f3a:	f7 01       	movw	r30, r14
    3f3c:	80 81       	ld	r24, Z
    3f3e:	91 81       	ldd	r25, Z+1	; 0x01
    3f40:	88 0e       	add	r8, r24
    3f42:	99 1e       	adc	r9, r25
    3f44:	a1 1c       	adc	r10, r1
    3f46:	b1 1c       	adc	r11, r1
    3f48:	0a c0       	rjmp	.+20     	; 0x3f5e <GetGateThreshold+0xe2>
    }
    else                                /* p-channel */
    {
      Ugs -= (1023 - ADCW);               /* Ugs = - (Vcc - U_g) */
    3f4a:	f7 01       	movw	r30, r14
    3f4c:	80 81       	ld	r24, Z
    3f4e:	91 81       	ldd	r25, Z+1	; 0x01
    3f50:	96 01       	movw	r18, r12
    3f52:	28 1b       	sub	r18, r24
    3f54:	39 0b       	sbc	r19, r25
    3f56:	82 1a       	sub	r8, r18
    3f58:	93 0a       	sbc	r9, r19
    3f5a:	a1 08       	sbc	r10, r1
    3f5c:	b1 08       	sbc	r11, r1
    3f5e:	6a 94       	dec	r6
  /* sanitize bit mask for drain to prevent a never-ending loop */ 
  Drain_ADC &= 0b00000111;              /* drain */
  ADMUX = Probes.Pin_3 | (1 << REFS0);  /* select probe-3 for ADC input */

  /* sample 10 times */
  for (Counter = 0; Counter < 10; Counter++) 
    3f60:	61 10       	cpse	r6, r1
    3f62:	cf cf       	rjmp	.-98     	; 0x3f02 <GetGateThreshold+0x86>
      Ugs -= (1023 - ADCW);               /* Ugs = - (Vcc - U_g) */
    }
  }

  /* calculate V_th */
  Ugs /= 10;                     /* average of 10 samples */
    3f64:	c5 01       	movw	r24, r10
    3f66:	b4 01       	movw	r22, r8
    3f68:	2a e0       	ldi	r18, 0x0A	; 10
    3f6a:	30 e0       	ldi	r19, 0x00	; 0
    3f6c:	40 e0       	ldi	r20, 0x00	; 0
    3f6e:	50 e0       	ldi	r21, 0x00	; 0
    3f70:	0e 94 62 28 	call	0x50c4	; 0x50c4 <__divmodsi4>
  Ugs *= Config.Vcc;             /* convert to voltage */
    3f74:	a0 91 95 01 	lds	r26, 0x0195
    3f78:	b0 91 96 01 	lds	r27, 0x0196
    3f7c:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
  Ugs /= 1024;                   /* using 10 bit resolution */
    3f80:	8b 01       	movw	r16, r22
    3f82:	9c 01       	movw	r18, r24
    3f84:	99 23       	and	r25, r25
    3f86:	24 f4       	brge	.+8      	; 0x3f90 <GetGateThreshold+0x114>
    3f88:	01 50       	subi	r16, 0x01	; 1
    3f8a:	1c 4f       	sbci	r17, 0xFC	; 252
    3f8c:	2f 4f       	sbci	r18, 0xFF	; 255
    3f8e:	3f 4f       	sbci	r19, 0xFF	; 255
    3f90:	d9 01       	movw	r26, r18
    3f92:	c8 01       	movw	r24, r16
    3f94:	07 2e       	mov	r0, r23
    3f96:	7a e0       	ldi	r23, 0x0A	; 10
    3f98:	b5 95       	asr	r27
    3f9a:	a7 95       	ror	r26
    3f9c:	97 95       	ror	r25
    3f9e:	87 95       	ror	r24
    3fa0:	7a 95       	dec	r23
    3fa2:	d1 f7       	brne	.-12     	; 0x3f98 <GetGateThreshold+0x11c>
    3fa4:	70 2d       	mov	r23, r0

  /* save data */
  Semi.U_2 = (int16_t)Ugs;       /* gate threshold voltage (in mV) */
    3fa6:	90 93 75 01 	sts	0x0175, r25
    3faa:	80 93 74 01 	sts	0x0174, r24
}
    3fae:	df 91       	pop	r29
    3fb0:	cf 91       	pop	r28
    3fb2:	1f 91       	pop	r17
    3fb4:	0f 91       	pop	r16
    3fb6:	ff 90       	pop	r15
    3fb8:	ef 90       	pop	r14
    3fba:	df 90       	pop	r13
    3fbc:	cf 90       	pop	r12
    3fbe:	bf 90       	pop	r11
    3fc0:	af 90       	pop	r10
    3fc2:	9f 90       	pop	r9
    3fc4:	8f 90       	pop	r8
    3fc6:	7f 90       	pop	r7
    3fc8:	6f 90       	pop	r6
    3fca:	5f 90       	pop	r5
    3fcc:	4f 90       	pop	r4
    3fce:	3f 90       	pop	r3
    3fd0:	08 95       	ret

00003fd2 <GetLeakageCurrent>:
 *  returns:
 *  - leakage current in 킕
 */

uint16_t GetLeakageCurrent(void)
{
    3fd2:	cf 92       	push	r12
    3fd4:	df 92       	push	r13
    3fd6:	ef 92       	push	r14
    3fd8:	ff 92       	push	r15
   *    Diode:    probe-1 = cathode /  probe-2 = anode
   *    NPN BJT:  probe-1 = collector / probe-2 = emitter
   *    PNP BJT:  probe-1 = emitter / probe-2 = collector
   */

  R_PORT = 0;                      /* set resistor port to Gnd */
    3fda:	15 b8       	out	0x05, r1	; 5
  R_DDR = Probes.Rl_2;             /* pull down probe-2 via Rl */
    3fdc:	ed e7       	ldi	r30, 0x7D	; 125
    3fde:	f1 e0       	ldi	r31, 0x01	; 1
    3fe0:	85 81       	ldd	r24, Z+5	; 0x05
    3fe2:	84 b9       	out	0x04, r24	; 4
  ADC_DDR = Probes.ADC_1;          /* set probe-1 to output */
    3fe4:	81 85       	ldd	r24, Z+9	; 0x09
    3fe6:	87 b9       	out	0x07, r24	; 7
  ADC_PORT = Probes.ADC_1;         /* pull-up probe-1 directly */
    3fe8:	88 b9       	out	0x08, r24	; 8

  U_Rl = ReadU_5ms(Probes.Pin_2);  /* get voltage at Rl */
    3fea:	81 81       	ldd	r24, Z+1	; 0x01
    3fec:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>

  /* calculate current */
  R_Shunt = Config.RiL + (R_LOW * 10);  /* consider internal resistance of MCU (0.1 Ohms) */ 
  R_Shunt += 5;                    /* for rounding */
    3ff0:	e0 91 97 01 	lds	r30, 0x0197
    3ff4:	f0 91 98 01 	lds	r31, 0x0198
    3ff8:	eb 56       	subi	r30, 0x6B	; 107
    3ffa:	f5 4e       	sbci	r31, 0xE5	; 229
  R_Shunt /= 10;                   /* scale to Ohms */
  Value = U_Rl * 100000;           /* scale to 10nV */
    3ffc:	dc 01       	movw	r26, r24
    3ffe:	20 ea       	ldi	r18, 0xA0	; 160
    4000:	36 e8       	ldi	r19, 0x86	; 134
    4002:	41 e0       	ldi	r20, 0x01	; 1
    4004:	50 e0       	ldi	r21, 0x00	; 0
    4006:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
    400a:	6b 01       	movw	r12, r22
    400c:	7c 01       	movw	r14, r24
  U_Rl = ReadU_5ms(Probes.Pin_2);  /* get voltage at Rl */

  /* calculate current */
  R_Shunt = Config.RiL + (R_LOW * 10);  /* consider internal resistance of MCU (0.1 Ohms) */ 
  R_Shunt += 5;                    /* for rounding */
  R_Shunt /= 10;                   /* scale to Ohms */
    400e:	9f 01       	movw	r18, r30
    4010:	ad ec       	ldi	r26, 0xCD	; 205
    4012:	bc ec       	ldi	r27, 0xCC	; 204
    4014:	0e 94 87 28 	call	0x510e	; 0x510e <__umulhisi3>
    4018:	96 95       	lsr	r25
    401a:	87 95       	ror	r24
    401c:	96 95       	lsr	r25
    401e:	87 95       	ror	r24
    4020:	96 95       	lsr	r25
    4022:	87 95       	ror	r24
  Value = U_Rl * 100000;           /* scale to 10nV */
  Value /= R_Shunt;                /* in 10nA */
    4024:	9c 01       	movw	r18, r24
    4026:	40 e0       	ldi	r20, 0x00	; 0
    4028:	50 e0       	ldi	r21, 0x00	; 0
    402a:	c7 01       	movw	r24, r14
    402c:	b6 01       	movw	r22, r12
    402e:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
  Value += 55;                     /* for rounding */
    4032:	ca 01       	movw	r24, r20
    4034:	b9 01       	movw	r22, r18
    4036:	69 5c       	subi	r22, 0xC9	; 201
    4038:	7f 4f       	sbci	r23, 0xFF	; 255
    403a:	8f 4f       	sbci	r24, 0xFF	; 255
    403c:	9f 4f       	sbci	r25, 0xFF	; 255
  Value /= 100;                    /* scale to 킕 */
  I_leak = Value;

  /* clean up */
  ADC_DDR = 0;           /* set ADC port to HiZ mode */
    403e:	17 b8       	out	0x07, r1	; 7
  ADC_PORT = 0;          /* set ADC port low */
    4040:	18 b8       	out	0x08, r1	; 8
  R_DDR = 0;             /* set resistor port to HiZ mode */
    4042:	14 b8       	out	0x04, r1	; 4
  R_PORT = 0;            /* set resistor port low */
    4044:	15 b8       	out	0x05, r1	; 5
  R_Shunt += 5;                    /* for rounding */
  R_Shunt /= 10;                   /* scale to Ohms */
  Value = U_Rl * 100000;           /* scale to 10nV */
  Value /= R_Shunt;                /* in 10nA */
  Value += 55;                     /* for rounding */
  Value /= 100;                    /* scale to 킕 */
    4046:	24 e6       	ldi	r18, 0x64	; 100
    4048:	30 e0       	ldi	r19, 0x00	; 0
    404a:	40 e0       	ldi	r20, 0x00	; 0
    404c:	50 e0       	ldi	r21, 0x00	; 0
    404e:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
  ADC_PORT = 0;          /* set ADC port low */
  R_DDR = 0;             /* set resistor port to HiZ mode */
  R_PORT = 0;            /* set resistor port low */

  return I_leak;
}
    4052:	c9 01       	movw	r24, r18
    4054:	ff 90       	pop	r15
    4056:	ef 90       	pop	r14
    4058:	df 90       	pop	r13
    405a:	cf 90       	pop	r12
    405c:	08 95       	ret

0000405e <CheckDiode>:
/*
 *  check for diode
 */

void CheckDiode(void)
{
    405e:	2f 92       	push	r2
    4060:	3f 92       	push	r3
    4062:	4f 92       	push	r4
    4064:	5f 92       	push	r5
    4066:	6f 92       	push	r6
    4068:	7f 92       	push	r7
    406a:	8f 92       	push	r8
    406c:	9f 92       	push	r9
    406e:	af 92       	push	r10
    4070:	bf 92       	push	r11
    4072:	cf 92       	push	r12
    4074:	df 92       	push	r13
    4076:	ef 92       	push	r14
    4078:	ff 92       	push	r15
    407a:	0f 93       	push	r16
    407c:	1f 93       	push	r17
    407e:	cf 93       	push	r28
    4080:	df 93       	push	r29
    4082:	00 d0       	rcall	.+0      	; 0x4084 <CheckDiode+0x26>
    4084:	00 d0       	rcall	.+0      	; 0x4086 <CheckDiode+0x28>
    4086:	cd b7       	in	r28, 0x3d	; 61
    4088:	de b7       	in	r29, 0x3e	; 62
  uint16_t          U2_Rl;         /* Vf #2 with Rl pull-down */
  uint16_t          U2_Rh;         /* Vf #2 with Rh pull-down */
  uint16_t          U2_Zero;       /* Vf #2 zero */
  uint16_t          U_Diff;        /* Vf difference */

  wdt_reset();                          /* reset watchdog */
    408a:	a8 95       	wdr

  DischargeProbes();                    /* try to discharge probes */
    408c:	0e 94 64 18 	call	0x30c8	; 0x30c8 <DischargeProbes>
  if (Check.Found == COMP_ERROR) return;     /* skip on error */
    4090:	80 91 01 01 	lds	r24, 0x0101
    4094:	81 30       	cpi	r24, 0x01	; 1
    4096:	09 f4       	brne	.+2      	; 0x409a <CheckDiode+0x3c>
    4098:	3e c1       	rjmp	.+636    	; 0x4316 <CheckDiode+0x2b8>
   *  Vf #1, supporting a possible p-channel MOSFET
   */

  /* we assume: probe-1 = A / probe2 = C */
  /* set probes: Gnd -- probe-2 / probe-1 -- HiZ */
  ADC_PORT = 0;
    409a:	18 b8       	out	0x08, r1	; 8
  ADC_DDR = Probes.ADC_2;               /* pull down cathode directly */
    409c:	0f 2e       	mov	r0, r31
    409e:	fd e7       	ldi	r31, 0x7D	; 125
    40a0:	ef 2e       	mov	r14, r31
    40a2:	f1 e0       	ldi	r31, 0x01	; 1
    40a4:	ff 2e       	mov	r15, r31
    40a6:	f0 2d       	mov	r31, r0
    40a8:	f7 01       	movw	r30, r14
    40aa:	82 85       	ldd	r24, Z+10	; 0x0a
    40ac:	87 b9       	out	0x07, r24	; 7
  /* R_DDR is set to HiZ by DischargeProbes() */
  U1_Zero = ReadU(Probes.Pin_1);        /* get voltage at anode */
    40ae:	80 81       	ld	r24, Z
    40b0:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    40b4:	6c 01       	movw	r12, r24

  /* measure voltage across DUT (Vf) with Rh */
  /* set probes: Gnd -- probe-2 / probe-1 -- Rh -- Vcc */
  R_DDR = Probes.Rh_1;                  /* enable Rh for probe-1 */
    40b6:	f7 01       	movw	r30, r14
    40b8:	84 81       	ldd	r24, Z+4	; 0x04
    40ba:	84 b9       	out	0x04, r24	; 4
  R_PORT = Probes.Rh_1;                 /* pull up anode via Rh */
    40bc:	85 b9       	out	0x05, r24	; 5
  PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLUP);     /* discharge gate */
    40be:	61 e1       	ldi	r22, 0x11	; 17
    40c0:	87 81       	ldd	r24, Z+7	; 0x07
    40c2:	0e 94 2c 19 	call	0x3258	; 0x3258 <PullProbe>
  U1_Rh = ReadU_5ms(Probes.Pin_1);      /* get voltage at anode */
    40c6:	f7 01       	movw	r30, r14
    40c8:	80 81       	ld	r24, Z
    40ca:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
    40ce:	4c 01       	movw	r8, r24
                                        /* neglect voltage at cathode */

  /* measure voltage across DUT (Vf) with Rl */
  /* set probes: Gnd -- probe-2 / probe-1 -- Rl -- Vcc */
  R_DDR = Probes.Rl_1;                  /* enable Rl for probe-1 */
    40d0:	f7 01       	movw	r30, r14
    40d2:	83 81       	ldd	r24, Z+3	; 0x03
    40d4:	84 b9       	out	0x04, r24	; 4
  R_PORT = Probes.Rl_1;                 /* pull up anode via Rl */
    40d6:	85 b9       	out	0x05, r24	; 5
  PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLUP);     /* discharge gate */
    40d8:	61 e1       	ldi	r22, 0x11	; 17
    40da:	87 81       	ldd	r24, Z+7	; 0x07
    40dc:	0e 94 2c 19 	call	0x3258	; 0x3258 <PullProbe>
  U1_Rl = ReadU_5ms(Probes.Pin_1);      /* get voltage at anode */
    40e0:	f7 01       	movw	r30, r14
    40e2:	80 81       	ld	r24, Z
    40e4:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
    40e8:	8c 01       	movw	r16, r24
  U1_Rl -= ReadU(Probes.Pin_2);         /* substract voltage at cathode */
    40ea:	f7 01       	movw	r30, r14
    40ec:	81 81       	ldd	r24, Z+1	; 0x01
    40ee:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    40f2:	7c 01       	movw	r14, r24


  DischargeProbes();                    /* try to discharge probes */
    40f4:	0e 94 64 18 	call	0x30c8	; 0x30c8 <DischargeProbes>
  if (Check.Found == COMP_ERROR) return;     /* skip on error */  
    40f8:	90 91 01 01 	lds	r25, 0x0101
    40fc:	91 30       	cpi	r25, 0x01	; 1
    40fe:	09 f4       	brne	.+2      	; 0x4102 <CheckDiode+0xa4>
    4100:	0a c1       	rjmp	.+532    	; 0x4316 <CheckDiode+0x2b8>
  /* set probes: Gnd -- probe-2 / probe-1 -- Rl -- Vcc */
  R_DDR = Probes.Rl_1;                  /* enable Rl for probe-1 */
  R_PORT = Probes.Rl_1;                 /* pull up anode via Rl */
  PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLUP);     /* discharge gate */
  U1_Rl = ReadU_5ms(Probes.Pin_1);      /* get voltage at anode */
  U1_Rl -= ReadU(Probes.Pin_2);         /* substract voltage at cathode */
    4102:	0e 19       	sub	r16, r14
    4104:	1f 09       	sbc	r17, r15
   *  Vf #2, supporting a possible n-channel MOSFET
   */

  /* we assume: probe-1 = A / probe2 = C */
  /* set probes: Gnd -- probe-2 / probe-1 -- HiZ */
  ADC_PORT = 0;
    4106:	18 b8       	out	0x08, r1	; 8
  ADC_DDR = Probes.ADC_2;               /* pull down cathode directly */
    4108:	0f 2e       	mov	r0, r31
    410a:	fd e7       	ldi	r31, 0x7D	; 125
    410c:	2f 2e       	mov	r2, r31
    410e:	f1 e0       	ldi	r31, 0x01	; 1
    4110:	3f 2e       	mov	r3, r31
    4112:	f0 2d       	mov	r31, r0
    4114:	f1 01       	movw	r30, r2
    4116:	82 85       	ldd	r24, Z+10	; 0x0a
    4118:	87 b9       	out	0x07, r24	; 7
  /* R_DDR is set to HiZ by DischargeProbes() */
  U2_Zero = ReadU(Probes.Pin_1);        /* get voltage at anode */
    411a:	80 81       	ld	r24, Z
    411c:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    4120:	48 2e       	mov	r4, r24
    4122:	59 2e       	mov	r5, r25

  /* set probes: Gnd -- Rh -- probe-2 / probe-1 -- Vcc */
  ADC_DDR = 0;                          /* set to HiZ to prepare change */
    4124:	17 b8       	out	0x07, r1	; 7
  ADC_PORT = Probes.ADC_1;              /* pull up anode directly */
    4126:	f1 01       	movw	r30, r2
    4128:	81 85       	ldd	r24, Z+9	; 0x09
    412a:	88 b9       	out	0x08, r24	; 8
  ADC_DDR = Probes.ADC_1;               /* enable output */
    412c:	87 b9       	out	0x07, r24	; 7
  R_PORT = 0;                           /* pull down cathode via Rh */
    412e:	15 b8       	out	0x05, r1	; 5
  R_DDR = Probes.Rh_2;                  /* enable Rh for probe-2 */
    4130:	86 81       	ldd	r24, Z+6	; 0x06
    4132:	84 b9       	out	0x04, r24	; 4
  PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLDOWN);   /* discharge gate */
    4134:	60 e1       	ldi	r22, 0x10	; 16
    4136:	87 81       	ldd	r24, Z+7	; 0x07
    4138:	0e 94 2c 19 	call	0x3258	; 0x3258 <PullProbe>
  U2_Rh = ReadU_5ms(Probes.Pin_1);      /* get voltage at anode */
    413c:	f1 01       	movw	r30, r2
    413e:	80 81       	ld	r24, Z
    4140:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
    4144:	5c 01       	movw	r10, r24
  U2_Rh -= ReadU(Probes.Pin_2);         /* substract voltage at cathode */
    4146:	f1 01       	movw	r30, r2
    4148:	81 81       	ldd	r24, Z+1	; 0x01
    414a:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    414e:	3c 01       	movw	r6, r24

  /* set probes: Gnd -- Rl -- probe-2 / probe-1 -- Vcc */
  R_DDR = Probes.Rl_2;                  /* pull down cathode via Rl */
    4150:	f1 01       	movw	r30, r2
    4152:	85 81       	ldd	r24, Z+5	; 0x05
    4154:	84 b9       	out	0x04, r24	; 4
  PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLDOWN);   /* discharge gate */
    4156:	60 e1       	ldi	r22, 0x10	; 16
    4158:	87 81       	ldd	r24, Z+7	; 0x07
    415a:	0e 94 2c 19 	call	0x3258	; 0x3258 <PullProbe>
  U2_Rl = ReadU_5ms(Probes.Pin_1);      /* get voltage at anode */
    415e:	f1 01       	movw	r30, r2
    4160:	80 81       	ld	r24, Z
    4162:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
    4166:	7c 01       	movw	r14, r24
  U2_Rl -= ReadU(Probes.Pin_2);         /* substract voltage at cathode */
    4168:	f1 01       	movw	r30, r2
    416a:	81 81       	ldd	r24, Z+1	; 0x01
    416c:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    4170:	e8 1a       	sub	r14, r24
    4172:	f9 0a       	sbc	r15, r25

  ADC_DDR = 0;                     /* stop pulling up */
    4174:	17 b8       	out	0x07, r1	; 7
  /*
   *  process results
   */

  /* choose between both measurements */
  if (U1_Rl > U2_Rl)          /* the higher voltage wins */
    4176:	e0 16       	cp	r14, r16
    4178:	f1 06       	cpc	r15, r17
    417a:	20 f4       	brcc	.+8      	; 0x4184 <CheckDiode+0x126>
  {
    U_Diff = U1_Rl - U2_Rl;   /* difference of U_Rls */
    417c:	c8 01       	movw	r24, r16
    417e:	8e 19       	sub	r24, r14
    4180:	9f 09       	sbc	r25, r15
    4182:	09 c0       	rjmp	.+18     	; 0x4196 <CheckDiode+0x138>
  ADC_DDR = Probes.ADC_1;               /* enable output */
  R_PORT = 0;                           /* pull down cathode via Rh */
  R_DDR = Probes.Rh_2;                  /* enable Rh for probe-2 */
  PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLDOWN);   /* discharge gate */
  U2_Rh = ReadU_5ms(Probes.Pin_1);      /* get voltage at anode */
  U2_Rh -= ReadU(Probes.Pin_2);         /* substract voltage at cathode */
    4184:	45 01       	movw	r8, r10
    4186:	86 18       	sub	r8, r6
    4188:	97 08       	sbc	r9, r7
    U2_Rh = U1_Rh;
    U2_Zero = U1_Zero;
  }
  else
  {
    U_Diff = U2_Rl - U1_Rl;   /* difference of U_Rls */
    418a:	c7 01       	movw	r24, r14
    418c:	80 1b       	sub	r24, r16
    418e:	91 0b       	sbc	r25, r17
  /* we assume: probe-1 = A / probe2 = C */
  /* set probes: Gnd -- probe-2 / probe-1 -- HiZ */
  ADC_PORT = 0;
  ADC_DDR = Probes.ADC_2;               /* pull down cathode directly */
  /* R_DDR is set to HiZ by DischargeProbes() */
  U2_Zero = ReadU(Probes.Pin_1);        /* get voltage at anode */
    4190:	c4 2c       	mov	r12, r4
    4192:	d5 2c       	mov	r13, r5

  /* set probes: Gnd -- Rl -- probe-2 / probe-1 -- Vcc */
  R_DDR = Probes.Rl_2;                  /* pull down cathode via Rl */
  PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLDOWN);   /* discharge gate */
  U2_Rl = ReadU_5ms(Probes.Pin_1);      /* get voltage at anode */
  U2_Rl -= ReadU(Probes.Pin_2);         /* substract voltage at cathode */
    4194:	87 01       	movw	r16, r14
   *  - nearly zero for diodes, BJTs etc.
   *  - about a diode drop for enh-mode MOSFETs
   *  - >1000mV for dep-mode FETs partly conducting 
   */

  if (U_Diff > 1000) return;       /* dep-mode FET not fully turned off */
    4196:	89 3e       	cpi	r24, 0xE9	; 233
    4198:	93 40       	sbci	r25, 0x03	; 3
    419a:	08 f0       	brcs	.+2      	; 0x419e <CheckDiode+0x140>
    419c:	bc c0       	rjmp	.+376    	; 0x4316 <CheckDiode+0x2b8>
    #define RESISTOR_LIMIT    16
  #else
    #define RESISTOR_LIMIT    10
  #endif

  if (U2_Rh <= RESISTOR_LIMIT) return;  /* small resistor or very large cap */
    419e:	2b e0       	ldi	r18, 0x0B	; 11
    41a0:	82 16       	cp	r8, r18
    41a2:	91 04       	cpc	r9, r1
    41a4:	08 f4       	brcc	.+2      	; 0x41a8 <CheckDiode+0x14a>
    41a6:	b7 c0       	rjmp	.+366    	; 0x4316 <CheckDiode+0x2b8>
   *  Hints:
   *  If U_Zero > 10 and U_Rh is about U_Zero it's a large cap.
   *  As larger the cap as lower U_Rl (charging time 15ms).
   */

  if (U2_Rh > U2_Zero)             /* prevent underrun */
    41a8:	c8 14       	cp	r12, r8
    41aa:	d9 04       	cpc	r13, r9
    41ac:	20 f4       	brcc	.+8      	; 0x41b6 <CheckDiode+0x158>
  {
    U_Diff = U2_Rh - U2_Zero;      /* calculate difference */
    41ae:	c4 01       	movw	r24, r8
    41b0:	8c 19       	sub	r24, r12
    41b2:	9d 09       	sbc	r25, r13
    41b4:	03 c0       	rjmp	.+6      	; 0x41bc <CheckDiode+0x15e>
  }
  else
  {
    U_Diff = U2_Zero - U2_Rh;
    41b6:	c6 01       	movw	r24, r12
    41b8:	88 19       	sub	r24, r8
    41ba:	99 09       	sbc	r25, r9
  }

  if ((U2_Zero > 2) && (U_Diff < 100)) return;    /* capacitor */
    41bc:	33 e0       	ldi	r19, 0x03	; 3
    41be:	c3 16       	cp	r12, r19
    41c0:	d1 04       	cpc	r13, r1
    41c2:	20 f0       	brcs	.+8      	; 0x41cc <CheckDiode+0x16e>
    41c4:	84 36       	cpi	r24, 0x64	; 100
    41c6:	91 05       	cpc	r25, r1
    41c8:	08 f4       	brcc	.+2      	; 0x41cc <CheckDiode+0x16e>
    41ca:	a5 c0       	rjmp	.+330    	; 0x4316 <CheckDiode+0x2b8>
   *  Hint: Actually we could change the threshold above from 10 to 40mV and
   *  remove this test completely. The lowest U_Rh measured for a diode was
   *  56mV for an AA118 (Germanium).
   */

  if (U2_Rh < 40)             /* resistor (< 3k) */
    41cc:	88 e2       	ldi	r24, 0x28	; 40
    41ce:	88 16       	cp	r8, r24
    41d0:	91 04       	cpc	r9, r1
    41d2:	08 f0       	brcs	.+2      	; 0x41d6 <CheckDiode+0x178>
    41d4:	6e c0       	rjmp	.+220    	; 0x42b2 <CheckDiode+0x254>
  {
    uint32_t      a, b;

    /* calculate expected U_Rl based on measured U_Rh in mV */
    b = (R_HIGH * 10) / ((R_LOW * 10) + Config.RiH + Config.RiL);  /* k factor */
    41d6:	0f 2e       	mov	r0, r31
    41d8:	fe e8       	ldi	r31, 0x8E	; 142
    41da:	ef 2e       	mov	r14, r31
    41dc:	f1 e0       	ldi	r31, 0x01	; 1
    41de:	ff 2e       	mov	r15, r31
    41e0:	f0 2d       	mov	r31, r0
    41e2:	f7 01       	movw	r30, r14
    41e4:	23 85       	ldd	r18, Z+11	; 0x0b
    41e6:	34 85       	ldd	r19, Z+12	; 0x0c
    41e8:	81 85       	ldd	r24, Z+9	; 0x09
    41ea:	92 85       	ldd	r25, Z+10	; 0x0a
    41ec:	28 0f       	add	r18, r24
    41ee:	39 1f       	adc	r19, r25
    41f0:	20 57       	subi	r18, 0x70	; 112
    41f2:	35 4e       	sbci	r19, 0xE5	; 229
    41f4:	40 e0       	ldi	r20, 0x00	; 0
    41f6:	50 e0       	ldi	r21, 0x00	; 0
    41f8:	60 e6       	ldi	r22, 0x60	; 96
    41fa:	77 eb       	ldi	r23, 0xB7	; 183
    41fc:	87 e4       	ldi	r24, 0x47	; 71
    41fe:	90 e0       	ldi	r25, 0x00	; 0
    4200:	0e 94 62 28 	call	0x50c4	; 0x50c4 <__divmodsi4>
    4204:	29 01       	movw	r4, r18
    4206:	3a 01       	movw	r6, r20
    a = b - 1;                          /* k-1 */
    4208:	21 50       	subi	r18, 0x01	; 1
    420a:	31 09       	sbc	r19, r1
    420c:	41 09       	sbc	r20, r1
    420e:	51 09       	sbc	r21, r1
    a *= 1000;                          /* scale for mV */
    4210:	a8 ee       	ldi	r26, 0xE8	; 232
    4212:	b3 e0       	ldi	r27, 0x03	; 3
    4214:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
    a /= Config.Vcc;                    /* /Vcc (in mV) */
    4218:	f7 01       	movw	r30, r14
    421a:	27 81       	ldd	r18, Z+7	; 0x07
    421c:	30 85       	ldd	r19, Z+8	; 0x08
    421e:	40 e0       	ldi	r20, 0x00	; 0
    4220:	50 e0       	ldi	r21, 0x00	; 0
    4222:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    4226:	ca 01       	movw	r24, r20
    4228:	b9 01       	movw	r22, r18
    a *= U2_Rh;                         /* *U_Rh (in mV) */
    422a:	64 01       	movw	r12, r8
    422c:	e1 2c       	mov	r14, r1
    422e:	f1 2c       	mov	r15, r1
    4230:	a7 01       	movw	r20, r14
    4232:	96 01       	movw	r18, r12
    4234:	0e 94 08 28 	call	0x5010	; 0x5010 <__mulsi3>
    4238:	69 83       	std	Y+1, r22	; 0x01
    423a:	7a 83       	std	Y+2, r23	; 0x02
    423c:	8b 83       	std	Y+3, r24	; 0x03
    423e:	9c 83       	std	Y+4, r25	; 0x04
    a += 1000;                          /* +1 (1000 for mV) */
    b *= 1000;                          /* for mV */
    4240:	a8 ee       	ldi	r26, 0xE8	; 232
    4242:	b3 e0       	ldi	r27, 0x03	; 3
    4244:	a3 01       	movw	r20, r6
    4246:	92 01       	movw	r18, r4
    4248:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
    424c:	9b 01       	movw	r18, r22
    424e:	ac 01       	movw	r20, r24
    b *= U2_Rh;                         /* *U_Rh (in mV) */
    4250:	c7 01       	movw	r24, r14
    4252:	b6 01       	movw	r22, r12
    4254:	0e 94 08 28 	call	0x5010	; 0x5010 <__mulsi3>
    b = (R_HIGH * 10) / ((R_LOW * 10) + Config.RiH + Config.RiL);  /* k factor */
    a = b - 1;                          /* k-1 */
    a *= 1000;                          /* scale for mV */
    a /= Config.Vcc;                    /* /Vcc (in mV) */
    a *= U2_Rh;                         /* *U_Rh (in mV) */
    a += 1000;                          /* +1 (1000 for mV) */
    4258:	29 81       	ldd	r18, Y+1	; 0x01
    425a:	3a 81       	ldd	r19, Y+2	; 0x02
    425c:	4b 81       	ldd	r20, Y+3	; 0x03
    425e:	5c 81       	ldd	r21, Y+4	; 0x04
    4260:	28 51       	subi	r18, 0x18	; 24
    4262:	3c 4f       	sbci	r19, 0xFC	; 252
    4264:	4f 4f       	sbci	r20, 0xFF	; 255
    4266:	5f 4f       	sbci	r21, 0xFF	; 255
    b *= 1000;                          /* for mV */
    b *= U2_Rh;                         /* *U_Rh (in mV) */
    b /= a;                             /* U_Rl in mV */
    4268:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    426c:	69 01       	movw	r12, r18
    426e:	7a 01       	movw	r14, r20
    U1_Rl = U1_Zero;
    U1_Rh = U1_Zero;
    U1_Zero /= 10;            /* 10% */
    U1_Rh += U1_Zero;         /* 110% */
    U1_Zero = (uint16_t)b;
    U1_Zero /= 33;            /* 3% */
    4270:	af e3       	ldi	r26, 0x3F	; 63
    4272:	b8 ef       	ldi	r27, 0xF8	; 248
    4274:	0e 94 87 28 	call	0x510e	; 0x510e <__umulhisi3>
    4278:	96 95       	lsr	r25
    427a:	87 95       	ror	r24
    427c:	92 95       	swap	r25
    427e:	82 95       	swap	r24
    4280:	8f 70       	andi	r24, 0x0F	; 15
    4282:	89 27       	eor	r24, r25
    4284:	9f 70       	andi	r25, 0x0F	; 15
    4286:	89 27       	eor	r24, r25
    U1_Rl -= U1_Zero;         /* 97% (for resistors near 1k) */
    4288:	28 1b       	sub	r18, r24
    428a:	39 0b       	sbc	r19, r25

    if ((U2_Rl >= U1_Rl) && (U2_Rl <= U1_Rh)) return;     /* resistor */
    428c:	02 17       	cp	r16, r18
    428e:	13 07       	cpc	r17, r19
    4290:	80 f0       	brcs	.+32     	; 0x42b2 <CheckDiode+0x254>

    /* check if calculated U_Rl is within some % of measured value */
    U1_Zero = (uint16_t)b;
    U1_Rl = U1_Zero;
    U1_Rh = U1_Zero;
    U1_Zero /= 10;            /* 10% */
    4292:	96 01       	movw	r18, r12
    4294:	ad ec       	ldi	r26, 0xCD	; 205
    4296:	bc ec       	ldi	r27, 0xCC	; 204
    4298:	0e 94 87 28 	call	0x510e	; 0x510e <__umulhisi3>
    429c:	96 95       	lsr	r25
    429e:	87 95       	ror	r24
    42a0:	96 95       	lsr	r25
    42a2:	87 95       	ror	r24
    42a4:	96 95       	lsr	r25
    42a6:	87 95       	ror	r24
    U1_Rh += U1_Zero;         /* 110% */
    42a8:	c8 0e       	add	r12, r24
    42aa:	d9 1e       	adc	r13, r25
    U1_Zero = (uint16_t)b;
    U1_Zero /= 33;            /* 3% */
    U1_Rl -= U1_Zero;         /* 97% (for resistors near 1k) */

    if ((U2_Rl >= U1_Rl) && (U2_Rl <= U1_Rh)) return;     /* resistor */
    42ac:	c0 16       	cp	r12, r16
    42ae:	d1 06       	cpc	r13, r17
    42b0:	90 f5       	brcc	.+100    	; 0x4316 <CheckDiode+0x2b8>

  /*
   *  if U_Rl (Vf) is between 0.15V and 4.64V it's a diode
   */

  if ((U2_Rl > 150) && (U2_Rl < 4640))
    42b2:	c8 01       	movw	r24, r16
    42b4:	87 59       	subi	r24, 0x97	; 151
    42b6:	91 09       	sbc	r25, r1
    42b8:	89 38       	cpi	r24, 0x89	; 137
    42ba:	91 41       	sbci	r25, 0x11	; 17
    42bc:	60 f5       	brcc	.+88     	; 0x4316 <CheckDiode+0x2b8>
  {
    /* if we haven't found any other component yet */
    if ((Check.Found == COMP_NONE) ||
    42be:	80 91 01 01 	lds	r24, 0x0101
    42c2:	88 23       	and	r24, r24
    42c4:	11 f0       	breq	.+4      	; 0x42ca <CheckDiode+0x26c>
    42c6:	8a 30       	cpi	r24, 0x0A	; 10
    42c8:	19 f4       	brne	.+6      	; 0x42d0 <CheckDiode+0x272>
        (Check.Found == COMP_RESISTOR))
    {
      Check.Found = COMP_DIODE;
    42ca:	84 e1       	ldi	r24, 0x14	; 20
    42cc:	80 93 01 01 	sts	0x0101, r24
    }

    /* save data */
    Diode = &Diodes[Check.Diodes];
    42d0:	60 e0       	ldi	r22, 0x00	; 0
    42d2:	71 e0       	ldi	r23, 0x01	; 1
    42d4:	fb 01       	movw	r30, r22
    42d6:	24 81       	ldd	r18, Z+4	; 0x04
    42d8:	82 2f       	mov	r24, r18
    42da:	90 e0       	ldi	r25, 0x00	; 0
    Diode->A = Probes.Pin_1;
    42dc:	7c 01       	movw	r14, r24
    42de:	ee 0c       	add	r14, r14
    42e0:	ff 1c       	adc	r15, r15
    42e2:	d7 01       	movw	r26, r14
    42e4:	a8 0f       	add	r26, r24
    42e6:	b9 1f       	adc	r27, r25
    42e8:	aa 0f       	add	r26, r26
    42ea:	bb 1f       	adc	r27, r27
    42ec:	a6 5b       	subi	r26, 0xB6	; 182
    42ee:	be 4f       	sbci	r27, 0xFE	; 254
    42f0:	4d e7       	ldi	r20, 0x7D	; 125
    42f2:	51 e0       	ldi	r21, 0x01	; 1
    42f4:	fa 01       	movw	r30, r20
    42f6:	30 81       	ld	r19, Z
    42f8:	3c 93       	st	X, r19
    Diode->C = Probes.Pin_2;
    42fa:	31 81       	ldd	r19, Z+1	; 0x01
    42fc:	11 96       	adiw	r26, 0x01	; 1
    42fe:	3c 93       	st	X, r19
    4300:	11 97       	sbiw	r26, 0x01	; 1
    Diode->V_f = U2_Rl;       /* Vf for high measurement current */
    4302:	13 96       	adiw	r26, 0x03	; 3
    4304:	1c 93       	st	X, r17
    4306:	0e 93       	st	-X, r16
    4308:	12 97       	sbiw	r26, 0x02	; 2
    Diode->V_f2 = U2_Rh;      /* Vf for low measurement current */
    430a:	fd 01       	movw	r30, r26
    430c:	95 82       	std	Z+5, r9	; 0x05
    430e:	84 82       	std	Z+4, r8	; 0x04
    Check.Diodes++;
    4310:	2f 5f       	subi	r18, 0xFF	; 255
    4312:	fb 01       	movw	r30, r22
    4314:	24 83       	std	Z+4, r18	; 0x04
  }

  #undef RESISTOR_LIMIT
}
    4316:	0f 90       	pop	r0
    4318:	0f 90       	pop	r0
    431a:	0f 90       	pop	r0
    431c:	0f 90       	pop	r0
    431e:	df 91       	pop	r29
    4320:	cf 91       	pop	r28
    4322:	1f 91       	pop	r17
    4324:	0f 91       	pop	r16
    4326:	ff 90       	pop	r15
    4328:	ef 90       	pop	r14
    432a:	df 90       	pop	r13
    432c:	cf 90       	pop	r12
    432e:	bf 90       	pop	r11
    4330:	af 90       	pop	r10
    4332:	9f 90       	pop	r9
    4334:	8f 90       	pop	r8
    4336:	7f 90       	pop	r7
    4338:	6f 90       	pop	r6
    433a:	5f 90       	pop	r5
    433c:	4f 90       	pop	r4
    433e:	3f 90       	pop	r3
    4340:	2f 90       	pop	r2
    4342:	08 95       	ret

00004344 <VerifyMOSFET>:
  uint8_t           Anode;
  uint8_t           Cathode;
  Diode_Type        *Diode;             /* pointer to diode */

  /* set expected body diode */
  if (Check.Type & TYPE_N_CHANNEL)      /* n-channel */
    4344:	80 91 02 01 	lds	r24, 0x0102
    4348:	80 ff       	sbrs	r24, 0
    434a:	05 c0       	rjmp	.+10     	; 0x4356 <VerifyMOSFET+0x12>
  {
    Anode = Semi.C;      /* anode at source */
    434c:	ef e6       	ldi	r30, 0x6F	; 111
    434e:	f1 e0       	ldi	r31, 0x01	; 1
    4350:	42 81       	ldd	r20, Z+2	; 0x02
    Cathode = Semi.B;    /* cathode at drain */
    4352:	31 81       	ldd	r19, Z+1	; 0x01
    4354:	04 c0       	rjmp	.+8      	; 0x435e <VerifyMOSFET+0x1a>
  }
  else                                  /* p-channel */
  {
    Anode = Semi.B;      /* anode at drain */
    4356:	ef e6       	ldi	r30, 0x6F	; 111
    4358:	f1 e0       	ldi	r31, 0x01	; 1
    435a:	41 81       	ldd	r20, Z+1	; 0x01
    Cathode = Semi.C;    /* cathode at source */
    435c:	32 81       	ldd	r19, Z+2	; 0x02
  }

  Diode = &Diodes[0];              /* first diode */

  /* check all known diodes for reversed one */
  while (n < Check.Diodes)
    435e:	20 91 04 01 	lds	r18, 0x0104
    4362:	22 23       	and	r18, r18
    4364:	d9 f0       	breq	.+54     	; 0x439c <VerifyMOSFET+0x58>
    4366:	eb e4       	ldi	r30, 0x4B	; 75
    4368:	f1 e0       	ldi	r31, 0x01	; 1
    436a:	80 e0       	ldi	r24, 0x00	; 0
    436c:	50 e0       	ldi	r21, 0x00	; 0
  {
    if ((Diode->A == Cathode) && (Diode->C == Anode))
    {
      Flag = 1;          /* signal match */
      n = 10;            /* end loop */
    436e:	7a e0       	ldi	r23, 0x0A	; 10
  /* check all known diodes for reversed one */
  while (n < Check.Diodes)
  {
    if ((Diode->A == Cathode) && (Diode->C == Anode))
    {
      Flag = 1;          /* signal match */
    4370:	61 e0       	ldi	r22, 0x01	; 1
    4372:	df 01       	movw	r26, r30
    4374:	11 97       	sbiw	r26, 0x01	; 1
  Diode = &Diodes[0];              /* first diode */

  /* check all known diodes for reversed one */
  while (n < Check.Diodes)
  {
    if ((Diode->A == Cathode) && (Diode->C == Anode))
    4376:	9c 91       	ld	r25, X
    4378:	93 13       	cpse	r25, r19
    437a:	05 c0       	rjmp	.+10     	; 0x4386 <VerifyMOSFET+0x42>
    437c:	90 81       	ld	r25, Z
    437e:	94 13       	cpse	r25, r20
    4380:	02 c0       	rjmp	.+4      	; 0x4386 <VerifyMOSFET+0x42>
    {
      Flag = 1;          /* signal match */
      n = 10;            /* end loop */
    4382:	87 2f       	mov	r24, r23
  /* check all known diodes for reversed one */
  while (n < Check.Diodes)
  {
    if ((Diode->A == Cathode) && (Diode->C == Anode))
    {
      Flag = 1;          /* signal match */
    4384:	56 2f       	mov	r21, r22
      n = 10;            /* end loop */
    }

    n++;                 /* next diode */
    4386:	8f 5f       	subi	r24, 0xFF	; 255
    4388:	36 96       	adiw	r30, 0x06	; 6
  }

  Diode = &Diodes[0];              /* first diode */

  /* check all known diodes for reversed one */
  while (n < Check.Diodes)
    438a:	82 17       	cp	r24, r18
    438c:	90 f3       	brcs	.-28     	; 0x4372 <VerifyMOSFET+0x2e>

    n++;                 /* next diode */
    Diode++;
  }

  if (Flag == 1)         /* found reversed diode */
    438e:	51 30       	cpi	r21, 0x01	; 1
    4390:	29 f4       	brne	.+10     	; 0x439c <VerifyMOSFET+0x58>
  {
    /* this can't be a MOSFET, so let's reset */
    Check.Found = COMP_NONE;
    4392:	e0 e0       	ldi	r30, 0x00	; 0
    4394:	f1 e0       	ldi	r31, 0x01	; 1
    4396:	11 82       	std	Z+1, r1	; 0x01
    Check.Type = 0;
    4398:	12 82       	std	Z+2, r1	; 0x02
    Check.Done = 0;
    439a:	10 82       	st	Z, r1
    439c:	08 95       	ret

0000439e <CheckBJTorEnhModeMOSFET>:
 *  - BJT_Type: NPN or PNP (also used for FET channel type)
 *  - U_Rl: voltage across Rl pulled down
 */

void CheckBJTorEnhModeMOSFET(uint8_t BJT_Type, uint16_t U_Rl)
{
    439e:	8f 92       	push	r8
    43a0:	9f 92       	push	r9
    43a2:	af 92       	push	r10
    43a4:	bf 92       	push	r11
    43a6:	cf 92       	push	r12
    43a8:	df 92       	push	r13
    43aa:	ef 92       	push	r14
    43ac:	ff 92       	push	r15
    43ae:	0f 93       	push	r16
    43b0:	1f 93       	push	r17
    43b2:	cf 93       	push	r28
    43b4:	df 93       	push	r29
    43b6:	18 2f       	mov	r17, r24
    43b8:	5b 01       	movw	r10, r22

  /*
   *  init, set probes and measure
   */

  if (BJT_Type == TYPE_NPN)   /* NPN / n-channel */
    43ba:	81 30       	cpi	r24, 0x01	; 1
    43bc:	31 f5       	brne	.+76     	; 0x440a <CheckBJTorEnhModeMOSFET+0x6c>
     *  - FET: probe-1 = D / probe-2 = S / probe-3 = G
     *  probes already set to: Gnd -- probe-2 / probe-1 -- Rl -- Vcc
     *  drive base/gate via Rh instead of Rl
     */

    R_DDR = Probes.Rl_1 | Probes.Rh_3;  /* enable Rl for probe-1 & Rh for probe-3 */
    43be:	cd e7       	ldi	r28, 0x7D	; 125
    43c0:	d1 e0       	ldi	r29, 0x01	; 1
    43c2:	98 85       	ldd	r25, Y+8	; 0x08
    43c4:	8b 81       	ldd	r24, Y+3	; 0x03
    43c6:	89 2b       	or	r24, r25
    43c8:	84 b9       	out	0x04, r24	; 4
    R_PORT = Probes.Rl_1 | Probes.Rh_3; /* pull up collector via Rl and base via Rh */
    43ca:	85 b9       	out	0x05, r24	; 5
    wait50ms();                         /* wait to skip gate charging of a FET */
    43cc:	0e 94 76 00 	call	0xec	; 0xec <wait50ms>
    U_R_c = Config.Vcc - ReadU(Probes.Pin_1);     /* U_R_c = Vcc - U_c */ 
    43d0:	0f 2e       	mov	r0, r31
    43d2:	fe e8       	ldi	r31, 0x8E	; 142
    43d4:	cf 2e       	mov	r12, r31
    43d6:	f1 e0       	ldi	r31, 0x01	; 1
    43d8:	df 2e       	mov	r13, r31
    43da:	f0 2d       	mov	r31, r0
    43dc:	f6 01       	movw	r30, r12
    43de:	e7 80       	ldd	r14, Z+7	; 0x07
    43e0:	f0 84       	ldd	r15, Z+8	; 0x08
    43e2:	88 81       	ld	r24, Y
    43e4:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    43e8:	e8 1a       	sub	r14, r24
    43ea:	f9 0a       	sbc	r15, r25
    U_R_b = Config.Vcc - ReadU(Probes.Pin_3);     /* U_R_b = Vcc - U_b */
    43ec:	f6 01       	movw	r30, r12
    43ee:	c7 80       	ldd	r12, Z+7	; 0x07
    43f0:	d0 84       	ldd	r13, Z+8	; 0x08
    43f2:	8a 81       	ldd	r24, Y+2	; 0x02
    43f4:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    43f8:	e6 01       	movw	r28, r12
    43fa:	c8 1b       	sub	r28, r24
    43fc:	d9 0b       	sbc	r29, r25
   */

  if (BJT_Type == TYPE_NPN)   /* NPN / n-channel */
  {
    BJT_Level = 2557;         /* voltage across base resistor (5.44킕) */
    FET_Level = 3400;         /* voltage across drain resistor (4.8mA) */
    43fe:	88 e4       	ldi	r24, 0x48	; 72
    4400:	9d e0       	ldi	r25, 0x0D	; 13
   *  init, set probes and measure
   */

  if (BJT_Type == TYPE_NPN)   /* NPN / n-channel */
  {
    BJT_Level = 2557;         /* voltage across base resistor (5.44킕) */
    4402:	2d ef       	ldi	r18, 0xFD	; 253
    4404:	39 e0       	ldi	r19, 0x09	; 9
    FET_Level = 3400;         /* voltage across drain resistor (4.8mA) */
    FET_Type = TYPE_N_CHANNEL;
    4406:	01 e0       	ldi	r16, 0x01	; 1
    4408:	13 c0       	rjmp	.+38     	; 0x4430 <CheckBJTorEnhModeMOSFET+0x92>
     *  - FET: probe-1 = S / probe-2 = D / probe-3 = G
     *  probes already set to: Gnd -- Rl - probe-2 / probe-1 -- Vcc
     *  drive base/gate via Rh instead of Rl
     */

    R_DDR = Probes.Rl_2 | Probes.Rh_3;  /* pull down base via Rh */
    440a:	cd e7       	ldi	r28, 0x7D	; 125
    440c:	d1 e0       	ldi	r29, 0x01	; 1
    440e:	98 85       	ldd	r25, Y+8	; 0x08
    4410:	8d 81       	ldd	r24, Y+5	; 0x05
    4412:	89 2b       	or	r24, r25
    4414:	84 b9       	out	0x04, r24	; 4
    U_R_c = ReadU_5ms(Probes.Pin_2);    /* U_R_c = U_c */
    4416:	89 81       	ldd	r24, Y+1	; 0x01
    4418:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
    441c:	7c 01       	movw	r14, r24
    U_R_b = ReadU(Probes.Pin_3);        /* U_R_b = U_b */
    441e:	8a 81       	ldd	r24, Y+2	; 0x02
    4420:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    4424:	ec 01       	movw	r28, r24
    U_R_b = Config.Vcc - ReadU(Probes.Pin_3);     /* U_R_b = Vcc - U_b */
  }
  else                        /* PNP / p-channel */
  {
    BJT_Level = 977;          /* voltage across base resistor (2.1킕) */
    FET_Level = 2000;         /* voltage across drain resistor (2.8mA) */
    4426:	80 ed       	ldi	r24, 0xD0	; 208
    4428:	97 e0       	ldi	r25, 0x07	; 7
    U_R_c = Config.Vcc - ReadU(Probes.Pin_1);     /* U_R_c = Vcc - U_c */ 
    U_R_b = Config.Vcc - ReadU(Probes.Pin_3);     /* U_R_b = Vcc - U_b */
  }
  else                        /* PNP / p-channel */
  {
    BJT_Level = 977;          /* voltage across base resistor (2.1킕) */
    442a:	21 ed       	ldi	r18, 0xD1	; 209
    442c:	33 e0       	ldi	r19, 0x03	; 3
    FET_Level = 2000;         /* voltage across drain resistor (2.8mA) */
    FET_Type = TYPE_P_CHANNEL;
    442e:	02 e0       	ldi	r16, 0x02	; 2

  /*
   *  distinguish BJT from enhancement-mode MOSFET
   */

  if (U_R_b > BJT_Level)      /* U_R_b exceeds minimum level of BJT */
    4430:	2c 17       	cp	r18, r28
    4432:	3d 07       	cpc	r19, r29
    4434:	08 f0       	brcs	.+2      	; 0x4438 <CheckBJTorEnhModeMOSFET+0x9a>
    4436:	9a c0       	rjmp	.+308    	; 0x456c <CheckBJTorEnhModeMOSFET+0x1ce>
     *  A reversed collector and emitter also passes the tests, but with a
     *  lower hFE. So we need to run the BJT test twice to be sure and select
     *  the results with the higher hFE.
     */

    if (Check.Found == COMP_BJT)        /* second test run */
    4438:	80 91 01 01 	lds	r24, 0x0101
    443c:	85 31       	cpi	r24, 0x15	; 21
    443e:	61 f4       	brne	.+24     	; 0x4458 <CheckBJTorEnhModeMOSFET+0xba>
    {
      Check.Done = 1;                   /* no more tests needed */
    4440:	e0 e0       	ldi	r30, 0x00	; 0
    4442:	f1 e0       	ldi	r31, 0x01	; 1
    4444:	81 e0       	ldi	r24, 0x01	; 1
    4446:	80 83       	st	Z, r24
      /*
       *  If the type is different from the one in the first run, we have
       *  a parasitic BJT (caused by a freewheeling diode on the same substrate).
       */

      if (!(Check.Type & BJT_Type)) Check.Type |= TYPE_PARASITIC;
    4448:	82 81       	ldd	r24, Z+2	; 0x02
    444a:	91 2f       	mov	r25, r17
    444c:	98 23       	and	r25, r24
    444e:	49 f4       	brne	.+18     	; 0x4462 <CheckBJTorEnhModeMOSFET+0xc4>
    4450:	84 60       	ori	r24, 0x04	; 4
    4452:	80 93 02 01 	sts	0x0102, r24
    4456:	05 c0       	rjmp	.+10     	; 0x4462 <CheckBJTorEnhModeMOSFET+0xc4>
    }
    else                                /* first test run */
    {
      Check.Found = COMP_BJT;
    4458:	e0 e0       	ldi	r30, 0x00	; 0
    445a:	f1 e0       	ldi	r31, 0x01	; 1
    445c:	85 e1       	ldi	r24, 0x15	; 21
    445e:	81 83       	std	Z+1, r24	; 0x01
      Check.Type = BJT_Type;
    4460:	12 83       	std	Z+2, r17	; 0x02
    }

    /* leakage current */
    I_CE0 = GetLeakageCurrent();        /* get leakage current (in 킕) */
    4462:	0e 94 e9 1f 	call	0x3fd2	; 0x3fd2 <GetLeakageCurrent>
    4466:	6c 01       	movw	r12, r24
     *        = (U_R_c_conducting - U_R_c_leak) / R_c
     *    -> U_R_c = U_R_c_conducting - U_R_c_leak
     *             = U_R_c_conducting - U_Rl
     */

    if (U_R_c > U_Rl) U_R_c -= U_Rl;       /* - U_Rl (leakage) */
    4468:	ae 14       	cp	r10, r14
    446a:	bf 04       	cpc	r11, r15
    446c:	10 f4       	brcc	.+4      	; 0x4472 <CheckBJTorEnhModeMOSFET+0xd4>
    446e:	ea 18       	sub	r14, r10
    4470:	fb 08       	sbc	r15, r11
    hFE_E = U_R_c * R_HIGH;                /* U_R_c * R_b */
    4472:	d7 01       	movw	r26, r14
    4474:	20 ef       	ldi	r18, 0xF0	; 240
    4476:	3b e2       	ldi	r19, 0x2B	; 43
    4478:	47 e0       	ldi	r20, 0x07	; 7
    447a:	50 e0       	ldi	r21, 0x00	; 0
    447c:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
    hFE_E /= U_R_b;                        /* / U_R_b */
    4480:	9e 01       	movw	r18, r28
    4482:	40 e0       	ldi	r20, 0x00	; 0
    4484:	50 e0       	ldi	r21, 0x00	; 0
    4486:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    hFE_E *= 10;                           /* upscale to 0.1 */
    448a:	da 01       	movw	r26, r20
    448c:	c9 01       	movw	r24, r18
    448e:	88 0f       	add	r24, r24
    4490:	99 1f       	adc	r25, r25
    4492:	aa 1f       	adc	r26, r26
    4494:	bb 1f       	adc	r27, r27
    4496:	4c 01       	movw	r8, r24
    4498:	5d 01       	movw	r10, r26
    449a:	88 0c       	add	r8, r8
    449c:	99 1c       	adc	r9, r9
    449e:	aa 1c       	adc	r10, r10
    44a0:	bb 1c       	adc	r11, r11
    44a2:	88 0c       	add	r8, r8
    44a4:	99 1c       	adc	r9, r9
    44a6:	aa 1c       	adc	r10, r10
    44a8:	bb 1c       	adc	r11, r11
    44aa:	bc 01       	movw	r22, r24
    44ac:	cd 01       	movw	r24, r26
    44ae:	68 0d       	add	r22, r8
    44b0:	79 1d       	adc	r23, r9
    44b2:	8a 1d       	adc	r24, r10
    44b4:	9b 1d       	adc	r25, r11

    if (BJT_Type == TYPE_NPN)      /* NPN */
    44b6:	11 30       	cpi	r17, 0x01	; 1
    44b8:	69 f4       	brne	.+26     	; 0x44d4 <CheckBJTorEnhModeMOSFET+0x136>
      hFE_E /= (R_LOW * 10) + Config.RiH;    /* / R_c in 0.1 Ohm */
    44ba:	20 91 99 01 	lds	r18, 0x0199
    44be:	30 91 9a 01 	lds	r19, 0x019A
    44c2:	20 57       	subi	r18, 0x70	; 112
    44c4:	35 4e       	sbci	r19, 0xE5	; 229
    44c6:	40 e0       	ldi	r20, 0x00	; 0
    44c8:	50 e0       	ldi	r21, 0x00	; 0
    44ca:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    44ce:	49 01       	movw	r8, r18
    44d0:	5a 01       	movw	r10, r20
    44d2:	0c c0       	rjmp	.+24     	; 0x44ec <CheckBJTorEnhModeMOSFET+0x14e>
    else                           /* PNP */
      hFE_E /= (R_LOW * 10) + Config.RiL;    /* / R_c in 0.1 Ohm */
    44d4:	20 91 97 01 	lds	r18, 0x0197
    44d8:	30 91 98 01 	lds	r19, 0x0198
    44dc:	20 57       	subi	r18, 0x70	; 112
    44de:	35 4e       	sbci	r19, 0xE5	; 229
    44e0:	40 e0       	ldi	r20, 0x00	; 0
    44e2:	50 e0       	ldi	r21, 0x00	; 0
    44e4:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    44e8:	49 01       	movw	r8, r18
    44ea:	5a 01       	movw	r10, r20

    /* get hFE for common collector circuit */
    hFE_C = Get_hFE_C(BJT_Type);
    44ec:	81 2f       	mov	r24, r17
    44ee:	0e 94 7c 1e 	call	0x3cf8	; 0x3cf8 <Get_hFE_C>

    /* keep higher hFE */
    if (hFE_C > hFE_E) hFE_E = hFE_C;

    /* parasitic BJT */
    if (Check.Type & TYPE_PARASITIC)
    44f2:	30 91 02 01 	lds	r19, 0x0102
    44f6:	32 fd       	sbrc	r19, 2
    44f8:	7f c0       	rjmp	.+254    	; 0x45f8 <CheckBJTorEnhModeMOSFET+0x25a>
    44fa:	46 2f       	mov	r20, r22
    44fc:	57 2f       	mov	r21, r23
    44fe:	68 2f       	mov	r22, r24
    4500:	79 2f       	mov	r23, r25
    4502:	48 15       	cp	r20, r8
    4504:	59 05       	cpc	r21, r9
    4506:	6a 05       	cpc	r22, r10
    4508:	7b 05       	cpc	r23, r11
    450a:	10 f4       	brcc	.+4      	; 0x4510 <CheckBJTorEnhModeMOSFET+0x172>
    450c:	b5 01       	movw	r22, r10
    450e:	a4 01       	movw	r20, r8

      hFE_E = 0;    /* we keep the first type found at the moment */
    }

    /* only update data if hFE is higher than old one or not set yet */
    if (hFE_E > Semi.F_1)
    4510:	80 91 78 01 	lds	r24, 0x0178
    4514:	90 91 79 01 	lds	r25, 0x0179
    4518:	a0 91 7a 01 	lds	r26, 0x017A
    451c:	b0 91 7b 01 	lds	r27, 0x017B
    4520:	84 17       	cp	r24, r20
    4522:	95 07       	cpc	r25, r21
    4524:	a6 07       	cpc	r26, r22
    4526:	b7 07       	cpc	r27, r23
    4528:	08 f0       	brcs	.+2      	; 0x452c <CheckBJTorEnhModeMOSFET+0x18e>
    452a:	66 c0       	rjmp	.+204    	; 0x45f8 <CheckBJTorEnhModeMOSFET+0x25a>
    {
      /* save data */
      Semi.F_1 = hFE_E;            /* hFE */
    452c:	ef e6       	ldi	r30, 0x6F	; 111
    452e:	f1 e0       	ldi	r31, 0x01	; 1
    4530:	41 87       	std	Z+9, r20	; 0x09
    4532:	52 87       	std	Z+10, r21	; 0x0a
    4534:	63 87       	std	Z+11, r22	; 0x0b
    4536:	74 87       	std	Z+12, r23	; 0x0c
      Semi.I_1 = I_CE0;            /* leakage current */
    4538:	d0 86       	std	Z+8, r13	; 0x08
    453a:	c7 82       	std	Z+7, r12	; 0x07
      Semi.A = Probes.Pin_3;       /* base pin */
    453c:	80 91 7f 01 	lds	r24, 0x017F
    4540:	80 83       	st	Z, r24

      /* update Collector and Emitter pins */
      if (BJT_Type == TYPE_NPN)    /* NPN */
    4542:	11 30       	cpi	r17, 0x01	; 1
    4544:	41 f4       	brne	.+16     	; 0x4556 <CheckBJTorEnhModeMOSFET+0x1b8>
      {
        Semi.B = Probes.Pin_1;     /* collector pin */
    4546:	ad e7       	ldi	r26, 0x7D	; 125
    4548:	b1 e0       	ldi	r27, 0x01	; 1
    454a:	8c 91       	ld	r24, X
    454c:	81 83       	std	Z+1, r24	; 0x01
        Semi.C = Probes.Pin_2;     /* emitter pin */
    454e:	11 96       	adiw	r26, 0x01	; 1
    4550:	8c 91       	ld	r24, X
    4552:	82 83       	std	Z+2, r24	; 0x02
    4554:	51 c0       	rjmp	.+162    	; 0x45f8 <CheckBJTorEnhModeMOSFET+0x25a>
      }
      else                         /* PNP */
      {
        Semi.B = Probes.Pin_2;     /* collector pin */
    4556:	ef e6       	ldi	r30, 0x6F	; 111
    4558:	f1 e0       	ldi	r31, 0x01	; 1
    455a:	ad e7       	ldi	r26, 0x7D	; 125
    455c:	b1 e0       	ldi	r27, 0x01	; 1
    455e:	11 96       	adiw	r26, 0x01	; 1
    4560:	8c 91       	ld	r24, X
    4562:	11 97       	sbiw	r26, 0x01	; 1
    4564:	81 83       	std	Z+1, r24	; 0x01
        Semi.C = Probes.Pin_1;     /* emitter pin */
    4566:	8c 91       	ld	r24, X
    4568:	82 83       	std	Z+2, r24	; 0x02
    456a:	46 c0       	rjmp	.+140    	; 0x45f8 <CheckBJTorEnhModeMOSFET+0x25a>
      }
    }
  }
  else if ((U_Rl < 97) && (U_R_c > FET_Level))    /* no BJT */
    456c:	f1 e6       	ldi	r31, 0x61	; 97
    456e:	af 16       	cp	r10, r31
    4570:	b1 04       	cpc	r11, r1
    4572:	08 f0       	brcs	.+2      	; 0x4576 <CheckBJTorEnhModeMOSFET+0x1d8>
    4574:	41 c0       	rjmp	.+130    	; 0x45f8 <CheckBJTorEnhModeMOSFET+0x25a>
    4576:	8e 15       	cp	r24, r14
    4578:	9f 05       	cpc	r25, r15
    457a:	f0 f5       	brcc	.+124    	; 0x45f8 <CheckBJTorEnhModeMOSFET+0x25a>
     *  while an IGBT acts more like a diode. So we measure the voltage drop
     *  across the conducting path. A MOSFET got a low voltage drop based on
     *  it's R_DS_on and the current. An IGBT got a much higher voltage drop.
     */

    I_CE0= ReadU(Probes.Pin_1) - ReadU(Probes.Pin_2);
    457c:	cd e7       	ldi	r28, 0x7D	; 125
    457e:	d1 e0       	ldi	r29, 0x01	; 1
    4580:	88 81       	ld	r24, Y
    4582:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    4586:	7c 01       	movw	r14, r24
    4588:	89 81       	ldd	r24, Y+1	; 0x01
    458a:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    458e:	e7 01       	movw	r28, r14
    4590:	c8 1b       	sub	r28, r24
    4592:	d9 0b       	sbc	r29, r25

    if (I_CE0 < 250)          /* MOSFET */
    4594:	ca 3f       	cpi	r28, 0xFA	; 250
    4596:	d1 05       	cpc	r29, r1
    4598:	40 f4       	brcc	.+16     	; 0x45aa <CheckBJTorEnhModeMOSFET+0x20c>
    {
      Check.Found = COMP_FET;
    459a:	e0 e0       	ldi	r30, 0x00	; 0
    459c:	f1 e0       	ldi	r31, 0x01	; 1
    459e:	86 e1       	ldi	r24, 0x16	; 22
    45a0:	81 83       	std	Z+1, r24	; 0x01
      Check.Type = FET_Type | TYPE_ENHANCEMENT | TYPE_MOSFET;
    45a2:	80 2f       	mov	r24, r16
    45a4:	84 61       	ori	r24, 0x14	; 20
    45a6:	82 83       	std	Z+2, r24	; 0x02
    45a8:	07 c0       	rjmp	.+14     	; 0x45b8 <CheckBJTorEnhModeMOSFET+0x21a>
    }
    else                      /* IGBT */
    {
      Check.Found = COMP_IGBT;
    45aa:	e0 e0       	ldi	r30, 0x00	; 0
    45ac:	f1 e0       	ldi	r31, 0x01	; 1
    45ae:	87 e1       	ldi	r24, 0x17	; 23
    45b0:	81 83       	std	Z+1, r24	; 0x01
      Check.Type = FET_Type | TYPE_ENHANCEMENT;
    45b2:	80 2f       	mov	r24, r16
    45b4:	84 60       	ori	r24, 0x04	; 4
    45b6:	82 83       	std	Z+2, r24	; 0x02
    }

    Check.Done = 1;           /* transistor found */
    45b8:	81 e0       	ldi	r24, 0x01	; 1
    45ba:	80 93 00 01 	sts	0x0100, r24

    /* measure gate threshold voltage */
    GetGateThreshold(FET_Type);
    45be:	80 2f       	mov	r24, r16
    45c0:	0e 94 3e 1f 	call	0x3e7c	; 0x3e7c <GetGateThreshold>

    /* save data */
    Semi.A = Probes.Pin_3;          /* gate pin */
    45c4:	80 91 7f 01 	lds	r24, 0x017F
    45c8:	80 93 6f 01 	sts	0x016F, r24

    if (FET_Type == TYPE_N_CHANNEL)     /* n-channel */
    45cc:	01 30       	cpi	r16, 0x01	; 1
    45ce:	51 f4       	brne	.+20     	; 0x45e4 <CheckBJTorEnhModeMOSFET+0x246>
    {
      Semi.B = Probes.Pin_1;       /* drain pin */
    45d0:	ef e6       	ldi	r30, 0x6F	; 111
    45d2:	f1 e0       	ldi	r31, 0x01	; 1
    45d4:	ad e7       	ldi	r26, 0x7D	; 125
    45d6:	b1 e0       	ldi	r27, 0x01	; 1
    45d8:	8c 91       	ld	r24, X
    45da:	81 83       	std	Z+1, r24	; 0x01
      Semi.C = Probes.Pin_2;       /* source pin */
    45dc:	11 96       	adiw	r26, 0x01	; 1
    45de:	8c 91       	ld	r24, X
    45e0:	82 83       	std	Z+2, r24	; 0x02
    45e2:	0a c0       	rjmp	.+20     	; 0x45f8 <CheckBJTorEnhModeMOSFET+0x25a>
    }
    else                                /* p-channel */
    {
      Semi.B = Probes.Pin_2;       /* drain pin */
    45e4:	ef e6       	ldi	r30, 0x6F	; 111
    45e6:	f1 e0       	ldi	r31, 0x01	; 1
    45e8:	ad e7       	ldi	r26, 0x7D	; 125
    45ea:	b1 e0       	ldi	r27, 0x01	; 1
    45ec:	11 96       	adiw	r26, 0x01	; 1
    45ee:	8c 91       	ld	r24, X
    45f0:	11 97       	sbiw	r26, 0x01	; 1
    45f2:	81 83       	std	Z+1, r24	; 0x01
      Semi.C = Probes.Pin_1;       /* source pin */
    45f4:	8c 91       	ld	r24, X
    45f6:	82 83       	std	Z+2, r24	; 0x02
    }
  }
}
    45f8:	df 91       	pop	r29
    45fa:	cf 91       	pop	r28
    45fc:	1f 91       	pop	r17
    45fe:	0f 91       	pop	r16
    4600:	ff 90       	pop	r15
    4602:	ef 90       	pop	r14
    4604:	df 90       	pop	r13
    4606:	cf 90       	pop	r12
    4608:	bf 90       	pop	r11
    460a:	af 90       	pop	r10
    460c:	9f 90       	pop	r9
    460e:	8f 90       	pop	r8
    4610:	08 95       	ret

00004612 <CheckDepletionModeFET>:
 *  requires:
 *  - voltage across Rl in pull-down mode
 */

void CheckDepletionModeFET(void)
{
    4612:	cf 92       	push	r12
    4614:	df 92       	push	r13
    4616:	ef 92       	push	r14
    4618:	ff 92       	push	r15
    461a:	0f 93       	push	r16
    461c:	1f 93       	push	r17
    461e:	cf 93       	push	r28
    4620:	df 93       	push	r29
  /*
   *  check if we got a n-channel JFET or depletion-mode MOSFET
   *  - JFETs are depletion-mode only
   */

  if (Check.Done == 0)        /* no transistor found yet */
    4622:	80 91 00 01 	lds	r24, 0x0100
    4626:	81 11       	cpse	r24, r1
    4628:	cd c0       	rjmp	.+410    	; 0x47c4 <CheckDepletionModeFET+0x1b2>
  {
    /* we assume: probe-1 = D / probe-2 = S / probe-3 = G */
    /* probes already set to: Gnd -- Rl -- probe-2 / probe-1 -- Vcc */
    R_DDR = Probes.Rl_2 | Probes.Rh_3;  /* pull down gate via Rh */
    462a:	cd e7       	ldi	r28, 0x7D	; 125
    462c:	d1 e0       	ldi	r29, 0x01	; 1
    462e:	98 85       	ldd	r25, Y+8	; 0x08
    4630:	8d 81       	ldd	r24, Y+5	; 0x05
    4632:	89 2b       	or	r24, r25
    4634:	84 b9       	out	0x04, r24	; 4
    U_1 = ReadU_20ms(Probes.Pin_2);     /* voltage at source */
    4636:	89 81       	ldd	r24, Y+1	; 0x01
    4638:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>
    463c:	8c 01       	movw	r16, r24

    R_PORT = Probes.Rh_3;               /* pull up gate via Rh */
    463e:	88 85       	ldd	r24, Y+8	; 0x08
    4640:	85 b9       	out	0x05, r24	; 5
    U_2 = ReadU_20ms(Probes.Pin_2);     /* voltage at source */
    4642:	89 81       	ldd	r24, Y+1	; 0x01
    4644:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>
    Diff_1 = U_2 - U_1;                 /* source voltage difference */
    4648:	ec 01       	movw	r28, r24
    464a:	c0 1b       	sub	r28, r16
    464c:	d1 0b       	sbc	r29, r17
     *  voltage vs. connected to ground we got a depletion-mode n-channel FET.
     *  The source resistor creates a voltage offset based on the current
     *  causing V_GS to become negative with the gate pulled down.
     */

    if (U_2 > (U_1 + 488))
    464e:	08 51       	subi	r16, 0x18	; 24
    4650:	1e 4f       	sbci	r17, 0xFE	; 254
    4652:	08 17       	cp	r16, r24
    4654:	19 07       	cpc	r17, r25
    4656:	08 f0       	brcs	.+2      	; 0x465a <CheckDepletionModeFET+0x48>
    4658:	ab c0       	rjmp	.+342    	; 0x47b0 <CheckDepletionModeFET+0x19e>
       *  - to detect drain and source of MOSFET
       */

      /* we simulate: probe-1 = S / probe-2 = D / probe-3 = G */
      /* set probes: Gnd -- Rl -- probe-1 / probe-2 -- Vcc */
      ADC_PORT = Probes.ADC_2;               /* set ADC port to high */
    465a:	0f 2e       	mov	r0, r31
    465c:	fd e7       	ldi	r31, 0x7D	; 125
    465e:	ef 2e       	mov	r14, r31
    4660:	f1 e0       	ldi	r31, 0x01	; 1
    4662:	ff 2e       	mov	r15, r31
    4664:	f0 2d       	mov	r31, r0
    4666:	f7 01       	movw	r30, r14
    4668:	82 85       	ldd	r24, Z+10	; 0x0a
    466a:	88 b9       	out	0x08, r24	; 8
      ADC_DDR = Probes.ADC_2;                /* pull up drain directly */
    466c:	87 b9       	out	0x07, r24	; 7
      R_DDR = Probes.Rl_1 | Probes.Rh_3;     /* enable Rl for source and Rh for gate */
    466e:	90 85       	ldd	r25, Z+8	; 0x08
    4670:	83 81       	ldd	r24, Z+3	; 0x03
    4672:	89 2b       	or	r24, r25
    4674:	84 b9       	out	0x04, r24	; 4
      R_PORT = 0;                            /* pull down source via Rl / pull down gate via Rh */
    4676:	15 b8       	out	0x05, r1	; 5
      U_1 = ReadU_20ms(Probes.Pin_1);        /* voltage at source */
    4678:	80 81       	ld	r24, Z
    467a:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>
    467e:	8c 01       	movw	r16, r24

      R_PORT = Probes.Rh_3;                  /* pull up gate via Rh */
    4680:	f7 01       	movw	r30, r14
    4682:	80 85       	ldd	r24, Z+8	; 0x08
    4684:	85 b9       	out	0x05, r24	; 5
      U_2 = ReadU_20ms(Probes.Pin_1);        /* voltage at source */
    4686:	80 81       	ld	r24, Z
    4688:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>
      Diff_2 = U_2 - U_1;                    /* source voltage difference */
    468c:	80 1b       	sub	r24, r16
    468e:	91 0b       	sbc	r25, r17
    4690:	8c 01       	movw	r16, r24
      /*
       *  Compare gate voltages to distinguish JFET from MOSFET
       */

      /* set probes: Gnd -- probe-2 / probe-1 -- Rl -- Vcc */
      ADC_PORT = 0;                          /* set ADC port to low */
    4692:	18 b8       	out	0x08, r1	; 8
      ADC_DDR = Probes.ADC_2;                /* pull down source directly */
    4694:	f7 01       	movw	r30, r14
    4696:	82 85       	ldd	r24, Z+10	; 0x0a
    4698:	87 b9       	out	0x07, r24	; 7
      R_DDR = Probes.Rl_1 | Probes.Rh_3;     /* enable Rl for probe-1 & Rh for probe-3 */
    469a:	90 85       	ldd	r25, Z+8	; 0x08
    469c:	83 81       	ldd	r24, Z+3	; 0x03
    469e:	89 2b       	or	r24, r25
    46a0:	84 b9       	out	0x04, r24	; 4
      R_PORT = Probes.Rl_1 | Probes.Rh_3;    /* pull up drain via Rl / pull up gate via Rh */
    46a2:	85 b9       	out	0x05, r24	; 5

      U_1 = ReadU_20ms(Probes.Pin_3);        /* get voltage at gate */
    46a4:	82 81       	ldd	r24, Z+2	; 0x02
    46a6:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>

      if (U_1 > 3911)              /* MOSFET */
    46aa:	88 34       	cpi	r24, 0x48	; 72
    46ac:	9f 40       	sbci	r25, 0x0F	; 15
    46ae:	20 f0       	brcs	.+8      	; 0x46b8 <CheckDepletionModeFET+0xa6>
      {
        /* n channel depletion-mode MOSFET */ 
        Check.Type = TYPE_N_CHANNEL | TYPE_DEPLETION | TYPE_MOSFET;
    46b0:	89 e1       	ldi	r24, 0x19	; 25
    46b2:	80 93 02 01 	sts	0x0102, r24
    46b6:	41 c0       	rjmp	.+130    	; 0x473a <CheckDepletionModeFET+0x128>
      }
      else                         /* JFET */
      {
        /* n channel JFET (depletion-mode only) */
        Check.Type = TYPE_N_CHANNEL | TYPE_DEPLETION | TYPE_JFET;
    46b8:	89 e2       	ldi	r24, 0x29	; 41
    46ba:	80 93 02 01 	sts	0x0102, r24
    46be:	3d c0       	rjmp	.+122    	; 0x473a <CheckDepletionModeFET+0x128>

  if ((Check.Done == 0) && (Flag == 0))      /* no transistor found yet */
  {
    /* we assume: probe-1 = S / probe-2 = D / probe-3 = G */
    /* set probes: Gnd -- probe-2 / probe-1 -- Rl -- Vcc */
    ADC_PORT = 0;                       /* set ADC port to Gnd */
    46c0:	18 b8       	out	0x08, r1	; 8
    ADC_DDR = Probes.ADC_2;             /* pull down drain directly */
    46c2:	cd e7       	ldi	r28, 0x7D	; 125
    46c4:	d1 e0       	ldi	r29, 0x01	; 1
    46c6:	8a 85       	ldd	r24, Y+10	; 0x0a
    46c8:	87 b9       	out	0x07, r24	; 7
    R_DDR = Probes.Rl_1 | Probes.Rh_3;  /* enable Rl for probe-1 & Rh for probe-3 */
    46ca:	98 85       	ldd	r25, Y+8	; 0x08
    46cc:	8b 81       	ldd	r24, Y+3	; 0x03
    46ce:	89 2b       	or	r24, r25
    46d0:	84 b9       	out	0x04, r24	; 4
    R_PORT = Probes.Rl_1 | Probes.Rh_3; /* pull up source via Rl / pull up gate via Rh */
    46d2:	85 b9       	out	0x05, r24	; 5
    U_1 = ReadU_20ms(Probes.Pin_1);     /* get voltage at source */
    46d4:	88 81       	ld	r24, Y
    46d6:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>
    46da:	6c 01       	movw	r12, r24

    R_PORT = Probes.Rl_1;               /* pull down gate via Rh */
    46dc:	8b 81       	ldd	r24, Y+3	; 0x03
    46de:	85 b9       	out	0x05, r24	; 5
    U_2 = ReadU_20ms(Probes.Pin_1);     /* get voltage at source */
    46e0:	88 81       	ld	r24, Y
    46e2:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>
    46e6:	7c 01       	movw	r14, r24
     *  voltage vs. connected to ground we got a depletion-mode p-channel FET.
     *  The source resistor creates a voltage offset based on the current
     *  causing V_GS to become positive with the gate pulled up.
     */

    if (U_1 > (U_2 + 488))
    46e8:	88 51       	subi	r24, 0x18	; 24
    46ea:	9e 4f       	sbci	r25, 0xFE	; 254
    46ec:	8c 15       	cp	r24, r12
    46ee:	9d 05       	cpc	r25, r13
    46f0:	08 f0       	brcs	.+2      	; 0x46f4 <CheckDepletionModeFET+0xe2>
    46f2:	68 c0       	rjmp	.+208    	; 0x47c4 <CheckDepletionModeFET+0x1b2>
       *  - to detect drain and source of MOSFET
       */

      /* we simulate: probe-1 = D / probe-2 = S / probe-3 = G */
      /* set probes: Gnd -- probe-1 / probe-2 -- Rl -- Vcc */
      ADC_DDR = Probes.ADC_1;             /* pull down drain directly */
    46f4:	89 85       	ldd	r24, Y+9	; 0x09
    46f6:	87 b9       	out	0x07, r24	; 7
      R_DDR = Probes.Rl_2 | Probes.Rh_3;  /* enable Rl for probe-2 & Rh for probe-3 */
    46f8:	98 85       	ldd	r25, Y+8	; 0x08
    46fa:	8d 81       	ldd	r24, Y+5	; 0x05
    46fc:	89 2b       	or	r24, r25
    46fe:	84 b9       	out	0x04, r24	; 4
      R_PORT = Probes.Rl_2 | Probes.Rh_3; /* pull up source via Rl / pull up gate via Rh */
    4700:	85 b9       	out	0x05, r24	; 5
      U_1 = ReadU_20ms(Probes.Pin_2);     /* get voltage at source */
    4702:	89 81       	ldd	r24, Y+1	; 0x01
    4704:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>
    4708:	8c 01       	movw	r16, r24

      R_PORT = Probes.Rl_2;               /* pull down gate via Rh */
    470a:	8d 81       	ldd	r24, Y+5	; 0x05
    470c:	85 b9       	out	0x05, r24	; 5
      U_2 = ReadU_20ms(Probes.Pin_2);     /* get voltage at source */
    470e:	89 81       	ldd	r24, Y+1	; 0x01
    4710:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>
      Diff_2 = U_1 - U_2;                 /* source voltage difference */
    4714:	08 1b       	sub	r16, r24
    4716:	19 0b       	sbc	r17, r25
      /*
       *  Compare gate voltages to distinguish JFET from MOSFET
       */

      /* set probes: probe-2 = HiZ / probe-1 -- Vcc */
      ADC_PORT = Probes.ADC_1;          /* pull up source directly */
    4718:	89 85       	ldd	r24, Y+9	; 0x09
    471a:	88 b9       	out	0x08, r24	; 8
      ADC_DDR = Probes.ADC_1;           /* enable pull up for source */
    471c:	87 b9       	out	0x07, r24	; 7
      /* gate is still pulled down via Rh */
      U_1 = ReadU_20ms(Probes.Pin_3);   /* get voltage at gate */
    471e:	8a 81       	ldd	r24, Y+2	; 0x02
    4720:	0e 94 2c 01 	call	0x258	; 0x258 <ReadU_20ms>

      if (U_1 < 977)               /* MOSFET */
    4724:	81 3d       	cpi	r24, 0xD1	; 209
    4726:	93 40       	sbci	r25, 0x03	; 3
    4728:	20 f4       	brcc	.+8      	; 0x4732 <CheckDepletionModeFET+0x120>
      {
        /* p-channel depletion-mode MOSFET */ 
        Check.Type =  TYPE_P_CHANNEL | TYPE_DEPLETION | TYPE_MOSFET;
    472a:	8a e1       	ldi	r24, 0x1A	; 26
    472c:	80 93 02 01 	sts	0x0102, r24
    4730:	45 c0       	rjmp	.+138    	; 0x47bc <CheckDepletionModeFET+0x1aa>
      }
      else                         /* JFET */
      {
        /* p-channel JFET (depletion-mode only) */
        Check.Type = TYPE_P_CHANNEL | TYPE_DEPLETION | TYPE_JFET;
    4732:	8a e2       	ldi	r24, 0x2A	; 42
    4734:	80 93 02 01 	sts	0x0102, r24
    4738:	41 c0       	rjmp	.+130    	; 0x47bc <CheckDepletionModeFET+0x1aa>
   */

  if (Flag == 1)         /* found depletion-mode FET */
  {
    /* common stuff */
    Check.Found = COMP_FET;
    473a:	e0 e0       	ldi	r30, 0x00	; 0
    473c:	f1 e0       	ldi	r31, 0x01	; 1
    473e:	86 e1       	ldi	r24, 0x16	; 22
    4740:	81 83       	std	Z+1, r24	; 0x01
    Check.Done = 1;
    4742:	81 e0       	ldi	r24, 0x01	; 1
    4744:	80 83       	st	Z, r24
    Semi.A = Probes.Pin_3;         /* gate pin */
    4746:	80 91 7f 01 	lds	r24, 0x017F
    474a:	80 93 6f 01 	sts	0x016F, r24
    /*
     *  drain & source pinout
     *  - larger voltage difference wins
     */

    if (Diff_1 > Diff_2)      /* drain and source as assumed */
    474e:	0c 17       	cp	r16, r28
    4750:	1d 07       	cpc	r17, r29
    4752:	50 f4       	brcc	.+20     	; 0x4768 <CheckDepletionModeFET+0x156>
    {
      Semi.B = Probes.Pin_1;       /* drain pin */
    4754:	ef e6       	ldi	r30, 0x6F	; 111
    4756:	f1 e0       	ldi	r31, 0x01	; 1
    4758:	ad e7       	ldi	r26, 0x7D	; 125
    475a:	b1 e0       	ldi	r27, 0x01	; 1
    475c:	8c 91       	ld	r24, X
    475e:	81 83       	std	Z+1, r24	; 0x01
      Semi.C = Probes.Pin_2;       /* source pin */
    4760:	11 96       	adiw	r26, 0x01	; 1
    4762:	8c 91       	ld	r24, X
    4764:	82 83       	std	Z+2, r24	; 0x02
    4766:	0a c0       	rjmp	.+20     	; 0x477c <CheckDepletionModeFET+0x16a>
    }
    else                      /* drain and source reversed */
    {
      Semi.B = Probes.Pin_2;       /* drain pin */
    4768:	ef e6       	ldi	r30, 0x6F	; 111
    476a:	f1 e0       	ldi	r31, 0x01	; 1
    476c:	ad e7       	ldi	r26, 0x7D	; 125
    476e:	b1 e0       	ldi	r27, 0x01	; 1
    4770:	11 96       	adiw	r26, 0x01	; 1
    4772:	8c 91       	ld	r24, X
    4774:	11 97       	sbiw	r26, 0x01	; 1
    4776:	81 83       	std	Z+1, r24	; 0x01
      Semi.C = Probes.Pin_1;       /* source pin */
    4778:	8c 91       	ld	r24, X
    477a:	82 83       	std	Z+2, r24	; 0x02
     *  drain & source symmetry
     *  - if both voltage differences are about the same we got a
     *    symmetrical FET
     */

    U_2 = Diff_1 / 50;             /* 2% of Diff_1 */
    477c:	9e 01       	movw	r18, r28
    477e:	36 95       	lsr	r19
    4780:	27 95       	ror	r18
    4782:	ab e7       	ldi	r26, 0x7B	; 123
    4784:	b4 e1       	ldi	r27, 0x14	; 20
    4786:	0e 94 87 28 	call	0x510e	; 0x510e <__umulhisi3>
    478a:	96 95       	lsr	r25
    478c:	87 95       	ror	r24
    U_1 = Diff_1 - U_2;            /* 98% */
    478e:	9e 01       	movw	r18, r28
    4790:	28 1b       	sub	r18, r24
    4792:	39 0b       	sbc	r19, r25
    U_2 += Diff_1;                 /* 102% */
    if ((Diff_2 >= U_1) && (Diff_2 <= U_2))
    4794:	02 17       	cp	r16, r18
    4796:	13 07       	cpc	r17, r19
    4798:	a8 f0       	brcs	.+42     	; 0x47c4 <CheckDepletionModeFET+0x1b2>
     *    symmetrical FET
     */

    U_2 = Diff_1 / 50;             /* 2% of Diff_1 */
    U_1 = Diff_1 - U_2;            /* 98% */
    U_2 += Diff_1;                 /* 102% */
    479a:	c8 0f       	add	r28, r24
    479c:	d9 1f       	adc	r29, r25
    if ((Diff_2 >= U_1) && (Diff_2 <= U_2))
    479e:	c0 17       	cp	r28, r16
    47a0:	d1 07       	cpc	r29, r17
    47a2:	80 f0       	brcs	.+32     	; 0x47c4 <CheckDepletionModeFET+0x1b2>
    {
      Check.Type |= TYPE_SYMMETRICAL; 
    47a4:	e0 e0       	ldi	r30, 0x00	; 0
    47a6:	f1 e0       	ldi	r31, 0x01	; 1
    47a8:	82 81       	ldd	r24, Z+2	; 0x02
    47aa:	80 64       	ori	r24, 0x40	; 64
    47ac:	82 83       	std	Z+2, r24	; 0x02
    47ae:	0a c0       	rjmp	.+20     	; 0x47c4 <CheckDepletionModeFET+0x1b2>
  /*
   *  check if we got a p-channel JFET or depletion-mode MOSFET
   *  - JFETs are depletion-mode only
   */

  if ((Check.Done == 0) && (Flag == 0))      /* no transistor found yet */
    47b0:	80 91 00 01 	lds	r24, 0x0100
    47b4:	88 23       	and	r24, r24
    47b6:	09 f4       	brne	.+2      	; 0x47ba <CheckDepletionModeFET+0x1a8>
    47b8:	83 cf       	rjmp	.-250    	; 0x46c0 <CheckDepletionModeFET+0xae>
    47ba:	04 c0       	rjmp	.+8      	; 0x47c4 <CheckDepletionModeFET+0x1b2>
    R_PORT = Probes.Rl_1 | Probes.Rh_3; /* pull up source via Rl / pull up gate via Rh */
    U_1 = ReadU_20ms(Probes.Pin_1);     /* get voltage at source */

    R_PORT = Probes.Rl_1;               /* pull down gate via Rh */
    U_2 = ReadU_20ms(Probes.Pin_1);     /* get voltage at source */
    Diff_1 = U_1 - U_2;                 /* source voltage difference */
    47bc:	e6 01       	movw	r28, r12
    47be:	ce 19       	sub	r28, r14
    47c0:	df 09       	sbc	r29, r15
    47c2:	bb cf       	rjmp	.-138    	; 0x473a <CheckDepletionModeFET+0x128>
    if ((Diff_2 >= U_1) && (Diff_2 <= U_2))
    {
      Check.Type |= TYPE_SYMMETRICAL; 
    }
  }
}
    47c4:	df 91       	pop	r29
    47c6:	cf 91       	pop	r28
    47c8:	1f 91       	pop	r17
    47ca:	0f 91       	pop	r16
    47cc:	ff 90       	pop	r15
    47ce:	ef 90       	pop	r14
    47d0:	df 90       	pop	r13
    47d2:	cf 90       	pop	r12
    47d4:	08 95       	ret

000047d6 <CheckThyristorTriac>:
 *  - 1 if component was found
 *  - 0 if component wasn't found
 */

uint8_t CheckThyristorTriac(void)
{
    47d6:	cf 92       	push	r12
    47d8:	df 92       	push	r13
    47da:	ef 92       	push	r14
    47dc:	ff 92       	push	r15
    47de:	0f 93       	push	r16
    47e0:	1f 93       	push	r17
    47e2:	cf 93       	push	r28
    47e4:	df 93       	push	r29

  /* we assume: probe-1 = A / probe-2 = C / probe-3 = G for a SCR */
  /*            probe-1 = MT2 / probe-2 = MT1 / probe-3 = G for a triac */  

  /* V_GT (gate trigger voltage) */
  U_1 = ReadU(Probes.Pin_3);            /* voltage at gate */
    47e6:	cd e7       	ldi	r28, 0x7D	; 125
    47e8:	d1 e0       	ldi	r29, 0x01	; 1
    47ea:	8a 81       	ldd	r24, Y+2	; 0x02
    47ec:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    47f0:	7c 01       	movw	r14, r24
  U_2 = ReadU(Probes.Pin_2);            /* voltage at cathode */
    47f2:	89 81       	ldd	r24, Y+1	; 0x01
    47f4:	0e 94 8a 00 	call	0x114	; 0x114 <ReadU>
    47f8:	6c 01       	movw	r12, r24
  V_GT = U_1 - U_2;                     /* = Ug - Uc */

  /* discharge gate and check load current */
  PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLDOWN);    /* discharge gate */
    47fa:	60 e1       	ldi	r22, 0x10	; 16
    47fc:	8f 81       	ldd	r24, Y+7	; 0x07
    47fe:	0e 94 2c 19 	call	0x3258	; 0x3258 <PullProbe>
  U_1 = ReadU_5ms(Probes.Pin_1);        /* get voltage at anode */
    4802:	88 81       	ld	r24, Y
    4804:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
    4808:	8c 01       	movw	r16, r24

  /* simulate short loss of current and check load current again */ 
  R_PORT = 0;                           /* pull down anode */
    480a:	15 b8       	out	0x05, r1	; 5
  wait5ms();
    480c:	0e 94 7b 00 	call	0xf6	; 0xf6 <wait5ms>
  R_PORT = Probes.Rl_1;                 /* and pull up anode again */
    4810:	9b 81       	ldd	r25, Y+3	; 0x03
    4812:	95 b9       	out	0x05, r25	; 5
  U_2 = ReadU_5ms(Probes.Pin_1);        /* get voltage at anode (below Rl) */
    4814:	88 81       	ld	r24, Y
    4816:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>

  /* voltages at anode match behaviour of thyristor or triac */
  if ((U_1 < 1600) && (U_2 > 4400))
    481a:	00 34       	cpi	r16, 0x40	; 64
    481c:	16 40       	sbci	r17, 0x06	; 6
    481e:	08 f0       	brcs	.+2      	; 0x4822 <CheckThyristorTriac+0x4c>
    4820:	49 c0       	rjmp	.+146    	; 0x48b4 <CheckThyristorTriac+0xde>
    4822:	81 33       	cpi	r24, 0x31	; 49
    4824:	91 41       	sbci	r25, 0x11	; 17
    4826:	08 f4       	brcc	.+2      	; 0x482a <CheckThyristorTriac+0x54>
    4828:	47 c0       	rjmp	.+142    	; 0x48b8 <CheckThyristorTriac+0xe2>
     *  A thyrister shouldn't conduct but a triac should (Q3 operation mode).
     */

    /* reverse Anode and Cathode (MT2 and MT1) */
    /* set probes: Gnd -- probe-1 / probe-2 -- Rl -- Vcc  */
    R_DDR = 0;                          /* disable all probe resistors */
    482a:	14 b8       	out	0x04, r1	; 4
    R_PORT = 0;
    482c:	15 b8       	out	0x05, r1	; 5
    ADC_PORT = Probes.ADC_2;            /* pull up Cathode directly */
    482e:	8a 85       	ldd	r24, Y+10	; 0x0a
    4830:	88 b9       	out	0x08, r24	; 8
    wait5ms();
    4832:	0e 94 7b 00 	call	0xf6	; 0xf6 <wait5ms>
    R_DDR = Probes.Rl_1;                /* pull down Anode via Rl */ 
    4836:	8b 81       	ldd	r24, Y+3	; 0x03
    4838:	84 b9       	out	0x04, r24	; 4
    /* probe-3 = gate is in HiZ mode */

    /* check if DUT doesn't conduct */
    U_1 = ReadU_5ms(Probes.Pin_1);      /* get voltage at Anode */
    483a:	88 81       	ld	r24, Y
    483c:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>

    if (U_1 <= 244)      /* voltage at Anode is low (no current) */
    4840:	85 3f       	cpi	r24, 0xF5	; 245
    4842:	91 05       	cpc	r25, r1
    4844:	d8 f5       	brcc	.+118    	; 0x48bc <CheckThyristorTriac+0xe6>
    {
      /* trigger the gate with a negative current (Triac: Q3) */
      PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLDOWN);
    4846:	60 e1       	ldi	r22, 0x10	; 16
    4848:	8f 81       	ldd	r24, Y+7	; 0x07
    484a:	0e 94 2c 19 	call	0x3258	; 0x3258 <PullProbe>

      /* check for conduction */
      U_1 = ReadU_5ms(Probes.Pin_1);    /* get voltage at Anode */
    484e:	88 81       	ld	r24, Y
    4850:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>
    4854:	ec 01       	movw	r28, r24

      if (U_1 < 733)         /* no current -> Thyristor */
    4856:	8d 3d       	cpi	r24, 0xDD	; 221
    4858:	92 40       	sbci	r25, 0x02	; 2
    485a:	38 f4       	brcc	.+14     	; 0x486a <CheckThyristorTriac+0x94>
      {
        Check.Found = COMP_THYRISTOR;   /* we found a Thyristor */
    485c:	e0 e0       	ldi	r30, 0x00	; 0
    485e:	f1 e0       	ldi	r31, 0x01	; 1
    4860:	89 e1       	ldi	r24, 0x19	; 25
    4862:	81 83       	std	Z+1, r24	; 0x01
        Check.Done = 1;                 /* detected component */
    4864:	81 e0       	ldi	r24, 0x01	; 1
    4866:	80 83       	st	Z, r24
    4868:	2f c0       	rjmp	.+94     	; 0x48c8 <CheckThyristorTriac+0xf2>
         *  To verify the Triac we stop the current flow for a moment and check
         *  the voltage at MT2 again. The Triac shouldn't conduct anymore,
         */

        /* drop load current for a moment */
        R_PORT = Probes.Rl_1;           /* pull up MT2 via Rl */
    486a:	0d e7       	ldi	r16, 0x7D	; 125
    486c:	11 e0       	ldi	r17, 0x01	; 1
    486e:	f8 01       	movw	r30, r16
    4870:	83 81       	ldd	r24, Z+3	; 0x03
    4872:	85 b9       	out	0x05, r24	; 5
        wait5ms();
    4874:	0e 94 7b 00 	call	0xf6	; 0xf6 <wait5ms>
        R_PORT = 0;                     /* and pull down MT2 via Rl */
    4878:	15 b8       	out	0x05, r1	; 5

        /* and check load current again */
        U_2 = ReadU_5ms(Probes.Pin_1);  /* get voltage at MT2 */
    487a:	f8 01       	movw	r30, r16
    487c:	80 81       	ld	r24, Z
    487e:	0e 94 23 01 	call	0x246	; 0x246 <ReadU_5ms>

        if (U_2 <= 244)       /* no current */
    4882:	85 3f       	cpi	r24, 0xF5	; 245
    4884:	91 05       	cpc	r25, r1
    4886:	e0 f4       	brcc	.+56     	; 0x48c0 <CheckThyristorTriac+0xea>
        {
          if (Check.Found == COMP_TRIAC)     /* second test run */
    4888:	80 91 01 01 	lds	r24, 0x0101
    488c:	88 31       	cpi	r24, 0x18	; 24
    488e:	19 f4       	brne	.+6      	; 0x4896 <CheckThyristorTriac+0xc0>
          {
            Check.Done = 1;             /* no more tests needed */
    4890:	81 e0       	ldi	r24, 0x01	; 1
    4892:	80 93 00 01 	sts	0x0100, r24
          }

          Check.Found = COMP_TRIAC;     /* found Triac */
    4896:	88 e1       	ldi	r24, 0x18	; 24
    4898:	80 93 01 01 	sts	0x0101, r24
           *  through MT2 would be a little bit lower. Another issue is that some
           *  Triacs don't support Q4. So we support up to two test runs and prefer
           *  the one with the higher voltage at MT2.
           */

          if (U_1 > Semi.I_1)      /* first run or higher current */
    489c:	80 91 76 01 	lds	r24, 0x0176
    48a0:	90 91 77 01 	lds	r25, 0x0177
    48a4:	8c 17       	cp	r24, r28
    48a6:	9d 07       	cpc	r25, r29
    48a8:	68 f4       	brcc	.+26     	; 0x48c4 <CheckThyristorTriac+0xee>
          {
            Semi.I_1 = U_1;        /* update reference value */
    48aa:	d0 93 77 01 	sts	0x0177, r29
    48ae:	c0 93 76 01 	sts	0x0176, r28
    48b2:	0a c0       	rjmp	.+20     	; 0x48c8 <CheckThyristorTriac+0xf2>
 *  - 0 if component wasn't found
 */

uint8_t CheckThyristorTriac(void)
{
  uint8_t           Flag = 0;      /* return value */
    48b4:	80 e0       	ldi	r24, 0x00	; 0
    48b6:	1a c0       	rjmp	.+52     	; 0x48ec <CheckThyristorTriac+0x116>
    48b8:	80 e0       	ldi	r24, 0x00	; 0
    48ba:	18 c0       	rjmp	.+48     	; 0x48ec <CheckThyristorTriac+0x116>
    48bc:	80 e0       	ldi	r24, 0x00	; 0
    48be:	16 c0       	rjmp	.+44     	; 0x48ec <CheckThyristorTriac+0x116>
    48c0:	80 e0       	ldi	r24, 0x00	; 0
    48c2:	14 c0       	rjmp	.+40     	; 0x48ec <CheckThyristorTriac+0x116>
            Semi.I_1 = U_1;        /* update reference value */
            Flag = 2;              /* save data and signal success */
          }
          else                     /* wrong pinout */
          {
            Flag = 1;              /* signal success, but don't save data */
    48c4:	81 e0       	ldi	r24, 0x01	; 1
    48c6:	12 c0       	rjmp	.+36     	; 0x48ec <CheckThyristorTriac+0x116>
  }

  if (Flag == 2)         /* save data and signal success */
  {
    /* save data */
    Semi.A = Probes.Pin_3;    /* Gate pin */
    48c8:	ef e6       	ldi	r30, 0x6F	; 111
    48ca:	f1 e0       	ldi	r31, 0x01	; 1
    48cc:	ad e7       	ldi	r26, 0x7D	; 125
    48ce:	b1 e0       	ldi	r27, 0x01	; 1
    48d0:	12 96       	adiw	r26, 0x02	; 2
    48d2:	8c 91       	ld	r24, X
    48d4:	12 97       	sbiw	r26, 0x02	; 2
    48d6:	80 83       	st	Z, r24
    Semi.B = Probes.Pin_1;    /* Anode/MT2 pin */
    48d8:	8c 91       	ld	r24, X
    48da:	81 83       	std	Z+1, r24	; 0x01
    Semi.C = Probes.Pin_2;    /* Cathode/MT1 pin */
    48dc:	11 96       	adiw	r26, 0x01	; 1
    48de:	8c 91       	ld	r24, X
    48e0:	82 83       	std	Z+2, r24	; 0x02
  /*            probe-1 = MT2 / probe-2 = MT1 / probe-3 = G for a triac */  

  /* V_GT (gate trigger voltage) */
  U_1 = ReadU(Probes.Pin_3);            /* voltage at gate */
  U_2 = ReadU(Probes.Pin_2);            /* voltage at cathode */
  V_GT = U_1 - U_2;                     /* = Ug - Uc */
    48e2:	ec 18       	sub	r14, r12
    48e4:	fd 08       	sbc	r15, r13
  {
    /* save data */
    Semi.A = Probes.Pin_3;    /* Gate pin */
    Semi.B = Probes.Pin_1;    /* Anode/MT2 pin */
    Semi.C = Probes.Pin_2;    /* Cathode/MT1 pin */
    Semi.U_1 = V_GT;          /* gate trigger voltage (in mV) */
    48e6:	f4 82       	std	Z+4, r15	; 0x04
    48e8:	e3 82       	std	Z+3, r14	; 0x03

    Flag = 1;                 /* signal success */
    48ea:	81 e0       	ldi	r24, 0x01	; 1
  }

  return Flag;
}
    48ec:	df 91       	pop	r29
    48ee:	cf 91       	pop	r28
    48f0:	1f 91       	pop	r17
    48f2:	0f 91       	pop	r16
    48f4:	ff 90       	pop	r15
    48f6:	ef 90       	pop	r14
    48f8:	df 90       	pop	r13
    48fa:	cf 90       	pop	r12
    48fc:	08 95       	ret

000048fe <NumberOfDigits>:
/*
 *  get number of digits of a value
 */

uint8_t NumberOfDigits(uint32_t Value)
{
    48fe:	cf 92       	push	r12
    4900:	df 92       	push	r13
    4902:	ef 92       	push	r14
    4904:	ff 92       	push	r15
    4906:	cf 93       	push	r28
  uint8_t           Counter = 1;   /* return value */

  while (Value >= 10)
    4908:	6a 30       	cpi	r22, 0x0A	; 10
    490a:	71 05       	cpc	r23, r1
    490c:	81 05       	cpc	r24, r1
    490e:	91 05       	cpc	r25, r1
    4910:	a8 f0       	brcs	.+42     	; 0x493c <NumberOfDigits+0x3e>
    4912:	c1 e0       	ldi	r28, 0x01	; 1
  {
    Value /= 10;
    4914:	0f 2e       	mov	r0, r31
    4916:	fa e0       	ldi	r31, 0x0A	; 10
    4918:	cf 2e       	mov	r12, r31
    491a:	d1 2c       	mov	r13, r1
    491c:	e1 2c       	mov	r14, r1
    491e:	f1 2c       	mov	r15, r1
    4920:	f0 2d       	mov	r31, r0
    4922:	a7 01       	movw	r20, r14
    4924:	96 01       	movw	r18, r12
    4926:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    492a:	ca 01       	movw	r24, r20
    492c:	b9 01       	movw	r22, r18
    Counter++;
    492e:	cf 5f       	subi	r28, 0xFF	; 255

uint8_t NumberOfDigits(uint32_t Value)
{
  uint8_t           Counter = 1;   /* return value */

  while (Value >= 10)
    4930:	2a 30       	cpi	r18, 0x0A	; 10
    4932:	31 05       	cpc	r19, r1
    4934:	41 05       	cpc	r20, r1
    4936:	51 05       	cpc	r21, r1
    4938:	a0 f7       	brcc	.-24     	; 0x4922 <NumberOfDigits+0x24>
    493a:	01 c0       	rjmp	.+2      	; 0x493e <NumberOfDigits+0x40>
 *  get number of digits of a value
 */

uint8_t NumberOfDigits(uint32_t Value)
{
  uint8_t           Counter = 1;   /* return value */
    493c:	c1 e0       	ldi	r28, 0x01	; 1
    Value /= 10;
    Counter++;
  }

  return Counter;
}
    493e:	8c 2f       	mov	r24, r28
    4940:	cf 91       	pop	r28
    4942:	ff 90       	pop	r15
    4944:	ef 90       	pop	r14
    4946:	df 90       	pop	r13
    4948:	cf 90       	pop	r12
    494a:	08 95       	ret

0000494c <CmpValue>:
 *  - 0 if equal
 *  - 1 if first value is larger than second one
 */

int8_t CmpValue(uint32_t Value1, int8_t Scale1, uint32_t Value2, int8_t Scale2)
{
    494c:	4f 92       	push	r4
    494e:	5f 92       	push	r5
    4950:	6f 92       	push	r6
    4952:	7f 92       	push	r7
    4954:	8f 92       	push	r8
    4956:	9f 92       	push	r9
    4958:	af 92       	push	r10
    495a:	bf 92       	push	r11
    495c:	ef 92       	push	r14
    495e:	0f 93       	push	r16
    4960:	1f 93       	push	r17
    4962:	cf 93       	push	r28
    4964:	df 93       	push	r29
    4966:	4b 01       	movw	r8, r22
    4968:	5c 01       	movw	r10, r24
    496a:	c4 2f       	mov	r28, r20
    496c:	28 01       	movw	r4, r16
    496e:	39 01       	movw	r6, r18
  int8_t            Flag;               /* return value */
  int8_t            Len1, Len2;         /* length */

  /* determine virtual length */
  Len1 = NumberOfDigits(Value1) + Scale1;
    4970:	0e 94 7f 24 	call	0x48fe	; 0x48fe <NumberOfDigits>
    4974:	d8 2f       	mov	r29, r24
  Len2 = NumberOfDigits(Value2) + Scale2;
    4976:	c3 01       	movw	r24, r6
    4978:	b2 01       	movw	r22, r4
    497a:	0e 94 7f 24 	call	0x48fe	; 0x48fe <NumberOfDigits>

  if ((Value1 == 0) || (Value2 == 0))    /* special case */
    497e:	81 14       	cp	r8, r1
    4980:	91 04       	cpc	r9, r1
    4982:	a1 04       	cpc	r10, r1
    4984:	b1 04       	cpc	r11, r1
    4986:	09 f4       	brne	.+2      	; 0x498a <CmpValue+0x3e>
    4988:	3f c0       	rjmp	.+126    	; 0x4a08 <CmpValue+0xbc>
    498a:	41 14       	cp	r4, r1
    498c:	51 04       	cpc	r5, r1
    498e:	61 04       	cpc	r6, r1
    4990:	71 04       	cpc	r7, r1
    4992:	09 f4       	brne	.+2      	; 0x4996 <CmpValue+0x4a>
    4994:	44 c0       	rjmp	.+136    	; 0x4a1e <CmpValue+0xd2>
{
  int8_t            Flag;               /* return value */
  int8_t            Len1, Len2;         /* length */

  /* determine virtual length */
  Len1 = NumberOfDigits(Value1) + Scale1;
    4996:	cd 0f       	add	r28, r29
  Len2 = NumberOfDigits(Value2) + Scale2;
    4998:	e8 0e       	add	r14, r24

  if ((Value1 == 0) || (Value2 == 0))    /* special case */
  {
    Flag = 10;                /* perform direct comparison */
  }
  else if (Len1 > Len2)       /* more digits -> larger */
    499a:	ec 16       	cp	r14, r28
    499c:	0c f4       	brge	.+2      	; 0x49a0 <CmpValue+0x54>
    499e:	45 c0       	rjmp	.+138    	; 0x4a2a <CmpValue+0xde>
  {
    Flag = 1;
  }
  else if (Len1 == Len2)      /* same length */
    49a0:	ce 11       	cpse	r28, r14
    49a2:	45 c0       	rjmp	.+138    	; 0x4a2e <CmpValue+0xe2>
  {
    /* re-scale to longer value */
    Len1 -= Scale1;
    49a4:	2d 2f       	mov	r18, r29
    Len2 -= Scale2;
    49a6:	98 2f       	mov	r25, r24

    while (Len1 > Len2)       /* up-scale Value #2 */
    49a8:	8d 17       	cp	r24, r29
    49aa:	b4 f4       	brge	.+44     	; 0x49d8 <CmpValue+0x8c>
    {
      Value2 *= 10;
    49ac:	44 0c       	add	r4, r4
    49ae:	55 1c       	adc	r5, r5
    49b0:	66 1c       	adc	r6, r6
    49b2:	77 1c       	adc	r7, r7
    49b4:	b3 01       	movw	r22, r6
    49b6:	a2 01       	movw	r20, r4
    49b8:	44 0f       	add	r20, r20
    49ba:	55 1f       	adc	r21, r21
    49bc:	66 1f       	adc	r22, r22
    49be:	77 1f       	adc	r23, r23
    49c0:	44 0f       	add	r20, r20
    49c2:	55 1f       	adc	r21, r21
    49c4:	66 1f       	adc	r22, r22
    49c6:	77 1f       	adc	r23, r23
    49c8:	44 0e       	add	r4, r20
    49ca:	55 1e       	adc	r5, r21
    49cc:	66 1e       	adc	r6, r22
    49ce:	77 1e       	adc	r7, r23
    49d0:	9f 5f       	subi	r25, 0xFF	; 255
  {
    /* re-scale to longer value */
    Len1 -= Scale1;
    Len2 -= Scale2;

    while (Len1 > Len2)       /* up-scale Value #2 */
    49d2:	29 13       	cpse	r18, r25
    49d4:	eb cf       	rjmp	.-42     	; 0x49ac <CmpValue+0x60>
    49d6:	9d 2f       	mov	r25, r29
      Value2 *= 10;
      Len2++;
      /* Scale2-- */
    }

    while (Len2 > Len1)       /* up-scale Value #1 */
    49d8:	29 17       	cp	r18, r25
    49da:	0c f5       	brge	.+66     	; 0x4a1e <CmpValue+0xd2>
    {
      Value1 *= 10;
    49dc:	88 0c       	add	r8, r8
    49de:	99 1c       	adc	r9, r9
    49e0:	aa 1c       	adc	r10, r10
    49e2:	bb 1c       	adc	r11, r11
    49e4:	b5 01       	movw	r22, r10
    49e6:	a4 01       	movw	r20, r8
    49e8:	44 0f       	add	r20, r20
    49ea:	55 1f       	adc	r21, r21
    49ec:	66 1f       	adc	r22, r22
    49ee:	77 1f       	adc	r23, r23
    49f0:	44 0f       	add	r20, r20
    49f2:	55 1f       	adc	r21, r21
    49f4:	66 1f       	adc	r22, r22
    49f6:	77 1f       	adc	r23, r23
    49f8:	84 0e       	add	r8, r20
    49fa:	95 1e       	adc	r9, r21
    49fc:	a6 1e       	adc	r10, r22
    49fe:	b7 1e       	adc	r11, r23
    4a00:	2f 5f       	subi	r18, 0xFF	; 255
      Value2 *= 10;
      Len2++;
      /* Scale2-- */
    }

    while (Len2 > Len1)       /* up-scale Value #1 */
    4a02:	29 13       	cpse	r18, r25
    4a04:	eb cf       	rjmp	.-42     	; 0x49dc <CmpValue+0x90>
    4a06:	0b c0       	rjmp	.+22     	; 0x4a1e <CmpValue+0xd2>
  }

  if (Flag == 10)             /* perform direct comparison */
  {
    if (Value1 > Value2) Flag = 1;
    else if (Value1 < Value2) Flag = -1;
    4a08:	81 e0       	ldi	r24, 0x01	; 1
    4a0a:	84 14       	cp	r8, r4
    4a0c:	95 04       	cpc	r9, r5
    4a0e:	a6 04       	cpc	r10, r6
    4a10:	b7 04       	cpc	r11, r7
    4a12:	08 f0       	brcs	.+2      	; 0x4a16 <CmpValue+0xca>
    4a14:	80 e0       	ldi	r24, 0x00	; 0
    4a16:	81 95       	neg	r24
    4a18:	0b c0       	rjmp	.+22     	; 0x4a30 <CmpValue+0xe4>
    Flag = -1;
  }

  if (Flag == 10)             /* perform direct comparison */
  {
    if (Value1 > Value2) Flag = 1;
    4a1a:	81 e0       	ldi	r24, 0x01	; 1
    4a1c:	09 c0       	rjmp	.+18     	; 0x4a30 <CmpValue+0xe4>
    4a1e:	48 14       	cp	r4, r8
    4a20:	59 04       	cpc	r5, r9
    4a22:	6a 04       	cpc	r6, r10
    4a24:	7b 04       	cpc	r7, r11
    4a26:	80 f7       	brcc	.-32     	; 0x4a08 <CmpValue+0xbc>
    4a28:	f8 cf       	rjmp	.-16     	; 0x4a1a <CmpValue+0xce>
  {
    Flag = 10;                /* perform direct comparison */
  }
  else if (Len1 > Len2)       /* more digits -> larger */
  {
    Flag = 1;
    4a2a:	81 e0       	ldi	r24, 0x01	; 1
    4a2c:	01 c0       	rjmp	.+2      	; 0x4a30 <CmpValue+0xe4>

    Flag = 10;                /* perform direct comparison */
  }
  else                        /* less digits -> smaller */
  {
    Flag = -1;
    4a2e:	8f ef       	ldi	r24, 0xFF	; 255
    else if (Value1 < Value2) Flag = -1;
    else Flag = 0;
  }

  return Flag;
}
    4a30:	df 91       	pop	r29
    4a32:	cf 91       	pop	r28
    4a34:	1f 91       	pop	r17
    4a36:	0f 91       	pop	r16
    4a38:	ef 90       	pop	r14
    4a3a:	bf 90       	pop	r11
    4a3c:	af 90       	pop	r10
    4a3e:	9f 90       	pop	r9
    4a40:	8f 90       	pop	r8
    4a42:	7f 90       	pop	r7
    4a44:	6f 90       	pop	r6
    4a46:	5f 90       	pop	r5
    4a48:	4f 90       	pop	r4
    4a4a:	08 95       	ret

00004a4c <RescaleValue>:
 *  - value and scale
 *  - new scale
 */

uint32_t RescaleValue(uint32_t Value, int8_t Scale, int8_t NewScale)
{
    4a4c:	cf 92       	push	r12
    4a4e:	df 92       	push	r13
    4a50:	ef 92       	push	r14
    4a52:	ff 92       	push	r15
    4a54:	0f 93       	push	r16
    4a56:	1f 93       	push	r17
    4a58:	cf 93       	push	r28
    4a5a:	df 93       	push	r29
    4a5c:	c4 2f       	mov	r28, r20
    4a5e:	d2 2f       	mov	r29, r18
  uint32_t          NewValue;      /* return value */

  NewValue = Value;           /* take old value */

  while (Scale != NewScale)   /* processing loop */
    4a60:	42 17       	cp	r20, r18
    4a62:	51 f1       	breq	.+84     	; 0x4ab8 <RescaleValue+0x6c>
  {
    if (NewScale > Scale)     /* upscale */
    {
      NewValue /= 10;
    4a64:	0f 2e       	mov	r0, r31
    4a66:	fa e0       	ldi	r31, 0x0A	; 10
    4a68:	cf 2e       	mov	r12, r31
    4a6a:	d1 2c       	mov	r13, r1
    4a6c:	e1 2c       	mov	r14, r1
    4a6e:	f1 2c       	mov	r15, r1
    4a70:	f0 2d       	mov	r31, r0

  NewValue = Value;           /* take old value */

  while (Scale != NewScale)   /* processing loop */
  {
    if (NewScale > Scale)     /* upscale */
    4a72:	cd 17       	cp	r28, r29
    4a74:	44 f4       	brge	.+16     	; 0x4a86 <RescaleValue+0x3a>
    {
      NewValue /= 10;
    4a76:	a7 01       	movw	r20, r14
    4a78:	96 01       	movw	r18, r12
    4a7a:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    4a7e:	ca 01       	movw	r24, r20
    4a80:	b9 01       	movw	r22, r18
      Scale++;
    4a82:	cf 5f       	subi	r28, 0xFF	; 255
    4a84:	17 c0       	rjmp	.+46     	; 0x4ab4 <RescaleValue+0x68>
    }
    else                      /* downscale */
    {
      NewValue *= 10;
    4a86:	dc 01       	movw	r26, r24
    4a88:	cb 01       	movw	r24, r22
    4a8a:	88 0f       	add	r24, r24
    4a8c:	99 1f       	adc	r25, r25
    4a8e:	aa 1f       	adc	r26, r26
    4a90:	bb 1f       	adc	r27, r27
    4a92:	8c 01       	movw	r16, r24
    4a94:	9d 01       	movw	r18, r26
    4a96:	00 0f       	add	r16, r16
    4a98:	11 1f       	adc	r17, r17
    4a9a:	22 1f       	adc	r18, r18
    4a9c:	33 1f       	adc	r19, r19
    4a9e:	00 0f       	add	r16, r16
    4aa0:	11 1f       	adc	r17, r17
    4aa2:	22 1f       	adc	r18, r18
    4aa4:	33 1f       	adc	r19, r19
    4aa6:	bc 01       	movw	r22, r24
    4aa8:	cd 01       	movw	r24, r26
    4aaa:	60 0f       	add	r22, r16
    4aac:	71 1f       	adc	r23, r17
    4aae:	82 1f       	adc	r24, r18
    4ab0:	93 1f       	adc	r25, r19
      Scale--;
    4ab2:	c1 50       	subi	r28, 0x01	; 1
{
  uint32_t          NewValue;      /* return value */

  NewValue = Value;           /* take old value */

  while (Scale != NewScale)   /* processing loop */
    4ab4:	dc 13       	cpse	r29, r28
    4ab6:	dd cf       	rjmp	.-70     	; 0x4a72 <RescaleValue+0x26>
      Scale--;
    }
  }

  return NewValue;
}
    4ab8:	df 91       	pop	r29
    4aba:	cf 91       	pop	r28
    4abc:	1f 91       	pop	r17
    4abe:	0f 91       	pop	r16
    4ac0:	ff 90       	pop	r15
    4ac2:	ef 90       	pop	r14
    4ac4:	df 90       	pop	r13
    4ac6:	cf 90       	pop	r12
    4ac8:	08 95       	ret

00004aca <DisplayValue>:
 *    e.g: p = 10^-12 -> -12
 *  - unit character (0 = none)
 */

void DisplayValue(uint32_t Value, int8_t Exponent, unsigned char Unit)
{
    4aca:	7f 92       	push	r7
    4acc:	8f 92       	push	r8
    4ace:	9f 92       	push	r9
    4ad0:	af 92       	push	r10
    4ad2:	bf 92       	push	r11
    4ad4:	cf 92       	push	r12
    4ad6:	df 92       	push	r13
    4ad8:	ef 92       	push	r14
    4ada:	ff 92       	push	r15
    4adc:	0f 93       	push	r16
    4ade:	1f 93       	push	r17
    4ae0:	cf 93       	push	r28
    4ae2:	df 93       	push	r29
    4ae4:	6b 01       	movw	r12, r22
    4ae6:	7c 01       	movw	r14, r24
    4ae8:	d4 2f       	mov	r29, r20
    4aea:	72 2e       	mov	r7, r18
  uint8_t           Offset = 0;         /* exponent offset to next 10^3 step */
  uint8_t           Index;              /* index ID */
  uint8_t           Length;             /* string length */

  /* scale value down to 4 digits */
  while (Value >= 10000)
    4aec:	80 e1       	ldi	r24, 0x10	; 16
    4aee:	c8 16       	cp	r12, r24
    4af0:	87 e2       	ldi	r24, 0x27	; 39
    4af2:	d8 06       	cpc	r13, r24
    4af4:	e1 04       	cpc	r14, r1
    4af6:	f1 04       	cpc	r15, r1
    4af8:	c8 f0       	brcs	.+50     	; 0x4b2c <DisplayValue+0x62>
  {
    Value += 5;                       /* for automagic rounding */
    Value = Value / 10;               /* scale down by 10^1 */
    4afa:	0f 2e       	mov	r0, r31
    4afc:	fa e0       	ldi	r31, 0x0A	; 10
    4afe:	8f 2e       	mov	r8, r31
    4b00:	91 2c       	mov	r9, r1
    4b02:	a1 2c       	mov	r10, r1
    4b04:	b1 2c       	mov	r11, r1
    4b06:	f0 2d       	mov	r31, r0
  uint8_t           Length;             /* string length */

  /* scale value down to 4 digits */
  while (Value >= 10000)
  {
    Value += 5;                       /* for automagic rounding */
    4b08:	c7 01       	movw	r24, r14
    4b0a:	b6 01       	movw	r22, r12
    4b0c:	6b 5f       	subi	r22, 0xFB	; 251
    4b0e:	7f 4f       	sbci	r23, 0xFF	; 255
    4b10:	8f 4f       	sbci	r24, 0xFF	; 255
    4b12:	9f 4f       	sbci	r25, 0xFF	; 255
    Value = Value / 10;               /* scale down by 10^1 */
    4b14:	a5 01       	movw	r20, r10
    4b16:	94 01       	movw	r18, r8
    4b18:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    4b1c:	69 01       	movw	r12, r18
    4b1e:	7a 01       	movw	r14, r20
    4b20:	df 5f       	subi	r29, 0xFF	; 255
  uint8_t           Offset = 0;         /* exponent offset to next 10^3 step */
  uint8_t           Index;              /* index ID */
  uint8_t           Length;             /* string length */

  /* scale value down to 4 digits */
  while (Value >= 10000)
    4b22:	20 31       	cpi	r18, 0x10	; 16
    4b24:	37 42       	sbci	r19, 0x27	; 39
    4b26:	41 05       	cpc	r20, r1
    4b28:	51 05       	cpc	r21, r1
    4b2a:	70 f7       	brcc	.-36     	; 0x4b08 <DisplayValue+0x3e>

  /*
   *  determine prefix and offset (= number of digits right of dot)
   */

  if (Exponent >= -12)                  /* prevent index underflow */
    4b2c:	d4 3f       	cpi	r29, 0xF4	; 244
    4b2e:	0c f4       	brge	.+2      	; 0x4b32 <DisplayValue+0x68>
    4b30:	66 c0       	rjmp	.+204    	; 0x4bfe <DisplayValue+0x134>
  {
    Exponent += 12;                     /* shift exponent to be >= 0 */ 
    4b32:	d4 5f       	subi	r29, 0xF4	; 244
    Index = Exponent / 3;               /* number of 10^3 steps */
    4b34:	86 e5       	ldi	r24, 0x56	; 86
    4b36:	d8 02       	muls	r29, r24
    4b38:	81 2d       	mov	r24, r1
    4b3a:	11 24       	eor	r1, r1
    4b3c:	d7 fd       	sbrc	r29, 7
    4b3e:	83 95       	inc	r24
    Offset = Exponent % 3;              /* offset to lower 10^3 step */
    4b40:	98 2f       	mov	r25, r24
    4b42:	99 0f       	add	r25, r25
    4b44:	98 0f       	add	r25, r24
    4b46:	bd 2e       	mov	r11, r29
    4b48:	b9 1a       	sub	r11, r25

    if (Offset > 0)                     /* dot required */
    4b4a:	21 f0       	breq	.+8      	; 0x4b54 <DisplayValue+0x8a>
    {
      Index++;                          /* upscale prefix */ 
    4b4c:	8f 5f       	subi	r24, 0xFF	; 255
      Offset = 3 - Offset;              /* reverse value (1 or 2) */
    4b4e:	93 e0       	ldi	r25, 0x03	; 3
    4b50:	9b 19       	sub	r25, r11
    4b52:	b9 2e       	mov	r11, r25
    }    

    /* look up prefix in table (also prevent array overflow) */
    if (Index <= 6) Prefix = eeprom_read_byte(&Prefix_table[Index]);
    4b54:	87 30       	cpi	r24, 0x07	; 7
    4b56:	38 f4       	brcc	.+14     	; 0x4b66 <DisplayValue+0x9c>
    4b58:	90 e0       	ldi	r25, 0x00	; 0
    4b5a:	8b 53       	subi	r24, 0x3B	; 59
    4b5c:	9f 4f       	sbci	r25, 0xFF	; 255
    4b5e:	0e 94 d2 28 	call	0x51a4	; 0x51a4 <eeprom_read_byte>
    4b62:	18 2f       	mov	r17, r24
    4b64:	01 c0       	rjmp	.+2      	; 0x4b68 <DisplayValue+0x9e>
 *  - unit character (0 = none)
 */

void DisplayValue(uint32_t Value, int8_t Exponent, unsigned char Unit)
{
  unsigned char     Prefix = 0;         /* prefix character */
    4b66:	10 e0       	ldi	r17, 0x00	; 0
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__utoa_ncheck (unsigned int, char *, unsigned char);
	return __utoa_ncheck (__val, __s, __radix);
    4b68:	4a e0       	ldi	r20, 0x0A	; 10
    4b6a:	6d e1       	ldi	r22, 0x1D	; 29
    4b6c:	71 e0       	ldi	r23, 0x01	; 1
    4b6e:	c6 01       	movw	r24, r12
    4b70:	0e 94 a8 28 	call	0x5150	; 0x5150 <__utoa_ncheck>
   *  display value
   */

  /* convert value into string */
  utoa((uint16_t)Value, OutBuffer, 10);
  Length = strlen(OutBuffer);
    4b74:	ed e1       	ldi	r30, 0x1D	; 29
    4b76:	f1 e0       	ldi	r31, 0x01	; 1
    4b78:	01 90       	ld	r0, Z+
    4b7a:	00 20       	and	r0, r0
    4b7c:	e9 f7       	brne	.-6      	; 0x4b78 <DisplayValue+0xae>
    4b7e:	31 97       	sbiw	r30, 0x01	; 1
    4b80:	ed 51       	subi	r30, 0x1D	; 29
    4b82:	f1 40       	sbci	r31, 0x01	; 1
    4b84:	0e 2f       	mov	r16, r30

  /* we misuse Exponent for the dot position */
  Exponent = Length - Offset;           /* calculate position */
    4b86:	de 2f       	mov	r29, r30
    4b88:	db 19       	sub	r29, r11

  if (Exponent <= 0)                    /* we have to prepend "0." */
    4b8a:	1d 16       	cp	r1, r29
    4b8c:	74 f0       	brlt	.+28     	; 0x4baa <DisplayValue+0xe0>
  {
    /* 0: factor 10 / -1: factor 100 */
    LCD_Data('0');
    4b8e:	80 e3       	ldi	r24, 0x30	; 48
    4b90:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    LCD_Data('.');
    4b94:	8e e2       	ldi	r24, 0x2E	; 46
    4b96:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    if (Exponent < 0) LCD_Data('0');    /* extra 0 for factor 100 */
    4b9a:	dd 23       	and	r29, r29
    4b9c:	34 f4       	brge	.+12     	; 0x4baa <DisplayValue+0xe0>
    4b9e:	02 c0       	rjmp	.+4      	; 0x4ba4 <DisplayValue+0xda>
 */

void DisplayValue(uint32_t Value, int8_t Exponent, unsigned char Unit)
{
  unsigned char     Prefix = 0;         /* prefix character */
  uint8_t           Offset = 0;         /* exponent offset to next 10^3 step */
    4ba0:	b1 2c       	mov	r11, r1
 *  - unit character (0 = none)
 */

void DisplayValue(uint32_t Value, int8_t Exponent, unsigned char Unit)
{
  unsigned char     Prefix = 0;         /* prefix character */
    4ba2:	10 e0       	ldi	r17, 0x00	; 0
  if (Exponent <= 0)                    /* we have to prepend "0." */
  {
    /* 0: factor 10 / -1: factor 100 */
    LCD_Data('0');
    LCD_Data('.');
    if (Exponent < 0) LCD_Data('0');    /* extra 0 for factor 100 */
    4ba4:	80 e3       	ldi	r24, 0x30	; 48
    4ba6:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
  }

  if (Offset == 0) Exponent = -1;       /* disable dot if not needed */
    4baa:	b1 10       	cpse	r11, r1
    4bac:	01 c0       	rjmp	.+2      	; 0x4bb0 <DisplayValue+0xe6>
    4bae:	df ef       	ldi	r29, 0xFF	; 255

  /* adjust position to match array or disable dot if set to 0 */ 
  Exponent--;
    4bb0:	ef ef       	ldi	r30, 0xFF	; 255
    4bb2:	ed 0f       	add	r30, r29

  /* display value and add dot if requested */
  Index = 0;
  while (Index < Length)                /* loop through string */
    4bb4:	01 11       	cpse	r16, r1
    4bb6:	03 c0       	rjmp	.+6      	; 0x4bbe <DisplayValue+0xf4>
    4bb8:	17 c0       	rjmp	.+46     	; 0x4be8 <DisplayValue+0x11e>
 *  - unit character (0 = none)
 */

void DisplayValue(uint32_t Value, int8_t Exponent, unsigned char Unit)
{
  unsigned char     Prefix = 0;         /* prefix character */
    4bba:	10 e0       	ldi	r17, 0x00	; 0
  }

  if (Offset == 0) Exponent = -1;       /* disable dot if not needed */

  /* adjust position to match array or disable dot if set to 0 */ 
  Exponent--;
    4bbc:	ee ef       	ldi	r30, 0xFE	; 254
    4bbe:	cd e1       	ldi	r28, 0x1D	; 29
    4bc0:	d1 e0       	ldi	r29, 0x01	; 1
    4bc2:	e1 2c       	mov	r14, r1
    4bc4:	f1 2c       	mov	r15, r1
  /* display value and add dot if requested */
  Index = 0;
  while (Index < Length)                /* loop through string */
  {
    LCD_Data(OutBuffer[Index]);              /* display char */
    if (Index == Exponent) LCD_Data('.');    /* display dot */
    4bc6:	ce 2e       	mov	r12, r30
    4bc8:	ee 0f       	add	r30, r30
    4bca:	dd 08       	sbc	r13, r13

  /* display value and add dot if requested */
  Index = 0;
  while (Index < Length)                /* loop through string */
  {
    LCD_Data(OutBuffer[Index]);              /* display char */
    4bcc:	89 91       	ld	r24, Y+
    4bce:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    if (Index == Exponent) LCD_Data('.');    /* display dot */
    4bd2:	ec 14       	cp	r14, r12
    4bd4:	fd 04       	cpc	r15, r13
    4bd6:	19 f4       	brne	.+6      	; 0x4bde <DisplayValue+0x114>
    4bd8:	8e e2       	ldi	r24, 0x2E	; 46
    4bda:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    4bde:	8f ef       	ldi	r24, 0xFF	; 255
    4be0:	e8 1a       	sub	r14, r24
    4be2:	f8 0a       	sbc	r15, r24
  /* adjust position to match array or disable dot if set to 0 */ 
  Exponent--;

  /* display value and add dot if requested */
  Index = 0;
  while (Index < Length)                /* loop through string */
    4be4:	e0 16       	cp	r14, r16
    4be6:	90 f3       	brcs	.-28     	; 0x4bcc <DisplayValue+0x102>
    if (Index == Exponent) LCD_Data('.');    /* display dot */
    Index++;                                 /* next one */
  }

  /* display prefix and unit */
  if (Prefix) LCD_Data(Prefix);
    4be8:	11 23       	and	r17, r17
    4bea:	19 f0       	breq	.+6      	; 0x4bf2 <DisplayValue+0x128>
    4bec:	81 2f       	mov	r24, r17
    4bee:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
  if (Unit) LCD_Data(Unit);
    4bf2:	77 20       	and	r7, r7
    4bf4:	29 f1       	breq	.+74     	; 0x4c40 <DisplayValue+0x176>
    4bf6:	87 2d       	mov	r24, r7
    4bf8:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    4bfc:	21 c0       	rjmp	.+66     	; 0x4c40 <DisplayValue+0x176>
    4bfe:	4a e0       	ldi	r20, 0x0A	; 10
    4c00:	6d e1       	ldi	r22, 0x1D	; 29
    4c02:	71 e0       	ldi	r23, 0x01	; 1
    4c04:	c6 01       	movw	r24, r12
    4c06:	0e 94 a8 28 	call	0x5150	; 0x5150 <__utoa_ncheck>
   *  display value
   */

  /* convert value into string */
  utoa((uint16_t)Value, OutBuffer, 10);
  Length = strlen(OutBuffer);
    4c0a:	ed e1       	ldi	r30, 0x1D	; 29
    4c0c:	f1 e0       	ldi	r31, 0x01	; 1
    4c0e:	01 90       	ld	r0, Z+
    4c10:	00 20       	and	r0, r0
    4c12:	e9 f7       	brne	.-6      	; 0x4c0e <DisplayValue+0x144>
    4c14:	31 97       	sbiw	r30, 0x01	; 1
    4c16:	ed 51       	subi	r30, 0x1D	; 29
    4c18:	f1 40       	sbci	r31, 0x01	; 1
    4c1a:	0e 2f       	mov	r16, r30

  /* we misuse Exponent for the dot position */
  Exponent = Length - Offset;           /* calculate position */
    4c1c:	de 2f       	mov	r29, r30

  if (Exponent <= 0)                    /* we have to prepend "0." */
    4c1e:	1e 16       	cp	r1, r30
    4c20:	64 f0       	brlt	.+24     	; 0x4c3a <DisplayValue+0x170>
  {
    /* 0: factor 10 / -1: factor 100 */
    LCD_Data('0');
    4c22:	80 e3       	ldi	r24, 0x30	; 48
    4c24:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    LCD_Data('.');
    4c28:	8e e2       	ldi	r24, 0x2E	; 46
    4c2a:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    if (Exponent < 0) LCD_Data('0');    /* extra 0 for factor 100 */
    4c2e:	00 23       	and	r16, r16
    4c30:	0c f4       	brge	.+2      	; 0x4c34 <DisplayValue+0x16a>
    4c32:	b6 cf       	rjmp	.-148    	; 0x4ba0 <DisplayValue+0xd6>
 *  - unit character (0 = none)
 */

void DisplayValue(uint32_t Value, int8_t Exponent, unsigned char Unit)
{
  unsigned char     Prefix = 0;         /* prefix character */
    4c34:	10 e0       	ldi	r17, 0x00	; 0
    LCD_Data('0');
    LCD_Data('.');
    if (Exponent < 0) LCD_Data('0');    /* extra 0 for factor 100 */
  }

  if (Offset == 0) Exponent = -1;       /* disable dot if not needed */
    4c36:	df ef       	ldi	r29, 0xFF	; 255
    4c38:	bb cf       	rjmp	.-138    	; 0x4bb0 <DisplayValue+0xe6>
  /* adjust position to match array or disable dot if set to 0 */ 
  Exponent--;

  /* display value and add dot if requested */
  Index = 0;
  while (Index < Length)                /* loop through string */
    4c3a:	e1 11       	cpse	r30, r1
    4c3c:	be cf       	rjmp	.-132    	; 0x4bba <DisplayValue+0xf0>
    4c3e:	d9 cf       	rjmp	.-78     	; 0x4bf2 <DisplayValue+0x128>
  }

  /* display prefix and unit */
  if (Prefix) LCD_Data(Prefix);
  if (Unit) LCD_Data(Unit);
}
    4c40:	df 91       	pop	r29
    4c42:	cf 91       	pop	r28
    4c44:	1f 91       	pop	r17
    4c46:	0f 91       	pop	r16
    4c48:	ff 90       	pop	r15
    4c4a:	ef 90       	pop	r14
    4c4c:	df 90       	pop	r13
    4c4e:	cf 90       	pop	r12
    4c50:	bf 90       	pop	r11
    4c52:	af 90       	pop	r10
    4c54:	9f 90       	pop	r9
    4c56:	8f 90       	pop	r8
    4c58:	7f 90       	pop	r7
    4c5a:	08 95       	ret

00004c5c <DisplaySignedValue>:
 *    e.g: p = 10^-12 -> -12
 *  - unit character (0 = none)
 */

void DisplaySignedValue(int32_t Value, int8_t Exponent, unsigned char Unit)
{
    4c5c:	cf 92       	push	r12
    4c5e:	df 92       	push	r13
    4c60:	ef 92       	push	r14
    4c62:	ff 92       	push	r15
    4c64:	cf 93       	push	r28
    4c66:	df 93       	push	r29
    4c68:	6b 01       	movw	r12, r22
    4c6a:	7c 01       	movw	r14, r24
    4c6c:	c4 2f       	mov	r28, r20
    4c6e:	d2 2f       	mov	r29, r18
  /* take care about sign */
  if (Value < 0)              /* negative value */
    4c70:	99 23       	and	r25, r25
    4c72:	5c f4       	brge	.+22     	; 0x4c8a <DisplaySignedValue+0x2e>
  {
    LCD_Data('-');            /* display: "-" */
    4c74:	8d e2       	ldi	r24, 0x2D	; 45
    4c76:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
    Value = -Value;           /* make value positive */
    4c7a:	f0 94       	com	r15
    4c7c:	e0 94       	com	r14
    4c7e:	d0 94       	com	r13
    4c80:	c0 94       	com	r12
    4c82:	c1 1c       	adc	r12, r1
    4c84:	d1 1c       	adc	r13, r1
    4c86:	e1 1c       	adc	r14, r1
    4c88:	f1 1c       	adc	r15, r1
  }

  /* and display unsigned value */
  DisplayValue((int32_t)Value, Exponent, Unit);
    4c8a:	2d 2f       	mov	r18, r29
    4c8c:	4c 2f       	mov	r20, r28
    4c8e:	c7 01       	movw	r24, r14
    4c90:	b6 01       	movw	r22, r12
    4c92:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
}
    4c96:	df 91       	pop	r29
    4c98:	cf 91       	pop	r28
    4c9a:	ff 90       	pop	r15
    4c9c:	ef 90       	pop	r14
    4c9e:	df 90       	pop	r13
    4ca0:	cf 90       	pop	r12
    4ca2:	08 95       	ret

00004ca4 <TestKey>:
 *  - 4 if rotary encoder was turned left
 *  The turning velocity is returned by Enc.Velocity.
 */

uint8_t TestKey(uint16_t Timeout, uint8_t Mode)
{
    4ca4:	cf 92       	push	r12
    4ca6:	df 92       	push	r13
    4ca8:	ef 92       	push	r14
    4caa:	ff 92       	push	r15
    4cac:	0f 93       	push	r16
    4cae:	1f 93       	push	r17
    4cb0:	cf 93       	push	r28
    4cb2:	df 93       	push	r29
    4cb4:	8c 01       	movw	r16, r24
    4cb6:	f6 2e       	mov	r15, r22
  Enc.Dir = DIR_RIGHT | DIR_LEFT;
  Enc.Pulses = 0;
  Enc.Velocity = 1;
  #endif

  if (Mode > 10)              /* consider operation mode */
    4cb8:	8a e0       	ldi	r24, 0x0A	; 10
    4cba:	86 17       	cp	r24, r22
    4cbc:	40 f4       	brcc	.+16     	; 0x4cce <TestKey+0x2a>
  {
    if (Config.TesterMode == MODE_AUTOHOLD)  /* auto hold mode */
    4cbe:	80 91 8e 01 	lds	r24, 0x018E
    4cc2:	81 30       	cpi	r24, 0x01	; 1
    4cc4:	69 f4       	brne	.+26     	; 0x4ce0 <TestKey+0x3c>
    {
      Timeout = 0;                 /* disable timeout */
      Mode -= 10;                  /* set cursor mode */
    4cc6:	86 ef       	ldi	r24, 0xF6	; 246
    4cc8:	f8 0e       	add	r15, r24

  if (Mode > 10)              /* consider operation mode */
  {
    if (Config.TesterMode == MODE_AUTOHOLD)  /* auto hold mode */
    {
      Timeout = 0;                 /* disable timeout */
    4cca:	00 e0       	ldi	r16, 0x00	; 0
    4ccc:	10 e0       	ldi	r17, 0x00	; 0
    {
      Mode = 0;                    /* disable cursor */
    }
  }

  if (Mode > 0)               /* cursor enabled */
    4cce:	ff 20       	and	r15, r15
    4cd0:	41 f0       	breq	.+16     	; 0x4ce2 <TestKey+0x3e>
  {
    /* set position: char 16 in line 2 */
    LCD_Cmd(CMD_SET_DD_RAM_ADDR | 0x4F);
    4cd2:	8f ec       	ldi	r24, 0xCF	; 207
    4cd4:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <LCD_Cmd>

    /* enable cursor */
    LCD_Cmd(CMD_DISPLAY_CONTROL | FLAG_DISPLAY_ON | FLAG_CURSOR_ON);
    4cd8:	8e e0       	ldi	r24, 0x0E	; 14
    4cda:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <LCD_Cmd>
    4cde:	01 c0       	rjmp	.+2      	; 0x4ce2 <TestKey+0x3e>
      Timeout = 0;                 /* disable timeout */
      Mode -= 10;                  /* set cursor mode */
    }
    else                                     /* continous mode */
    {
      Mode = 0;                    /* disable cursor */
    4ce0:	f1 2c       	mov	r15, r1
    4ce2:	e1 2c       	mov	r14, r1
    4ce4:	d1 e0       	ldi	r29, 0x01	; 1
  {
    /* take care about timeout */
    if (Timeout > 0)                    /* timeout enabled */
    {
      if (Timeout > 5) Timeout -= 5;    /* decrease timeout by 5ms */
      else Run = 0;                     /* end loop on timeout */
    4ce6:	c0 e0       	ldi	r28, 0x00	; 0
          }
          else                            /* turn on */
          {
            /* enable cursor */
            LCD_Cmd(CMD_DISPLAY_CONTROL | FLAG_DISPLAY_ON | FLAG_CURSOR_ON);
            Run = 1;                      /* toggle flag */
    4ce8:	cc 24       	eor	r12, r12
    4cea:	c3 94       	inc	r12
          /* we misuse Run as toggle switch */
          if (Run == 1)                   /* turn off */
          {
            /* disable cursor */
            LCD_Cmd(CMD_DISPLAY_CONTROL | FLAG_DISPLAY_ON | FLAG_CURSOR_OFF);
            Run = 2;                      /* toggle flag */
    4cec:	68 94       	set
    4cee:	dd 24       	eor	r13, r13
    4cf0:	d1 f8       	bld	r13, 1
   */
 
  while (Run)
  {
    /* take care about timeout */
    if (Timeout > 0)                    /* timeout enabled */
    4cf2:	01 15       	cp	r16, r1
    4cf4:	11 05       	cpc	r17, r1
    4cf6:	39 f0       	breq	.+14     	; 0x4d06 <TestKey+0x62>
    {
      if (Timeout > 5) Timeout -= 5;    /* decrease timeout by 5ms */
    4cf8:	06 30       	cpi	r16, 0x06	; 6
    4cfa:	11 05       	cpc	r17, r1
    4cfc:	18 f0       	brcs	.+6      	; 0x4d04 <TestKey+0x60>
    4cfe:	05 50       	subi	r16, 0x05	; 5
    4d00:	11 09       	sbc	r17, r1
    4d02:	01 c0       	rjmp	.+2      	; 0x4d06 <TestKey+0x62>
      else Run = 0;                     /* end loop on timeout */
    4d04:	dc 2f       	mov	r29, r28
    }

    /* check for key press */
    /* push button is low active */
    if (!(CONTROL_PIN & (1 << TEST_BUTTON)))      /* if key is pressed */
    4d06:	4f 99       	sbic	0x09, 7	; 9
    4d08:	18 c0       	rjmp	.+48     	; 0x4d3a <TestKey+0x96>
    {
      Counter = 0;            /* reset counter */
      MilliSleep(30);         /* time to debounce */
    4d0a:	8e e1       	ldi	r24, 0x1E	; 30
    4d0c:	90 e0       	ldi	r25, 0x00	; 0
    4d0e:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>

    /* check for key press */
    /* push button is low active */
    if (!(CONTROL_PIN & (1 << TEST_BUTTON)))      /* if key is pressed */
    {
      Counter = 0;            /* reset counter */
    4d12:	c0 e0       	ldi	r28, 0x00	; 0
      while (Run)             /* detect how long key is pressed */
      {
        if (!(CONTROL_PIN & (1 << TEST_BUTTON)))  /* key still pressed */
        {
          Counter++;                        /* increase counter */
          if (Counter > 26) Run = 0;        /* end loop if 300ms are reached */
    4d14:	10 e0       	ldi	r17, 0x00	; 0
    if (!(CONTROL_PIN & (1 << TEST_BUTTON)))      /* if key is pressed */
    {
      Counter = 0;            /* reset counter */
      MilliSleep(30);         /* time to debounce */

      while (Run)             /* detect how long key is pressed */
    4d16:	09 c0       	rjmp	.+18     	; 0x4d2a <TestKey+0x86>
      {
        if (!(CONTROL_PIN & (1 << TEST_BUTTON)))  /* key still pressed */
        {
          Counter++;                        /* increase counter */
    4d18:	cf 5f       	subi	r28, 0xFF	; 255
          if (Counter > 26) Run = 0;        /* end loop if 300ms are reached */
    4d1a:	cb 31       	cpi	r28, 0x1B	; 27
    4d1c:	28 f4       	brcc	.+10     	; 0x4d28 <TestKey+0x84>
          else MilliSleep(10);              /* otherweise wait 10ms */
    4d1e:	8a e0       	ldi	r24, 0x0A	; 10
    4d20:	90 e0       	ldi	r25, 0x00	; 0
    4d22:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>
    4d26:	01 c0       	rjmp	.+2      	; 0x4d2a <TestKey+0x86>
      while (Run)             /* detect how long key is pressed */
      {
        if (!(CONTROL_PIN & (1 << TEST_BUTTON)))  /* key still pressed */
        {
          Counter++;                        /* increase counter */
          if (Counter > 26) Run = 0;        /* end loop if 300ms are reached */
    4d28:	d1 2f       	mov	r29, r17
    if (!(CONTROL_PIN & (1 << TEST_BUTTON)))      /* if key is pressed */
    {
      Counter = 0;            /* reset counter */
      MilliSleep(30);         /* time to debounce */

      while (Run)             /* detect how long key is pressed */
    4d2a:	dd 23       	and	r29, r29
    4d2c:	11 f0       	breq	.+4      	; 0x4d32 <TestKey+0x8e>
      {
        if (!(CONTROL_PIN & (1 << TEST_BUTTON)))  /* key still pressed */
    4d2e:	4f 9b       	sbis	0x09, 7	; 9
    4d30:	f3 cf       	rjmp	.-26     	; 0x4d18 <TestKey+0x74>
          Run = 0;                          /* end loop */
        }
      }

      /* determine key press type */
      if (Counter > 26) Flag = 2;       /* long (>= 300ms) */
    4d32:	cb 31       	cpi	r28, 0x1B	; 27
    4d34:	20 f5       	brcc	.+72     	; 0x4d7e <TestKey+0xda>
      else Flag = 1;                    /* short (< 300ms) */
    4d36:	c1 e0       	ldi	r28, 0x01	; 1
    4d38:	1a c0       	rjmp	.+52     	; 0x4d6e <TestKey+0xca>
        Flag += 2;                 /* adjust feedback */
        break;                     /* leave loop */
      }
      #endif

      MilliSleep(5);               /* wait a little bit more (5ms) */
    4d3a:	85 e0       	ldi	r24, 0x05	; 5
    4d3c:	90 e0       	ldi	r25, 0x00	; 0
    4d3e:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>

      /* simulate blinking cursor
         The LCDs built in cursor blinking is ugly and slow */
      
      if (Mode == 2)                    /* blinking cursor */
    4d42:	82 e0       	ldi	r24, 0x02	; 2
    4d44:	f8 12       	cpse	r15, r24
    4d46:	10 c0       	rjmp	.+32     	; 0x4d68 <TestKey+0xc4>
      {
        Counter++;                        /* increase counter */
    4d48:	e3 94       	inc	r14

        if (Counter == 100)               /* every 500ms (1Hz) */
    4d4a:	84 e6       	ldi	r24, 0x64	; 100
    4d4c:	e8 12       	cpse	r14, r24
    4d4e:	0c c0       	rjmp	.+24     	; 0x4d68 <TestKey+0xc4>
        {
          Counter = 0;                    /* reset counter */

          /* we misuse Run as toggle switch */
          if (Run == 1)                   /* turn off */
    4d50:	d1 30       	cpi	r29, 0x01	; 1
    4d52:	29 f4       	brne	.+10     	; 0x4d5e <TestKey+0xba>
          {
            /* disable cursor */
            LCD_Cmd(CMD_DISPLAY_CONTROL | FLAG_DISPLAY_ON | FLAG_CURSOR_OFF);
    4d54:	8c e0       	ldi	r24, 0x0C	; 12
    4d56:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <LCD_Cmd>
            Run = 2;                      /* toggle flag */
    4d5a:	dd 2d       	mov	r29, r13
    4d5c:	0e c0       	rjmp	.+28     	; 0x4d7a <TestKey+0xd6>
          }
          else                            /* turn on */
          {
            /* enable cursor */
            LCD_Cmd(CMD_DISPLAY_CONTROL | FLAG_DISPLAY_ON | FLAG_CURSOR_ON);
    4d5e:	8e e0       	ldi	r24, 0x0E	; 14
    4d60:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <LCD_Cmd>
            Run = 1;                      /* toggle flag */
    4d64:	dc 2d       	mov	r29, r12
    4d66:	09 c0       	rjmp	.+18     	; 0x4d7a <TestKey+0xd6>

  /*
   *  wait for key press or timeout
   */
 
  while (Run)
    4d68:	d1 11       	cpse	r29, r1
    4d6a:	c3 cf       	rjmp	.-122    	; 0x4cf2 <TestKey+0x4e>
    4d6c:	c0 e0       	ldi	r28, 0x00	; 0

  /*
   *  clean up
   */

  if (Mode > 0)               /* cursor enabled */
    4d6e:	ff 20       	and	r15, r15
    4d70:	41 f0       	breq	.+16     	; 0x4d82 <TestKey+0xde>
  {
    /* disable cursor */
    LCD_Cmd(CMD_DISPLAY_CONTROL | FLAG_DISPLAY_ON | FLAG_CURSOR_OFF);
    4d72:	8c e0       	ldi	r24, 0x0C	; 12
    4d74:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <LCD_Cmd>
    4d78:	04 c0       	rjmp	.+8      	; 0x4d82 <TestKey+0xde>
      Timeout = 0;                 /* disable timeout */
      Mode -= 10;                  /* set cursor mode */
    }
    else                                     /* continous mode */
    {
      Mode = 0;                    /* disable cursor */
    4d7a:	ec 2e       	mov	r14, r28
    4d7c:	ba cf       	rjmp	.-140    	; 0x4cf2 <TestKey+0x4e>
          Run = 0;                          /* end loop */
        }
      }

      /* determine key press type */
      if (Counter > 26) Flag = 2;       /* long (>= 300ms) */
    4d7e:	c2 e0       	ldi	r28, 0x02	; 2
    4d80:	f6 cf       	rjmp	.-20     	; 0x4d6e <TestKey+0xca>
    /* disable cursor */
    LCD_Cmd(CMD_DISPLAY_CONTROL | FLAG_DISPLAY_ON | FLAG_CURSOR_OFF);
  }

  return Flag;
}
    4d82:	8c 2f       	mov	r24, r28
    4d84:	df 91       	pop	r29
    4d86:	cf 91       	pop	r28
    4d88:	1f 91       	pop	r17
    4d8a:	0f 91       	pop	r16
    4d8c:	ff 90       	pop	r15
    4d8e:	ef 90       	pop	r14
    4d90:	df 90       	pop	r13
    4d92:	cf 90       	pop	r12
    4d94:	08 95       	ret

00004d96 <WaitKey>:
 */

void WaitKey(void)
{
  /* wait for key press or 3000ms timeout */
  TestKey(3000, 11);
    4d96:	6b e0       	ldi	r22, 0x0B	; 11
    4d98:	88 eb       	ldi	r24, 0xB8	; 184
    4d9a:	9b e0       	ldi	r25, 0x0B	; 11
    4d9c:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <TestKey>
    4da0:	08 95       	ret

00004da2 <ShortCircuit>:
 *  - 0 on any problem
 *  - 1 on success
 */

uint8_t ShortCircuit(uint8_t Mode)
{
    4da2:	0f 93       	push	r16
    4da4:	1f 93       	push	r17
    4da6:	cf 93       	push	r28
    4da8:	df 93       	push	r29
    4daa:	d8 2f       	mov	r29, r24
  uint8_t           Test;               /* test feedback */
  uint8_t           Comp;               /* expected result */
  unsigned char     *String;            /* display string pointer */

  /* init */
  if (Mode == 0)         /* remove short */
    4dac:	88 23       	and	r24, r24
    4dae:	21 f0       	breq	.+8      	; 0x4db8 <ShortCircuit+0x16>
    String = (unsigned char *)Remove_str;
    Comp = 0;
  }
  else                   /* create short */
  {
    String = (unsigned char *)Create_str;
    4db0:	00 e2       	ldi	r16, 0x20	; 32
    4db2:	12 e0       	ldi	r17, 0x02	; 2
    Comp = 3;
    4db4:	c3 e0       	ldi	r28, 0x03	; 3
    4db6:	03 c0       	rjmp	.+6      	; 0x4dbe <ShortCircuit+0x1c>
  unsigned char     *String;            /* display string pointer */

  /* init */
  if (Mode == 0)         /* remove short */
  {
    String = (unsigned char *)Remove_str;
    4db8:	07 e2       	ldi	r16, 0x27	; 39
    4dba:	12 e0       	ldi	r17, 0x02	; 2
    Comp = 0;
    4dbc:	c0 e0       	ldi	r28, 0x00	; 0
    String = (unsigned char *)Create_str;
    Comp = 3;
  } 

  /* check if already done */
  Test = AllProbesShorted();            /* get current status */
    4dbe:	0e 94 52 18 	call	0x30a4	; 0x30a4 <AllProbesShorted>
  if (Test == Comp) Flag = 1;           /* skip loop if job already done */
    4dc2:	8c 13       	cpse	r24, r28
    4dc4:	17 c0       	rjmp	.+46     	; 0x4df4 <ShortCircuit+0x52>
    4dc6:	14 c0       	rjmp	.+40     	; 0x4df0 <ShortCircuit+0x4e>
  }  

  /* wait until all probes are dis/connected */
  while (Flag == 2)
  {
    Test = AllProbesShorted();     /* check for short circuits */
    4dc8:	0e 94 52 18 	call	0x30a4	; 0x30a4 <AllProbesShorted>

    if (Test == Comp)         /* job done */
    4dcc:	8c 13       	cpse	r24, r28
    4dce:	06 c0       	rjmp	.+12     	; 0x4ddc <ShortCircuit+0x3a>
    {
       Flag = 1;              /* end loop */
       MilliSleep(200);       /* time to debounce */
    4dd0:	88 ec       	ldi	r24, 0xC8	; 200
    4dd2:	90 e0       	ldi	r25, 0x00	; 0
    4dd4:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>
  {
    Test = AllProbesShorted();     /* check for short circuits */

    if (Test == Comp)         /* job done */
    {
       Flag = 1;              /* end loop */
    4dd8:	81 e0       	ldi	r24, 0x01	; 1
    4dda:	19 c0       	rjmp	.+50     	; 0x4e0e <ShortCircuit+0x6c>
       MilliSleep(200);       /* time to debounce */
    }
    else                      /* job not done yet */
    {
      Test = TestKey(100, 0);      /* wait 100ms or detect key press */
    4ddc:	60 e0       	ldi	r22, 0x00	; 0
    4dde:	84 e6       	ldi	r24, 0x64	; 100
    4de0:	90 e0       	ldi	r25, 0x00	; 0
    4de2:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <TestKey>
      if (Mode == 0) Test = 0;     /* ignore key for un-short mode */
    4de6:	dd 23       	and	r29, r29
    4de8:	79 f3       	breq	.-34     	; 0x4dc8 <ShortCircuit+0x26>
      if (Test > 0) Flag = 0;      /* abort on key press */
    4dea:	81 11       	cpse	r24, r1
    4dec:	0f c0       	rjmp	.+30     	; 0x4e0c <ShortCircuit+0x6a>
    4dee:	ec cf       	rjmp	.-40     	; 0x4dc8 <ShortCircuit+0x26>
    Comp = 3;
  } 

  /* check if already done */
  Test = AllProbesShorted();            /* get current status */
  if (Test == Comp) Flag = 1;           /* skip loop if job already done */
    4df0:	81 e0       	ldi	r24, 0x01	; 1
    4df2:	0d c0       	rjmp	.+26     	; 0x4e0e <ShortCircuit+0x6c>

  /* if necessary tell user what to do */
  if (Flag == 2)
  {
    LCD_Clear();
    4df4:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>
    LCD_EEString(String);               /* display: Remove/Create */
    4df8:	c8 01       	movw	r24, r16
    4dfa:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
    LCD_Line2();
    4dfe:	0e 94 52 0f 	call	0x1ea4	; 0x1ea4 <LCD_Line2>
    LCD_EEString(ShortCircuit_str);     /* display: short circuit! */
    4e02:	81 e1       	ldi	r24, 0x11	; 17
    4e04:	92 e0       	ldi	r25, 0x02	; 2
    4e06:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
    4e0a:	de cf       	rjmp	.-68     	; 0x4dc8 <ShortCircuit+0x26>
    }
    else                      /* job not done yet */
    {
      Test = TestKey(100, 0);      /* wait 100ms or detect key press */
      if (Mode == 0) Test = 0;     /* ignore key for un-short mode */
      if (Test > 0) Flag = 0;      /* abort on key press */
    4e0c:	80 e0       	ldi	r24, 0x00	; 0
    }
  }

  return Flag;
}
    4e0e:	df 91       	pop	r29
    4e10:	cf 91       	pop	r28
    4e12:	1f 91       	pop	r17
    4e14:	0f 91       	pop	r16
    4e16:	08 95       	ret

00004e18 <MenuTool>:
 *  returns:
 *  - number of selected item
 */

uint8_t MenuTool(uint8_t Items, uint8_t Type, void *Menu[], unsigned char *Unit)
{
    4e18:	df 92       	push	r13
    4e1a:	ef 92       	push	r14
    4e1c:	ff 92       	push	r15
    4e1e:	0f 93       	push	r16
    4e20:	1f 93       	push	r17
    4e22:	cf 93       	push	r28
    4e24:	df 93       	push	r29
    4e26:	d6 2e       	mov	r13, r22
    4e28:	7a 01       	movw	r14, r20
    4e2a:	89 01       	movw	r16, r18
  uint8_t           Run = 1;            /* loop control flag */
  uint8_t           n;                  /* temp value */
  void              *Address;           /* address of menu element */
  uint16_t          Value;              /* temp. value */

  Items--;                    /* to match array counter */
    4e2c:	df ef       	ldi	r29, 0xFF	; 255
    4e2e:	d8 0f       	add	r29, r24
  LCD_Data(':');              /* whatever: */
    4e30:	8a e3       	ldi	r24, 0x3A	; 58
    4e32:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>
 *  - number of selected item
 */

uint8_t MenuTool(uint8_t Items, uint8_t Type, void *Menu[], unsigned char *Unit)
{
  uint8_t           Selected = 0;       /* return value / ID of selected item */
    4e36:	c0 e0       	ldi	r28, 0x00	; 0
  {
    /*
     *  display item
     */

    LCD_ClearLine2();
    4e38:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <LCD_ClearLine2>
    Address = &Menu[Selected];     /* get address of element */
    4e3c:	ec 2f       	mov	r30, r28
    4e3e:	f0 e0       	ldi	r31, 0x00	; 0
    4e40:	ee 0f       	add	r30, r30
    4e42:	ff 1f       	adc	r31, r31
    4e44:	c7 01       	movw	r24, r14
    4e46:	8e 0f       	add	r24, r30
    4e48:	9f 1f       	adc	r25, r31

    if (Type == 1)                 /* fixed string */
    4e4a:	21 e0       	ldi	r18, 0x01	; 1
    4e4c:	d2 12       	cpse	r13, r18
    4e4e:	06 c0       	rjmp	.+12     	; 0x4e5c <MenuTool+0x44>
    {
      LCD_EEString(*(unsigned char **)Address);
    4e50:	fc 01       	movw	r30, r24
    4e52:	80 81       	ld	r24, Z
    4e54:	91 81       	ldd	r25, Z+1	; 0x01
    4e56:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
    4e5a:	09 c0       	rjmp	.+18     	; 0x4e6e <MenuTool+0x56>
    }
    else                           /* uint16_t in Flash or EEPROM */
    {
      Value = MEM_read_word(Address);   /* read value at flash/eeprom address */
    4e5c:	0e 94 da 28 	call	0x51b4	; 0x51b4 <eeprom_read_word>
      DisplayValue(Value, 0, 0);
    4e60:	bc 01       	movw	r22, r24
    4e62:	80 e0       	ldi	r24, 0x00	; 0
    4e64:	90 e0       	ldi	r25, 0x00	; 0
    4e66:	20 e0       	ldi	r18, 0x00	; 0
    4e68:	40 e0       	ldi	r20, 0x00	; 0
    4e6a:	0e 94 65 25 	call	0x4aca	; 0x4aca <DisplayValue>
    }

    if (Unit)                      /* optional fixed string */
    4e6e:	01 15       	cp	r16, r1
    4e70:	11 05       	cpc	r17, r1
    4e72:	19 f0       	breq	.+6      	; 0x4e7a <MenuTool+0x62>
    {
      LCD_EEString(Unit);
    4e74:	c8 01       	movw	r24, r16
    4e76:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>

    /*
     *  show navigation help
     */

    MilliSleep(100);               /* smooth UI */
    4e7a:	84 e6       	ldi	r24, 0x64	; 100
    4e7c:	90 e0       	ldi	r25, 0x00	; 0
    4e7e:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>

    /* set position: char 16 in line 2 */
    LCD_Cmd(CMD_SET_DD_RAM_ADDR | 0x4F);
    4e82:	8f ec       	ldi	r24, 0xCF	; 207
    4e84:	0e 94 42 0f 	call	0x1e84	; 0x1e84 <LCD_Cmd>

    if (Selected < Items) n = '>';      /* another item follows */
    4e88:	cd 17       	cp	r28, r29
    4e8a:	10 f0       	brcs	.+4      	; 0x4e90 <MenuTool+0x78>
    else n = '<';                       /* last item */
    4e8c:	8c e3       	ldi	r24, 0x3C	; 60
    4e8e:	01 c0       	rjmp	.+2      	; 0x4e92 <MenuTool+0x7a>
    MilliSleep(100);               /* smooth UI */

    /* set position: char 16 in line 2 */
    LCD_Cmd(CMD_SET_DD_RAM_ADDR | 0x4F);

    if (Selected < Items) n = '>';      /* another item follows */
    4e90:	8e e3       	ldi	r24, 0x3E	; 62
    else n = '<';                       /* last item */

    LCD_Data(n);
    4e92:	0e 94 46 0f 	call	0x1e8c	; 0x1e8c <LCD_Data>

    /*
     *  process user feedback
     */

    n = TestKey(0, 0);             /* wait for testkey */
    4e96:	60 e0       	ldi	r22, 0x00	; 0
    4e98:	80 e0       	ldi	r24, 0x00	; 0
    4e9a:	90 e0       	ldi	r25, 0x00	; 0
    4e9c:	0e 94 52 26 	call	0x4ca4	; 0x4ca4 <TestKey>

    if (n == 1)                    /* short key press: moves to next item */
    4ea0:	81 30       	cpi	r24, 0x01	; 1
    4ea2:	29 f4       	brne	.+10     	; 0x4eae <MenuTool+0x96>
      #ifdef HW_ENCODER
      /* alternative action for rotory encoder */
      if (Run == 2) break;              /* select current item */
      #endif

      Selected++;                       /* move to next item */
    4ea4:	cf 5f       	subi	r28, 0xFF	; 255
      if (Selected > Items)             /* max. number of items exceeded */
    4ea6:	dc 17       	cp	r29, r28
    4ea8:	38 f6       	brcc	.-114    	; 0x4e38 <MenuTool+0x20>
      {
        Selected = 0;                   /* roll over to first one */
    4eaa:	c0 e0       	ldi	r28, 0x00	; 0
    4eac:	c5 cf       	rjmp	.-118    	; 0x4e38 <MenuTool+0x20>
      }
    }
    else if (n == 2)               /* long key press: select current item */
    4eae:	82 30       	cpi	r24, 0x02	; 2
    4eb0:	19 f6       	brne	.-122    	; 0x4e38 <MenuTool+0x20>
      Run = 2;                          /* signal change by encoder */
    }
    #endif
  }

  LCD_Clear();                 /* feedback for user */
    4eb2:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>
  MilliSleep(500);             /* smooth UI */
    4eb6:	84 ef       	ldi	r24, 0xF4	; 244
    4eb8:	91 e0       	ldi	r25, 0x01	; 1
    4eba:	0e 94 56 17 	call	0x2eac	; 0x2eac <MilliSleep>

  return Selected;
}
    4ebe:	8c 2f       	mov	r24, r28
    4ec0:	df 91       	pop	r29
    4ec2:	cf 91       	pop	r28
    4ec4:	1f 91       	pop	r17
    4ec6:	0f 91       	pop	r16
    4ec8:	ff 90       	pop	r15
    4eca:	ef 90       	pop	r14
    4ecc:	df 90       	pop	r13
    4ece:	08 95       	ret

00004ed0 <MainMenu>:
/*
 *  main menu
 */

void MainMenu(void)
{
    4ed0:	1f 93       	push	r17
    4ed2:	cf 93       	push	r28
    4ed4:	df 93       	push	r29
    4ed6:	cd b7       	in	r28, 0x3d	; 61
    4ed8:	de b7       	in	r29, 0x3e	; 62
    4eda:	a1 97       	sbiw	r28, 0x21	; 33
    4edc:	0f b6       	in	r0, 0x3f	; 63
    4ede:	f8 94       	cli
    4ee0:	de bf       	out	0x3e, r29	; 62
    4ee2:	0f be       	out	0x3f, r0	; 63
    4ee4:	cd bf       	out	0x3d, r28	; 61
   *  setup menu
   */

  /* extra items */
  #ifdef SW_PWM
  MenuItem[Item] = (void *)PWM_str;          /* PWM tool */
    4ee6:	84 e1       	ldi	r24, 0x14	; 20
    4ee8:	91 e0       	ldi	r25, 0x01	; 1
    4eea:	9a 83       	std	Y+2, r25	; 0x02
    4eec:	89 83       	std	Y+1, r24	; 0x01
  MenuID[Item] = 5;
    4eee:	85 e0       	ldi	r24, 0x05	; 5
    4ef0:	8f 8b       	std	Y+23, r24	; 0x17
  MenuItem[Item] = (void *)Zener_str;        /* Zener tool */
  MenuID[Item] = 7;  
  Item++;
  #endif
  #ifdef SW_ESR
  MenuItem[Item] = (void *)ESR_str;          /* in-circuit ESR */
    4ef2:	8c e1       	ldi	r24, 0x1C	; 28
    4ef4:	91 e0       	ldi	r25, 0x01	; 1
    4ef6:	9c 83       	std	Y+4, r25	; 0x04
    4ef8:	8b 83       	std	Y+3, r24	; 0x03
  MenuID[Item] = 8;
    4efa:	88 e0       	ldi	r24, 0x08	; 8
    4efc:	88 8f       	std	Y+24, r24	; 0x18
  MenuItem[Item] = (void *)FreqCounter_str;  /* frequency counter */
  MenuID[Item] = 9;
  Item++;
  #endif
  #ifdef SW_ENCODER
  MenuItem[Item] = (void *)Encoder_str;      /* rotary encoder check */
    4efe:	8a ed       	ldi	r24, 0xDA	; 218
    4f00:	91 e0       	ldi	r25, 0x01	; 1
    4f02:	9e 83       	std	Y+6, r25	; 0x06
    4f04:	8d 83       	std	Y+5, r24	; 0x05
  MenuID[Item] = 10;
    4f06:	8a e0       	ldi	r24, 0x0A	; 10
    4f08:	89 8f       	std	Y+25, r24	; 0x19
  Item++;
  #endif

  /* standard items */
  MenuItem[Item] = (void *)Selftest_str;    /* selftest */
    4f0a:	8a e4       	ldi	r24, 0x4A	; 74
    4f0c:	92 e0       	ldi	r25, 0x02	; 2
    4f0e:	98 87       	std	Y+8, r25	; 0x08
    4f10:	8f 83       	std	Y+7, r24	; 0x07
  MenuID[Item] = 1;
    4f12:	81 e0       	ldi	r24, 0x01	; 1
    4f14:	8a 8f       	std	Y+26, r24	; 0x1a
  Item++;
  MenuItem[Item] = (void *)Show_str;        /* show self-adjustment values */
    4f16:	8e e2       	ldi	r24, 0x2E	; 46
    4f18:	92 e0       	ldi	r25, 0x02	; 2
    4f1a:	9a 87       	std	Y+10, r25	; 0x0a
    4f1c:	89 87       	std	Y+9, r24	; 0x09
  MenuID[Item] = 4;
    4f1e:	84 e0       	ldi	r24, 0x04	; 4
    4f20:	8b 8f       	std	Y+27, r24	; 0x1b
  Item++;
  MenuItem[Item] = (void *)Adjustment_str;  /* self-adjustment */
    4f22:	8f e3       	ldi	r24, 0x3F	; 63
    4f24:	92 e0       	ldi	r25, 0x02	; 2
    4f26:	9c 87       	std	Y+12, r25	; 0x0c
    4f28:	8b 87       	std	Y+11, r24	; 0x0b
  MenuID[Item] = 2;
    4f2a:	82 e0       	ldi	r24, 0x02	; 2
    4f2c:	8c 8f       	std	Y+28, r24	; 0x1c
  Item++;  
  MenuItem[Item] = (void *)Save_str;        /* store self-adjustment values */
    4f2e:	8a e3       	ldi	r24, 0x3A	; 58
    4f30:	92 e0       	ldi	r25, 0x02	; 2
    4f32:	9e 87       	std	Y+14, r25	; 0x0e
    4f34:	8d 87       	std	Y+13, r24	; 0x0d
  MenuID[Item] = 3;
    4f36:	83 e0       	ldi	r24, 0x03	; 3
    4f38:	8d 8f       	std	Y+29, r24	; 0x1d
  Item++;
  MenuItem[Item] = (void *)Exit_str;        /* exit menu */
    4f3a:	8c ef       	ldi	r24, 0xFC	; 252
    4f3c:	91 e0       	ldi	r25, 0x01	; 1
    4f3e:	98 8b       	std	Y+16, r25	; 0x10
    4f40:	8f 87       	std	Y+15, r24	; 0x0f
  MenuID[Item] = 0;
    4f42:	1e 8e       	std	Y+30, r1	; 0x1e

  /*
   *  run menu
   */

  LCD_Clear();
    4f44:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>
  LCD_EEString(Select_str);                  /* display "Select" */
    4f48:	83 e5       	ldi	r24, 0x53	; 83
    4f4a:	92 e0       	ldi	r25, 0x02	; 2
    4f4c:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
  Item++;                                    /* add 1 for item #0 */
  ID = MenuTool(Item, 1, MenuItem, NULL);
    4f50:	20 e0       	ldi	r18, 0x00	; 0
    4f52:	30 e0       	ldi	r19, 0x00	; 0
    4f54:	ae 01       	movw	r20, r28
    4f56:	4f 5f       	subi	r20, 0xFF	; 255
    4f58:	5f 4f       	sbci	r21, 0xFF	; 255
    4f5a:	61 e0       	ldi	r22, 0x01	; 1
    4f5c:	88 e0       	ldi	r24, 0x08	; 8
    4f5e:	0e 94 0c 27 	call	0x4e18	; 0x4e18 <MenuTool>
  ID = MenuID[ID];
    4f62:	fe 01       	movw	r30, r28
    4f64:	e8 0f       	add	r30, r24
    4f66:	f1 1d       	adc	r31, r1

  /* run selected item */
  switch (ID)
    4f68:	e7 89       	ldd	r30, Z+23	; 0x17
    4f6a:	8e 2f       	mov	r24, r30
    4f6c:	90 e0       	ldi	r25, 0x00	; 0
    4f6e:	fc 01       	movw	r30, r24
    4f70:	31 97       	sbiw	r30, 0x01	; 1
    4f72:	ea 30       	cpi	r30, 0x0A	; 10
    4f74:	f1 05       	cpc	r31, r1
    4f76:	80 f5       	brcc	.+96     	; 0x4fd8 <MainMenu+0x108>
    4f78:	e3 5b       	subi	r30, 0xB3	; 179
    4f7a:	ff 4f       	sbci	r31, 0xFF	; 255
    4f7c:	0c 94 81 28 	jmp	0x5102	; 0x5102 <__tablejump2__>
  {
    /* case 0:              exit menu */

    case 1:              /* self-test */
      Flag = SelfTest();
    4f80:	0e 94 bf 04 	call	0x97e	; 0x97e <SelfTest>
    4f84:	18 2f       	mov	r17, r24
      break;
    4f86:	29 c0       	rjmp	.+82     	; 0x4fda <MainMenu+0x10a>

    case 2:              /* self-adjustment */
      Flag = SelfAdjust();
    4f88:	0e 94 37 02 	call	0x46e	; 0x46e <SelfAdjust>
    4f8c:	18 2f       	mov	r17, r24
      break;
    4f8e:	25 c0       	rjmp	.+74     	; 0x4fda <MainMenu+0x10a>

    case 3:              /* safe self-adjustment values */
      SafeAdjust();
    4f90:	0e 94 43 01 	call	0x286	; 0x286 <SafeAdjust>
      break;
    4f94:	30 c0       	rjmp	.+96     	; 0x4ff6 <MainMenu+0x126>

    case 4:              /* show self-adjustment values */
      ShowAdjust();
    4f96:	0e 94 c4 01 	call	0x388	; 0x388 <ShowAdjust>
      break;
    4f9a:	2d c0       	rjmp	.+90     	; 0x4ff6 <MainMenu+0x126>

    #ifdef SW_PWM
    case 5:              /* PWM tool */
      /* run PWM menu */
      LCD_Clear();
    4f9c:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>
      LCD_EEString(PWM_str);
    4fa0:	84 e1       	ldi	r24, 0x14	; 20
    4fa2:	91 e0       	ldi	r25, 0x01	; 1
    4fa4:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
      ID = MenuTool(8, 2, (void *)PWM_Freq_table, (unsigned char *)Hertz_str);
    4fa8:	2c e0       	ldi	r18, 0x0C	; 12
    4faa:	31 e0       	ldi	r19, 0x01	; 1
    4fac:	49 e4       	ldi	r20, 0x49	; 73
    4fae:	50 e0       	ldi	r21, 0x00	; 0
    4fb0:	62 e0       	ldi	r22, 0x02	; 2
    4fb2:	88 e0       	ldi	r24, 0x08	; 8
    4fb4:	0e 94 0c 27 	call	0x4e18	; 0x4e18 <MenuTool>
      Frequency = MEM_read_word(&PWM_Freq_table[ID]);  /* get selected frequency */
    4fb8:	90 e0       	ldi	r25, 0x00	; 0
    4fba:	88 0f       	add	r24, r24
    4fbc:	99 1f       	adc	r25, r25
    4fbe:	87 5b       	subi	r24, 0xB7	; 183
    4fc0:	9f 4f       	sbci	r25, 0xFF	; 255
    4fc2:	0e 94 da 28 	call	0x51b4	; 0x51b4 <eeprom_read_word>
      PWM_Tool(Frequency);                             /* and run PWM tool */
    4fc6:	0e 94 de 0a 	call	0x15bc	; 0x15bc <PWM_Tool>
      break;
    4fca:	15 c0       	rjmp	.+42     	; 0x4ff6 <MainMenu+0x126>
      break;
    #endif

    #ifdef SW_ESR
    case 8:              /* ESR tool */
      ESR_Tool();
    4fcc:	0e 94 cf 0b 	call	0x179e	; 0x179e <ESR_Tool>
      break;
    4fd0:	12 c0       	rjmp	.+36     	; 0x4ff6 <MainMenu+0x126>
      break;
    #endif

    #ifdef SW_ENCODER
    case 10:             /* rotary encoder check */
      Encoder_Tool();
    4fd2:	0e 94 b3 0c 	call	0x1966	; 0x1966 <Encoder_Tool>
      break;
    4fd6:	0f c0       	rjmp	.+30     	; 0x4ff6 <MainMenu+0x126>
  #else
    #define MENU_ITEMS  5  
  #endif

  uint8_t           Item = 0;           /* item number */
  uint8_t           Flag = 1;           /* control flag */
    4fd8:	11 e0       	ldi	r17, 0x01	; 1
      break;
    #endif
  }

  /* display end of item */
  LCD_Clear();
    4fda:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>
  if (Flag == 0)
    4fde:	11 11       	cpse	r17, r1
    4fe0:	05 c0       	rjmp	.+10     	; 0x4fec <MainMenu+0x11c>
    LCD_EEString(Error_str);       /* display: error! */
    4fe2:	81 e0       	ldi	r24, 0x01	; 1
    4fe4:	92 e0       	ldi	r25, 0x02	; 2
    4fe6:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
    4fea:	08 c0       	rjmp	.+16     	; 0x4ffc <MainMenu+0x12c>
  else
    LCD_EEString(Done_str);        /* display: done! */
    4fec:	8a e5       	ldi	r24, 0x5A	; 90
    4fee:	92 e0       	ldi	r25, 0x02	; 2
    4ff0:	0e 94 bf 0f 	call	0x1f7e	; 0x1f7e <LCD_EEString>
    4ff4:	03 c0       	rjmp	.+6      	; 0x4ffc <MainMenu+0x12c>
      break;
    #endif
  }

  /* display end of item */
  LCD_Clear();
    4ff6:	0e 94 4a 0f 	call	0x1e94	; 0x1e94 <LCD_Clear>
    4ffa:	f8 cf       	rjmp	.-16     	; 0x4fec <MainMenu+0x11c>
    LCD_EEString(Error_str);       /* display: error! */
  else
    LCD_EEString(Done_str);        /* display: done! */

#undef MENU_ITEMS
}
    4ffc:	a1 96       	adiw	r28, 0x21	; 33
    4ffe:	0f b6       	in	r0, 0x3f	; 63
    5000:	f8 94       	cli
    5002:	de bf       	out	0x3e, r29	; 62
    5004:	0f be       	out	0x3f, r0	; 63
    5006:	cd bf       	out	0x3d, r28	; 61
    5008:	df 91       	pop	r29
    500a:	cf 91       	pop	r28
    500c:	1f 91       	pop	r17
    500e:	08 95       	ret

00005010 <__mulsi3>:
    5010:	db 01       	movw	r26, r22
    5012:	8f 93       	push	r24
    5014:	9f 93       	push	r25
    5016:	0e 94 9d 28 	call	0x513a	; 0x513a <__muluhisi3>
    501a:	bf 91       	pop	r27
    501c:	af 91       	pop	r26
    501e:	a2 9f       	mul	r26, r18
    5020:	80 0d       	add	r24, r0
    5022:	91 1d       	adc	r25, r1
    5024:	a3 9f       	mul	r26, r19
    5026:	90 0d       	add	r25, r0
    5028:	b2 9f       	mul	r27, r18
    502a:	90 0d       	add	r25, r0
    502c:	11 24       	eor	r1, r1
    502e:	08 95       	ret

00005030 <__udivmodhi4>:
    5030:	aa 1b       	sub	r26, r26
    5032:	bb 1b       	sub	r27, r27
    5034:	51 e1       	ldi	r21, 0x11	; 17
    5036:	07 c0       	rjmp	.+14     	; 0x5046 <__udivmodhi4_ep>

00005038 <__udivmodhi4_loop>:
    5038:	aa 1f       	adc	r26, r26
    503a:	bb 1f       	adc	r27, r27
    503c:	a6 17       	cp	r26, r22
    503e:	b7 07       	cpc	r27, r23
    5040:	10 f0       	brcs	.+4      	; 0x5046 <__udivmodhi4_ep>
    5042:	a6 1b       	sub	r26, r22
    5044:	b7 0b       	sbc	r27, r23

00005046 <__udivmodhi4_ep>:
    5046:	88 1f       	adc	r24, r24
    5048:	99 1f       	adc	r25, r25
    504a:	5a 95       	dec	r21
    504c:	a9 f7       	brne	.-22     	; 0x5038 <__udivmodhi4_loop>
    504e:	80 95       	com	r24
    5050:	90 95       	com	r25
    5052:	bc 01       	movw	r22, r24
    5054:	cd 01       	movw	r24, r26
    5056:	08 95       	ret

00005058 <__divmodhi4>:
    5058:	97 fb       	bst	r25, 7
    505a:	07 2e       	mov	r0, r23
    505c:	16 f4       	brtc	.+4      	; 0x5062 <__divmodhi4+0xa>
    505e:	00 94       	com	r0
    5060:	07 d0       	rcall	.+14     	; 0x5070 <__divmodhi4_neg1>
    5062:	77 fd       	sbrc	r23, 7
    5064:	09 d0       	rcall	.+18     	; 0x5078 <__divmodhi4_neg2>
    5066:	0e 94 18 28 	call	0x5030	; 0x5030 <__udivmodhi4>
    506a:	07 fc       	sbrc	r0, 7
    506c:	05 d0       	rcall	.+10     	; 0x5078 <__divmodhi4_neg2>
    506e:	3e f4       	brtc	.+14     	; 0x507e <__divmodhi4_exit>

00005070 <__divmodhi4_neg1>:
    5070:	90 95       	com	r25
    5072:	81 95       	neg	r24
    5074:	9f 4f       	sbci	r25, 0xFF	; 255
    5076:	08 95       	ret

00005078 <__divmodhi4_neg2>:
    5078:	70 95       	com	r23
    507a:	61 95       	neg	r22
    507c:	7f 4f       	sbci	r23, 0xFF	; 255

0000507e <__divmodhi4_exit>:
    507e:	08 95       	ret

00005080 <__udivmodsi4>:
    5080:	a1 e2       	ldi	r26, 0x21	; 33
    5082:	1a 2e       	mov	r1, r26
    5084:	aa 1b       	sub	r26, r26
    5086:	bb 1b       	sub	r27, r27
    5088:	fd 01       	movw	r30, r26
    508a:	0d c0       	rjmp	.+26     	; 0x50a6 <__udivmodsi4_ep>

0000508c <__udivmodsi4_loop>:
    508c:	aa 1f       	adc	r26, r26
    508e:	bb 1f       	adc	r27, r27
    5090:	ee 1f       	adc	r30, r30
    5092:	ff 1f       	adc	r31, r31
    5094:	a2 17       	cp	r26, r18
    5096:	b3 07       	cpc	r27, r19
    5098:	e4 07       	cpc	r30, r20
    509a:	f5 07       	cpc	r31, r21
    509c:	20 f0       	brcs	.+8      	; 0x50a6 <__udivmodsi4_ep>
    509e:	a2 1b       	sub	r26, r18
    50a0:	b3 0b       	sbc	r27, r19
    50a2:	e4 0b       	sbc	r30, r20
    50a4:	f5 0b       	sbc	r31, r21

000050a6 <__udivmodsi4_ep>:
    50a6:	66 1f       	adc	r22, r22
    50a8:	77 1f       	adc	r23, r23
    50aa:	88 1f       	adc	r24, r24
    50ac:	99 1f       	adc	r25, r25
    50ae:	1a 94       	dec	r1
    50b0:	69 f7       	brne	.-38     	; 0x508c <__udivmodsi4_loop>
    50b2:	60 95       	com	r22
    50b4:	70 95       	com	r23
    50b6:	80 95       	com	r24
    50b8:	90 95       	com	r25
    50ba:	9b 01       	movw	r18, r22
    50bc:	ac 01       	movw	r20, r24
    50be:	bd 01       	movw	r22, r26
    50c0:	cf 01       	movw	r24, r30
    50c2:	08 95       	ret

000050c4 <__divmodsi4>:
    50c4:	05 2e       	mov	r0, r21
    50c6:	97 fb       	bst	r25, 7
    50c8:	1e f4       	brtc	.+6      	; 0x50d0 <__divmodsi4+0xc>
    50ca:	00 94       	com	r0
    50cc:	0e 94 79 28 	call	0x50f2	; 0x50f2 <__negsi2>
    50d0:	57 fd       	sbrc	r21, 7
    50d2:	07 d0       	rcall	.+14     	; 0x50e2 <__divmodsi4_neg2>
    50d4:	0e 94 40 28 	call	0x5080	; 0x5080 <__udivmodsi4>
    50d8:	07 fc       	sbrc	r0, 7
    50da:	03 d0       	rcall	.+6      	; 0x50e2 <__divmodsi4_neg2>
    50dc:	4e f4       	brtc	.+18     	; 0x50f0 <__divmodsi4_exit>
    50de:	0c 94 79 28 	jmp	0x50f2	; 0x50f2 <__negsi2>

000050e2 <__divmodsi4_neg2>:
    50e2:	50 95       	com	r21
    50e4:	40 95       	com	r20
    50e6:	30 95       	com	r19
    50e8:	21 95       	neg	r18
    50ea:	3f 4f       	sbci	r19, 0xFF	; 255
    50ec:	4f 4f       	sbci	r20, 0xFF	; 255
    50ee:	5f 4f       	sbci	r21, 0xFF	; 255

000050f0 <__divmodsi4_exit>:
    50f0:	08 95       	ret

000050f2 <__negsi2>:
    50f2:	90 95       	com	r25
    50f4:	80 95       	com	r24
    50f6:	70 95       	com	r23
    50f8:	61 95       	neg	r22
    50fa:	7f 4f       	sbci	r23, 0xFF	; 255
    50fc:	8f 4f       	sbci	r24, 0xFF	; 255
    50fe:	9f 4f       	sbci	r25, 0xFF	; 255
    5100:	08 95       	ret

00005102 <__tablejump2__>:
    5102:	ee 0f       	add	r30, r30
    5104:	ff 1f       	adc	r31, r31
    5106:	05 90       	lpm	r0, Z+
    5108:	f4 91       	lpm	r31, Z
    510a:	e0 2d       	mov	r30, r0
    510c:	09 94       	ijmp

0000510e <__umulhisi3>:
    510e:	a2 9f       	mul	r26, r18
    5110:	b0 01       	movw	r22, r0
    5112:	b3 9f       	mul	r27, r19
    5114:	c0 01       	movw	r24, r0
    5116:	a3 9f       	mul	r26, r19
    5118:	70 0d       	add	r23, r0
    511a:	81 1d       	adc	r24, r1
    511c:	11 24       	eor	r1, r1
    511e:	91 1d       	adc	r25, r1
    5120:	b2 9f       	mul	r27, r18
    5122:	70 0d       	add	r23, r0
    5124:	81 1d       	adc	r24, r1
    5126:	11 24       	eor	r1, r1
    5128:	91 1d       	adc	r25, r1
    512a:	08 95       	ret

0000512c <__usmulhisi3>:
    512c:	0e 94 87 28 	call	0x510e	; 0x510e <__umulhisi3>

00005130 <__usmulhisi3_tail>:
    5130:	b7 ff       	sbrs	r27, 7
    5132:	08 95       	ret
    5134:	82 1b       	sub	r24, r18
    5136:	93 0b       	sbc	r25, r19
    5138:	08 95       	ret

0000513a <__muluhisi3>:
    513a:	0e 94 87 28 	call	0x510e	; 0x510e <__umulhisi3>
    513e:	a5 9f       	mul	r26, r21
    5140:	90 0d       	add	r25, r0
    5142:	b4 9f       	mul	r27, r20
    5144:	90 0d       	add	r25, r0
    5146:	a4 9f       	mul	r26, r20
    5148:	80 0d       	add	r24, r0
    514a:	91 1d       	adc	r25, r1
    514c:	11 24       	eor	r1, r1
    514e:	08 95       	ret

00005150 <__utoa_ncheck>:
    5150:	bb 27       	eor	r27, r27

00005152 <__utoa_common>:
    5152:	fb 01       	movw	r30, r22
    5154:	55 27       	eor	r21, r21
    5156:	aa 27       	eor	r26, r26
    5158:	88 0f       	add	r24, r24
    515a:	99 1f       	adc	r25, r25
    515c:	aa 1f       	adc	r26, r26
    515e:	a4 17       	cp	r26, r20
    5160:	10 f0       	brcs	.+4      	; 0x5166 <__utoa_common+0x14>
    5162:	a4 1b       	sub	r26, r20
    5164:	83 95       	inc	r24
    5166:	50 51       	subi	r21, 0x10	; 16
    5168:	b9 f7       	brne	.-18     	; 0x5158 <__utoa_common+0x6>
    516a:	a0 5d       	subi	r26, 0xD0	; 208
    516c:	aa 33       	cpi	r26, 0x3A	; 58
    516e:	08 f0       	brcs	.+2      	; 0x5172 <__utoa_common+0x20>
    5170:	a9 5d       	subi	r26, 0xD9	; 217
    5172:	a1 93       	st	Z+, r26
    5174:	00 97       	sbiw	r24, 0x00	; 0
    5176:	79 f7       	brne	.-34     	; 0x5156 <__utoa_common+0x4>
    5178:	b1 11       	cpse	r27, r1
    517a:	b1 93       	st	Z+, r27
    517c:	11 92       	st	Z+, r1
    517e:	cb 01       	movw	r24, r22
    5180:	0c 94 c2 28 	jmp	0x5184	; 0x5184 <strrev>

00005184 <strrev>:
    5184:	dc 01       	movw	r26, r24
    5186:	fc 01       	movw	r30, r24
    5188:	67 2f       	mov	r22, r23
    518a:	71 91       	ld	r23, Z+
    518c:	77 23       	and	r23, r23
    518e:	e1 f7       	brne	.-8      	; 0x5188 <strrev+0x4>
    5190:	32 97       	sbiw	r30, 0x02	; 2
    5192:	04 c0       	rjmp	.+8      	; 0x519c <strrev+0x18>
    5194:	7c 91       	ld	r23, X
    5196:	6d 93       	st	X+, r22
    5198:	70 83       	st	Z, r23
    519a:	62 91       	ld	r22, -Z
    519c:	ae 17       	cp	r26, r30
    519e:	bf 07       	cpc	r27, r31
    51a0:	c8 f3       	brcs	.-14     	; 0x5194 <strrev+0x10>
    51a2:	08 95       	ret

000051a4 <eeprom_read_byte>:
    51a4:	f9 99       	sbic	0x1f, 1	; 31
    51a6:	fe cf       	rjmp	.-4      	; 0x51a4 <eeprom_read_byte>
    51a8:	92 bd       	out	0x22, r25	; 34
    51aa:	81 bd       	out	0x21, r24	; 33
    51ac:	f8 9a       	sbi	0x1f, 0	; 31
    51ae:	99 27       	eor	r25, r25
    51b0:	80 b5       	in	r24, 0x20	; 32
    51b2:	08 95       	ret

000051b4 <eeprom_read_word>:
    51b4:	a8 e1       	ldi	r26, 0x18	; 24
    51b6:	b0 e0       	ldi	r27, 0x00	; 0
    51b8:	42 e0       	ldi	r20, 0x02	; 2
    51ba:	50 e0       	ldi	r21, 0x00	; 0
    51bc:	0c 94 f5 28 	jmp	0x51ea	; 0x51ea <eeprom_read_blraw>

000051c0 <eeprom_write_byte>:
    51c0:	26 2f       	mov	r18, r22

000051c2 <eeprom_write_r18>:
    51c2:	f9 99       	sbic	0x1f, 1	; 31
    51c4:	fe cf       	rjmp	.-4      	; 0x51c2 <eeprom_write_r18>
    51c6:	1f ba       	out	0x1f, r1	; 31
    51c8:	92 bd       	out	0x22, r25	; 34
    51ca:	81 bd       	out	0x21, r24	; 33
    51cc:	20 bd       	out	0x20, r18	; 32
    51ce:	0f b6       	in	r0, 0x3f	; 63
    51d0:	f8 94       	cli
    51d2:	fa 9a       	sbi	0x1f, 2	; 31
    51d4:	f9 9a       	sbi	0x1f, 1	; 31
    51d6:	0f be       	out	0x3f, r0	; 63
    51d8:	01 96       	adiw	r24, 0x01	; 1
    51da:	08 95       	ret

000051dc <eeprom_write_word>:
    51dc:	0e 94 e0 28 	call	0x51c0	; 0x51c0 <eeprom_write_byte>
    51e0:	27 2f       	mov	r18, r23
    51e2:	0c 94 e1 28 	jmp	0x51c2	; 0x51c2 <eeprom_write_r18>

000051e6 <eeprom_read_block>:
    51e6:	dc 01       	movw	r26, r24
    51e8:	cb 01       	movw	r24, r22

000051ea <eeprom_read_blraw>:
    51ea:	fc 01       	movw	r30, r24
    51ec:	f9 99       	sbic	0x1f, 1	; 31
    51ee:	fe cf       	rjmp	.-4      	; 0x51ec <eeprom_read_blraw+0x2>
    51f0:	06 c0       	rjmp	.+12     	; 0x51fe <eeprom_read_blraw+0x14>
    51f2:	f2 bd       	out	0x22, r31	; 34
    51f4:	e1 bd       	out	0x21, r30	; 33
    51f6:	f8 9a       	sbi	0x1f, 0	; 31
    51f8:	31 96       	adiw	r30, 0x01	; 1
    51fa:	00 b4       	in	r0, 0x20	; 32
    51fc:	0d 92       	st	X+, r0
    51fe:	41 50       	subi	r20, 0x01	; 1
    5200:	50 40       	sbci	r21, 0x00	; 0
    5202:	b8 f7       	brcc	.-18     	; 0x51f2 <eeprom_read_blraw+0x8>
    5204:	08 95       	ret

00005206 <_exit>:
    5206:	f8 94       	cli

00005208 <__stop_program>:
    5208:	ff cf       	rjmp	.-2      	; 0x5208 <__stop_program>
