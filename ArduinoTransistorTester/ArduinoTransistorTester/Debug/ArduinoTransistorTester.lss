
ArduinoTransistorTester.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  00007203  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00006e8c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000000b8  00800100  00800100  00006f20  2**0
                  ALLOC
  3 .eeprom       000002e3  00810000  00810000  00006f20  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .comment      00000030  00000000  00000000  00007203  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00007234  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000490  00000000  00000000  00007270  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000b01c  00000000  00000000  00007700  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000210a  00000000  00000000  0001271c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002b2b  00000000  00000000  00014826  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00001388  00000000  00000000  00017354  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000128d  00000000  00000000  000186dc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000b0aa  00000000  00000000  00019969  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000400  00000000  00000000  00024a13  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 58 04 	jmp	0x8b0	; 0x8b0 <__ctors_end>
       4:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
       8:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
       c:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      10:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      14:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      18:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      1c:	0c 94 79 22 	jmp	0x44f2	; 0x44f2 <__vector_7>
      20:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      24:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      28:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      2c:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      30:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      34:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      38:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      3c:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      40:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      44:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      48:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      4c:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      50:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      54:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      58:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      5c:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      60:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      64:	0c 94 6a 04 	jmp	0x8d4	; 0x8d4 <__bad_interrupt>
      68:	fd 21       	and	r31, r13
      6a:	18 22       	and	r1, r24
      6c:	18 22       	and	r1, r24
      6e:	18 22       	and	r1, r24
      70:	18 22       	and	r1, r24
      72:	18 22       	and	r1, r24
      74:	18 22       	and	r1, r24
      76:	18 22       	and	r1, r24
      78:	18 22       	and	r1, r24
      7a:	12 22       	and	r1, r18
      7c:	15 22       	and	r1, r21
      7e:	18 22       	and	r1, r24
      80:	18 22       	and	r1, r24
      82:	18 22       	and	r1, r24
      84:	18 22       	and	r1, r24
      86:	18 22       	and	r1, r24
      88:	18 22       	and	r1, r24
      8a:	18 22       	and	r1, r24
      8c:	18 22       	and	r1, r24
      8e:	00 22       	and	r0, r16
      90:	03 22       	and	r0, r19
      92:	06 22       	and	r0, r22
      94:	09 22       	and	r0, r25
      96:	0f 22       	and	r0, r31
      98:	0c 22       	and	r0, r28
      9a:	03 36       	cpi	r16, 0x63	; 99
      9c:	07 36       	cpi	r16, 0x67	; 103
      9e:	0b 36       	cpi	r16, 0x6B	; 107
      a0:	0f 36       	cpi	r16, 0x6F	; 111
      a2:	13 36       	cpi	r17, 0x63	; 99
      a4:	16 36       	cpi	r17, 0x66	; 102
      a6:	3a 36       	cpi	r19, 0x6A	; 106
      a8:	3a 36       	cpi	r19, 0x6A	; 106
      aa:	2e 36       	cpi	r18, 0x6E	; 110
      ac:	3a 36       	cpi	r19, 0x6A	; 106
      ae:	31 36       	cpi	r19, 0x61	; 97
      b0:	34 36       	cpi	r19, 0x64	; 100
      b2:	37 36       	cpi	r19, 0x67	; 103

000000b4 <PinTable>:
      b4:	05 0a 06 05 06 0a 05 0a 06 09 06 0a 05 0a 06 09     ................
      c4:	06 0a 05 0a 06 09 06 0a 05 0a 06 09 06 0a 05 0a     ................
      d4:	06 05 0a 06                                         ....

000000d8 <SymbolData>:
      d8:	00 00 00 00 80 60 10 10 08 c8 c4 04 04 04 84 48     .....`.........H
      e8:	28 1f 10 60 80 00 00 00 08 08 08 3e c9 08 08 08     (..`.......>....
      f8:	08 ff ff 14 22 41 80 c0 00 00 00 00 c1 3e 00 00     ...."A.......>..
     108:	00 00 00 00 00 03 04 04 08 09 11 10 10 11 11 09     ................
     118:	0a 7c 04 03 00 00 00 00 00 00 00 00 80 60 10 10     .|...........`..
     128:	08 c8 c4 04 04 c4 84 48 28 1f 10 60 80 00 00 00     .......H(..`....
     138:	08 08 08 3e c9 08 08 08 08 ff ff 14 22 41 81 01     ...>........"A..
     148:	00 00 00 00 c1 3e 00 00 00 00 00 00 00 03 04 04     .....>..........
     158:	08 09 11 10 10 10 10 09 0a 7c 04 03 00 00 00 00     .........|......
     168:	00 00 00 00 80 60 10 10 c8 08 e4 44 44 44 44 48     .....`.....DDDDH
     178:	48 7f 10 60 80 00 00 00 00 00 00 3e c1 00 00 00     H..`.......>....
     188:	ff 00 9c 08 08 1c 3e 08 08 f8 00 00 c1 3e 00 00     ......>......>..
     198:	01 01 01 01 01 03 05 05 09 08 13 11 11 11 11 09     ................
     1a8:	09 7f 0c 03 00 00 00 00 40 40 40 40 c0 60 50 50     ........@@@@.`PP
     1b8:	c8 08 e4 44 44 44 44 48 48 7f 10 60 80 00 00 00     ...DDDDHH..`....
     1c8:	00 00 00 3e c1 00 00 00 ff 00 9c 08 08 3e 1c 08     ...>.........>..
     1d8:	08 f8 00 00 c1 3e 00 00 00 00 00 00 00 03 04 04     .....>..........
     1e8:	09 08 13 11 11 11 11 09 09 7f 04 03 00 00 00 00     ................
     1f8:	00 00 00 00 80 60 10 10 c8 08 e4 44 44 44 44 48     .....`.....DDDDH
     208:	48 7f 10 60 80 00 00 00 00 00 00 3e c1 00 00 00     H..`.......>....
     218:	ff 00 ff 08 08 1c 3e 08 08 f8 00 00 c1 3e 00 00     ......>......>..
     228:	01 01 01 01 01 03 05 05 09 08 13 11 11 11 11 09     ................
     238:	09 7f 0c 03 00 00 00 00 40 40 40 40 c0 60 50 50     ........@@@@.`PP
     248:	c8 08 e4 44 44 44 44 48 48 7f 10 60 80 00 00 00     ...DDDDHH..`....
     258:	00 00 00 3e c1 00 00 00 ff 00 ff 08 08 3e 1c 08     ...>.........>..
     268:	08 f8 00 00 c1 3e 00 00 00 00 00 00 00 03 04 04     .....>..........
     278:	09 08 13 11 11 11 11 09 09 7f 04 03 00 00 00 00     ................
     288:	00 00 00 00 80 60 10 10 08 08 04 e4 84 84 84 88     .....`..........
     298:	88 ff 10 60 80 00 00 00 80 80 80 be c1 80 80 80     ...`............
     2a8:	e0 c0 80 ff 80 80 80 80 80 80 00 00 c1 3e 00 00     .............>..
     2b8:	00 00 00 00 00 03 04 04 0b 09 10 13 10 10 10 08     ................
     2c8:	08 7f 04 03 00 00 00 00 80 80 80 80 80 e0 90 90     ................
     2d8:	c8 e8 84 e4 84 84 84 88 88 ff 10 60 80 00 00 00     ...........`....
     2e8:	00 00 00 3e c1 00 00 00 01 03 00 ff 80 80 80 80     ...>............
     2f8:	80 80 00 00 c1 3e 00 00 00 00 00 00 00 03 04 04     .....>..........
     308:	08 08 10 13 10 10 10 08 08 7f 04 03 00 00 00 00     ................
     318:	00 00 00 00 80 60 10 10 88 08 c4 04 04 04 84 48     .....`.........H
     328:	28 1f 10 60 80 00 00 00 08 08 08 3e c9 08 08 08     (..`.......>....
     338:	ff 00 ff 14 22 41 80 c0 00 00 00 00 c1 3e 00 00     ...."A.......>..
     348:	00 00 00 00 00 03 04 04 08 08 11 10 10 11 11 09     ................
     358:	0a 7c 04 03 00 00 00 00 00 00 00 00 80 60 10 10     .|...........`..
     368:	88 08 c4 04 04 c4 84 48 28 1f 10 60 80 00 00 00     .......H(..`....
     378:	08 08 08 3e c9 08 08 08 ff 00 ff 14 22 41 81 01     ...>........"A..
     388:	00 00 00 00 c1 3e 00 00 00 00 00 00 00 03 04 04     .....>..........
     398:	08 08 11 10 10 10 10 09 0a 7c 04 03 00 00 00 00     .........|......
     3a8:	00 00 00 00 00 00 00 20 e0 e0 e0 e0 fe e0 e0 e0     ....... ........
     3b8:	e0 20 00 00 00 00 00 00 00 00 00 00 00 00 00 80     . ..............
     3c8:	80 83 8f bf ff bf 8f 83 80 80 00 00 00 00 00 00     ................
     3d8:	00 08 08 08 08 08 08 08 08 04 02 01 7f 00 00 00     ................
	...
     3f0:	00 00 00 80 80 80 80 80 80 80 80 80 fe 80 80 80     ................
     400:	80 80 80 80 80 80 00 00 00 00 00 80 e0 f8 fe ff     ................
     410:	fe f8 e0 80 00 01 07 1f 7f ff 7f 1f 07 01 00 00     ................
     420:	10 10 10 11 11 09 05 03 01 01 01 01 ff 01 01 01     ................
     430:	01 01 01 01 01 01 00 00                             ........

00000438 <FontTable>:
     438:	ff 01 02 03 04 05 06 07 ff ff ff ff ff ff ff ff     ................
     448:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
     458:	10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f     ................
     468:	20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f      !"#$%&'()*+,-./
     478:	30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f     0123456789:;<=>?
     488:	40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f     @ABCDEFGHIJKLMNO
     498:	50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f     PQRSTUVWXYZ[\]^_
     4a8:	60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e ff     `abcdefghijklmn.
     4b8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
     4c8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
     4d8:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
     4e8:	ff ff ff ff ff 05 ff ff ff ff ff ff ff ff ff ff     ................
     4f8:	ff ff ff ff 08 ff ff ff ff ff ff ff ff ff ff ff     ................
     508:	ff ff ff ff ff ff 09 ff ff ff ff ff 0a ff ff 0b     ................
     518:	ff ff ff ff 0c ff ff ff ff ff ff ff ff ff ff ff     ................
     528:	ff ff ff ff ff ff 0d ff ff ff ff ff 0e ff ff ff     ................

00000538 <FontData>:
	...
     540:	08 7f 3e 1c 08 7f 7f 08 08 7f 7f 08 1c 3e 7f 08     ..>..........>..
     550:	08 7f 7f 00 00 7f 7f 08 4c 5e 72 02 72 5e 4c 00     ........L^r.r^L.
     560:	c0 7e 3e 20 1e 3e 20 00 08 7f 41 41 41 41 41 41     .~> .> ...AAAAAA
     570:	41 41 41 41 41 41 7f 08 7d 7e 13 11 13 7e 7d 00     AAAAAA..}~...~}.
     580:	1d 3e 63 41 63 3e 1d 00 3f 7f 41 40 41 7f 3f 00     .>cAc>..?.A@A.?.
     590:	ff ff 49 49 49 7f 36 00 31 7a 4a 4a 7e 3d 40 00     ..III.6.1zJJ~=@.
     5a0:	18 3d 66 42 66 3d 18 00 3e 7e 41 40 21 7e 7e 00     .=fBf=..>~A@!~~.
	...
     5c0:	00 06 6f 6f 06 00 00 00 00 0b 07 00 00 0b 07 00     ..oo............
     5d0:	36 7f 7f 36 7f 7f 36 00 04 2e 2a 6b 2a 3a 10 00     6..6..6...*k*:..
     5e0:	63 73 38 1c 0e 67 63 00 36 7f 49 79 3b 6a 48 00     cs8..gc.6.Iy;jH.
     5f0:	00 00 07 0b 00 00 00 00 00 00 1c 3e 63 41 00 00     ...........>cA..
     600:	00 00 41 63 3e 1c 00 00 00 15 0a 1f 1f 0a 15 00     ..Ac>...........
     610:	00 18 18 7e 7e 18 18 00 00 00 b0 70 00 00 00 00     ...~~......p....
     620:	08 08 08 08 08 08 08 00 00 00 60 60 00 00 00 00     ..........``....
     630:	60 70 38 1c 0e 07 03 00 1c 3e 63 41 63 3e 1c 00     `p8......>cAc>..
     640:	00 42 7f 7f 40 00 00 00 62 73 51 59 49 4f 46 00     .B..@...bsQYIOF.
     650:	22 63 41 49 49 77 36 00 18 1c 16 13 7f 7f 10 00     "cAIIw6.........
     660:	27 67 45 45 45 7d 38 00 3c 7e 4b 49 49 79 30 00     'gEEE}8.<~KIIy0.
     670:	03 03 71 79 0d 07 03 00 36 7f 49 49 49 7f 36 00     ..qy....6.III.6.
     680:	06 4f 49 49 69 3f 1e 00 00 00 00 66 66 00 00 00     .OIIi?.....ff...
     690:	00 00 00 a6 66 00 00 00 00 08 1c 36 63 00 00 00     ....f......6c...
     6a0:	36 36 36 36 36 36 36 00 00 41 63 36 1c 08 00 00     6666666..Ac6....
     6b0:	02 03 69 6d 07 06 00 00 3e 63 5d 55 5d 6b 2e 00     ..im....>c]U]k..
     6c0:	7c 7e 13 11 13 7e 7c 00 7f 7f 49 49 49 7f 36 00     |~...~|...III.6.
     6d0:	1c 3e 63 41 41 63 22 00 7f 7f 41 41 63 3e 1c 00     .>cAAc"...AAc>..
     6e0:	7f 7f 49 49 49 49 41 00 7f 7f 09 09 09 09 01 00     ..IIIIA.........
     6f0:	1c 3e 63 41 49 79 79 00 7f 7f 08 08 08 7f 7f 00     .>cAIyy.........
     700:	00 00 41 7f 7f 41 00 00 30 70 40 40 40 7f 3f 00     ..A..A..0p@@@.?.
     710:	7f 7f 18 3c 36 63 41 00 7f 7f 40 40 40 40 40 00     ...<6cA...@@@@@.
     720:	7f 7f 0e 1c 0e 7f 7f 00 7f 7f 0e 1c 38 7f 7f 00     ............8...
     730:	1c 3e 63 41 63 3e 1c 00 7f 7f 11 11 11 1f 0e 00     .>cAc>..........
     740:	3e 7f 41 51 71 3f 5e 00 7f 7f 09 19 39 6f 46 00     >.AQq?^.....9oF.
     750:	26 6f 49 49 49 7b 32 00 00 01 01 7f 7f 01 01 00     &oIII{2.........
     760:	3f 7f 40 40 40 7f 3f 00 0f 1f 38 70 38 1f 0f 00     ?.@@@.?...8p8...
     770:	3f 7f 40 38 40 7f 3f 00 63 77 3e 1c 3e 77 63 00     ?.@8@.?.cw>.>wc.
     780:	00 07 0f 78 78 0f 07 00 61 71 79 5d 4f 47 43 00     ...xx...aqy]OGC.
     790:	00 7f 7f 41 41 00 00 00 03 07 0e 1c 38 70 60 00     ...AA.......8p`.
     7a0:	00 41 41 7f 7f 00 00 00 08 0c 06 03 06 0c 08 00     .AA.............
     7b0:	80 80 80 80 80 80 80 00 00 00 07 0b 00 00 00 00     ................
     7c0:	30 7a 4a 4a 7e 3c 40 00 7f 7f 44 42 62 7e 3c 00     0zJJ~<@...DBb~<.
     7d0:	18 3c 66 42 42 66 24 00 3c 7e 42 42 44 7f 7f 00     .<fBBf$.<~BBD...
     7e0:	3c 7e 4a 4a 4a 6e 2c 00 00 08 7e 7f 09 0a 00 00     <~JJJn,...~.....
     7f0:	1c 3e a2 a2 92 fe 7c 00 7f 7f 04 02 02 7e 7c 00     .>....|......~|.
     800:	00 00 48 7b 7b 40 00 00 00 40 c0 88 fb 7b 00 00     ..H{{@...@...{..
     810:	00 7f 7f 08 34 66 42 00 00 00 01 7f 7f 00 00 00     ....4fB.........
     820:	7e 7e 02 7e 04 7e 7c 00 7e 7e 04 02 06 7c 78 00     ~~.~.~|.~~...|x.
     830:	18 3c 66 42 66 3c 18 00 fe fe 22 42 42 7e 3c 00     .<fBf<...."BB~<.
     840:	00 3c 7e 42 42 22 fe fe 7e 7e 04 02 02 0e 0c 00     .<~BB"..~~......
     850:	24 6e 4a 4a 4a 7a 30 00 04 04 3f 7f 44 64 20 00     $nJJJz0...?.Dd .
     860:	3e 7e 40 40 20 7e 7e 00 0e 1e 30 60 30 1e 0e 00     >~@@ ~~...0`0...
     870:	3e 7e 40 30 40 7e 3e 00 62 76 1c 08 1c 76 62 00     >~@0@~>.bv...vb.
     880:	1e 3e a0 a0 90 fe 7e 00 42 62 72 5a 4e 46 00 00     .>....~.BbrZNF..
     890:	08 3e 77 41 41 00 00 00 00 00 00 7f 7f 00 00 00     .>wAA...........
     8a0:	00 00 41 41 77 3e 08 00 1c 1c 1c 7f 3e 1c 08 00     ..AAw>......>...

000008b0 <__ctors_end>:
     8b0:	11 24       	eor	r1, r1
     8b2:	1f be       	out	0x3f, r1	; 63
     8b4:	cf ef       	ldi	r28, 0xFF	; 255
     8b6:	d8 e0       	ldi	r29, 0x08	; 8
     8b8:	de bf       	out	0x3e, r29	; 62
     8ba:	cd bf       	out	0x3d, r28	; 61

000008bc <__do_clear_bss>:
     8bc:	21 e0       	ldi	r18, 0x01	; 1
     8be:	a0 e0       	ldi	r26, 0x00	; 0
     8c0:	b1 e0       	ldi	r27, 0x01	; 1
     8c2:	01 c0       	rjmp	.+2      	; 0x8c6 <.do_clear_bss_start>

000008c4 <.do_clear_bss_loop>:
     8c4:	1d 92       	st	X+, r1

000008c6 <.do_clear_bss_start>:
     8c6:	a8 3b       	cpi	r26, 0xB8	; 184
     8c8:	b2 07       	cpc	r27, r18
     8ca:	e1 f7       	brne	.-8      	; 0x8c4 <.do_clear_bss_loop>
     8cc:	0e 94 96 20 	call	0x412c	; 0x412c <main>
     8d0:	0c 94 44 37 	jmp	0x6e88	; 0x6e88 <_exit>

000008d4 <__bad_interrupt>:
     8d4:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000008d8 <ReadU>:
 *           may also include setting of voltage reference
 *
 */

uint16_t ReadU(uint8_t Probe)
{
     8d8:	6f 92       	push	r6
     8da:	7f 92       	push	r7
     8dc:	9f 92       	push	r9
     8de:	af 92       	push	r10
     8e0:	bf 92       	push	r11
     8e2:	cf 92       	push	r12
     8e4:	df 92       	push	r13
     8e6:	ef 92       	push	r14
     8e8:	ff 92       	push	r15
     8ea:	0f 93       	push	r16
     8ec:	1f 93       	push	r17
     8ee:	cf 93       	push	r28
     8f0:	df 93       	push	r29
  uint16_t          U;             /* return value (mV) */
  uint8_t           Counter;       /* loop counter */
  uint32_t          Value;         /* ADC value */

  Probe |= (1 << REFS0);           /* use external buffer cap anyway */
     8f2:	80 64       	ori	r24, 0x40	; 64
                                   /* and AVcc as default */

sample:

  ADMUX = Probe;                   /* set input channel and U reference */
     8f4:	0f 2e       	mov	r0, r31
     8f6:	fc e7       	ldi	r31, 0x7C	; 124
     8f8:	ef 2e       	mov	r14, r31
     8fa:	f1 2c       	mov	r15, r1
     8fc:	f0 2d       	mov	r31, r0

  /* if voltage reference has changed run a dummy conversion */
  /* (recommended by datasheet) */
  Counter = Probe & (1 << REFS1);    /* get REFS1 bit flag */
  if (Counter != Config.RefFlag)
     8fe:	0f 2e       	mov	r0, r31
     900:	fb ea       	ldi	r31, 0xAB	; 171
     902:	6f 2e       	mov	r6, r31
     904:	f1 e0       	ldi	r31, 0x01	; 1
     906:	7f 2e       	mov	r7, r31
     908:	f0 2d       	mov	r31, r0
  {
    _delay_us(100);                     /* time for voltage stabilization */

    ADCSRA |= (1 << ADSC);           /* start conversion */
     90a:	ea e7       	ldi	r30, 0x7A	; 122
     90c:	f0 e0       	ldi	r31, 0x00	; 0
   *  sample ADC readings
   */

  Value = 0UL;                     /* reset sampling variable */
  Counter = 0;                     /* reset counter */
  while (Counter < Config.Samples) /* take samples */
     90e:	91 2c       	mov	r9, r1
     910:	a1 2c       	mov	r10, r1
     912:	b1 2c       	mov	r11, r1
     914:	c1 2c       	mov	r12, r1
     916:	d1 2c       	mov	r13, r1
  {
    ADCSRA |= (1 << ADSC);         /* start conversion */
    while (ADCSRA & (1 << ADSC));  /* wait until conversion is done */

    Value += ADCW;                 /* add ADC reading */
     918:	08 e7       	ldi	r16, 0x78	; 120
     91a:	10 e0       	ldi	r17, 0x00	; 0
  Probe |= (1 << REFS0);           /* use external buffer cap anyway */
                                   /* and AVcc as default */

sample:

  ADMUX = Probe;                   /* set input channel and U reference */
     91c:	d7 01       	movw	r26, r14
     91e:	8c 93       	st	X, r24

  /* if voltage reference has changed run a dummy conversion */
  /* (recommended by datasheet) */
  Counter = Probe & (1 << REFS1);    /* get REFS1 bit flag */
     920:	28 2f       	mov	r18, r24
     922:	20 78       	andi	r18, 0x80	; 128
  if (Counter != Config.RefFlag)
     924:	e3 01       	movw	r28, r6
     926:	9b 81       	ldd	r25, Y+3	; 0x03
     928:	92 17       	cp	r25, r18
     92a:	71 f0       	breq	.+28     	; 0x948 <__stack+0x49>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     92c:	af e8       	ldi	r26, 0x8F	; 143
     92e:	b1 e0       	ldi	r27, 0x01	; 1
     930:	11 97       	sbiw	r26, 0x01	; 1
     932:	f1 f7       	brne	.-4      	; 0x930 <__stack+0x31>
     934:	00 c0       	rjmp	.+0      	; 0x936 <__stack+0x37>
     936:	00 00       	nop
  {
    _delay_us(100);                     /* time for voltage stabilization */

    ADCSRA |= (1 << ADSC);           /* start conversion */
     938:	90 81       	ld	r25, Z
     93a:	90 64       	ori	r25, 0x40	; 64
     93c:	90 83       	st	Z, r25
    while (ADCSRA & (1 << ADSC));    /* wait until conversion is done */
     93e:	90 81       	ld	r25, Z
     940:	96 fd       	sbrc	r25, 6
     942:	fd cf       	rjmp	.-6      	; 0x93e <__stack+0x3f>

    Config.RefFlag = Counter;        /* update flag */
     944:	e3 01       	movw	r28, r6
     946:	2b 83       	std	Y+3, r18	; 0x03
   *  sample ADC readings
   */

  Value = 0UL;                     /* reset sampling variable */
  Counter = 0;                     /* reset counter */
  while (Counter < Config.Samples) /* take samples */
     948:	d3 01       	movw	r26, r6
     94a:	11 96       	adiw	r26, 0x01	; 1
     94c:	cc 91       	ld	r28, X
     94e:	cc 23       	and	r28, r28
     950:	39 f1       	breq	.+78     	; 0x9a0 <__stack+0xa1>
     952:	49 2d       	mov	r20, r9
     954:	5a 2d       	mov	r21, r10
     956:	6b 2d       	mov	r22, r11
     958:	7c 2d       	mov	r23, r12
     95a:	3d 2d       	mov	r19, r13
  {
    ADCSRA |= (1 << ADSC);         /* start conversion */
     95c:	90 81       	ld	r25, Z
     95e:	90 64       	ori	r25, 0x40	; 64
     960:	90 83       	st	Z, r25
    while (ADCSRA & (1 << ADSC));  /* wait until conversion is done */
     962:	90 81       	ld	r25, Z
     964:	96 fd       	sbrc	r25, 6
     966:	fd cf       	rjmp	.-6      	; 0x962 <__stack+0x63>

    Value += ADCW;                 /* add ADC reading */
     968:	d8 01       	movw	r26, r16
     96a:	cd 91       	ld	r28, X+
     96c:	dc 91       	ld	r29, X
     96e:	4c 0f       	add	r20, r28
     970:	5d 1f       	adc	r21, r29
     972:	61 1d       	adc	r22, r1
     974:	71 1d       	adc	r23, r1

    /* auto-switch voltage reference for low readings */
    if ((Counter == 4) &&
     976:	34 30       	cpi	r19, 0x04	; 4
     978:	61 f4       	brne	.+24     	; 0x992 <__stack+0x93>
     97a:	41 15       	cp	r20, r1
     97c:	b4 e0       	ldi	r27, 0x04	; 4
     97e:	5b 07       	cpc	r21, r27
     980:	40 f4       	brcc	.+16     	; 0x992 <__stack+0x93>
        ((uint16_t)Value < 1024) &&
     982:	88 23       	and	r24, r24
     984:	34 f0       	brlt	.+12     	; 0x992 <__stack+0x93>
        !(Probe & (1 << REFS1)) &&
     986:	e3 01       	movw	r28, r6
     988:	9a 81       	ldd	r25, Y+2	; 0x02
     98a:	91 30       	cpi	r25, 0x01	; 1
     98c:	11 f4       	brne	.+4      	; 0x992 <__stack+0x93>
        (Config.AutoScale == 1))
    {
      Probe |= (1 << REFS1);       /* select internal bandgap reference */
     98e:	80 68       	ori	r24, 0x80	; 128
      goto sample;                 /* re-run sampling */
     990:	c5 cf       	rjmp	.-118    	; 0x91c <__stack+0x1d>
    }

    Counter++;                     /* one less to do */
     992:	3f 5f       	subi	r19, 0xFF	; 255
   *  sample ADC readings
   */

  Value = 0UL;                     /* reset sampling variable */
  Counter = 0;                     /* reset counter */
  while (Counter < Config.Samples) /* take samples */
     994:	d3 01       	movw	r26, r6
     996:	11 96       	adiw	r26, 0x01	; 1
     998:	cc 91       	ld	r28, X
     99a:	3c 17       	cp	r19, r28
     99c:	f8 f2       	brcs	.-66     	; 0x95c <__stack+0x5d>
     99e:	03 c0       	rjmp	.+6      	; 0x9a6 <__stack+0xa7>
     9a0:	40 e0       	ldi	r20, 0x00	; 0
     9a2:	50 e0       	ldi	r21, 0x00	; 0
     9a4:	ba 01       	movw	r22, r20
   *  convert ADC reading to voltage
   *  - single sample: U = ADC reading * U_ref / 1024
   */

  /* get voltage of reference used */
  if (Probe & (1 << REFS1)) U = Config.Bandgap;   /* bandgap reference */
     9a6:	88 23       	and	r24, r24
     9a8:	2c f4       	brge	.+10     	; 0x9b4 <__stack+0xb5>
     9aa:	a0 91 af 01 	lds	r26, 0x01AF
     9ae:	b0 91 b0 01 	lds	r27, 0x01B0
     9b2:	04 c0       	rjmp	.+8      	; 0x9bc <__stack+0xbd>
  else U = Config.Vcc;                            /* Vcc reference */   
     9b4:	a0 91 b1 01 	lds	r26, 0x01B1
     9b8:	b0 91 b2 01 	lds	r27, 0x01B2

  /* convert to voltage; */
  Value *= U;                      /* ADC readings * U_ref */
     9bc:	9a 01       	movw	r18, r20
     9be:	ab 01       	movw	r20, r22
     9c0:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
//  Value += 511 * Config.Samples;   /* automagic rounding */
  Value /= 1024;                   /* / 1024 for 10bit ADC */
     9c4:	05 2e       	mov	r0, r21
     9c6:	5a e0       	ldi	r21, 0x0A	; 10
     9c8:	96 95       	lsr	r25
     9ca:	87 95       	ror	r24
     9cc:	77 95       	ror	r23
     9ce:	67 95       	ror	r22
     9d0:	5a 95       	dec	r21
     9d2:	d1 f7       	brne	.-12     	; 0x9c8 <__stack+0xc9>
     9d4:	50 2d       	mov	r21, r0

  /* de-sample to get average voltage */
  Value /= Config.Samples;
     9d6:	2c 2f       	mov	r18, r28
     9d8:	30 e0       	ldi	r19, 0x00	; 0
     9da:	40 e0       	ldi	r20, 0x00	; 0
     9dc:	50 e0       	ldi	r21, 0x00	; 0
     9de:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
  U = (uint16_t)Value;

  return U; 
}
     9e2:	c9 01       	movw	r24, r18
     9e4:	df 91       	pop	r29
     9e6:	cf 91       	pop	r28
     9e8:	1f 91       	pop	r17
     9ea:	0f 91       	pop	r16
     9ec:	ff 90       	pop	r15
     9ee:	ef 90       	pop	r14
     9f0:	df 90       	pop	r13
     9f2:	cf 90       	pop	r12
     9f4:	bf 90       	pop	r11
     9f6:	af 90       	pop	r10
     9f8:	9f 90       	pop	r9
     9fa:	7f 90       	pop	r7
     9fc:	6f 90       	pop	r6
     9fe:	08 95       	ret

00000a00 <ReadU_5ms>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     a00:	ef e1       	ldi	r30, 0x1F	; 31
     a02:	fe e4       	ldi	r31, 0x4E	; 78
     a04:	31 97       	sbiw	r30, 0x01	; 1
     a06:	f1 f7       	brne	.-4      	; 0xa04 <ReadU_5ms+0x4>
     a08:	00 c0       	rjmp	.+0      	; 0xa0a <ReadU_5ms+0xa>
     a0a:	00 00       	nop

uint16_t ReadU_5ms(uint8_t Probe)
{
   _delay_ms(5);       /* wait 5ms */

   return (ReadU(Probe));
     a0c:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
}
     a10:	08 95       	ret

00000a12 <ReadU_20ms>:
     a12:	2f ef       	ldi	r18, 0xFF	; 255
     a14:	39 ef       	ldi	r19, 0xF9	; 249
     a16:	90 e0       	ldi	r25, 0x00	; 0
     a18:	21 50       	subi	r18, 0x01	; 1
     a1a:	30 40       	sbci	r19, 0x00	; 0
     a1c:	90 40       	sbci	r25, 0x00	; 0
     a1e:	e1 f7       	brne	.-8      	; 0xa18 <ReadU_20ms+0x6>
     a20:	00 c0       	rjmp	.+0      	; 0xa22 <ReadU_20ms+0x10>
     a22:	00 00       	nop

uint16_t ReadU_20ms(uint8_t Probe)
{
  _delay_ms(20);       /* wait 20ms */

  return (ReadU(Probe));
     a24:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
}
     a28:	08 95       	ret

00000a2a <SetAdjustDefaults>:
 */

void SetAdjustDefaults(void)
{
  /* set default values */
  NV.RiL = R_MCU_LOW;
     a2a:	eb e9       	ldi	r30, 0x9B	; 155
     a2c:	f1 e0       	ldi	r31, 0x01	; 1
     a2e:	88 ec       	ldi	r24, 0xC8	; 200
     a30:	90 e0       	ldi	r25, 0x00	; 0
     a32:	91 83       	std	Z+1, r25	; 0x01
     a34:	80 83       	st	Z, r24
  NV.RiH = R_MCU_HIGH;
     a36:	8c ed       	ldi	r24, 0xDC	; 220
     a38:	90 e0       	ldi	r25, 0x00	; 0
     a3a:	93 83       	std	Z+3, r25	; 0x03
     a3c:	82 83       	std	Z+2, r24	; 0x02
  NV.RZero = R_ZERO;
     a3e:	84 e1       	ldi	r24, 0x14	; 20
     a40:	90 e0       	ldi	r25, 0x00	; 0
     a42:	95 83       	std	Z+5, r25	; 0x05
     a44:	84 83       	std	Z+4, r24	; 0x04
  NV.CapZero = C_ZERO;
     a46:	8b e2       	ldi	r24, 0x2B	; 43
     a48:	86 83       	std	Z+6, r24	; 0x06
  NV.RefOffset = UREF_OFFSET;
     a4a:	17 82       	std	Z+7, r1	; 0x07
  NV.CompOffset = COMPARATOR_OFFSET;
     a4c:	8f e0       	ldi	r24, 0x0F	; 15
     a4e:	80 87       	std	Z+8, r24	; 0x08
  NV.Contrast = LCD_CONTRAST;
     a50:	86 e1       	ldi	r24, 0x16	; 22
     a52:	81 87       	std	Z+9, r24	; 0x09
     a54:	08 95       	ret

00000a56 <CheckSum>:
  uint8_t      *Data = (uint8_t *)&NV;  /* pointer to RAM */

  /* we simply add all bytes, besides the checksum */
  for (n = 0; n < (sizeof(NV_Type) - 1); n++)
  {  
    Checksum += *Data;
     a56:	80 91 9b 01 	lds	r24, 0x019B
     a5a:	9a e0       	ldi	r25, 0x0A	; 10
     a5c:	91 50       	subi	r25, 0x01	; 1
  uint8_t      Checksum = 0;            /* checksum / return value */
  uint8_t      n;                       /* counter */
  uint8_t      *Data = (uint8_t *)&NV;  /* pointer to RAM */

  /* we simply add all bytes, besides the checksum */
  for (n = 0; n < (sizeof(NV_Type) - 1); n++)
     a5e:	f1 f7       	brne	.-4      	; 0xa5c <CheckSum+0x6>
     a60:	88 0f       	add	r24, r24
     a62:	98 2f       	mov	r25, r24
     a64:	99 0f       	add	r25, r25
     a66:	99 0f       	add	r25, r25
     a68:	89 0f       	add	r24, r25
  {  
    Checksum += *Data;
  }

  /* fix for zero (not updated yet) */
  if (Checksum == 0) Checksum++;
     a6a:	09 f4       	brne	.+2      	; 0xa6e <CheckSum+0x18>
     a6c:	81 e0       	ldi	r24, 0x01	; 1

  return Checksum;
}
     a6e:	08 95       	ret

00000a70 <ManageAdjust>:
 *  - mode: load/save
 *  - ID: profile ID
 */

void ManageAdjust(uint8_t Mode, uint8_t ID)
{
     a70:	ff 92       	push	r15
     a72:	0f 93       	push	r16
     a74:	1f 93       	push	r17
     a76:	cf 93       	push	r28
     a78:	df 93       	push	r29
     a7a:	f8 2e       	mov	r15, r24
  uint8_t      n;                            /* counter */
  uint8_t      *Addr_RAM = (uint8_t *)&NV;   /* pointer to RAM */
  uint8_t      *Addr_EE;                     /* pointer to EEPROM */

  /* determine EEPROM address */
  if (ID == 2)                     /* profile #2 */
     a7c:	62 30       	cpi	r22, 0x02	; 2
     a7e:	19 f0       	breq	.+6      	; 0xa86 <ManageAdjust+0x16>
  {
    Addr_EE = (uint8_t *)&NV_EE2;
  }
  else                             /* profile #1 */
  {
    Addr_EE = (uint8_t *)&NV_EE;
     a80:	08 ed       	ldi	r16, 0xD8	; 216
     a82:	12 e0       	ldi	r17, 0x02	; 2
     a84:	02 c0       	rjmp	.+4      	; 0xa8a <ManageAdjust+0x1a>
  uint8_t      *Addr_EE;                     /* pointer to EEPROM */

  /* determine EEPROM address */
  if (ID == 2)                     /* profile #2 */
  {
    Addr_EE = (uint8_t *)&NV_EE2;
     a86:	0d ec       	ldi	r16, 0xCD	; 205
     a88:	12 e0       	ldi	r17, 0x02	; 2
  else                             /* profile #1 */
  {
    Addr_EE = (uint8_t *)&NV_EE;
  }

  NV.CheckSum = CheckSum();        /* update checksum */
     a8a:	0e 94 2b 05 	call	0xa56	; 0xa56 <CheckSum>
     a8e:	80 93 a5 01 	sts	0x01A5, r24
 */

void ManageAdjust(uint8_t Mode, uint8_t ID)
{
  uint8_t      n;                            /* counter */
  uint8_t      *Addr_RAM = (uint8_t *)&NV;   /* pointer to RAM */
     a92:	cb e9       	ldi	r28, 0x9B	; 155
     a94:	d1 e0       	ldi	r29, 0x01	; 1
   *  read/write EEPROM byte-wise to/from data structure 
   */

  for (n = 0; n < sizeof(NV_Type); n++)
  {
    if (Mode == MODE_SAVE)              /* write */
     a96:	82 e0       	ldi	r24, 0x02	; 2
     a98:	f8 12       	cpse	r15, r24
     a9a:	05 c0       	rjmp	.+10     	; 0xaa6 <ManageAdjust+0x36>
    {
      eeprom_write_byte(Addr_EE, *Addr_RAM);    /* write a byte */
     a9c:	68 81       	ld	r22, Y
     a9e:	c8 01       	movw	r24, r16
     aa0:	0e 94 26 37 	call	0x6e4c	; 0x6e4c <eeprom_write_byte>
     aa4:	04 c0       	rjmp	.+8      	; 0xaae <ManageAdjust+0x3e>
    }
    else                                /* read */
    {
      *Addr_RAM = eeprom_read_byte(Addr_EE);    /* read a byte */
     aa6:	c8 01       	movw	r24, r16
     aa8:	0e 94 18 37 	call	0x6e30	; 0x6e30 <eeprom_read_byte>
     aac:	88 83       	st	Y, r24
    }

    Addr_RAM++;               /* next byte */
     aae:	21 96       	adiw	r28, 0x01	; 1
    Addr_EE++;                /* next byte */
     ab0:	0f 5f       	subi	r16, 0xFF	; 255
     ab2:	1f 4f       	sbci	r17, 0xFF	; 255

  /*
   *  read/write EEPROM byte-wise to/from data structure 
   */

  for (n = 0; n < sizeof(NV_Type); n++)
     ab4:	81 e0       	ldi	r24, 0x01	; 1
     ab6:	c6 3a       	cpi	r28, 0xA6	; 166
     ab8:	d8 07       	cpc	r29, r24
     aba:	69 f7       	brne	.-38     	; 0xa96 <ManageAdjust+0x26>

  /*
   *  check checksum on read
   */

  if (Mode != MODE_SAVE)           /* read mode */
     abc:	82 e0       	ldi	r24, 0x02	; 2
     abe:	f8 16       	cp	r15, r24
     ac0:	c1 f0       	breq	.+48     	; 0xaf2 <ManageAdjust+0x82>
  {
    n = CheckSum();
     ac2:	0e 94 2b 05 	call	0xa56	; 0xa56 <CheckSum>

    if (NV.CheckSum != 0)          /* EEPROM updated */
     ac6:	90 91 a5 01 	lds	r25, 0x01A5
     aca:	99 23       	and	r25, r25
     acc:	91 f0       	breq	.+36     	; 0xaf2 <ManageAdjust+0x82>
    {
      if (NV.CheckSum != n)        /* mismatch */
     ace:	89 17       	cp	r24, r25
     ad0:	81 f0       	breq	.+32     	; 0xaf2 <ManageAdjust+0x82>
      {
        /* tell user */
        LCD_Clear();
     ad2:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
        LCD_EEString(Checksum_str);          /* display: Checksum */
     ad6:	87 e4       	ldi	r24, 0x47	; 71
     ad8:	91 e0       	ldi	r25, 0x01	; 1
     ada:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
        LCD_NextLine_EEString(Error_str);    /* display: error! */
     ade:	81 e4       	ldi	r24, 0x41	; 65
     ae0:	92 e0       	ldi	r25, 0x02	; 2
     ae2:	0e 94 1d 10 	call	0x203a	; 0x203a <LCD_NextLine_EEString>
        MilliSleep(2000);                    /* give user some time to read */
     ae6:	80 ed       	ldi	r24, 0xD0	; 208
     ae8:	97 e0       	ldi	r25, 0x07	; 7
     aea:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>

        SetAdjustDefaults();                 /* set defaults */
     aee:	0e 94 15 05 	call	0xa2a	; 0xa2a <SetAdjustDefaults>
      }
    }
  }
}
     af2:	df 91       	pop	r29
     af4:	cf 91       	pop	r28
     af6:	1f 91       	pop	r17
     af8:	0f 91       	pop	r16
     afa:	ff 90       	pop	r15
     afc:	08 95       	ret

00000afe <ShowAdjust>:
/*
 *  show adjustment values and offsets
 */

void ShowAdjust(void)
{
     afe:	0f 93       	push	r16
     b00:	1f 93       	push	r17
     b02:	cf 93       	push	r28
     b04:	df 93       	push	r29
  LCD_NextLine_Mode(MODE_KEY);          /* set next line mode */
     b06:	81 e0       	ldi	r24, 0x01	; 1
     b08:	0e 94 1a 10 	call	0x2034	; 0x2034 <LCD_NextLine_Mode>

  /* display RiL and RiH */
  LCD_Clear();
     b0c:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
  LCD_EEString_Space(RiLow_str);             /* display: Ri- */
     b10:	87 e7       	ldi	r24, 0x77	; 119
     b12:	91 e0       	ldi	r25, 0x01	; 1
     b14:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>
  DisplayValue(NV.RiL, -1, LCD_CHAR_OMEGA);
     b18:	cb e9       	ldi	r28, 0x9B	; 155
     b1a:	d1 e0       	ldi	r29, 0x01	; 1
     b1c:	68 81       	ld	r22, Y
     b1e:	79 81       	ldd	r23, Y+1	; 0x01
     b20:	80 e0       	ldi	r24, 0x00	; 0
     b22:	90 e0       	ldi	r25, 0x00	; 0
     b24:	24 e0       	ldi	r18, 0x04	; 4
     b26:	4f ef       	ldi	r20, 0xFF	; 255
     b28:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
  LCD_NextLine_EEString_Space(RiHigh_str);   /* display: Ri+ */
     b2c:	83 e7       	ldi	r24, 0x73	; 115
     b2e:	91 e0       	ldi	r25, 0x01	; 1
     b30:	0e 94 28 10 	call	0x2050	; 0x2050 <LCD_NextLine_EEString_Space>
  DisplayValue(NV.RiH, -1, LCD_CHAR_OMEGA);
     b34:	6a 81       	ldd	r22, Y+2	; 0x02
     b36:	7b 81       	ldd	r23, Y+3	; 0x03
     b38:	80 e0       	ldi	r24, 0x00	; 0
     b3a:	90 e0       	ldi	r25, 0x00	; 0
     b3c:	24 e0       	ldi	r18, 0x04	; 4
     b3e:	4f ef       	ldi	r20, 0xFF	; 255
     b40:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>

  /* display C-Zero */
  LCD_NextLine_EEString_Space(CapOffset_str);     /* display: C0 */
     b44:	8d e5       	ldi	r24, 0x5D	; 93
     b46:	91 e0       	ldi	r25, 0x01	; 1
     b48:	0e 94 28 10 	call	0x2050	; 0x2050 <LCD_NextLine_EEString_Space>
  DisplayValue(NV.CapZero, -12, 'F');    /* display C0 offset */
     b4c:	6e 81       	ldd	r22, Y+6	; 0x06
     b4e:	70 e0       	ldi	r23, 0x00	; 0
     b50:	80 e0       	ldi	r24, 0x00	; 0
     b52:	90 e0       	ldi	r25, 0x00	; 0
     b54:	26 e4       	ldi	r18, 0x46	; 70
     b56:	44 ef       	ldi	r20, 0xF4	; 244
     b58:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>

  /* display R-Zero */
  LCD_NextLine_EEString_Space(ROffset_str);        /* display: R0 */
     b5c:	8a e5       	ldi	r24, 0x5A	; 90
     b5e:	91 e0       	ldi	r25, 0x01	; 1
     b60:	0e 94 28 10 	call	0x2050	; 0x2050 <LCD_NextLine_EEString_Space>
  DisplayValue(NV.RZero, -2, LCD_CHAR_OMEGA);  /* display R0 */
     b64:	6c 81       	ldd	r22, Y+4	; 0x04
     b66:	7d 81       	ldd	r23, Y+5	; 0x05
     b68:	80 e0       	ldi	r24, 0x00	; 0
     b6a:	90 e0       	ldi	r25, 0x00	; 0
     b6c:	24 e0       	ldi	r18, 0x04	; 4
     b6e:	4e ef       	ldi	r20, 0xFE	; 254
     b70:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>

  /* display internal bandgap reference */
  LCD_NextLine_EEString_Space(URef_str);     /* display: Vref */
     b74:	83 e8       	ldi	r24, 0x83	; 131
     b76:	91 e0       	ldi	r25, 0x01	; 1
     b78:	0e 94 28 10 	call	0x2050	; 0x2050 <LCD_NextLine_EEString_Space>
  DisplayValue(Config.Bandgap, -3, 'V');     /* display bandgap ref */
     b7c:	0b ea       	ldi	r16, 0xAB	; 171
     b7e:	11 e0       	ldi	r17, 0x01	; 1
     b80:	f8 01       	movw	r30, r16
     b82:	64 81       	ldd	r22, Z+4	; 0x04
     b84:	75 81       	ldd	r23, Z+5	; 0x05
     b86:	80 e0       	ldi	r24, 0x00	; 0
     b88:	90 e0       	ldi	r25, 0x00	; 0
     b8a:	26 e5       	ldi	r18, 0x56	; 86
     b8c:	4d ef       	ldi	r20, 0xFD	; 253
     b8e:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>

  /* display Vcc */
  LCD_NextLine_EEString_Space(Vcc_str);      /* display: Vcc */
     b92:	86 e5       	ldi	r24, 0x56	; 86
     b94:	91 e0       	ldi	r25, 0x01	; 1
     b96:	0e 94 28 10 	call	0x2050	; 0x2050 <LCD_NextLine_EEString_Space>
  DisplayValue(Config.Vcc, -3, 'V');         /* display Vcc */
     b9a:	f8 01       	movw	r30, r16
     b9c:	66 81       	ldd	r22, Z+6	; 0x06
     b9e:	77 81       	ldd	r23, Z+7	; 0x07
     ba0:	80 e0       	ldi	r24, 0x00	; 0
     ba2:	90 e0       	ldi	r25, 0x00	; 0
     ba4:	26 e5       	ldi	r18, 0x56	; 86
     ba6:	4d ef       	ldi	r20, 0xFD	; 253
     ba8:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>

  /* display offset of analog comparator */
  LCD_NextLine_EEString_Space(CompOffset_str);    /* display: AComp */
     bac:	80 e5       	ldi	r24, 0x50	; 80
     bae:	91 e0       	ldi	r25, 0x01	; 1
     bb0:	0e 94 28 10 	call	0x2050	; 0x2050 <LCD_NextLine_EEString_Space>
  DisplaySignedValue(NV.CompOffset, -3, 'V');
     bb4:	68 85       	ldd	r22, Y+8	; 0x08
     bb6:	06 2e       	mov	r0, r22
     bb8:	00 0c       	add	r0, r0
     bba:	77 0b       	sbc	r23, r23
     bbc:	88 0b       	sbc	r24, r24
     bbe:	99 0b       	sbc	r25, r25
     bc0:	26 e5       	ldi	r18, 0x56	; 86
     bc2:	4d ef       	ldi	r20, 0xFD	; 253
     bc4:	0e 94 34 33 	call	0x6668	; 0x6668 <DisplaySignedValue>

  WaitKey();                  /* let the user read */
     bc8:	0e 94 ca 33 	call	0x6794	; 0x6794 <WaitKey>
}
     bcc:	df 91       	pop	r29
     bce:	cf 91       	pop	r28
     bd0:	1f 91       	pop	r17
     bd2:	0f 91       	pop	r16
     bd4:	08 95       	ret

00000bd6 <SelfAdjust>:
 *  - 0 on error
 *  - 1 on success
 */

uint8_t SelfAdjust(void)
{
     bd6:	2f 92       	push	r2
     bd8:	3f 92       	push	r3
     bda:	4f 92       	push	r4
     bdc:	5f 92       	push	r5
     bde:	6f 92       	push	r6
     be0:	7f 92       	push	r7
     be2:	8f 92       	push	r8
     be4:	9f 92       	push	r9
     be6:	af 92       	push	r10
     be8:	bf 92       	push	r11
     bea:	cf 92       	push	r12
     bec:	df 92       	push	r13
     bee:	ef 92       	push	r14
     bf0:	ff 92       	push	r15
     bf2:	0f 93       	push	r16
     bf4:	1f 93       	push	r17
     bf6:	cf 93       	push	r28
     bf8:	df 93       	push	r29
     bfa:	cd b7       	in	r28, 0x3d	; 61
     bfc:	de b7       	in	r29, 0x3e	; 62
     bfe:	2c 97       	sbiw	r28, 0x0c	; 12
     c00:	0f b6       	in	r0, 0x3f	; 63
     c02:	f8 94       	cli
     c04:	de bf       	out	0x3e, r29	; 62
     c06:	0f be       	out	0x3f, r0	; 63
     c08:	cd bf       	out	0x3d, r28	; 61
  /*
   *  measurements
   */

  /* make sure all probes are shorted */
  Counter = ShortCircuit(1);
     c0a:	81 e0       	ldi	r24, 0x01	; 1
     c0c:	0e 94 d0 33 	call	0x67a0	; 0x67a0 <ShortCircuit>
  if (Counter == 0) Test = 10;     /* skip adjustment on error */
     c10:	88 23       	and	r24, r24
     c12:	09 f4       	brne	.+2      	; 0xc16 <SelfAdjust+0x40>
     c14:	bd c1       	rjmp	.+890    	; 0xf90 <SelfAdjust+0x3ba>
     c16:	41 2c       	mov	r4, r1
     c18:	51 2c       	mov	r5, r1
     c1a:	1a 82       	std	Y+2, r1	; 0x02
     c1c:	1c 82       	std	Y+4, r1	; 0x04
     c1e:	1b 82       	std	Y+3, r1	; 0x03
     c20:	19 82       	std	Y+1, r1	; 0x01
     c22:	21 2c       	mov	r2, r1
     c24:	31 2c       	mov	r3, r1
     c26:	b1 2c       	mov	r11, r1
     c28:	1a 86       	std	Y+10, r1	; 0x0a
     c2a:	19 86       	std	Y+9, r1	; 0x09
     c2c:	18 86       	std	Y+8, r1	; 0x08
     c2e:	c1 2c       	mov	r12, r1
     c30:	d1 2c       	mov	r13, r1
     c32:	e1 2c       	mov	r14, r1
     c34:	f1 2c       	mov	r15, r1
     c36:	61 2c       	mov	r6, r1
     c38:	71 2c       	mov	r7, r1
     c3a:	aa 24       	eor	r10, r10
     c3c:	a3 94       	inc	r10
 *  - 0 on error
 *  - 1 on success
 */

uint8_t SelfAdjust(void)
{
     c3e:	01 e0       	ldi	r16, 0x01	; 1
          Val1 = ReadU_5ms(TP1);
          U_RiL += Val1;

          /* TP2: Gnd -- Ri -- probe -- Rl -- Ri -- Vcc */
          ADC_DDR = 1 << TP2;
          R_PORT =  1 << (TP2 * 2);
     c40:	68 94       	set
     c42:	88 24       	eor	r8, r8
     c44:	82 f8       	bld	r8, 2
        case 3:     /* internal resistance of MCU in pull-down mode */
          LCD_EEString(RiLow_str);      /* display: Ri- */

          /* TP1:  Gnd -- Ri -- probe -- Rl -- Ri -- Vcc */
          ADC_PORT = 0;
          ADC_DDR = 1 << TP1;
     c46:	10 2f       	mov	r17, r16
          R_DDR = 1 << (TP1 * 2);
          Val1 = ReadU_5ms(TP1);
          U_RiL += Val1;

          /* TP2: Gnd -- Ri -- probe -- Rl -- Ri -- Vcc */
          ADC_DDR = 1 << TP2;
     c48:	68 94       	set
     c4a:	99 24       	eor	r9, r9
     c4c:	91 f8       	bld	r9, 1

          break;

        case 2:     /* un-short probes */
          ShortCircuit(0);              /* make sure probes are not shorted */
          Counter = 100;                /* skip test */
     c4e:	24 e6       	ldi	r18, 0x64	; 100
     c50:	2f 83       	std	Y+7, r18	; 0x07
     c52:	5e 82       	std	Y+6, r5	; 0x06
     c54:	4d 82       	std	Y+5, r4	; 0x05
     c56:	4b 2c       	mov	r4, r11
     c58:	59 2c       	mov	r5, r9
     c5a:	7b c1       	rjmp	.+758    	; 0xf52 <SelfAdjust+0x37c>

    /* repeat each measurement 5 times */
    while (Counter <= 5)
    {
      /* display test number */
      LCD_Clear();
     c5c:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
      LCD_Char('A');                    /* display: a */
     c60:	81 e4       	ldi	r24, 0x41	; 65
     c62:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
      LCD_Char('0' + Test);             /* display number */
     c66:	89 2d       	mov	r24, r9
     c68:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
      LCD_Space();
     c6c:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>

      /*
       *  tests
       */

      switch (Test)
     c70:	3c 85       	ldd	r19, Y+12	; 0x0c
     c72:	33 30       	cpi	r19, 0x03	; 3
     c74:	09 f4       	brne	.+2      	; 0xc78 <SelfAdjust+0xa2>
     c76:	4f c0       	rjmp	.+158    	; 0xd16 <SelfAdjust+0x140>
     c78:	30 f4       	brcc	.+12     	; 0xc86 <SelfAdjust+0xb0>
     c7a:	31 30       	cpi	r19, 0x01	; 1
     c7c:	61 f0       	breq	.+24     	; 0xc96 <SelfAdjust+0xc0>
     c7e:	32 30       	cpi	r19, 0x02	; 2
     c80:	09 f4       	brne	.+2      	; 0xc84 <SelfAdjust+0xae>
     c82:	42 c0       	rjmp	.+132    	; 0xd08 <SelfAdjust+0x132>
     c84:	1b c1       	rjmp	.+566    	; 0xebc <SelfAdjust+0x2e6>
     c86:	8c 85       	ldd	r24, Y+12	; 0x0c
     c88:	84 30       	cpi	r24, 0x04	; 4
     c8a:	09 f4       	brne	.+2      	; 0xc8e <SelfAdjust+0xb8>
     c8c:	71 c0       	rjmp	.+226    	; 0xd70 <SelfAdjust+0x19a>
     c8e:	85 30       	cpi	r24, 0x05	; 5
     c90:	09 f4       	brne	.+2      	; 0xc94 <SelfAdjust+0xbe>
     c92:	aa c0       	rjmp	.+340    	; 0xde8 <SelfAdjust+0x212>
     c94:	13 c1       	rjmp	.+550    	; 0xebc <SelfAdjust+0x2e6>
      {
        case 1:     /* resistance of probe leads (probes shorted) */
          LCD_EEString_Space(ROffset_str);   /* display: R0 */
     c96:	8a e5       	ldi	r24, 0x5A	; 90
     c98:	91 e0       	ldi	r25, 0x01	; 1
     c9a:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>
          LCD_EEString(ProbeComb_str);       /* display: 12 13 23 */          
     c9e:	80 e6       	ldi	r24, 0x60	; 96
     ca0:	91 e0       	ldi	r25, 0x01	; 1
     ca2:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
          /*
           *  The resistance is for two probes in series and we expect it to be
           *  smaller than 1.00 Ohms, i.e. 0.50 Ohms for a single probe
           */

          UpdateProbes(TP2, TP1, 0);
     ca6:	40 e0       	ldi	r20, 0x00	; 0
     ca8:	60 e0       	ldi	r22, 0x00	; 0
     caa:	81 2f       	mov	r24, r17
     cac:	0e 94 04 23 	call	0x4608	; 0x4608 <UpdateProbes>
          Val1 = SmallResistor(0);
     cb0:	80 e0       	ldi	r24, 0x00	; 0
     cb2:	0e 94 92 25 	call	0x4b24	; 0x4b24 <SmallResistor>
     cb6:	3c 01       	movw	r6, r24
          if (Val1 < 100)                    /* within limit */
     cb8:	94 e6       	ldi	r25, 0x64	; 100
     cba:	69 16       	cp	r6, r25
     cbc:	71 04       	cpc	r7, r1
     cbe:	18 f4       	brcc	.+6      	; 0xcc6 <SelfAdjust+0xf0>
          {
            RSum += Val1;
     cc0:	26 0c       	add	r2, r6
     cc2:	37 1c       	adc	r3, r7
            RCounter++;
     cc4:	43 94       	inc	r4
          }

          UpdateProbes(TP3, TP1, 0);
     cc6:	40 e0       	ldi	r20, 0x00	; 0
     cc8:	60 e0       	ldi	r22, 0x00	; 0
     cca:	85 2d       	mov	r24, r5
     ccc:	0e 94 04 23 	call	0x4608	; 0x4608 <UpdateProbes>
          Val2 = SmallResistor(0);
     cd0:	80 e0       	ldi	r24, 0x00	; 0
     cd2:	0e 94 92 25 	call	0x4b24	; 0x4b24 <SmallResistor>
     cd6:	7c 01       	movw	r14, r24
          if (Val2 < 100)                    /* whithin limit */
     cd8:	84 36       	cpi	r24, 0x64	; 100
     cda:	91 05       	cpc	r25, r1
     cdc:	18 f4       	brcc	.+6      	; 0xce4 <SelfAdjust+0x10e>
          {
            RSum += Val2;
     cde:	28 0e       	add	r2, r24
     ce0:	39 1e       	adc	r3, r25
            RCounter++;
     ce2:	43 94       	inc	r4
          }

          UpdateProbes(TP3, TP2, 0);
     ce4:	40 e0       	ldi	r20, 0x00	; 0
     ce6:	61 2f       	mov	r22, r17
     ce8:	85 2d       	mov	r24, r5
     cea:	0e 94 04 23 	call	0x4608	; 0x4608 <UpdateProbes>
          Val3 = SmallResistor(0);
     cee:	80 e0       	ldi	r24, 0x00	; 0
     cf0:	0e 94 92 25 	call	0x4b24	; 0x4b24 <SmallResistor>
     cf4:	6c 01       	movw	r12, r24
          if (Val3 < 100)                    /* within limit */
     cf6:	84 36       	cpi	r24, 0x64	; 100
     cf8:	91 05       	cpc	r25, r1
     cfa:	08 f0       	brcs	.+2      	; 0xcfe <SelfAdjust+0x128>
     cfc:	e1 c0       	rjmp	.+450    	; 0xec0 <SelfAdjust+0x2ea>
          {
            RSum += Val3;
     cfe:	28 0e       	add	r2, r24
     d00:	39 1e       	adc	r3, r25
            RCounter++;
     d02:	43 94       	inc	r4
      LCD_Clear();
      LCD_Char('A');                    /* display: a */
      LCD_Char('0' + Test);             /* display number */
      LCD_Space();

      DisplayFlag = 1;        /* display values by default */
     d04:	81 2f       	mov	r24, r17
     d06:	e1 c0       	rjmp	.+450    	; 0xeca <SelfAdjust+0x2f4>
          }

          break;

        case 2:     /* un-short probes */
          ShortCircuit(0);              /* make sure probes are not shorted */
     d08:	80 e0       	ldi	r24, 0x00	; 0
     d0a:	0e 94 d0 33 	call	0x67a0	; 0x67a0 <ShortCircuit>
          Counter = 100;                /* skip test */
          DisplayFlag = 0;              /* reset display flag */
     d0e:	80 e0       	ldi	r24, 0x00	; 0

          break;

        case 2:     /* un-short probes */
          ShortCircuit(0);              /* make sure probes are not shorted */
          Counter = 100;                /* skip test */
     d10:	2f 81       	ldd	r18, Y+7	; 0x07
     d12:	2b 87       	std	Y+11, r18	; 0x0b
          DisplayFlag = 0;              /* reset display flag */
          break;
     d14:	da c0       	rjmp	.+436    	; 0xeca <SelfAdjust+0x2f4>

        case 3:     /* internal resistance of MCU in pull-down mode */
          LCD_EEString(RiLow_str);      /* display: Ri- */
     d16:	87 e7       	ldi	r24, 0x77	; 119
     d18:	91 e0       	ldi	r25, 0x01	; 1
     d1a:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>

          /* TP1:  Gnd -- Ri -- probe -- Rl -- Ri -- Vcc */
          ADC_PORT = 0;
     d1e:	18 b8       	out	0x08, r1	; 8
          ADC_DDR = 1 << TP1;
     d20:	07 b9       	out	0x07, r16	; 7
          R_PORT = 1 << (TP1 * 2);
     d22:	05 b9       	out	0x05, r16	; 5
          R_DDR = 1 << (TP1 * 2);
     d24:	04 b9       	out	0x04, r16	; 4
          Val1 = ReadU_5ms(TP1);
     d26:	80 e0       	ldi	r24, 0x00	; 0
     d28:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
     d2c:	3c 01       	movw	r6, r24
          U_RiL += Val1;

          /* TP2: Gnd -- Ri -- probe -- Rl -- Ri -- Vcc */
          ADC_DDR = 1 << TP2;
     d2e:	32 e0       	ldi	r19, 0x02	; 2
     d30:	37 b9       	out	0x07, r19	; 7
          R_PORT =  1 << (TP2 * 2);
     d32:	85 b8       	out	0x05, r8	; 5
          R_DDR = 1 << (TP2 * 2);
     d34:	84 b8       	out	0x04, r8	; 4
          Val2 = ReadU_5ms(TP2);
     d36:	81 2f       	mov	r24, r17
     d38:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
     d3c:	7c 01       	movw	r14, r24
     d3e:	53 01       	movw	r10, r6
     d40:	a8 0e       	add	r10, r24
     d42:	b9 1e       	adc	r11, r25
          U_RiL += Val2;
     d44:	8b 81       	ldd	r24, Y+3	; 0x03
     d46:	9c 81       	ldd	r25, Y+4	; 0x04
     d48:	a8 0e       	add	r10, r24
     d4a:	b9 1e       	adc	r11, r25

          /* TP3: Gnd -- Ri -- probe -- Rl -- Ri -- Vcc */
          ADC_DDR = 1 << TP3;
     d4c:	87 b8       	out	0x07, r8	; 7
          R_PORT =  1 << (TP3 * 2);
     d4e:	90 e1       	ldi	r25, 0x10	; 16
     d50:	95 b9       	out	0x05, r25	; 5
          R_DDR = 1 << (TP3 * 2);
     d52:	94 b9       	out	0x04, r25	; 4
          Val3 = ReadU_5ms(TP3);
     d54:	85 2d       	mov	r24, r5
     d56:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
     d5a:	6c 01       	movw	r12, r24
          U_RiL += Val3;
     d5c:	f5 01       	movw	r30, r10
     d5e:	e8 0f       	add	r30, r24
     d60:	f9 1f       	adc	r31, r25
     d62:	fc 83       	std	Y+4, r31	; 0x04
     d64:	eb 83       	std	Y+3, r30	; 0x03

          RiL_Counter += 3;
     d66:	f9 81       	ldd	r31, Y+1	; 0x01
     d68:	fd 5f       	subi	r31, 0xFD	; 253
     d6a:	f9 83       	std	Y+1, r31	; 0x01
      LCD_Clear();
      LCD_Char('A');                    /* display: a */
      LCD_Char('0' + Test);             /* display number */
      LCD_Space();

      DisplayFlag = 1;        /* display values by default */
     d6c:	81 2f       	mov	r24, r17
          R_DDR = 1 << (TP3 * 2);
          Val3 = ReadU_5ms(TP3);
          U_RiL += Val3;

          RiL_Counter += 3;
          break;
     d6e:	ad c0       	rjmp	.+346    	; 0xeca <SelfAdjust+0x2f4>

        case 4:     /* internal resistance of MCU in pull-up mode */
          LCD_EEString(RiHigh_str);     /* display: Ri+ */
     d70:	83 e7       	ldi	r24, 0x73	; 115
     d72:	91 e0       	ldi	r25, 0x01	; 1
     d74:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>

          /* TP1: Gnd -- Ri -- Rl -- probe -- Ri -- Vcc */
          R_PORT = 0;
     d78:	15 b8       	out	0x05, r1	; 5
          ADC_PORT = 1 << TP1;
     d7a:	08 b9       	out	0x08, r16	; 8
          ADC_DDR = 1 << TP1;
     d7c:	07 b9       	out	0x07, r16	; 7
          R_DDR = 1 << (TP1 * 2);
     d7e:	04 b9       	out	0x04, r16	; 4
          Val1 = Config.Vcc - ReadU_5ms(TP1);
     d80:	60 90 b1 01 	lds	r6, 0x01B1
     d84:	70 90 b2 01 	lds	r7, 0x01B2
     d88:	80 e0       	ldi	r24, 0x00	; 0
     d8a:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
     d8e:	68 1a       	sub	r6, r24
     d90:	79 0a       	sbc	r7, r25
          U_RiH += Val1;

          /* TP2: Gnd -- Ri -- Rl -- probe -- Ri -- Vcc */
          ADC_PORT = 1 << TP2;
     d92:	22 e0       	ldi	r18, 0x02	; 2
     d94:	28 b9       	out	0x08, r18	; 8
          ADC_DDR = 1 << TP2;
     d96:	27 b9       	out	0x07, r18	; 7
          R_DDR = 1 << (TP2 * 2);
     d98:	84 b8       	out	0x04, r8	; 4
          Val2 = Config.Vcc - ReadU_5ms(TP2);
     d9a:	e0 90 b1 01 	lds	r14, 0x01B1
     d9e:	f0 90 b2 01 	lds	r15, 0x01B2
     da2:	81 2f       	mov	r24, r17
     da4:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
     da8:	e8 1a       	sub	r14, r24
     daa:	f9 0a       	sbc	r15, r25
     dac:	53 01       	movw	r10, r6
     dae:	ae 0c       	add	r10, r14
     db0:	bf 1c       	adc	r11, r15
          U_RiH += Val2;
     db2:	8d 81       	ldd	r24, Y+5	; 0x05
     db4:	9e 81       	ldd	r25, Y+6	; 0x06
     db6:	a8 0e       	add	r10, r24
     db8:	b9 1e       	adc	r11, r25

          /* TP3: Gnd -- Ri -- Rl -- probe -- Ri -- Vcc */
          ADC_PORT = 1 << TP3;
     dba:	88 b8       	out	0x08, r8	; 8
          ADC_DDR = 1 << TP3;
     dbc:	87 b8       	out	0x07, r8	; 7
          R_DDR = 1 << (TP3 * 2);
     dbe:	90 e1       	ldi	r25, 0x10	; 16
     dc0:	94 b9       	out	0x04, r25	; 4
          Val3 = Config.Vcc - ReadU_5ms(TP3);
     dc2:	c0 90 b1 01 	lds	r12, 0x01B1
     dc6:	d0 90 b2 01 	lds	r13, 0x01B2
     dca:	85 2d       	mov	r24, r5
     dcc:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
     dd0:	c8 1a       	sub	r12, r24
     dd2:	d9 0a       	sbc	r13, r25
          U_RiH += Val3;
     dd4:	f5 01       	movw	r30, r10
     dd6:	ec 0d       	add	r30, r12
     dd8:	fd 1d       	adc	r31, r13
     dda:	fe 83       	std	Y+6, r31	; 0x06
     ddc:	ed 83       	std	Y+5, r30	; 0x05

          RiH_Counter += 3;
     dde:	fa 81       	ldd	r31, Y+2	; 0x02
     de0:	fd 5f       	subi	r31, 0xFD	; 253
     de2:	fa 83       	std	Y+2, r31	; 0x02
      LCD_Clear();
      LCD_Char('A');                    /* display: a */
      LCD_Char('0' + Test);             /* display number */
      LCD_Space();

      DisplayFlag = 1;        /* display values by default */
     de4:	81 2f       	mov	r24, r17
          R_DDR = 1 << (TP3 * 2);
          Val3 = Config.Vcc - ReadU_5ms(TP3);
          U_RiH += Val3;

          RiH_Counter += 3;
          break;
     de6:	71 c0       	rjmp	.+226    	; 0xeca <SelfAdjust+0x2f4>

        case 5:     /* capacitance offset (PCB and probe leads) */
          LCD_EEString_Space(CapOffset_str);   /* display: C0 */
     de8:	8d e5       	ldi	r24, 0x5D	; 93
     dea:	91 e0       	ldi	r25, 0x01	; 1
     dec:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>
          LCD_EEString(ProbeComb_str);         /* display: 12 13 23 */
     df0:	80 e6       	ldi	r24, 0x60	; 96
     df2:	91 e0       	ldi	r25, 0x01	; 1
     df4:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
          /*
           *  The capacitance is for two probes and we expect it to be
           *  less than 100pF.
           */

          MeasureCap(TP2, TP1, 0);
     df8:	40 e0       	ldi	r20, 0x00	; 0
     dfa:	60 e0       	ldi	r22, 0x00	; 0
     dfc:	81 2f       	mov	r24, r17
     dfe:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <MeasureCap>
          Val1 = (uint16_t)Caps[0].Raw;
     e02:	80 91 42 01 	lds	r24, 0x0142
     e06:	90 91 43 01 	lds	r25, 0x0143
     e0a:	a0 91 44 01 	lds	r26, 0x0144
     e0e:	b0 91 45 01 	lds	r27, 0x0145
     e12:	3c 01       	movw	r6, r24
          /* limit offset to 100pF */
          if ((Caps[0].Scale == -12) && (Caps[0].Raw <= 100))
     e14:	20 91 3d 01 	lds	r18, 0x013D
     e18:	24 3f       	cpi	r18, 0xF4	; 244
     e1a:	71 f4       	brne	.+28     	; 0xe38 <SelfAdjust+0x262>
     e1c:	85 36       	cpi	r24, 0x65	; 101
     e1e:	91 05       	cpc	r25, r1
     e20:	a1 05       	cpc	r26, r1
     e22:	b1 05       	cpc	r27, r1
     e24:	48 f4       	brcc	.+18     	; 0xe38 <SelfAdjust+0x262>
          {
            CapSum += Val1;
     e26:	29 85       	ldd	r18, Y+9	; 0x09
     e28:	3a 85       	ldd	r19, Y+10	; 0x0a
     e2a:	28 0f       	add	r18, r24
     e2c:	39 1f       	adc	r19, r25
     e2e:	3a 87       	std	Y+10, r19	; 0x0a
     e30:	29 87       	std	Y+9, r18	; 0x09
            CapCounter++;            
     e32:	38 85       	ldd	r19, Y+8	; 0x08
     e34:	3f 5f       	subi	r19, 0xFF	; 255
     e36:	38 87       	std	Y+8, r19	; 0x08
          }

          MeasureCap(TP3, TP1, 1);
     e38:	41 2f       	mov	r20, r17
     e3a:	60 e0       	ldi	r22, 0x00	; 0
     e3c:	85 2d       	mov	r24, r5
     e3e:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <MeasureCap>
          Val2 = (uint16_t)Caps[1].Raw;
     e42:	80 91 4d 01 	lds	r24, 0x014D
     e46:	90 91 4e 01 	lds	r25, 0x014E
     e4a:	a0 91 4f 01 	lds	r26, 0x014F
     e4e:	b0 91 50 01 	lds	r27, 0x0150
     e52:	7c 01       	movw	r14, r24
          /* limit offset to 100pF */
          if ((Caps[1].Scale == -12) && (Caps[1].Raw <= 100))
     e54:	20 91 48 01 	lds	r18, 0x0148
     e58:	24 3f       	cpi	r18, 0xF4	; 244
     e5a:	71 f4       	brne	.+28     	; 0xe78 <SelfAdjust+0x2a2>
     e5c:	85 36       	cpi	r24, 0x65	; 101
     e5e:	91 05       	cpc	r25, r1
     e60:	a1 05       	cpc	r26, r1
     e62:	b1 05       	cpc	r27, r1
     e64:	48 f4       	brcc	.+18     	; 0xe78 <SelfAdjust+0x2a2>
          {
            CapSum += Val2;
     e66:	e9 85       	ldd	r30, Y+9	; 0x09
     e68:	fa 85       	ldd	r31, Y+10	; 0x0a
     e6a:	e8 0f       	add	r30, r24
     e6c:	f9 1f       	adc	r31, r25
     e6e:	fa 87       	std	Y+10, r31	; 0x0a
     e70:	e9 87       	std	Y+9, r30	; 0x09
            CapCounter++;            
     e72:	f8 85       	ldd	r31, Y+8	; 0x08
     e74:	ff 5f       	subi	r31, 0xFF	; 255
     e76:	f8 87       	std	Y+8, r31	; 0x08
          }

          MeasureCap(TP3, TP2, 2);
     e78:	45 2d       	mov	r20, r5
     e7a:	61 2f       	mov	r22, r17
     e7c:	85 2d       	mov	r24, r5
     e7e:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <MeasureCap>
          Val3 = (uint16_t)Caps[2].Raw;
     e82:	80 91 58 01 	lds	r24, 0x0158
     e86:	90 91 59 01 	lds	r25, 0x0159
     e8a:	a0 91 5a 01 	lds	r26, 0x015A
     e8e:	b0 91 5b 01 	lds	r27, 0x015B
     e92:	6c 01       	movw	r12, r24
          /* limit offset to 100pF */
          if ((Caps[2].Scale == -12) && (Caps[2].Raw <= 100))
     e94:	20 91 53 01 	lds	r18, 0x0153
     e98:	24 3f       	cpi	r18, 0xF4	; 244
     e9a:	a1 f4       	brne	.+40     	; 0xec4 <SelfAdjust+0x2ee>
     e9c:	85 36       	cpi	r24, 0x65	; 101
     e9e:	91 05       	cpc	r25, r1
     ea0:	a1 05       	cpc	r26, r1
     ea2:	b1 05       	cpc	r27, r1
     ea4:	88 f4       	brcc	.+34     	; 0xec8 <SelfAdjust+0x2f2>
          {
            CapSum += Val3;
     ea6:	29 85       	ldd	r18, Y+9	; 0x09
     ea8:	3a 85       	ldd	r19, Y+10	; 0x0a
     eaa:	28 0f       	add	r18, r24
     eac:	39 1f       	adc	r19, r25
     eae:	3a 87       	std	Y+10, r19	; 0x0a
     eb0:	29 87       	std	Y+9, r18	; 0x09
            CapCounter++;            
     eb2:	38 85       	ldd	r19, Y+8	; 0x08
     eb4:	3f 5f       	subi	r19, 0xFF	; 255
     eb6:	38 87       	std	Y+8, r19	; 0x08
      LCD_Clear();
      LCD_Char('A');                    /* display: a */
      LCD_Char('0' + Test);             /* display number */
      LCD_Space();

      DisplayFlag = 1;        /* display values by default */
     eb8:	81 2f       	mov	r24, r17
     eba:	07 c0       	rjmp	.+14     	; 0xeca <SelfAdjust+0x2f4>
     ebc:	81 2f       	mov	r24, r17
     ebe:	05 c0       	rjmp	.+10     	; 0xeca <SelfAdjust+0x2f4>
     ec0:	81 2f       	mov	r24, r17
     ec2:	03 c0       	rjmp	.+6      	; 0xeca <SelfAdjust+0x2f4>
     ec4:	81 2f       	mov	r24, r17
     ec6:	01 c0       	rjmp	.+2      	; 0xeca <SelfAdjust+0x2f4>
     ec8:	81 2f       	mov	r24, r17

          break;
      }

      /* reset ports to defaults */
      ADC_DDR = 0;                      /* input mode */
     eca:	17 b8       	out	0x07, r1	; 7
      ADC_PORT = 0;                     /* all pins low */
     ecc:	18 b8       	out	0x08, r1	; 8
      R_DDR = 0;                        /* input mode */
     ece:	14 b8       	out	0x04, r1	; 4
      R_PORT = 0;                       /* all pins low */
     ed0:	15 b8       	out	0x05, r1	; 5

      /* display values */
      if (DisplayFlag)
     ed2:	88 23       	and	r24, r24
     ed4:	09 f1       	breq	.+66     	; 0xf18 <SelfAdjust+0x342>
      {
        LCD_NextLine();                 /* move to line #2 */
     ed6:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <LCD_NextLine>
        DisplayValue(Val1, 0 , 0);      /* display TP1 */
     eda:	c3 01       	movw	r24, r6
     edc:	a0 e0       	ldi	r26, 0x00	; 0
     ede:	b0 e0       	ldi	r27, 0x00	; 0
     ee0:	20 e0       	ldi	r18, 0x00	; 0
     ee2:	40 e0       	ldi	r20, 0x00	; 0
     ee4:	bc 01       	movw	r22, r24
     ee6:	cd 01       	movw	r24, r26
     ee8:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
        LCD_Space();
     eec:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
        DisplayValue(Val2, 0 , 0);      /* display TP2 */
     ef0:	c7 01       	movw	r24, r14
     ef2:	a0 e0       	ldi	r26, 0x00	; 0
     ef4:	b0 e0       	ldi	r27, 0x00	; 0
     ef6:	20 e0       	ldi	r18, 0x00	; 0
     ef8:	40 e0       	ldi	r20, 0x00	; 0
     efa:	bc 01       	movw	r22, r24
     efc:	cd 01       	movw	r24, r26
     efe:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
        LCD_Space();
     f02:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
        DisplayValue(Val3, 0 , 0);      /* display TP3 */
     f06:	c6 01       	movw	r24, r12
     f08:	a0 e0       	ldi	r26, 0x00	; 0
     f0a:	b0 e0       	ldi	r27, 0x00	; 0
     f0c:	20 e0       	ldi	r18, 0x00	; 0
     f0e:	40 e0       	ldi	r20, 0x00	; 0
     f10:	bc 01       	movw	r22, r24
     f12:	cd 01       	movw	r24, r26
     f14:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
      }

      /* wait and check test push button */
      if (Counter < 100)                     /* when we don't skip this test */
     f18:	8b 85       	ldd	r24, Y+11	; 0x0b
     f1a:	84 36       	cpi	r24, 0x64	; 100
     f1c:	78 f4       	brcc	.+30     	; 0xf3c <SelfAdjust+0x366>
      {
        DisplayFlag = TestKey(1000, 0);      /* catch key press or timeout */
     f1e:	60 e0       	ldi	r22, 0x00	; 0
     f20:	88 ee       	ldi	r24, 0xE8	; 232
     f22:	93 e0       	ldi	r25, 0x03	; 3
     f24:	0e 94 58 33 	call	0x66b0	; 0x66b0 <TestKey>

        /* short press -> next test / long press -> end selftest */
        if (DisplayFlag > 0)
     f28:	88 23       	and	r24, r24
     f2a:	41 f0       	breq	.+16     	; 0xf3c <SelfAdjust+0x366>
     f2c:	ac 84       	ldd	r10, Y+12	; 0x0c
        {
          Counter = 100;                       /* skip current test anyway */
          if (DisplayFlag == 2) Test = 100;    /* also skip selftest */
     f2e:	82 30       	cpi	r24, 0x02	; 2
     f30:	61 f4       	brne	.+24     	; 0xf4a <SelfAdjust+0x374>
     f32:	0f 2e       	mov	r0, r31
     f34:	f4 e6       	ldi	r31, 0x64	; 100
     f36:	af 2e       	mov	r10, r31
     f38:	f0 2d       	mov	r31, r0
     f3a:	07 c0       	rjmp	.+14     	; 0xf4a <SelfAdjust+0x374>
        } 
      }
 
      Counter++;                        /* next run */
     f3c:	9b 85       	ldd	r25, Y+11	; 0x0b
     f3e:	9f 5f       	subi	r25, 0xFF	; 255
     f40:	9b 87       	std	Y+11, r25	; 0x0b
  while (Test <= 5)      /* loop through tests */
  {
    Counter = 1;

    /* repeat each measurement 5 times */
    while (Counter <= 5)
     f42:	96 30       	cpi	r25, 0x06	; 6
     f44:	08 f4       	brcc	.+2      	; 0xf48 <SelfAdjust+0x372>
     f46:	8a ce       	rjmp	.-748    	; 0xc5c <SelfAdjust+0x86>
     f48:	ac 84       	ldd	r10, Y+12	; 0x0c
      }
 
      Counter++;                        /* next run */
    }

    Test++;                             /* next one */
     f4a:	a3 94       	inc	r10

  /* make sure all probes are shorted */
  Counter = ShortCircuit(1);
  if (Counter == 0) Test = 10;     /* skip adjustment on error */

  while (Test <= 5)      /* loop through tests */
     f4c:	e5 e0       	ldi	r30, 0x05	; 5
     f4e:	ea 15       	cp	r30, r10
     f50:	40 f0       	brcs	.+16     	; 0xf62 <SelfAdjust+0x38c>
    while (Counter <= 5)
    {
      /* display test number */
      LCD_Clear();
      LCD_Char('A');                    /* display: a */
      LCD_Char('0' + Test);             /* display number */
     f52:	0f 2e       	mov	r0, r31
     f54:	f0 e3       	ldi	r31, 0x30	; 48
     f56:	9f 2e       	mov	r9, r31
     f58:	f0 2d       	mov	r31, r0
     f5a:	9a 0c       	add	r9, r10
     f5c:	ac 86       	std	Y+12, r10	; 0x0c
     f5e:	0b 87       	std	Y+11, r16	; 0x0b
     f60:	7d ce       	rjmp	.-774    	; 0xc5c <SelfAdjust+0x86>
     f62:	b4 2c       	mov	r11, r4
     f64:	4d 80       	ldd	r4, Y+5	; 0x05
     f66:	5e 80       	ldd	r5, Y+6	; 0x06
  /*
   *  calculate values and offsets
   */

  /* capacitance auto-zero: calculate average value for all probe pairs */
  if (CapCounter == 15)
     f68:	f8 85       	ldd	r31, Y+8	; 0x08
     f6a:	ff 30       	cpi	r31, 0x0F	; 15
     f6c:	e1 f4       	brne	.+56     	; 0xfa6 <SelfAdjust+0x3d0>
  {
    /* calculate average offset (pF) */
    NV.CapZero = CapSum / CapCounter;
     f6e:	29 85       	ldd	r18, Y+9	; 0x09
     f70:	3a 85       	ldd	r19, Y+10	; 0x0a
     f72:	a9 e8       	ldi	r26, 0x89	; 137
     f74:	b8 e8       	ldi	r27, 0x88	; 136
     f76:	0e 94 cd 36 	call	0x6d9a	; 0x6d9a <__umulhisi3>
     f7a:	96 95       	lsr	r25
     f7c:	87 95       	ror	r24
     f7e:	96 95       	lsr	r25
     f80:	87 95       	ror	r24
     f82:	96 95       	lsr	r25
     f84:	87 95       	ror	r24
     f86:	80 93 a1 01 	sts	0x01A1, r24
    Flag++;
     f8a:	aa 24       	eor	r10, r10
     f8c:	a3 94       	inc	r10
     f8e:	0c c0       	rjmp	.+24     	; 0xfa8 <SelfAdjust+0x3d2>
     f90:	41 2c       	mov	r4, r1
     f92:	51 2c       	mov	r5, r1
     f94:	1a 82       	std	Y+2, r1	; 0x02
     f96:	1c 82       	std	Y+4, r1	; 0x04
     f98:	1b 82       	std	Y+3, r1	; 0x03
     f9a:	19 82       	std	Y+1, r1	; 0x01
     f9c:	21 2c       	mov	r2, r1
     f9e:	31 2c       	mov	r3, r1
     fa0:	b1 2c       	mov	r11, r1
 *  - 1 on success
 */

uint8_t SelfAdjust(void)
{
  uint8_t           Flag = 0;           /* return value */
     fa2:	a1 2c       	mov	r10, r1
     fa4:	01 c0       	rjmp	.+2      	; 0xfa8 <SelfAdjust+0x3d2>
     fa6:	a1 2c       	mov	r10, r1
    NV.CapZero = CapSum / CapCounter;
    Flag++;
  }

  /* resistance auto-zero: calculate average value for all probes pairs */
  if (RCounter == 15)
     fa8:	2f e0       	ldi	r18, 0x0F	; 15
     faa:	b2 12       	cpse	r11, r18
     fac:	10 c0       	rjmp	.+32     	; 0xfce <SelfAdjust+0x3f8>
  { 
    /* calculate average offset (0.01 Ohms) */
    NV.RZero = RSum / RCounter;
     fae:	91 01       	movw	r18, r2
     fb0:	a9 e8       	ldi	r26, 0x89	; 137
     fb2:	b8 e8       	ldi	r27, 0x88	; 136
     fb4:	0e 94 cd 36 	call	0x6d9a	; 0x6d9a <__umulhisi3>
     fb8:	96 95       	lsr	r25
     fba:	87 95       	ror	r24
     fbc:	96 95       	lsr	r25
     fbe:	87 95       	ror	r24
     fc0:	96 95       	lsr	r25
     fc2:	87 95       	ror	r24
     fc4:	90 93 a0 01 	sts	0x01A0, r25
     fc8:	80 93 9f 01 	sts	0x019F, r24
    Flag++;
     fcc:	a3 94       	inc	r10
  }

  /* RiL & RiH */
  if ((RiL_Counter == 15) && (RiH_Counter == 15))
     fce:	39 81       	ldd	r19, Y+1	; 0x01
     fd0:	3f 30       	cpi	r19, 0x0F	; 15
     fd2:	09 f0       	breq	.+2      	; 0xfd6 <SelfAdjust+0x400>
     fd4:	69 c0       	rjmp	.+210    	; 0x10a8 <SelfAdjust+0x4d2>
     fd6:	8a 81       	ldd	r24, Y+2	; 0x02
     fd8:	8f 30       	cpi	r24, 0x0F	; 15
     fda:	09 f0       	breq	.+2      	; 0xfde <SelfAdjust+0x408>
     fdc:	65 c0       	rjmp	.+202    	; 0x10a8 <SelfAdjust+0x4d2>
     *  Ri = Rl * (U_Ri / U_Rl)
     *  - scale up by 100, round up/down and scale down by 10
     */

    /* use values multiplied by 3 to increase accuracy */    
    U_RiL /= 5;                         /* average sum of 3 U_RiL */
     fde:	2b 81       	ldd	r18, Y+3	; 0x03
     fe0:	3c 81       	ldd	r19, Y+4	; 0x04
     fe2:	ad ec       	ldi	r26, 0xCD	; 205
     fe4:	bc ec       	ldi	r27, 0xCC	; 204
     fe6:	0e 94 cd 36 	call	0x6d9a	; 0x6d9a <__umulhisi3>
     fea:	ac 01       	movw	r20, r24
     fec:	56 95       	lsr	r21
     fee:	47 95       	ror	r20
     ff0:	56 95       	lsr	r21
     ff2:	47 95       	ror	r20
    U_RiH /= 5;                         /* average sum of 3 U_RiH */
     ff4:	92 01       	movw	r18, r4
     ff6:	0e 94 cd 36 	call	0x6d9a	; 0x6d9a <__umulhisi3>
     ffa:	8c 01       	movw	r16, r24
     ffc:	16 95       	lsr	r17
     ffe:	07 95       	ror	r16
    1000:	16 95       	lsr	r17
    1002:	07 95       	ror	r16
    Val1 = (Config.Vcc * 3) - U_RiL - U_RiH;  /* U_Rl * 3 */
    1004:	20 91 b1 01 	lds	r18, 0x01B1
    1008:	30 91 b2 01 	lds	r19, 0x01B2
    100c:	69 01       	movw	r12, r18
    100e:	cc 0c       	add	r12, r12
    1010:	dd 1c       	adc	r13, r13
    1012:	c2 0e       	add	r12, r18
    1014:	d3 1e       	adc	r13, r19
    1016:	c4 1a       	sub	r12, r20
    1018:	d5 0a       	sbc	r13, r21
    101a:	c0 1a       	sub	r12, r16
    101c:	d1 0a       	sbc	r13, r17

    /* RiL */
    Val0 = ((uint32_t)R_LOW * 100 * U_RiL) / Val1;     /* Rl * U_Ri / U_Rl in 0.01 Ohm */
    101e:	e1 2c       	mov	r14, r1
    1020:	f1 2c       	mov	r15, r1
    1022:	da 01       	movw	r26, r20
    1024:	20 ea       	ldi	r18, 0xA0	; 160
    1026:	39 e0       	ldi	r19, 0x09	; 9
    1028:	41 e0       	ldi	r20, 0x01	; 1
    102a:	50 e0       	ldi	r21, 0x00	; 0
    102c:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
    1030:	a7 01       	movw	r20, r14
    1032:	96 01       	movw	r18, r12
    1034:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    Val0 += 5;                                         /* for automagic rounding */
    1038:	ca 01       	movw	r24, r20
    103a:	b9 01       	movw	r22, r18
    103c:	6b 5f       	subi	r22, 0xFB	; 251
    103e:	7f 4f       	sbci	r23, 0xFF	; 255
    1040:	8f 4f       	sbci	r24, 0xFF	; 255
    1042:	9f 4f       	sbci	r25, 0xFF	; 255
    Val0 /= 10;                                        /* scale down to 0.1 Ohm */
    1044:	2a e0       	ldi	r18, 0x0A	; 10
    1046:	30 e0       	ldi	r19, 0x00	; 0
    1048:	40 e0       	ldi	r20, 0x00	; 0
    104a:	50 e0       	ldi	r21, 0x00	; 0
    104c:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    if (Val0 < 250UL)         /* < 25 Ohms */
    1050:	2a 3f       	cpi	r18, 0xFA	; 250
    1052:	31 05       	cpc	r19, r1
    1054:	41 05       	cpc	r20, r1
    1056:	51 05       	cpc	r21, r1
    1058:	28 f4       	brcc	.+10     	; 0x1064 <SelfAdjust+0x48e>
    {
      NV.RiL = (uint16_t)Val0;
    105a:	30 93 9c 01 	sts	0x019C, r19
    105e:	20 93 9b 01 	sts	0x019B, r18
      Flag++;
    1062:	a3 94       	inc	r10
    }

    /* RiH */
    Val0 = ((uint32_t)R_LOW * 100 * U_RiH) / Val1;     /* Rl * U_Ri / U_Rl in 0.01 Ohm */
    1064:	d8 01       	movw	r26, r16
    1066:	20 ea       	ldi	r18, 0xA0	; 160
    1068:	39 e0       	ldi	r19, 0x09	; 9
    106a:	41 e0       	ldi	r20, 0x01	; 1
    106c:	50 e0       	ldi	r21, 0x00	; 0
    106e:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
    1072:	a7 01       	movw	r20, r14
    1074:	96 01       	movw	r18, r12
    1076:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    Val0 += 5;                                         /* for automagic rounding */
    107a:	ca 01       	movw	r24, r20
    107c:	b9 01       	movw	r22, r18
    107e:	6b 5f       	subi	r22, 0xFB	; 251
    1080:	7f 4f       	sbci	r23, 0xFF	; 255
    1082:	8f 4f       	sbci	r24, 0xFF	; 255
    1084:	9f 4f       	sbci	r25, 0xFF	; 255
    Val0 /= 10;                                        /* scale down to 0.1 Ohm */
    1086:	2a e0       	ldi	r18, 0x0A	; 10
    1088:	30 e0       	ldi	r19, 0x00	; 0
    108a:	40 e0       	ldi	r20, 0x00	; 0
    108c:	50 e0       	ldi	r21, 0x00	; 0
    108e:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    if (Val0 < 280UL)         /* < 29 Ohms */
    1092:	28 31       	cpi	r18, 0x18	; 24
    1094:	91 e0       	ldi	r25, 0x01	; 1
    1096:	39 07       	cpc	r19, r25
    1098:	41 05       	cpc	r20, r1
    109a:	51 05       	cpc	r21, r1
    109c:	28 f4       	brcc	.+10     	; 0x10a8 <SelfAdjust+0x4d2>
    {
      NV.RiH = (uint16_t)Val0;
    109e:	30 93 9e 01 	sts	0x019E, r19
    10a2:	20 93 9d 01 	sts	0x019D, r18
      Flag++;
    10a6:	a3 94       	inc	r10
    }
  }

  /* show values and offsets */
  ShowAdjust();
    10a8:	0e 94 7f 05 	call	0xafe	; 0xafe <ShowAdjust>

  if (Flag == 4) Flag = 1;         /* all adjustments done -> success */
    10ac:	81 e0       	ldi	r24, 0x01	; 1
    10ae:	e4 e0       	ldi	r30, 0x04	; 4
    10b0:	ae 12       	cpse	r10, r30
    10b2:	80 e0       	ldi	r24, 0x00	; 0
  else Flag = 0;                   /* signal error */

  return Flag;
}
    10b4:	2c 96       	adiw	r28, 0x0c	; 12
    10b6:	0f b6       	in	r0, 0x3f	; 63
    10b8:	f8 94       	cli
    10ba:	de bf       	out	0x3e, r29	; 62
    10bc:	0f be       	out	0x3f, r0	; 63
    10be:	cd bf       	out	0x3d, r28	; 61
    10c0:	df 91       	pop	r29
    10c2:	cf 91       	pop	r28
    10c4:	1f 91       	pop	r17
    10c6:	0f 91       	pop	r16
    10c8:	ff 90       	pop	r15
    10ca:	ef 90       	pop	r14
    10cc:	df 90       	pop	r13
    10ce:	cf 90       	pop	r12
    10d0:	bf 90       	pop	r11
    10d2:	af 90       	pop	r10
    10d4:	9f 90       	pop	r9
    10d6:	8f 90       	pop	r8
    10d8:	7f 90       	pop	r7
    10da:	6f 90       	pop	r6
    10dc:	5f 90       	pop	r5
    10de:	4f 90       	pop	r4
    10e0:	3f 90       	pop	r3
    10e2:	2f 90       	pop	r2
    10e4:	08 95       	ret

000010e6 <SelfTest>:
 *  - 0 on error
 *  - 1 on success
 */

uint8_t SelfTest(void)
{
    10e6:	2f 92       	push	r2
    10e8:	3f 92       	push	r3
    10ea:	4f 92       	push	r4
    10ec:	5f 92       	push	r5
    10ee:	6f 92       	push	r6
    10f0:	7f 92       	push	r7
    10f2:	8f 92       	push	r8
    10f4:	9f 92       	push	r9
    10f6:	af 92       	push	r10
    10f8:	bf 92       	push	r11
    10fa:	cf 92       	push	r12
    10fc:	df 92       	push	r13
    10fe:	ef 92       	push	r14
    1100:	ff 92       	push	r15
    1102:	0f 93       	push	r16
    1104:	1f 93       	push	r17
    1106:	cf 93       	push	r28
    1108:	df 93       	push	r29
    110a:	00 d0       	rcall	.+0      	; 0x110c <SelfTest+0x26>
    110c:	1f 92       	push	r1
    110e:	cd b7       	in	r28, 0x3d	; 61
    1110:	de b7       	in	r29, 0x3e	; 62
  uint8_t           DisplayFlag;        /* display flag */
  uint16_t          Val0;               /* voltage/value */
  int16_t           Val1 = 0, Val2 = 0, Val3 = 0;   /* voltages/values */

  /* make sure all probes are shorted */
  Counter = ShortCircuit(1);
    1112:	81 e0       	ldi	r24, 0x01	; 1
    1114:	0e 94 d0 33 	call	0x67a0	; 0x67a0 <ShortCircuit>
  if (Counter == 0) Test = 10;     /* skip selftest */
    1118:	88 23       	and	r24, r24
    111a:	09 f4       	brne	.+2      	; 0x111e <SelfTest+0x38>
    111c:	51 c1       	rjmp	.+674    	; 0x13c0 <SelfTest+0x2da>
    111e:	00 e0       	ldi	r16, 0x00	; 0
    1120:	10 e0       	ldi	r17, 0x00	; 0
    1122:	21 2c       	mov	r2, r1
    1124:	31 2c       	mov	r3, r1
    1126:	81 2c       	mov	r8, r1
    1128:	91 2c       	mov	r9, r1
    112a:	ff 24       	eor	r15, r15
    112c:	f3 94       	inc	r15
          LCD_EEString(ProbeComb_str);    /* display: 12 13 23 */

          /* set up a voltage divider with the Rh's */

          /* TP1: Gnd -- Rh -- probe-2 -- probe-1 -- Rh -- Vcc */
          R_PORT = 2 << (TP1 * 2);
    112e:	68 94       	set
    1130:	77 24       	eor	r7, r7
    1132:	71 f8       	bld	r7, 1
          R_DDR = (2 << (TP1 * 2)) | (2 << (TP2 * 2));
          Val1 = ReadU_20ms(TP3);
          Val1 -= (Config.Vcc / 2);
    1134:	0f 2e       	mov	r0, r31
    1136:	fb ea       	ldi	r31, 0xAB	; 171
    1138:	4f 2e       	mov	r4, r31
    113a:	f1 e0       	ldi	r31, 0x01	; 1
    113c:	5f 2e       	mov	r5, r31
    113e:	f0 2d       	mov	r31, r0
          R_DDR = (2 << (TP1 * 2)) | (2 << (TP3 * 2));
          Val2 = ReadU_20ms(TP2);
          Val2 -= (Config.Vcc / 2);

          /* TP1: Gnd -- Rh -- probe-3 -- probe-2 -- Rh -- Vcc */
          R_PORT = 2 << (TP2 * 2);
    1140:	68 94       	set
    1142:	66 24       	eor	r6, r6
    1144:	63 f8       	bld	r6, 3
          LCD_EEString(ProbeComb_str);    /* display: 12 13 23 */

          /* set up a voltage divider with the Rh's */

          /* TP1: Gnd -- Rh -- probe-2 -- probe-1 -- Rh -- Vcc */
          R_PORT = 2 << (TP1 * 2);
    1146:	b7 2c       	mov	r11, r7

          break;

        case 4:     /* un-short probes */
          ShortCircuit(0);         /* make sure probes are not shorted */
          Counter = 100;           /* skip test */
    1148:	84 e6       	ldi	r24, 0x64	; 100
    114a:	89 83       	std	Y+1, r24	; 0x01
    114c:	22 c1       	rjmp	.+580    	; 0x1392 <SelfTest+0x2ac>

    /* repeat each test 5 times */
    while (Counter <= 5)
    {
      /* display test number */
      LCD_Clear();
    114e:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
      LCD_Char('T');                    /* display: T */
    1152:	84 e5       	ldi	r24, 0x54	; 84
    1154:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
      LCD_Char('0' + Test);             /* display test number */
    1158:	8d 2d       	mov	r24, r13
    115a:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
      LCD_Space();
    115e:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>

      /*
       *  tests
       */

      switch (Test)
    1162:	ea 81       	ldd	r30, Y+2	; 0x02
    1164:	e3 30       	cpi	r30, 0x03	; 3
    1166:	09 f4       	brne	.+2      	; 0x116a <SelfTest+0x84>
    1168:	71 c0       	rjmp	.+226    	; 0x124c <SelfTest+0x166>
    116a:	28 f4       	brcc	.+10     	; 0x1176 <SelfTest+0x90>
    116c:	e1 30       	cpi	r30, 0x01	; 1
    116e:	69 f0       	breq	.+26     	; 0x118a <SelfTest+0xa4>
    1170:	e2 30       	cpi	r30, 0x02	; 2
    1172:	01 f1       	breq	.+64     	; 0x11b4 <SelfTest+0xce>
    1174:	ce c0       	rjmp	.+412    	; 0x1312 <SelfTest+0x22c>
    1176:	fa 81       	ldd	r31, Y+2	; 0x02
    1178:	f5 30       	cpi	r31, 0x05	; 5
    117a:	09 f4       	brne	.+2      	; 0x117e <SelfTest+0x98>
    117c:	9e c0       	rjmp	.+316    	; 0x12ba <SelfTest+0x1d4>
    117e:	08 f4       	brcc	.+2      	; 0x1182 <SelfTest+0x9c>
    1180:	96 c0       	rjmp	.+300    	; 0x12ae <SelfTest+0x1c8>
    1182:	f6 30       	cpi	r31, 0x06	; 6
    1184:	09 f4       	brne	.+2      	; 0x1188 <SelfTest+0xa2>
    1186:	ae c0       	rjmp	.+348    	; 0x12e4 <SelfTest+0x1fe>
    1188:	c4 c0       	rjmp	.+392    	; 0x1312 <SelfTest+0x22c>
      {
        case 1:     /* reference voltage */
          Val0 = ReadU(0x0e);           /* dummy read for bandgap stabilization */
    118a:	8e e0       	ldi	r24, 0x0E	; 14
    118c:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
          Val0 = ReadU(0x0e);           /* read bandgap reference voltage */ 
    1190:	8e e0       	ldi	r24, 0x0E	; 14
    1192:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    1196:	7c 01       	movw	r14, r24
          LCD_EEString(URef_str);       /* display: Vref */
    1198:	83 e8       	ldi	r24, 0x83	; 131
    119a:	91 e0       	ldi	r25, 0x01	; 1
    119c:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>

          LCD_NextLine();
    11a0:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <LCD_NextLine>
          DisplayValue(Val0, -3, 'V');       /* display voltage in mV */
    11a4:	b7 01       	movw	r22, r14
    11a6:	80 e0       	ldi	r24, 0x00	; 0
    11a8:	90 e0       	ldi	r25, 0x00	; 0
    11aa:	26 e5       	ldi	r18, 0x56	; 86
    11ac:	4d ef       	ldi	r20, 0xFD	; 253
    11ae:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>

          DisplayFlag = 0;                   /* reset flag */
          break;
    11b2:	00 c1       	rjmp	.+512    	; 0x13b4 <SelfTest+0x2ce>

        case 2:     /* compare Rl resistors (probes still shorted) */
          LCD_EEString_Space(Rl_str);     /* display: +Rl- */
    11b4:	8e e6       	ldi	r24, 0x6E	; 110
    11b6:	91 e0       	ldi	r25, 0x01	; 1
    11b8:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>
          LCD_EEString(ProbeComb_str);    /* display: 12 13 23 */
    11bc:	80 e6       	ldi	r24, 0x60	; 96
    11be:	91 e0       	ldi	r25, 0x01	; 1
    11c0:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>

          /* set up a voltage divider with the Rl's */
          /* substract theoretical voltage of voltage divider */

          /* TP1: Gnd -- Rl -- probe-2 -- probe-1 -- Rl -- Vcc */
          R_PORT = 1 << (TP1 * 2);
    11c4:	81 e0       	ldi	r24, 0x01	; 1
    11c6:	85 b9       	out	0x05, r24	; 5
          R_DDR = (1 << (TP1 * 2)) | (1 << (TP2 * 2));
    11c8:	85 e0       	ldi	r24, 0x05	; 5
    11ca:	84 b9       	out	0x04, r24	; 4
          Val1 = ReadU_20ms(TP3);
    11cc:	8b 2d       	mov	r24, r11
    11ce:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>
    11d2:	4c 01       	movw	r8, r24
          Val1 -= ((int32_t)Config.Vcc * (R_MCU_LOW + R_LOW)) / (R_MCU_LOW + R_LOW + R_LOW + R_MCU_HIGH);
    11d4:	f2 01       	movw	r30, r4
    11d6:	26 81       	ldd	r18, Z+6	; 0x06
    11d8:	37 81       	ldd	r19, Z+7	; 0x07
    11da:	a0 e7       	ldi	r26, 0x70	; 112
    11dc:	b3 e0       	ldi	r27, 0x03	; 3
    11de:	0e 94 cd 36 	call	0x6d9a	; 0x6d9a <__umulhisi3>
    11e2:	24 ef       	ldi	r18, 0xF4	; 244
    11e4:	36 e0       	ldi	r19, 0x06	; 6
    11e6:	40 e0       	ldi	r20, 0x00	; 0
    11e8:	50 e0       	ldi	r21, 0x00	; 0
    11ea:	0e 94 a8 36 	call	0x6d50	; 0x6d50 <__divmodsi4>
    11ee:	82 1a       	sub	r8, r18
    11f0:	93 0a       	sbc	r9, r19

          /* TP1: Gnd -- Rl -- probe-3 -- probe-1 -- Rl -- Vcc */
          R_DDR = (1 << (TP1 * 2)) | (1 << (TP3 * 2));
    11f2:	f1 e1       	ldi	r31, 0x11	; 17
    11f4:	f4 b9       	out	0x04, r31	; 4
          Val2 = ReadU_20ms(TP2);
    11f6:	81 e0       	ldi	r24, 0x01	; 1
    11f8:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>
    11fc:	1c 01       	movw	r2, r24
          Val2 -= ((int32_t)Config.Vcc * (R_MCU_LOW + R_LOW)) / (R_MCU_LOW + R_LOW + R_LOW + R_MCU_HIGH);
    11fe:	f2 01       	movw	r30, r4
    1200:	26 81       	ldd	r18, Z+6	; 0x06
    1202:	37 81       	ldd	r19, Z+7	; 0x07
    1204:	a0 e7       	ldi	r26, 0x70	; 112
    1206:	b3 e0       	ldi	r27, 0x03	; 3
    1208:	0e 94 cd 36 	call	0x6d9a	; 0x6d9a <__umulhisi3>
    120c:	24 ef       	ldi	r18, 0xF4	; 244
    120e:	36 e0       	ldi	r19, 0x06	; 6
    1210:	40 e0       	ldi	r20, 0x00	; 0
    1212:	50 e0       	ldi	r21, 0x00	; 0
    1214:	0e 94 a8 36 	call	0x6d50	; 0x6d50 <__divmodsi4>
    1218:	22 1a       	sub	r2, r18
    121a:	33 0a       	sbc	r3, r19

          /* TP1: Gnd -- Rl -- probe-3 -- probe-2 -- Rl -- Vcc */
          R_PORT = 1 << (TP2 * 2);
    121c:	f4 e0       	ldi	r31, 0x04	; 4
    121e:	f5 b9       	out	0x05, r31	; 5
          R_DDR = (1 << (TP2 * 2)) | (1 << (TP3 * 2));
    1220:	84 e1       	ldi	r24, 0x14	; 20
    1222:	84 b9       	out	0x04, r24	; 4
          Val3 = ReadU_20ms(TP2);
    1224:	81 e0       	ldi	r24, 0x01	; 1
    1226:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>
    122a:	8c 01       	movw	r16, r24
          Val3 -= ((int32_t)Config.Vcc * (R_MCU_LOW + R_LOW)) / (R_MCU_LOW + R_LOW + R_LOW + R_MCU_HIGH);
    122c:	f2 01       	movw	r30, r4
    122e:	26 81       	ldd	r18, Z+6	; 0x06
    1230:	37 81       	ldd	r19, Z+7	; 0x07
    1232:	a0 e7       	ldi	r26, 0x70	; 112
    1234:	b3 e0       	ldi	r27, 0x03	; 3
    1236:	0e 94 cd 36 	call	0x6d9a	; 0x6d9a <__umulhisi3>
    123a:	24 ef       	ldi	r18, 0xF4	; 244
    123c:	36 e0       	ldi	r19, 0x06	; 6
    123e:	40 e0       	ldi	r20, 0x00	; 0
    1240:	50 e0       	ldi	r21, 0x00	; 0
    1242:	0e 94 a8 36 	call	0x6d50	; 0x6d50 <__divmodsi4>
    1246:	02 1b       	sub	r16, r18
    1248:	13 0b       	sbc	r17, r19

          break;
    124a:	b7 c0       	rjmp	.+366    	; 0x13ba <SelfTest+0x2d4>

        case 3:     /* compare Rh resistors (probes still shorted) */
          LCD_EEString_Space(Rh_str);     /* display: +Rh- */
    124c:	89 e6       	ldi	r24, 0x69	; 105
    124e:	91 e0       	ldi	r25, 0x01	; 1
    1250:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>
          LCD_EEString(ProbeComb_str);    /* display: 12 13 23 */
    1254:	80 e6       	ldi	r24, 0x60	; 96
    1256:	91 e0       	ldi	r25, 0x01	; 1
    1258:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>

          /* set up a voltage divider with the Rh's */

          /* TP1: Gnd -- Rh -- probe-2 -- probe-1 -- Rh -- Vcc */
          R_PORT = 2 << (TP1 * 2);
    125c:	75 b8       	out	0x05, r7	; 5
          R_DDR = (2 << (TP1 * 2)) | (2 << (TP2 * 2));
    125e:	fa e0       	ldi	r31, 0x0A	; 10
    1260:	f4 b9       	out	0x04, r31	; 4
          Val1 = ReadU_20ms(TP3);
    1262:	8b 2d       	mov	r24, r11
    1264:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>
          Val1 -= (Config.Vcc / 2);
    1268:	f2 01       	movw	r30, r4
    126a:	26 81       	ldd	r18, Z+6	; 0x06
    126c:	37 81       	ldd	r19, Z+7	; 0x07
    126e:	36 95       	lsr	r19
    1270:	27 95       	ror	r18
    1272:	4c 01       	movw	r8, r24
    1274:	82 1a       	sub	r8, r18
    1276:	93 0a       	sbc	r9, r19

          /* TP1: Gnd -- Rh -- probe-3 -- probe-1 -- Rh -- Vcc */
          R_DDR = (2 << (TP1 * 2)) | (2 << (TP3 * 2));
    1278:	f2 e2       	ldi	r31, 0x22	; 34
    127a:	f4 b9       	out	0x04, r31	; 4
          Val2 = ReadU_20ms(TP2);
    127c:	81 e0       	ldi	r24, 0x01	; 1
    127e:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>
          Val2 -= (Config.Vcc / 2);
    1282:	f2 01       	movw	r30, r4
    1284:	26 81       	ldd	r18, Z+6	; 0x06
    1286:	37 81       	ldd	r19, Z+7	; 0x07
    1288:	36 95       	lsr	r19
    128a:	27 95       	ror	r18
    128c:	1c 01       	movw	r2, r24
    128e:	22 1a       	sub	r2, r18
    1290:	33 0a       	sbc	r3, r19

          /* TP1: Gnd -- Rh -- probe-3 -- probe-2 -- Rh -- Vcc */
          R_PORT = 2 << (TP2 * 2);
    1292:	65 b8       	out	0x05, r6	; 5
          R_DDR = (2 << (TP2 * 2)) | (2 << (TP3 * 2));
    1294:	a4 b8       	out	0x04, r10	; 4
          Val3 = ReadU_20ms(TP1);
    1296:	80 e0       	ldi	r24, 0x00	; 0
    1298:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>
          Val3 -= (Config.Vcc / 2);
    129c:	f2 01       	movw	r30, r4
    129e:	26 81       	ldd	r18, Z+6	; 0x06
    12a0:	37 81       	ldd	r19, Z+7	; 0x07
    12a2:	36 95       	lsr	r19
    12a4:	27 95       	ror	r18
    12a6:	8c 01       	movw	r16, r24
    12a8:	02 1b       	sub	r16, r18
    12aa:	13 0b       	sbc	r17, r19

          break;
    12ac:	86 c0       	rjmp	.+268    	; 0x13ba <SelfTest+0x2d4>

        case 4:     /* un-short probes */
          ShortCircuit(0);         /* make sure probes are not shorted */
    12ae:	80 e0       	ldi	r24, 0x00	; 0
    12b0:	0e 94 d0 33 	call	0x67a0	; 0x67a0 <ShortCircuit>
          Counter = 100;           /* skip test */
    12b4:	f9 81       	ldd	r31, Y+1	; 0x01
    12b6:	fb 83       	std	Y+3, r31	; 0x03
          DisplayFlag = 0;         /* reset flag */
          break;
    12b8:	7d c0       	rjmp	.+250    	; 0x13b4 <SelfTest+0x2ce>

        case 5:     /* Rh resistors pulled down */
          LCD_EEString(RhLow_str);      /* display: Rh- */
    12ba:	8f e7       	ldi	r24, 0x7F	; 127
    12bc:	91 e0       	ldi	r25, 0x01	; 1
    12be:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>

          /* TP1: Gnd -- Rh -- probe */
          R_PORT = 0;
    12c2:	15 b8       	out	0x05, r1	; 5
          R_DDR = 2 << (TP1 * 2);
    12c4:	74 b8       	out	0x04, r7	; 4
          Val1 = ReadU_20ms(TP1);
    12c6:	80 e0       	ldi	r24, 0x00	; 0
    12c8:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>
    12cc:	4c 01       	movw	r8, r24

          /* TP1: Gnd -- Rh -- probe */
          R_DDR = 2 << (TP2 * 2);
    12ce:	64 b8       	out	0x04, r6	; 4
          Val2 = ReadU_20ms(TP2);
    12d0:	81 e0       	ldi	r24, 0x01	; 1
    12d2:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>
    12d6:	1c 01       	movw	r2, r24

          /* TP1: Gnd -- Rh -- probe */
          R_DDR = 2 << (TP3 * 2);
    12d8:	c4 b8       	out	0x04, r12	; 4
          Val3 = ReadU_20ms(TP3);
    12da:	8b 2d       	mov	r24, r11
    12dc:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>
    12e0:	8c 01       	movw	r16, r24

          break;
    12e2:	6b c0       	rjmp	.+214    	; 0x13ba <SelfTest+0x2d4>

        case 6:     /* Rh resistors pulled up */
          LCD_EEString(RhHigh_str);     /* display: Rh+ */
    12e4:	8b e7       	ldi	r24, 0x7B	; 123
    12e6:	91 e0       	ldi	r25, 0x01	; 1
    12e8:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>

          /* TP1: probe -- Rh -- Vcc */
          R_DDR = 2 << (TP1 * 2);
    12ec:	74 b8       	out	0x04, r7	; 4
          R_PORT = 2 << (TP1 * 2);
    12ee:	75 b8       	out	0x05, r7	; 5
          Val1 = ReadU_20ms(TP1);
    12f0:	80 e0       	ldi	r24, 0x00	; 0
    12f2:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>
    12f6:	4c 01       	movw	r8, r24

          /* TP1: probe -- Rh -- Vcc */
          R_DDR = 2 << (TP2 * 2);
    12f8:	64 b8       	out	0x04, r6	; 4
          R_PORT = 2 << (TP2 * 2);
    12fa:	65 b8       	out	0x05, r6	; 5
          Val2 = ReadU_20ms(TP2);
    12fc:	81 e0       	ldi	r24, 0x01	; 1
    12fe:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>
    1302:	1c 01       	movw	r2, r24

          /* TP1: probe -- Rh -- Vcc */
          R_DDR = 2 << (TP3 * 2);
    1304:	c4 b8       	out	0x04, r12	; 4
          R_PORT = 2 << (TP3 * 2);
    1306:	c5 b8       	out	0x05, r12	; 5
          Val3 = ReadU_20ms(TP3);
    1308:	8b 2d       	mov	r24, r11
    130a:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>
    130e:	8c 01       	movw	r16, r24

          break;
    1310:	54 c0       	rjmp	.+168    	; 0x13ba <SelfTest+0x2d4>
      }

      /* reset ports to defaults */
      R_DDR = 0;                             /* input mode */
    1312:	14 b8       	out	0x04, r1	; 4
      R_PORT = 0;                            /* all pins low */
    1314:	15 b8       	out	0x05, r1	; 5

      /* display voltages/values of all probes */
      if (DisplayFlag)
      {
        LCD_NextLine();                      /* move to line #2 */
    1316:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <LCD_NextLine>
        DisplaySignedValue(Val1, 0 , 0);     /* display TP1 */
    131a:	20 e0       	ldi	r18, 0x00	; 0
    131c:	40 e0       	ldi	r20, 0x00	; 0
    131e:	b4 01       	movw	r22, r8
    1320:	09 2c       	mov	r0, r9
    1322:	00 0c       	add	r0, r0
    1324:	88 0b       	sbc	r24, r24
    1326:	99 0b       	sbc	r25, r25
    1328:	0e 94 34 33 	call	0x6668	; 0x6668 <DisplaySignedValue>
        LCD_Space();
    132c:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
        DisplaySignedValue(Val2, 0 , 0);     /* display TP2 */
    1330:	20 e0       	ldi	r18, 0x00	; 0
    1332:	40 e0       	ldi	r20, 0x00	; 0
    1334:	b1 01       	movw	r22, r2
    1336:	03 2c       	mov	r0, r3
    1338:	00 0c       	add	r0, r0
    133a:	88 0b       	sbc	r24, r24
    133c:	99 0b       	sbc	r25, r25
    133e:	0e 94 34 33 	call	0x6668	; 0x6668 <DisplaySignedValue>
        LCD_Space();
    1342:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
        DisplaySignedValue(Val3, 0 , 0);     /* display TP3 */
    1346:	20 e0       	ldi	r18, 0x00	; 0
    1348:	40 e0       	ldi	r20, 0x00	; 0
    134a:	b8 01       	movw	r22, r16
    134c:	01 2e       	mov	r0, r17
    134e:	00 0c       	add	r0, r0
    1350:	88 0b       	sbc	r24, r24
    1352:	99 0b       	sbc	r25, r25
    1354:	0e 94 34 33 	call	0x6668	; 0x6668 <DisplaySignedValue>
      }

      /* wait and check test push button */
      if (Counter < 100)                     /* when we don't skip this test */
    1358:	8b 81       	ldd	r24, Y+3	; 0x03
    135a:	84 36       	cpi	r24, 0x64	; 100
    135c:	78 f4       	brcc	.+30     	; 0x137c <SelfTest+0x296>
      {
        DisplayFlag = TestKey(1000, 0);      /* catch key press or timeout */
    135e:	60 e0       	ldi	r22, 0x00	; 0
    1360:	88 ee       	ldi	r24, 0xE8	; 232
    1362:	93 e0       	ldi	r25, 0x03	; 3
    1364:	0e 94 58 33 	call	0x66b0	; 0x66b0 <TestKey>

        /* short press -> next test / long press -> end selftest */
        if (DisplayFlag > 0)
    1368:	88 23       	and	r24, r24
    136a:	41 f0       	breq	.+16     	; 0x137c <SelfTest+0x296>
    136c:	fa 80       	ldd	r15, Y+2	; 0x02
        {
          Counter = 100;                       /* skip current test anyway */
          if (DisplayFlag == 2) Test = 100;    /* also skip selftest */
    136e:	82 30       	cpi	r24, 0x02	; 2
    1370:	61 f4       	brne	.+24     	; 0x138a <SelfTest+0x2a4>
    1372:	0f 2e       	mov	r0, r31
    1374:	f4 e6       	ldi	r31, 0x64	; 100
    1376:	ff 2e       	mov	r15, r31
    1378:	f0 2d       	mov	r31, r0
    137a:	07 c0       	rjmp	.+14     	; 0x138a <SelfTest+0x2a4>
        } 
      }
 
      Counter++;                        /* next run */
    137c:	eb 81       	ldd	r30, Y+3	; 0x03
    137e:	ef 5f       	subi	r30, 0xFF	; 255
    1380:	eb 83       	std	Y+3, r30	; 0x03
  while (Test <= 6)
  {
    Counter = 1;

    /* repeat each test 5 times */
    while (Counter <= 5)
    1382:	e6 30       	cpi	r30, 0x06	; 6
    1384:	08 f4       	brcc	.+2      	; 0x1388 <SelfTest+0x2a2>
    1386:	e3 ce       	rjmp	.-570    	; 0x114e <SelfTest+0x68>
    1388:	fa 80       	ldd	r15, Y+2	; 0x02
      }
 
      Counter++;                        /* next run */
    }

    Test++;                             /* next one */
    138a:	f3 94       	inc	r15
  /* make sure all probes are shorted */
  Counter = ShortCircuit(1);
  if (Counter == 0) Test = 10;     /* skip selftest */

  /* loop through all tests */
  while (Test <= 6)
    138c:	f6 e0       	ldi	r31, 0x06	; 6
    138e:	ff 15       	cp	r31, r15
    1390:	b8 f0       	brcs	.+46     	; 0x13c0 <SelfTest+0x2da>
 *  - 0 on error
 *  - 1 on success
 */

uint8_t SelfTest(void)
{
    1392:	ee 24       	eor	r14, r14
    1394:	e3 94       	inc	r14
    while (Counter <= 5)
    {
      /* display test number */
      LCD_Clear();
      LCD_Char('T');                    /* display: T */
      LCD_Char('0' + Test);             /* display test number */
    1396:	0f 2e       	mov	r0, r31
    1398:	f0 e3       	ldi	r31, 0x30	; 48
    139a:	df 2e       	mov	r13, r31
    139c:	f0 2d       	mov	r31, r0
    139e:	df 0c       	add	r13, r15
          Val2 = ReadU_20ms(TP2);
          Val2 -= (Config.Vcc / 2);

          /* TP1: Gnd -- Rh -- probe-3 -- probe-2 -- Rh -- Vcc */
          R_PORT = 2 << (TP2 * 2);
          R_DDR = (2 << (TP2 * 2)) | (2 << (TP3 * 2));
    13a0:	0f 2e       	mov	r0, r31
    13a2:	f8 e2       	ldi	r31, 0x28	; 40
    13a4:	af 2e       	mov	r10, r31
    13a6:	f0 2d       	mov	r31, r0
          /* TP1: Gnd -- Rh -- probe */
          R_DDR = 2 << (TP2 * 2);
          Val2 = ReadU_20ms(TP2);

          /* TP1: Gnd -- Rh -- probe */
          R_DDR = 2 << (TP3 * 2);
    13a8:	68 94       	set
    13aa:	cc 24       	eor	r12, r12
    13ac:	c5 f8       	bld	r12, 5
    13ae:	fa 82       	std	Y+2, r15	; 0x02
    13b0:	eb 82       	std	Y+3, r14	; 0x03
    13b2:	cd ce       	rjmp	.-614    	; 0x114e <SelfTest+0x68>

          break;
      }

      /* reset ports to defaults */
      R_DDR = 0;                             /* input mode */
    13b4:	14 b8       	out	0x04, r1	; 4
      R_PORT = 0;                            /* all pins low */
    13b6:	15 b8       	out	0x05, r1	; 5
    13b8:	cf cf       	rjmp	.-98     	; 0x1358 <SelfTest+0x272>

          break;
      }

      /* reset ports to defaults */
      R_DDR = 0;                             /* input mode */
    13ba:	14 b8       	out	0x04, r1	; 4
      R_PORT = 0;                            /* all pins low */
    13bc:	15 b8       	out	0x05, r1	; 5
    13be:	ab cf       	rjmp	.-170    	; 0x1316 <SelfTest+0x230>
    Test++;                             /* next one */
  }

  Flag = 1;         /* signal success */
  return Flag;
} 
    13c0:	81 e0       	ldi	r24, 0x01	; 1
    13c2:	0f 90       	pop	r0
    13c4:	0f 90       	pop	r0
    13c6:	0f 90       	pop	r0
    13c8:	df 91       	pop	r29
    13ca:	cf 91       	pop	r28
    13cc:	1f 91       	pop	r17
    13ce:	0f 91       	pop	r16
    13d0:	ff 90       	pop	r15
    13d2:	ef 90       	pop	r14
    13d4:	df 90       	pop	r13
    13d6:	cf 90       	pop	r12
    13d8:	bf 90       	pop	r11
    13da:	af 90       	pop	r10
    13dc:	9f 90       	pop	r9
    13de:	8f 90       	pop	r8
    13e0:	7f 90       	pop	r7
    13e2:	6f 90       	pop	r6
    13e4:	5f 90       	pop	r5
    13e6:	4f 90       	pop	r4
    13e8:	3f 90       	pop	r3
    13ea:	2f 90       	pop	r2
    13ec:	08 95       	ret

000013ee <DelayTimer>:
 *  (requires prior call of SetupDelayTimer() for setup)
 */

void DelayTimer(void)
{
  TCNT0 = 0;                       /* reset counter to 0 */
    13ee:	16 bc       	out	0x26, r1	; 38
  TCCR0B = (1 << CS00);            /* start timer by setting prescaler */
    13f0:	81 e0       	ldi	r24, 0x01	; 1
    13f2:	85 bd       	out	0x25, r24	; 37

  while (!(TIFR0 & (1 << OCF0A)));   /* wait for output compare A match flag */
    13f4:	a9 9b       	sbis	0x15, 1	; 21
    13f6:	fe cf       	rjmp	.-4      	; 0x13f4 <DelayTimer+0x6>

  TCCR0B = 0;                      /* stop timer */
    13f8:	15 bc       	out	0x25, r1	; 37
  TIFR0 = (1 << OCF0A);            /* clear flag */
    13fa:	82 e0       	ldi	r24, 0x02	; 2
    13fc:	85 bb       	out	0x15, r24	; 21
    13fe:	08 95       	ret

00001400 <MeasureESR>:
 *  returns:
 *  - ESR in 0.01 Ohm
 */

uint16_t MeasureESR(Capacitor_Type *Cap)
{
    1400:	2f 92       	push	r2
    1402:	3f 92       	push	r3
    1404:	4f 92       	push	r4
    1406:	5f 92       	push	r5
    1408:	6f 92       	push	r6
    140a:	7f 92       	push	r7
    140c:	8f 92       	push	r8
    140e:	9f 92       	push	r9
    1410:	af 92       	push	r10
    1412:	bf 92       	push	r11
    1414:	cf 92       	push	r12
    1416:	df 92       	push	r13
    1418:	ef 92       	push	r14
    141a:	ff 92       	push	r15
    141c:	0f 93       	push	r16
    141e:	1f 93       	push	r17
    1420:	cf 93       	push	r28
    1422:	df 93       	push	r29
    1424:	cd b7       	in	r28, 0x3d	; 61
    1426:	de b7       	in	r29, 0x3e	; 62
    1428:	28 97       	sbiw	r28, 0x08	; 8
    142a:	0f b6       	in	r0, 0x3f	; 63
    142c:	f8 94       	cli
    142e:	de bf       	out	0x3e, r29	; 62
    1430:	0f be       	out	0x3f, r0	; 63
    1432:	cd bf       	out	0x3d, r28	; 61
  uint32_t          Value;

  #define LOOP_RUNS      255

  /* check for a capacitor >= 0.18F */
  if ((Cap == NULL) ||
    1434:	00 97       	sbiw	r24, 0x00	; 0
    1436:	09 f4       	brne	.+2      	; 0x143a <MeasureESR+0x3a>
    1438:	49 c1       	rjmp	.+658    	; 0x16cc <MeasureESR+0x2cc>
    143a:	6c 01       	movw	r12, r24
      (CmpValue(Cap->Value, Cap->Scale, 180, -9) < 0)) return ESR;
    143c:	fc 01       	movw	r30, r24
    143e:	63 81       	ldd	r22, Z+3	; 0x03
    1440:	74 81       	ldd	r23, Z+4	; 0x04
    1442:	85 81       	ldd	r24, Z+5	; 0x05
    1444:	96 81       	ldd	r25, Z+6	; 0x06
    1446:	0f 2e       	mov	r0, r31
    1448:	f7 ef       	ldi	r31, 0xF7	; 247
    144a:	ef 2e       	mov	r14, r31
    144c:	f0 2d       	mov	r31, r0
    144e:	04 eb       	ldi	r16, 0xB4	; 180
    1450:	10 e0       	ldi	r17, 0x00	; 0
    1452:	20 e0       	ldi	r18, 0x00	; 0
    1454:	30 e0       	ldi	r19, 0x00	; 0
    1456:	42 81       	ldd	r20, Z+2	; 0x02
    1458:	0e 94 ac 31 	call	0x6358	; 0x6358 <CmpValue>
  uint32_t          Value;

  #define LOOP_RUNS      255

  /* check for a capacitor >= 0.18F */
  if ((Cap == NULL) ||
    145c:	88 23       	and	r24, r24
    145e:	0c f4       	brge	.+2      	; 0x1462 <MeasureESR+0x62>
    1460:	38 c1       	rjmp	.+624    	; 0x16d2 <MeasureESR+0x2d2>

  /*
   *  init stuff
   */

  DischargeProbes();                    /* try to discharge probes */
    1462:	0e 94 a3 23 	call	0x4746	; 0x4746 <DischargeProbes>
  if (Check.Found == COMP_ERROR) return ESR;   /* skip on error */
    1466:	80 91 09 01 	lds	r24, 0x0109
    146a:	81 30       	cpi	r24, 0x01	; 1
    146c:	09 f4       	brne	.+2      	; 0x1470 <MeasureESR+0x70>
    146e:	34 c1       	rjmp	.+616    	; 0x16d8 <MeasureESR+0x2d8>

  Probe1 = Cap->A;       /* probe facing Gnd */
    1470:	f6 01       	movw	r30, r12
    1472:	10 81       	ld	r17, Z
  Probe2 = Cap->B;       /* probe facing Vcc */
    1474:	01 81       	ldd	r16, Z+1	; 0x01

  UpdateProbes(Probe1, Probe2, 0);      /* update probes */
    1476:	40 e0       	ldi	r20, 0x00	; 0
    1478:	60 2f       	mov	r22, r16
    147a:	81 2f       	mov	r24, r17
    147c:	0e 94 04 23 	call	0x4608	; 0x4608 <UpdateProbes>

  /* init variables */
  Sum_1 = 1;             /* 1 to prevent division by zero */
  Sum_2 = 1;             /* 1 to prevent division by zero */

  Probe1 |= (1 << REFS1) | (1 << REFS0);     /* select bandgap reference */
    1480:	10 6c       	ori	r17, 0xC0	; 192
    1482:	19 83       	std	Y+1, r17	; 0x01
  Probe2 |= (1 << REFS1) | (1 << REFS0);     /* select bandgap reference */
    1484:	00 6c       	ori	r16, 0xC0	; 192
    1486:	0a 83       	std	Y+2, r16	; 0x02
   *  setup timer0:
   *  - CTC mode (count up to OCR0A) 
   *  - prescaler 1 to match MCU cycles
   */

  TCCR0B = 0;                      /* disable timer */
    1488:	15 bc       	out	0x25, r1	; 37
  TCCR0A = (1 << WGM01);           /* set CTC mode, disable output compare pins */
    148a:	82 e0       	ldi	r24, 0x02	; 2
    148c:	84 bd       	out	0x24, r24	; 36
  OCR0A = Cycles;                  /* set number of MCU cycles */
    148e:	85 ed       	ldi	r24, 0xD5	; 213
    1490:	87 bd       	out	0x27, r24	; 39
  /*
   *  charge capacitor with a negative pulse of half length
   *  pulse: GND -- probe 2 / probe 1 -- Rl -- 5V
   */

  ADC_PORT = 0;               /* set ADC port to low */
    1492:	18 b8       	out	0x08, r1	; 8
  ADMUX = Probe1;             /* set input channel to probe 1 & set bandgap ref */
    1494:	f9 81       	ldd	r31, Y+1	; 0x01
    1496:	f0 93 7c 00 	sts	0x007C, r31
    149a:	8f e3       	ldi	r24, 0x3F	; 63
    149c:	9c e9       	ldi	r25, 0x9C	; 156
    149e:	01 97       	sbiw	r24, 0x01	; 1
    14a0:	f1 f7       	brne	.-4      	; 0x149e <MeasureESR+0x9e>
    14a2:	00 c0       	rjmp	.+0      	; 0x14a4 <MeasureESR+0xa4>
    14a4:	00 00       	nop
  _delay_ms(10);                 /* time for voltage stabilization */
  ADC_DDR = Probes.ADC_2;     /* pull down probe 2 directly */
    14a6:	ef e8       	ldi	r30, 0x8F	; 143
    14a8:	f1 e0       	ldi	r31, 0x01	; 1
    14aa:	82 85       	ldd	r24, Z+10	; 0x0a
    14ac:	87 b9       	out	0x07, r24	; 7
  R_PORT = Probes.Rl_1;       /* pull up probe 1 via Rl */
    14ae:	83 81       	ldd	r24, Z+3	; 0x03
    14b0:	85 b9       	out	0x05, r24	; 5
  R_DDR = Probes.Rl_1;        /* enable resistor */
    14b2:	84 b9       	out	0x04, r24	; 4
  DelayTimer();               /* wait 1/2 pulse */
    14b4:	0e 94 f7 09 	call	0x13ee	; 0x13ee <DelayTimer>
  R_PORT = 0;                 /* set resistor port to low */
    14b8:	15 b8       	out	0x05, r1	; 5
  R_DDR = 0;                  /* set resistor port to HiZ */
    14ba:	14 b8       	out	0x04, r1	; 4
    14bc:	22 24       	eor	r2, r2
    14be:	2a 94       	dec	r2

  UpdateProbes(Probe1, Probe2, 0);      /* update probes */

  /* init variables */
  Sum_1 = 1;             /* 1 to prevent division by zero */
  Sum_2 = 1;             /* 1 to prevent division by zero */
    14c0:	81 2c       	mov	r8, r1
    14c2:	91 2c       	mov	r9, r1
    14c4:	54 01       	movw	r10, r8
    14c6:	83 94       	inc	r8
  Probe2 = Cap->B;       /* probe facing Vcc */

  UpdateProbes(Probe1, Probe2, 0);      /* update probes */

  /* init variables */
  Sum_1 = 1;             /* 1 to prevent division by zero */
    14c8:	41 2c       	mov	r4, r1
    14ca:	51 2c       	mov	r5, r1
    14cc:	32 01       	movw	r6, r4
    14ce:	43 94       	inc	r4
     *  forward mode, probe 1 only (probe 2 in HiZ mode)
     *  get voltage at probe 1 (facing Gnd)
     *  set probes: GND -- probe 1 -- Rl -- 5V / probe 2 -- HiZ
     */

    ADC_DDR = Probes.ADC_1;        /* pull down probe 1 directly to GND */
    14d0:	0f e8       	ldi	r16, 0x8F	; 143
    14d2:	11 e0       	ldi	r17, 0x01	; 1
    R_PORT = Probes.Rl_1;          /* pull up probe 1 via Rl */
    R_DDR = Probes.Rl_1;           /* enable resistor */
    ADMUX = Probe1;                /* set input channel to probe 1 & set bandgap ref */
    14d4:	0f 2e       	mov	r0, r31
    14d6:	fc e7       	ldi	r31, 0x7C	; 124
    14d8:	ef 2e       	mov	r14, r31
    14da:	f1 2c       	mov	r15, r1
    14dc:	f0 2d       	mov	r31, r0
    wdt_reset();                   /* reset watchdog */
    /* run dummy conversion for ADMUX change */
    ADCSRA = ADC_Mask;             /* start conversion */
    14de:	0f 2e       	mov	r0, r31
    14e0:	f7 ed       	ldi	r31, 0xD7	; 215
    14e2:	3f 2e       	mov	r3, r31
    14e4:	f0 2d       	mov	r31, r0
    while (ADCSRA & (1 << ADSC));  /* wait until conversion is done */
    /* real conversion */
    ADCSRA = ADC_Mask;             /* start conversion */
    while (ADCSRA & (1 << ADSC));  /* wait until conversion is done */
    U_1 = ADCW;                    /* save ADC value */
    14e6:	0f 2e       	mov	r0, r31
    14e8:	f8 e7       	ldi	r31, 0x78	; 120
    14ea:	cf 2e       	mov	r12, r31
    14ec:	d1 2c       	mov	r13, r1
    14ee:	f0 2d       	mov	r31, r0
     *  forward mode, probe 1 only (probe 2 in HiZ mode)
     *  get voltage at probe 1 (facing Gnd)
     *  set probes: GND -- probe 1 -- Rl -- 5V / probe 2 -- HiZ
     */

    ADC_DDR = Probes.ADC_1;        /* pull down probe 1 directly to GND */
    14f0:	f8 01       	movw	r30, r16
    14f2:	81 85       	ldd	r24, Z+9	; 0x09
    14f4:	87 b9       	out	0x07, r24	; 7
    R_PORT = Probes.Rl_1;          /* pull up probe 1 via Rl */
    14f6:	83 81       	ldd	r24, Z+3	; 0x03
    14f8:	85 b9       	out	0x05, r24	; 5
    R_DDR = Probes.Rl_1;           /* enable resistor */
    14fa:	84 b9       	out	0x04, r24	; 4
    ADMUX = Probe1;                /* set input channel to probe 1 & set bandgap ref */
    14fc:	29 81       	ldd	r18, Y+1	; 0x01
    14fe:	f7 01       	movw	r30, r14
    1500:	20 83       	st	Z, r18
    wdt_reset();                   /* reset watchdog */
    1502:	a8 95       	wdr
    /* run dummy conversion for ADMUX change */
    ADCSRA = ADC_Mask;             /* start conversion */
    1504:	ea e7       	ldi	r30, 0x7A	; 122
    1506:	f0 e0       	ldi	r31, 0x00	; 0
    1508:	30 82       	st	Z, r3
    while (ADCSRA & (1 << ADSC));  /* wait until conversion is done */
    150a:	ea e7       	ldi	r30, 0x7A	; 122
    150c:	f0 e0       	ldi	r31, 0x00	; 0
    150e:	80 81       	ld	r24, Z
    1510:	86 fd       	sbrc	r24, 6
    1512:	fb cf       	rjmp	.-10     	; 0x150a <MeasureESR+0x10a>
    /* real conversion */
    ADCSRA = ADC_Mask;             /* start conversion */
    1514:	30 82       	st	Z, r3
    while (ADCSRA & (1 << ADSC));  /* wait until conversion is done */
    1516:	ea e7       	ldi	r30, 0x7A	; 122
    1518:	f0 e0       	ldi	r31, 0x00	; 0
    151a:	80 81       	ld	r24, Z
    151c:	86 fd       	sbrc	r24, 6
    151e:	fb cf       	rjmp	.-10     	; 0x1516 <MeasureESR+0x116>
    U_1 = ADCW;                    /* save ADC value */
    1520:	f6 01       	movw	r30, r12
    1522:	01 90       	ld	r0, Z+
    1524:	f0 81       	ld	r31, Z
    1526:	e0 2d       	mov	r30, r0
    1528:	fc 83       	std	Y+4, r31	; 0x04
    152a:	eb 83       	std	Y+3, r30	; 0x03
     *  forward mode, positive charging pulse
     *  get voltage at probe 2 (facing Vcc)
     *  set probes: GND -- probe 1 / probe 2 -- Rl -- 5V
     */

    ADMUX = Probe2;                /* set input channel to probe 2 & set bandgap ref */
    152c:	2a 81       	ldd	r18, Y+2	; 0x02
    152e:	f7 01       	movw	r30, r14
    1530:	20 83       	st	Z, r18
    /* run dummy conversion for ADMUX change */
    ADCSRA = ADC_Mask;             /* start conversion */
    1532:	ea e7       	ldi	r30, 0x7A	; 122
    1534:	f0 e0       	ldi	r31, 0x00	; 0
    1536:	30 82       	st	Z, r3
    while (ADCSRA & (1 << ADSC));  /* wait until conversion is done */
    1538:	ea e7       	ldi	r30, 0x7A	; 122
    153a:	f0 e0       	ldi	r31, 0x00	; 0
    153c:	80 81       	ld	r24, Z
    153e:	86 fd       	sbrc	r24, 6
    1540:	fb cf       	rjmp	.-10     	; 0x1538 <MeasureESR+0x138>

    /* read ADC in the mid of a positive charging pulse */
    ADCSRA = ADC_Mask;             /* start conversion with next ADC clock cycle */
    1542:	30 82       	st	Z, r3
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1544:	fa e1       	ldi	r31, 0x1A	; 26
    1546:	fa 95       	dec	r31
    1548:	f1 f7       	brne	.-4      	; 0x1546 <MeasureESR+0x146>
    154a:	00 c0       	rjmp	.+0      	; 0x154c <MeasureESR+0x14c>
    _delay_us(5);
    R_PORT = Probes.Rl_2;          /* pull up probe 2 via Rl */
    154c:	f8 01       	movw	r30, r16
    154e:	85 81       	ldd	r24, Z+5	; 0x05
    1550:	85 b9       	out	0x05, r24	; 5
    R_DDR = Probes.Rl_2;           /* enable resistor */
    1552:	84 b9       	out	0x04, r24	; 4
    DelayTimer();                  /* wait 1/2 pulse */
    1554:	0e 94 f7 09 	call	0x13ee	; 0x13ee <DelayTimer>
    DelayTimer();                  /* wait another 1/2 pulse */
    1558:	0e 94 f7 09 	call	0x13ee	; 0x13ee <DelayTimer>
    R_PORT = 0;                    /* set resistor port to low */
    155c:	15 b8       	out	0x05, r1	; 5
    R_DDR = 0;                     /* set resistor port to HiZ */
    155e:	14 b8       	out	0x04, r1	; 4
    while (ADCSRA & (1 << ADSC));  /* wait until conversion is done */
    1560:	ea e7       	ldi	r30, 0x7A	; 122
    1562:	f0 e0       	ldi	r31, 0x00	; 0
    1564:	80 81       	ld	r24, Z
    1566:	86 fd       	sbrc	r24, 6
    1568:	fb cf       	rjmp	.-10     	; 0x1560 <MeasureESR+0x160>
    U_2 = ADCW;                    /* save ADC value */
    156a:	f6 01       	movw	r30, r12
    156c:	01 90       	ld	r0, Z+
    156e:	f0 81       	ld	r31, Z
    1570:	e0 2d       	mov	r30, r0
    1572:	fe 83       	std	Y+6, r31	; 0x06
    1574:	ed 83       	std	Y+5, r30	; 0x05
     *  reverse mode, probe 2 only (probe 1 in HiZ mode)
     *  get voltage at probe 2 (facing Gnd)
     *  set probes: GND -- probe 2 -- Rl -- 5V / probe 1 -- HiZ
     */

    ADC_DDR = Probes.ADC_2;        /* pull down probe 2 directly */
    1576:	f8 01       	movw	r30, r16
    1578:	82 85       	ldd	r24, Z+10	; 0x0a
    157a:	87 b9       	out	0x07, r24	; 7
    R_PORT = Probes.Rl_2;          /* pull up probe 2 via Rl */
    157c:	85 81       	ldd	r24, Z+5	; 0x05
    157e:	85 b9       	out	0x05, r24	; 5
    R_DDR = Probes.Rl_2;           /* enable resistor */
    1580:	84 b9       	out	0x04, r24	; 4
    ADMUX = Probe2;                /* set input channel to probe 2 & set bandgap ref */
    1582:	2a 81       	ldd	r18, Y+2	; 0x02
    1584:	f7 01       	movw	r30, r14
    1586:	20 83       	st	Z, r18
    wdt_reset();                   /* reset watchdog */
    1588:	a8 95       	wdr
    /* run dummy conversion for ADMUX change */
    ADCSRA = ADC_Mask;             /* start conversion */
    158a:	ea e7       	ldi	r30, 0x7A	; 122
    158c:	f0 e0       	ldi	r31, 0x00	; 0
    158e:	30 82       	st	Z, r3
    while (ADCSRA & (1 << ADSC));  /* wait until conversion is done */
    1590:	ea e7       	ldi	r30, 0x7A	; 122
    1592:	f0 e0       	ldi	r31, 0x00	; 0
    1594:	80 81       	ld	r24, Z
    1596:	86 fd       	sbrc	r24, 6
    1598:	fb cf       	rjmp	.-10     	; 0x1590 <MeasureESR+0x190>
    /* real conversion */
    ADCSRA = ADC_Mask;             /* start conversion */
    159a:	30 82       	st	Z, r3
    while (ADCSRA & (1 << ADSC));  /* wait until conversion is done */
    159c:	ea e7       	ldi	r30, 0x7A	; 122
    159e:	f0 e0       	ldi	r31, 0x00	; 0
    15a0:	80 81       	ld	r24, Z
    15a2:	86 fd       	sbrc	r24, 6
    15a4:	fb cf       	rjmp	.-10     	; 0x159c <MeasureESR+0x19c>
    U_3 = ADCW;                    /* save ADC value */
    15a6:	f6 01       	movw	r30, r12
    15a8:	01 90       	ld	r0, Z+
    15aa:	f0 81       	ld	r31, Z
    15ac:	e0 2d       	mov	r30, r0
    15ae:	f8 87       	std	Y+8, r31	; 0x08
    15b0:	ef 83       	std	Y+7, r30	; 0x07
     *  reverse mode, negative charging pulse
     *  get voltage at probe 1 (facing Vcc)
     *  set probes: GND -- probe 2 / probe 1 -- Rl -- 5V
     */

    ADMUX = Probe1;                /* set input channel to probe 1 & set bandgap ref */
    15b2:	29 81       	ldd	r18, Y+1	; 0x01
    15b4:	f7 01       	movw	r30, r14
    15b6:	20 83       	st	Z, r18
    /* run dummy conversion for ADMUX change */
    ADCSRA = ADC_Mask;             /* start conversion */
    15b8:	ea e7       	ldi	r30, 0x7A	; 122
    15ba:	f0 e0       	ldi	r31, 0x00	; 0
    15bc:	30 82       	st	Z, r3
    while (ADCSRA & (1 << ADSC));  /* wait until conversion is done */
    15be:	ea e7       	ldi	r30, 0x7A	; 122
    15c0:	f0 e0       	ldi	r31, 0x00	; 0
    15c2:	80 81       	ld	r24, Z
    15c4:	86 fd       	sbrc	r24, 6
    15c6:	fb cf       	rjmp	.-10     	; 0x15be <MeasureESR+0x1be>

    /* read ADC in the mid of a negatve charging pulse */
    ADCSRA = ADC_Mask;             /* start conversion with next ADC clock cycle */
    15c8:	30 82       	st	Z, r3
    15ca:	fa e1       	ldi	r31, 0x1A	; 26
    15cc:	fa 95       	dec	r31
    15ce:	f1 f7       	brne	.-4      	; 0x15cc <MeasureESR+0x1cc>
    15d0:	00 c0       	rjmp	.+0      	; 0x15d2 <MeasureESR+0x1d2>
    _delay_us(5);
    R_PORT = Probes.Rl_1;          /* pull up probe 1 via Rl */
    15d2:	f8 01       	movw	r30, r16
    15d4:	83 81       	ldd	r24, Z+3	; 0x03
    15d6:	85 b9       	out	0x05, r24	; 5
    R_DDR = Probes.Rl_1;           /* enable resistor */
    15d8:	84 b9       	out	0x04, r24	; 4
    DelayTimer();                  /* wait 1/2 pulse */
    15da:	0e 94 f7 09 	call	0x13ee	; 0x13ee <DelayTimer>
    DelayTimer();                  /* wait another 1/2 pulse */
    15de:	0e 94 f7 09 	call	0x13ee	; 0x13ee <DelayTimer>
    R_PORT = 0;                    /* set resistor port to low */
    15e2:	15 b8       	out	0x05, r1	; 5
    R_DDR = 0;                     /* set resistor port to HiZ */
    15e4:	14 b8       	out	0x04, r1	; 4
    while (ADCSRA & (1 << ADSC));  /* wait until conversion is done */
    15e6:	ea e7       	ldi	r30, 0x7A	; 122
    15e8:	f0 e0       	ldi	r31, 0x00	; 0
    15ea:	80 81       	ld	r24, Z
    15ec:	86 fd       	sbrc	r24, 6
    15ee:	fb cf       	rjmp	.-10     	; 0x15e6 <MeasureESR+0x1e6>
    U_4 = ADCW;                    /* save ADC value */
    15f0:	f6 01       	movw	r30, r12
    15f2:	20 81       	ld	r18, Z
    15f4:	31 81       	ldd	r19, Z+1	; 0x01

    /*
     *  manage measured values
     */

    U_1 += U_3;          /* sum of both measurements without pulses/load */
    15f6:	8f 81       	ldd	r24, Y+7	; 0x07
    15f8:	98 85       	ldd	r25, Y+8	; 0x08
    15fa:	4b 81       	ldd	r20, Y+3	; 0x03
    15fc:	5c 81       	ldd	r21, Y+4	; 0x04
    15fe:	84 0f       	add	r24, r20
    1600:	95 1f       	adc	r25, r21
    Sum_1 += U_1;        /* add to total no-load sum */
    1602:	48 0e       	add	r4, r24
    1604:	59 1e       	adc	r5, r25
    1606:	61 1c       	adc	r6, r1
    1608:	71 1c       	adc	r7, r1
    U_2 += U_4;          /* sum of both measurements with pulses/load */
    160a:	8d 81       	ldd	r24, Y+5	; 0x05
    160c:	9e 81       	ldd	r25, Y+6	; 0x06
    160e:	82 0f       	add	r24, r18
    1610:	93 1f       	adc	r25, r19
    Sum_2 += U_2;        /* add to total with-load sum */
    1612:	88 0e       	add	r8, r24
    1614:	99 1e       	adc	r9, r25
    1616:	a1 1c       	adc	r10, r1
    1618:	b1 1c       	adc	r11, r1

    /*
     *  prevent runaway of cap's charge
     */

    if (U_4 <= 100)           /* <= 107mV */
    161a:	25 36       	cpi	r18, 0x65	; 101
    161c:	31 05       	cpc	r19, r1
    161e:	50 f4       	brcc	.+20     	; 0x1634 <MeasureESR+0x234>
    {
      /* charge cap a little bit more (negative pulse) */

      /* set probes: GND -- probe 2 / probe 1 -- Rl -- 5V */
      /* probe 2 is still pulled down directly */
      R_PORT = Probes.Rl_1;        /* pull up probe 1 via Rl */
    1620:	f8 01       	movw	r30, r16
    1622:	23 81       	ldd	r18, Z+3	; 0x03
    1624:	25 b9       	out	0x05, r18	; 5
      R_DDR = Probes.Rl_1;         /* enable pull up */
    1626:	24 b9       	out	0x04, r18	; 4
    1628:	fa e0       	ldi	r31, 0x0A	; 10
    162a:	fa 95       	dec	r31
    162c:	f1 f7       	brne	.-4      	; 0x162a <MeasureESR+0x22a>
    162e:	00 c0       	rjmp	.+0      	; 0x1630 <MeasureESR+0x230>
      _delay_us(2);
      R_DDR = 0;                   /* disable any pull up */      
    1630:	14 b8       	out	0x04, r1	; 4
      R_PORT = 0;                  /* reset probe resistors */
    1632:	15 b8       	out	0x05, r1	; 5
    }

    if (U_2 <= 100)
    1634:	85 36       	cpi	r24, 0x65	; 101
    1636:	91 05       	cpc	r25, r1
    1638:	80 f4       	brcc	.+32     	; 0x165a <MeasureESR+0x25a>
    {
      /* charge cap a little bit more (positive pulse) */

      /* set probes: GND -- probe 1 / probe 2 -- Rl -- 5V */
      ADC_DDR = Probes.ADC_1;      /* pull down probe 1 directly */
    163a:	f8 01       	movw	r30, r16
    163c:	81 85       	ldd	r24, Z+9	; 0x09
    163e:	87 b9       	out	0x07, r24	; 7
      R_PORT = Probes.Rl_2;        /* pull up probe 2 via Rl */
    1640:	85 81       	ldd	r24, Z+5	; 0x05
    1642:	85 b9       	out	0x05, r24	; 5
      R_DDR = Probes.Rl_2;         /* enable pull up */
    1644:	84 b9       	out	0x04, r24	; 4
    1646:	fa e0       	ldi	r31, 0x0A	; 10
    1648:	fa 95       	dec	r31
    164a:	f1 f7       	brne	.-4      	; 0x1648 <MeasureESR+0x248>
    164c:	00 c0       	rjmp	.+0      	; 0x164e <MeasureESR+0x24e>
      _delay_us(2);
      DelayTimer();                /* wait 1/2 pulse */
    164e:	0e 94 f7 09 	call	0x13ee	; 0x13ee <DelayTimer>
      DelayTimer();                /* wait another 1/2 pulse */
    1652:	0e 94 f7 09 	call	0x13ee	; 0x13ee <DelayTimer>
      R_DDR = 0;                   /* disable any pull up */      
    1656:	14 b8       	out	0x04, r1	; 4
      R_PORT = 0;                  /* reset probe resistors */
    1658:	15 b8       	out	0x05, r1	; 5
    165a:	2a 94       	dec	r2
   *  - measure start voltage (no load)
   *  - measure pulse voltage (with load)
   */  

  n = LOOP_RUNS;
  while (n > 0)
    165c:	21 10       	cpse	r2, r1
    165e:	48 cf       	rjmp	.-368    	; 0x14f0 <MeasureESR+0xf0>
  /*
   *  process measurements
   */

  /* calculate voltage across the DUT */
  if (Sum_2 > Sum_1)               /* valid measurement */
    1660:	48 14       	cp	r4, r8
    1662:	59 04       	cpc	r5, r9
    1664:	6a 04       	cpc	r6, r10
    1666:	7b 04       	cpc	r7, r11
    1668:	38 f4       	brcc	.+14     	; 0x1678 <MeasureESR+0x278>
  {
    Sum_2 -= Sum_1;                /* subtract voltage at DUT's low side (RiL) */
    166a:	a5 01       	movw	r20, r10
    166c:	94 01       	movw	r18, r8
    166e:	24 19       	sub	r18, r4
    1670:	35 09       	sbc	r19, r5
    1672:	46 09       	sbc	r20, r6
    1674:	57 09       	sbc	r21, r7
    1676:	03 c0       	rjmp	.+6      	; 0x167e <MeasureESR+0x27e>
  }
  else                             /* invalid measurement */
  {
    Sum_2 = 0;
    1678:	20 e0       	ldi	r18, 0x00	; 0
    167a:	30 e0       	ldi	r19, 0x00	; 0
    167c:	a9 01       	movw	r20, r18
   *    the ADC value into a voltage and desample the sums.
   *  - so ESR = Sum_2 * RiL / Sum_1
   *  - for a resolution of 0.01 Ohms we have to scale RiL to 0.01 Ohms
   */

  Value = (uint32_t)(NV.RiL * 10);      /* RiL in 0.01 Ohms */
    167e:	0b e9       	ldi	r16, 0x9B	; 155
    1680:	11 e0       	ldi	r17, 0x01	; 1
    1682:	f8 01       	movw	r30, r16
    1684:	80 81       	ld	r24, Z
    1686:	91 81       	ldd	r25, Z+1	; 0x01
    1688:	dc 01       	movw	r26, r24
    168a:	aa 0f       	add	r26, r26
    168c:	bb 1f       	adc	r27, r27
    168e:	88 0f       	add	r24, r24
    1690:	99 1f       	adc	r25, r25
    1692:	88 0f       	add	r24, r24
    1694:	99 1f       	adc	r25, r25
    1696:	88 0f       	add	r24, r24
    1698:	99 1f       	adc	r25, r25
    169a:	a8 0f       	add	r26, r24
    169c:	b9 1f       	adc	r27, r25
  Value *= Sum_2;
    169e:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
  Value /= Sum_1;
    16a2:	a3 01       	movw	r20, r6
    16a4:	92 01       	movw	r18, r4
    16a6:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
  U_1 = (uint16_t)Value;

  /* consider probe resistance */
  if (U_1 > NV.RZero)
    16aa:	f8 01       	movw	r30, r16
    16ac:	84 81       	ldd	r24, Z+4	; 0x04
    16ae:	95 81       	ldd	r25, Z+5	; 0x05
    16b0:	82 17       	cp	r24, r18
    16b2:	93 07       	cpc	r25, r19
    16b4:	28 f4       	brcc	.+10     	; 0x16c0 <MeasureESR+0x2c0>
  {
    U_1 -= NV.RZero;               /* subtract offset */
    16b6:	b9 01       	movw	r22, r18
    16b8:	68 1b       	sub	r22, r24
    16ba:	79 0b       	sbc	r23, r25
    16bc:	cb 01       	movw	r24, r22
    16be:	02 c0       	rjmp	.+4      	; 0x16c4 <MeasureESR+0x2c4>
 *  - ESR in 0.01 Ohm
 */

uint16_t MeasureESR(Capacitor_Type *Cap)
{
  uint16_t          ESR = 0;       /* return value */
    16c0:	80 e0       	ldi	r24, 0x00	; 0
    16c2:	90 e0       	ldi	r25, 0x00	; 0
    U_1 -= NV.RZero;               /* subtract offset */
    ESR = U_1;                     /* we got a valid result */
  }

  /* update Uref flag for next ADC run */
  Config.RefFlag = (1 << REFS1);        /* set REFS1 bit flag */
    16c4:	20 e8       	ldi	r18, 0x80	; 128
    16c6:	20 93 ae 01 	sts	0x01AE, r18

  return ESR;
    16ca:	08 c0       	rjmp	.+16     	; 0x16dc <MeasureESR+0x2dc>

  #define LOOP_RUNS      255

  /* check for a capacitor >= 0.18F */
  if ((Cap == NULL) ||
      (CmpValue(Cap->Value, Cap->Scale, 180, -9) < 0)) return ESR;
    16cc:	80 e0       	ldi	r24, 0x00	; 0
    16ce:	90 e0       	ldi	r25, 0x00	; 0
    16d0:	05 c0       	rjmp	.+10     	; 0x16dc <MeasureESR+0x2dc>
    16d2:	80 e0       	ldi	r24, 0x00	; 0
    16d4:	90 e0       	ldi	r25, 0x00	; 0
    16d6:	02 c0       	rjmp	.+4      	; 0x16dc <MeasureESR+0x2dc>
  /*
   *  init stuff
   */

  DischargeProbes();                    /* try to discharge probes */
  if (Check.Found == COMP_ERROR) return ESR;   /* skip on error */
    16d8:	80 e0       	ldi	r24, 0x00	; 0
    16da:	90 e0       	ldi	r25, 0x00	; 0
  Config.RefFlag = (1 << REFS1);        /* set REFS1 bit flag */

  return ESR;

  #undef LOOP_RUNS 
}
    16dc:	28 96       	adiw	r28, 0x08	; 8
    16de:	0f b6       	in	r0, 0x3f	; 63
    16e0:	f8 94       	cli
    16e2:	de bf       	out	0x3e, r29	; 62
    16e4:	0f be       	out	0x3f, r0	; 63
    16e6:	cd bf       	out	0x3d, r28	; 61
    16e8:	df 91       	pop	r29
    16ea:	cf 91       	pop	r28
    16ec:	1f 91       	pop	r17
    16ee:	0f 91       	pop	r16
    16f0:	ff 90       	pop	r15
    16f2:	ef 90       	pop	r14
    16f4:	df 90       	pop	r13
    16f6:	cf 90       	pop	r12
    16f8:	bf 90       	pop	r11
    16fa:	af 90       	pop	r10
    16fc:	9f 90       	pop	r9
    16fe:	8f 90       	pop	r8
    1700:	7f 90       	pop	r7
    1702:	6f 90       	pop	r6
    1704:	5f 90       	pop	r5
    1706:	4f 90       	pop	r4
    1708:	3f 90       	pop	r3
    170a:	2f 90       	pop	r2
    170c:	08 95       	ret

0000170e <LargeCap>:
 *  - 1 if capacitance is too high
 *  - 0 on any problem
 */

uint8_t LargeCap(Capacitor_Type *Cap)
{
    170e:	2f 92       	push	r2
    1710:	3f 92       	push	r3
    1712:	4f 92       	push	r4
    1714:	5f 92       	push	r5
    1716:	6f 92       	push	r6
    1718:	7f 92       	push	r7
    171a:	8f 92       	push	r8
    171c:	9f 92       	push	r9
    171e:	af 92       	push	r10
    1720:	bf 92       	push	r11
    1722:	cf 92       	push	r12
    1724:	df 92       	push	r13
    1726:	ef 92       	push	r14
    1728:	ff 92       	push	r15
    172a:	0f 93       	push	r16
    172c:	1f 93       	push	r17
    172e:	cf 93       	push	r28
    1730:	df 93       	push	r29
    1732:	00 d0       	rcall	.+0      	; 0x1734 <LargeCap+0x26>
    1734:	00 d0       	rcall	.+0      	; 0x1736 <LargeCap+0x28>
    1736:	1f 92       	push	r1
    1738:	cd b7       	in	r28, 0x3d	; 61
    173a:	de b7       	in	r29, 0x3e	; 62
    173c:	9b 83       	std	Y+3, r25	; 0x03
    173e:	8a 83       	std	Y+2, r24	; 0x02
  uint16_t          U_Drop = 0;    /* voltage drop */
  uint32_t          Raw;           /* raw capacitance value */
  uint32_t          Value;         /* corrected capacitance value */

  /* setup mode */
  Mode = FLAG_10MS | FLAG_PULLUP;       /* start with large caps */
    1740:	0f 2e       	mov	r0, r31
    1742:	f1 e1       	ldi	r31, 0x11	; 17
    1744:	cf 2e       	mov	r12, r31
    1746:	f0 2d       	mov	r31, r0
 *  - 0 on any problem
 */

uint8_t LargeCap(Capacitor_Type *Cap)
{
  uint8_t           Flag = 3;      /* return value */
    1748:	23 e0       	ldi	r18, 0x03	; 3
    174a:	29 83       	std	Y+1, r18	; 0x01

large_cap:

  /* prepare probes */
  DischargeProbes();                    /* try to discharge probes */
  if (Check.Found == COMP_ERROR) return 0;     /* skip on error */
    174c:	0f 2e       	mov	r0, r31
    174e:	f8 e0       	ldi	r31, 0x08	; 8
    1750:	8f 2e       	mov	r8, r31
    1752:	f1 e0       	ldi	r31, 0x01	; 1
    1754:	9f 2e       	mov	r9, r31
    1756:	f0 2d       	mov	r31, r0

  /* setup probes: Gnd -- probe 1 / probe 2 -- Rl -- Vcc */
  ADC_PORT = 0;                    /* set ADC port to low */
  ADC_DDR = Probes.ADC_2;          /* pull-down probe 2 directly */
    1758:	0f 2e       	mov	r0, r31
    175a:	ff e8       	ldi	r31, 0x8F	; 143
    175c:	ef 2e       	mov	r14, r31
    175e:	f1 e0       	ldi	r31, 0x01	; 1
    1760:	ff 2e       	mov	r15, r31
    1762:	f0 2d       	mov	r31, r0
  R_PORT = 0;                      /* set resistor port to low */
  R_DDR = 0;                       /* set resistor port to HiZ */
  U_Zero = ReadU(Probes.Pin_1);    /* get zero voltage (noise) */

  /* charge DUT with up to 500 pulses until it reaches 300mV */
  Pulses = 0;
    1764:	21 2c       	mov	r2, r1
    1766:	31 2c       	mov	r3, r1
  TempByte = 1;
    1768:	44 24       	eor	r4, r4
    176a:	43 94       	inc	r4

    /* end loop if charging is too slow */
    if ((Pulses == 126) && (U_Cap < 75)) TempByte = 0;
    
    /* end loop if 300mV are reached */
    if (U_Cap >= 300) TempByte = 0;
    176c:	71 2c       	mov	r7, r1

    /* zero offset */
    if (U_Cap > U_Zero)            /* voltage higher than zero offset */
      U_Cap -= U_Zero;                  /* subtract zero offset */
    else                           /* shouldn't happen but you never know */
      U_Cap = 0;                        /* assume 0V */
    176e:	52 2c       	mov	r5, r2
    1770:	63 2c       	mov	r6, r3
   */

large_cap:

  /* prepare probes */
  DischargeProbes();                    /* try to discharge probes */
    1772:	0e 94 a3 23 	call	0x4746	; 0x4746 <DischargeProbes>
  if (Check.Found == COMP_ERROR) return 0;     /* skip on error */
    1776:	d4 01       	movw	r26, r8
    1778:	11 96       	adiw	r26, 0x01	; 1
    177a:	8c 91       	ld	r24, X
    177c:	81 30       	cpi	r24, 0x01	; 1
    177e:	09 f4       	brne	.+2      	; 0x1782 <LargeCap+0x74>
    1780:	e8 c0       	rjmp	.+464    	; 0x1952 <LargeCap+0x244>

  /* setup probes: Gnd -- probe 1 / probe 2 -- Rl -- Vcc */
  ADC_PORT = 0;                    /* set ADC port to low */
    1782:	18 b8       	out	0x08, r1	; 8
  ADC_DDR = Probes.ADC_2;          /* pull-down probe 2 directly */
    1784:	f7 01       	movw	r30, r14
    1786:	82 85       	ldd	r24, Z+10	; 0x0a
    1788:	87 b9       	out	0x07, r24	; 7
  R_PORT = 0;                      /* set resistor port to low */
    178a:	15 b8       	out	0x05, r1	; 5
  R_DDR = 0;                       /* set resistor port to HiZ */
    178c:	14 b8       	out	0x04, r1	; 4
  U_Zero = ReadU(Probes.Pin_1);    /* get zero voltage (noise) */
    178e:	80 81       	ld	r24, Z
    1790:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    1794:	5c 01       	movw	r10, r24

  /* charge DUT with up to 500 pulses until it reaches 300mV */
  Pulses = 0;
    1796:	02 2d       	mov	r16, r2
    1798:	13 2d       	mov	r17, r3
  TempByte = 1;
    179a:	d4 2c       	mov	r13, r4
  while (TempByte)
  {
    Pulses++;
    179c:	0f 5f       	subi	r16, 0xFF	; 255
    179e:	1f 4f       	sbci	r17, 0xFF	; 255
    PullProbe(Probes.Rl_1, Mode);       /* charging pulse */
    17a0:	6c 2d       	mov	r22, r12
    17a2:	d7 01       	movw	r26, r14
    17a4:	13 96       	adiw	r26, 0x03	; 3
    17a6:	8c 91       	ld	r24, X
    17a8:	0e 94 6b 24 	call	0x48d6	; 0x48d6 <PullProbe>
    U_Cap = ReadU(Probes.Pin_1);        /* get voltage */
    17ac:	f7 01       	movw	r30, r14
    17ae:	80 81       	ld	r24, Z
    17b0:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>

    /* zero offset */
    if (U_Cap > U_Zero)            /* voltage higher than zero offset */
    17b4:	a8 16       	cp	r10, r24
    17b6:	b9 06       	cpc	r11, r25
    17b8:	08 f0       	brcs	.+2      	; 0x17bc <LargeCap+0xae>
    17ba:	cf c0       	rjmp	.+414    	; 0x195a <LargeCap+0x24c>
      U_Cap -= U_Zero;                  /* subtract zero offset */
    17bc:	9c 01       	movw	r18, r24
    17be:	2a 19       	sub	r18, r10
    17c0:	3b 09       	sbc	r19, r11
    17c2:	3d 83       	std	Y+5, r19	; 0x05
    17c4:	2c 83       	std	Y+4, r18	; 0x04
    else                           /* shouldn't happen but you never know */
      U_Cap = 0;                        /* assume 0V */

    /* end loop if charging is too slow */
    if ((Pulses == 126) && (U_Cap < 75)) TempByte = 0;
    17c6:	0e 37       	cpi	r16, 0x7E	; 126
    17c8:	11 05       	cpc	r17, r1
    17ca:	31 f4       	brne	.+12     	; 0x17d8 <LargeCap+0xca>
    17cc:	2b 34       	cpi	r18, 0x4B	; 75
    17ce:	31 05       	cpc	r19, r1
    17d0:	08 f0       	brcs	.+2      	; 0x17d4 <LargeCap+0xc6>
    17d2:	ca c0       	rjmp	.+404    	; 0x1968 <LargeCap+0x25a>
    17d4:	d7 2c       	mov	r13, r7
    17d6:	c8 c0       	rjmp	.+400    	; 0x1968 <LargeCap+0x25a>
    
    /* end loop if 300mV are reached */
    if (U_Cap >= 300) TempByte = 0;
    17d8:	4c 81       	ldd	r20, Y+4	; 0x04
    17da:	5d 81       	ldd	r21, Y+5	; 0x05
    17dc:	4c 32       	cpi	r20, 0x2C	; 44
    17de:	51 40       	sbci	r21, 0x01	; 1
    17e0:	20 f0       	brcs	.+8      	; 0x17ea <LargeCap+0xdc>
    17e2:	d7 2c       	mov	r13, r7
    17e4:	02 c0       	rjmp	.+4      	; 0x17ea <LargeCap+0xdc>

    /* zero offset */
    if (U_Cap > U_Zero)            /* voltage higher than zero offset */
      U_Cap -= U_Zero;                  /* subtract zero offset */
    else                           /* shouldn't happen but you never know */
      U_Cap = 0;                        /* assume 0V */
    17e6:	5c 82       	std	Y+4, r5	; 0x04
    17e8:	6d 82       	std	Y+5, r6	; 0x05
    
    /* end loop if 300mV are reached */
    if (U_Cap >= 300) TempByte = 0;

    /* end loop if maximum pulses are reached */
    if (Pulses == 500) TempByte = 0;
    17ea:	04 3f       	cpi	r16, 0xF4	; 244
    17ec:	81 e0       	ldi	r24, 0x01	; 1
    17ee:	18 07       	cpc	r17, r24
    17f0:	19 f4       	brne	.+6      	; 0x17f8 <LargeCap+0xea>
    17f2:	d7 2c       	mov	r13, r7
    17f4:	01 c0       	rjmp	.+2      	; 0x17f8 <LargeCap+0xea>

    /* end loop if charging is too slow */
    if ((Pulses == 126) && (U_Cap < 75)) TempByte = 0;
    
    /* end loop if 300mV are reached */
    if (U_Cap >= 300) TempByte = 0;
    17f6:	d7 2c       	mov	r13, r7

    /* end loop if maximum pulses are reached */
    if (Pulses == 500) TempByte = 0;

    wdt_reset();                        /* reset watchdog */
    17f8:	a8 95       	wdr
  U_Zero = ReadU(Probes.Pin_1);    /* get zero voltage (noise) */

  /* charge DUT with up to 500 pulses until it reaches 300mV */
  Pulses = 0;
  TempByte = 1;
  while (TempByte)
    17fa:	d1 10       	cpse	r13, r1
    17fc:	cf cf       	rjmp	.-98     	; 0x179c <LargeCap+0x8e>
    17fe:	2c 81       	ldd	r18, Y+4	; 0x04
    1800:	3d 81       	ldd	r19, Y+5	; 0x05
  {
    Pulses++;
    1802:	c8 01       	movw	r24, r16
    wdt_reset();                        /* reset watchdog */
  }

  /* if 300mV are not reached DUT isn't a cap or much too large (>100mF) */
  /* we can ignore that for mid-sized caps */
  if (U_Cap < 300)
    1804:	2c 32       	cpi	r18, 0x2C	; 44
    1806:	a1 e0       	ldi	r26, 0x01	; 1
    1808:	3a 07       	cpc	r19, r26
    180a:	08 f4       	brcc	.+2      	; 0x180e <LargeCap+0x100>
  {
    Flag = 1;
    180c:	49 82       	std	Y+1, r4	; 0x01
  }

  /* if 1300mV are reached with one pulse we got a small cap */
  if ((Pulses == 1) && (U_Cap > 1300))
    180e:	81 30       	cpi	r24, 0x01	; 1
    1810:	91 05       	cpc	r25, r1
    1812:	71 f4       	brne	.+28     	; 0x1830 <LargeCap+0x122>
    1814:	25 31       	cpi	r18, 0x15	; 21
    1816:	35 40       	sbci	r19, 0x05	; 5
    1818:	08 f4       	brcc	.+2      	; 0x181c <LargeCap+0x10e>
    181a:	ad c0       	rjmp	.+346    	; 0x1976 <LargeCap+0x268>
  {
    if (Mode & FLAG_10MS)                    /* 10ms pulses (>47F) */
    181c:	8c 2d       	mov	r24, r12
    181e:	80 71       	andi	r24, 0x10	; 16
    {
      Mode = FLAG_1MS | FLAG_PULLUP;         /* set mode to 1ms charging pulses (<47F) */
    1820:	0f 2e       	mov	r0, r31
    1822:	f9 e0       	ldi	r31, 0x09	; 9
    1824:	cf 2e       	mov	r12, r31
    1826:	f0 2d       	mov	r31, r0
  }

  /* if 1300mV are reached with one pulse we got a small cap */
  if ((Pulses == 1) && (U_Cap > 1300))
  {
    if (Mode & FLAG_10MS)                    /* 10ms pulses (>47F) */
    1828:	81 11       	cpse	r24, r1
    182a:	a3 cf       	rjmp	.-186    	; 0x1772 <LargeCap+0x64>
      Mode = FLAG_1MS | FLAG_PULLUP;         /* set mode to 1ms charging pulses (<47F) */
      goto large_cap;                        /* and re-run */
    }
    else                                     /* 1ms pulses (<47F) */
    {
      Flag = 2;                              /* signal low capacitance (<4.7F) */
    182c:	82 e0       	ldi	r24, 0x02	; 2
    182e:	e6 c0       	rjmp	.+460    	; 0x19fc <LargeCap+0x2ee>
  /* charge DUT with up to 500 pulses until it reaches 300mV */
  Pulses = 0;
  TempByte = 1;
  while (TempByte)
  {
    Pulses++;
    1830:	c8 01       	movw	r24, r16
   *  check if DUT sustains the charge and get the voltage drop
   *  - run the same time as before minus the 10ms charging time
   *  - this gives us the approximation of the self-discharging
   */

  if (Flag == 3)
    1832:	e9 81       	ldd	r30, Y+1	; 0x01
    1834:	e3 30       	cpi	r30, 0x03	; 3
    1836:	09 f0       	breq	.+2      	; 0x183a <LargeCap+0x12c>
    1838:	a4 c0       	rjmp	.+328    	; 0x1982 <LargeCap+0x274>
  {
    /* check self-discharging */
    TempInt = Pulses;
    while (TempInt > 0)
    183a:	89 2b       	or	r24, r25
    183c:	11 f4       	brne	.+4      	; 0x1842 <LargeCap+0x134>
    183e:	18 c0       	rjmp	.+48     	; 0x1870 <LargeCap+0x162>
  /* charge DUT with up to 500 pulses until it reaches 300mV */
  Pulses = 0;
  TempByte = 1;
  while (TempByte)
  {
    Pulses++;
    1840:	8c 01       	movw	r16, r24
    1842:	78 01       	movw	r14, r16
    /* check self-discharging */
    TempInt = Pulses;
    while (TempInt > 0)
    {
      TempInt--;                        /* descrease timeout */
      U_Drop = ReadU(Probes.Pin_1);     /* get voltage */
    1844:	0f 2e       	mov	r0, r31
    1846:	ff e8       	ldi	r31, 0x8F	; 143
    1848:	8f 2e       	mov	r8, r31
    184a:	f1 e0       	ldi	r31, 0x01	; 1
    184c:	9f 2e       	mov	r9, r31
    184e:	f0 2d       	mov	r31, r0
  {
    /* check self-discharging */
    TempInt = Pulses;
    while (TempInt > 0)
    {
      TempInt--;                        /* descrease timeout */
    1850:	f1 e0       	ldi	r31, 0x01	; 1
    1852:	ef 1a       	sub	r14, r31
    1854:	f1 08       	sbc	r15, r1
      U_Drop = ReadU(Probes.Pin_1);     /* get voltage */
    1856:	d4 01       	movw	r26, r8
    1858:	8c 91       	ld	r24, X
    185a:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
      U_Drop -= U_Zero;                 /* zero offset */
      wdt_reset();                      /* reset watchdog */
    185e:	a8 95       	wdr

  if (Flag == 3)
  {
    /* check self-discharging */
    TempInt = Pulses;
    while (TempInt > 0)
    1860:	e1 14       	cp	r14, r1
    1862:	f1 04       	cpc	r15, r1
    1864:	a9 f7       	brne	.-22     	; 0x1850 <LargeCap+0x142>
    {
      TempInt--;                        /* descrease timeout */
      U_Drop = ReadU(Probes.Pin_1);     /* get voltage */
      U_Drop -= U_Zero;                 /* zero offset */
    1866:	8a 19       	sub	r24, r10
    1868:	9b 09       	sbc	r25, r11
    186a:	2c 81       	ldd	r18, Y+4	; 0x04
    186c:	3d 81       	ldd	r19, Y+5	; 0x05
    186e:	04 c0       	rjmp	.+8      	; 0x1878 <LargeCap+0x16a>

  if (Flag == 3)
  {
    /* check self-discharging */
    TempInt = Pulses;
    while (TempInt > 0)
    1870:	2c 81       	ldd	r18, Y+4	; 0x04
    1872:	3d 81       	ldd	r19, Y+5	; 0x05
  int8_t            Scale;         /* capacitance scale */
  uint16_t          TempInt;       /* temp. value */
  uint16_t          Pulses;        /* number of charging pulses */
  uint16_t          U_Zero;        /* voltage before charging */
  uint16_t          U_Cap;         /* voltage of DUT */
  uint16_t          U_Drop = 0;    /* voltage drop */
    1874:	80 e0       	ldi	r24, 0x00	; 0
    1876:	90 e0       	ldi	r25, 0x00	; 0
      U_Drop -= U_Zero;                 /* zero offset */
      wdt_reset();                      /* reset watchdog */
    }

    /* calculate voltage drop */
    if (U_Cap > U_Drop) U_Drop = U_Cap - U_Drop;
    1878:	82 17       	cp	r24, r18
    187a:	93 07       	cpc	r25, r19
    187c:	88 f4       	brcc	.+34     	; 0x18a0 <LargeCap+0x192>
    187e:	f9 01       	movw	r30, r18
    1880:	e8 1b       	sub	r30, r24
    1882:	f9 0b       	sbc	r31, r25
    1884:	cf 01       	movw	r24, r30
    else U_Drop = 0;

    /* if voltage drop is too large consider DUT not to be a cap */
    if (U_Drop > 100) Flag = 0;
    1886:	e5 36       	cpi	r30, 0x65	; 101
    1888:	f1 05       	cpc	r31, r1
    188a:	08 f0       	brcs	.+2      	; 0x188e <LargeCap+0x180>
    188c:	79 c0       	rjmp	.+242    	; 0x1980 <LargeCap+0x272>
    188e:	0a c0       	rjmp	.+20     	; 0x18a4 <LargeCap+0x196>
   *  calculate capacitance
   *  - use factor from pre-calculated LargeCap_table
   *  - ignore NV.CapZero since it's in the pF range
   */

  if (Flag == 3)
    1890:	f9 81       	ldd	r31, Y+1	; 0x01
    1892:	f3 30       	cpi	r31, 0x03	; 3
    1894:	09 f0       	breq	.+2      	; 0x1898 <LargeCap+0x18a>
    1896:	5f c0       	rjmp	.+190    	; 0x1956 <LargeCap+0x248>
  /* charge DUT with up to 500 pulses until it reaches 300mV */
  Pulses = 0;
  TempByte = 1;
  while (TempByte)
  {
    Pulses++;
    1898:	8c 01       	movw	r16, r24
    189a:	80 e0       	ldi	r24, 0x00	; 0
    189c:	90 e0       	ldi	r25, 0x00	; 0
    189e:	02 c0       	rjmp	.+4      	; 0x18a4 <LargeCap+0x196>
    18a0:	80 e0       	ldi	r24, 0x00	; 0
    18a2:	90 e0       	ldi	r25, 0x00	; 0

  if (Flag == 3)
  {
    Scale = -9;                           /* factor is scaled to nF */
    /* get interpolated factor from table */
    Raw = GetFactor(U_Cap + U_Drop, TABLE_LARGE_CAP);
    18a4:	62 e0       	ldi	r22, 0x02	; 2
    18a6:	2c 81       	ldd	r18, Y+4	; 0x04
    18a8:	3d 81       	ldd	r19, Y+5	; 0x05
    18aa:	82 0f       	add	r24, r18
    18ac:	93 1f       	adc	r25, r19
    18ae:	0e 94 90 24 	call	0x4920	; 0x4920 <GetFactor>
    Raw *= Pulses;                        /* C = pulses * factor */
    18b2:	98 01       	movw	r18, r16
    18b4:	dc 01       	movw	r26, r24
    18b6:	0e 94 cd 36 	call	0x6d9a	; 0x6d9a <__umulhisi3>
    18ba:	4b 01       	movw	r8, r22
    18bc:	5c 01       	movw	r10, r24
    if (Mode & FLAG_10MS) Raw *= 10;      /* *10 for 10ms charging pulses */
    18be:	8c 2d       	mov	r24, r12
    18c0:	80 71       	andi	r24, 0x10	; 16
    18c2:	09 f4       	brne	.+2      	; 0x18c6 <LargeCap+0x1b8>
    18c4:	6e c0       	rjmp	.+220    	; 0x19a2 <LargeCap+0x294>
    18c6:	88 0c       	add	r8, r8
    18c8:	99 1c       	adc	r9, r9
    18ca:	aa 1c       	adc	r10, r10
    18cc:	bb 1c       	adc	r11, r11
    18ce:	d5 01       	movw	r26, r10
    18d0:	c4 01       	movw	r24, r8
    18d2:	88 0f       	add	r24, r24
    18d4:	99 1f       	adc	r25, r25
    18d6:	aa 1f       	adc	r26, r26
    18d8:	bb 1f       	adc	r27, r27
    18da:	88 0f       	add	r24, r24
    18dc:	99 1f       	adc	r25, r25
    18de:	aa 1f       	adc	r26, r26
    18e0:	bb 1f       	adc	r27, r27
    18e2:	a5 01       	movw	r20, r10
    18e4:	94 01       	movw	r18, r8
    18e6:	28 0f       	add	r18, r24
    18e8:	39 1f       	adc	r19, r25
    18ea:	4a 1f       	adc	r20, r26
    18ec:	5b 1f       	adc	r21, r27
    18ee:	49 01       	movw	r8, r18
    18f0:	5a 01       	movw	r10, r20

    if (Raw > (UINT32_MAX / 1000))        /* scale down if C >4.3mF */
    18f2:	28 33       	cpi	r18, 0x38	; 56
    18f4:	69 e8       	ldi	r22, 0x89	; 137
    18f6:	36 07       	cpc	r19, r22
    18f8:	61 e4       	ldi	r22, 0x41	; 65
    18fa:	46 07       	cpc	r20, r22
    18fc:	51 05       	cpc	r21, r1
    18fe:	08 f0       	brcs	.+2      	; 0x1902 <LargeCap+0x1f4>
    1900:	59 c0       	rjmp	.+178    	; 0x19b4 <LargeCap+0x2a6>
    1902:	41 c0       	rjmp	.+130    	; 0x1986 <LargeCap+0x278>

    Value = Raw;                          /* copy raw value */

    /* it seems that we got a systematic error */
    Value *= 100;
    if (Mode & FLAG_10MS) Value /= 109;   /* -9% for large cap */
    1904:	2d e6       	ldi	r18, 0x6D	; 109
    1906:	30 e0       	ldi	r19, 0x00	; 0
    1908:	40 e0       	ldi	r20, 0x00	; 0
    190a:	50 e0       	ldi	r21, 0x00	; 0
    190c:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    1910:	06 c0       	rjmp	.+12     	; 0x191e <LargeCap+0x210>
    else Value /= 104;                    /* -4% for mid cap */
    1912:	28 e6       	ldi	r18, 0x68	; 104
    1914:	30 e0       	ldi	r19, 0x00	; 0
    1916:	40 e0       	ldi	r20, 0x00	; 0
    1918:	50 e0       	ldi	r21, 0x00	; 0
    191a:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>

    /* copy data */
    Cap->A = Probes.Pin_2;    /* pull-down probe pin */
    191e:	ef e8       	ldi	r30, 0x8F	; 143
    1920:	f1 e0       	ldi	r31, 0x01	; 1
    1922:	81 81       	ldd	r24, Z+1	; 0x01
    1924:	aa 81       	ldd	r26, Y+2	; 0x02
    1926:	bb 81       	ldd	r27, Y+3	; 0x03
    1928:	8c 93       	st	X, r24
    Cap->B = Probes.Pin_1;    /* pull-up probe pin */
    192a:	80 81       	ld	r24, Z
    192c:	11 96       	adiw	r26, 0x01	; 1
    192e:	8c 93       	st	X, r24
    1930:	11 97       	sbiw	r26, 0x01	; 1
    Cap->Scale = Scale;       /* -9 or -6 */
    1932:	12 96       	adiw	r26, 0x02	; 2
    1934:	1c 93       	st	X, r17
    1936:	12 97       	sbiw	r26, 0x02	; 2
    Cap->Raw = Raw;
    1938:	fd 01       	movw	r30, r26
    193a:	87 82       	std	Z+7, r8	; 0x07
    193c:	90 86       	std	Z+8, r9	; 0x08
    193e:	a1 86       	std	Z+9, r10	; 0x09
    1940:	b2 86       	std	Z+10, r11	; 0x0a
    Cap->Value = Value;       /* max. 4.3*10^6nF or 100*10^3F */ 
    1942:	13 96       	adiw	r26, 0x03	; 3
    1944:	2d 93       	st	X+, r18
    1946:	3d 93       	st	X+, r19
    1948:	4d 93       	st	X+, r20
    194a:	5c 93       	st	X, r21
    194c:	16 97       	sbiw	r26, 0x06	; 6
  }

  return Flag;
    194e:	83 e0       	ldi	r24, 0x03	; 3
    1950:	55 c0       	rjmp	.+170    	; 0x19fc <LargeCap+0x2ee>

large_cap:

  /* prepare probes */
  DischargeProbes();                    /* try to discharge probes */
  if (Check.Found == COMP_ERROR) return 0;     /* skip on error */
    1952:	80 e0       	ldi	r24, 0x00	; 0
    1954:	53 c0       	rjmp	.+166    	; 0x19fc <LargeCap+0x2ee>
    1956:	89 81       	ldd	r24, Y+1	; 0x01
    1958:	51 c0       	rjmp	.+162    	; 0x19fc <LargeCap+0x2ee>
      U_Cap -= U_Zero;                  /* subtract zero offset */
    else                           /* shouldn't happen but you never know */
      U_Cap = 0;                        /* assume 0V */

    /* end loop if charging is too slow */
    if ((Pulses == 126) && (U_Cap < 75)) TempByte = 0;
    195a:	0e 37       	cpi	r16, 0x7E	; 126
    195c:	11 05       	cpc	r17, r1
    195e:	09 f0       	breq	.+2      	; 0x1962 <LargeCap+0x254>
    1960:	42 cf       	rjmp	.-380    	; 0x17e6 <LargeCap+0xd8>

    /* zero offset */
    if (U_Cap > U_Zero)            /* voltage higher than zero offset */
      U_Cap -= U_Zero;                  /* subtract zero offset */
    else                           /* shouldn't happen but you never know */
      U_Cap = 0;                        /* assume 0V */
    1962:	5c 82       	std	Y+4, r5	; 0x04
    1964:	6d 82       	std	Y+5, r6	; 0x05

    /* end loop if charging is too slow */
    if ((Pulses == 126) && (U_Cap < 75)) TempByte = 0;
    1966:	d7 2c       	mov	r13, r7
    
    /* end loop if 300mV are reached */
    if (U_Cap >= 300) TempByte = 0;
    1968:	ec 81       	ldd	r30, Y+4	; 0x04
    196a:	fd 81       	ldd	r31, Y+5	; 0x05
    196c:	ec 32       	cpi	r30, 0x2C	; 44
    196e:	f1 40       	sbci	r31, 0x01	; 1
    1970:	08 f0       	brcs	.+2      	; 0x1974 <LargeCap+0x266>
    1972:	41 cf       	rjmp	.-382    	; 0x17f6 <LargeCap+0xe8>
    1974:	3a cf       	rjmp	.-396    	; 0x17ea <LargeCap+0xdc>
   *  check if DUT sustains the charge and get the voltage drop
   *  - run the same time as before minus the 10ms charging time
   *  - this gives us the approximation of the self-discharging
   */

  if (Flag == 3)
    1976:	39 81       	ldd	r19, Y+1	; 0x01
    1978:	33 30       	cpi	r19, 0x03	; 3
    197a:	09 f4       	brne	.+2      	; 0x197e <LargeCap+0x270>
    197c:	61 cf       	rjmp	.-318    	; 0x1840 <LargeCap+0x132>
    197e:	88 cf       	rjmp	.-240    	; 0x1890 <LargeCap+0x182>
    /* calculate voltage drop */
    if (U_Cap > U_Drop) U_Drop = U_Cap - U_Drop;
    else U_Drop = 0;

    /* if voltage drop is too large consider DUT not to be a cap */
    if (U_Drop > 100) Flag = 0;
    1980:	19 82       	std	Y+1, r1	; 0x01
    1982:	89 81       	ldd	r24, Y+1	; 0x01
    1984:	3b c0       	rjmp	.+118    	; 0x19fc <LargeCap+0x2ee>
    }

    Value = Raw;                          /* copy raw value */

    /* it seems that we got a systematic error */
    Value *= 100;
    1986:	a4 e6       	ldi	r26, 0x64	; 100
    1988:	b0 e0       	ldi	r27, 0x00	; 0
    198a:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
   *  - ignore NV.CapZero since it's in the pF range
   */

  if (Flag == 3)
  {
    Scale = -9;                           /* factor is scaled to nF */
    198e:	17 ef       	ldi	r17, 0xF7	; 247
    1990:	b9 cf       	rjmp	.-142    	; 0x1904 <LargeCap+0x1f6>
    }

    Value = Raw;                          /* copy raw value */

    /* it seems that we got a systematic error */
    Value *= 100;
    1992:	a4 e6       	ldi	r26, 0x64	; 100
    1994:	b0 e0       	ldi	r27, 0x00	; 0
    1996:	a5 01       	movw	r20, r10
    1998:	94 01       	movw	r18, r8
    199a:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
   *  - ignore NV.CapZero since it's in the pF range
   */

  if (Flag == 3)
  {
    Scale = -9;                           /* factor is scaled to nF */
    199e:	17 ef       	ldi	r17, 0xF7	; 247
    19a0:	b8 cf       	rjmp	.-144    	; 0x1912 <LargeCap+0x204>
    /* get interpolated factor from table */
    Raw = GetFactor(U_Cap + U_Drop, TABLE_LARGE_CAP);
    Raw *= Pulses;                        /* C = pulses * factor */
    if (Mode & FLAG_10MS) Raw *= 10;      /* *10 for 10ms charging pulses */

    if (Raw > (UINT32_MAX / 1000))        /* scale down if C >4.3mF */
    19a2:	48 e3       	ldi	r20, 0x38	; 56
    19a4:	84 16       	cp	r8, r20
    19a6:	49 e8       	ldi	r20, 0x89	; 137
    19a8:	94 06       	cpc	r9, r20
    19aa:	41 e4       	ldi	r20, 0x41	; 65
    19ac:	a4 06       	cpc	r10, r20
    19ae:	b1 04       	cpc	r11, r1
    19b0:	98 f4       	brcc	.+38     	; 0x19d8 <LargeCap+0x2ca>
    19b2:	ef cf       	rjmp	.-34     	; 0x1992 <LargeCap+0x284>
    {
      Raw /= 1000;                        /* scale down by 10^3 */
    19b4:	ca 01       	movw	r24, r20
    19b6:	b9 01       	movw	r22, r18
    19b8:	28 ee       	ldi	r18, 0xE8	; 232
    19ba:	33 e0       	ldi	r19, 0x03	; 3
    19bc:	40 e0       	ldi	r20, 0x00	; 0
    19be:	50 e0       	ldi	r21, 0x00	; 0
    19c0:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    19c4:	82 2e       	mov	r8, r18
    19c6:	93 2e       	mov	r9, r19
    19c8:	a4 2e       	mov	r10, r20
    19ca:	b5 2e       	mov	r11, r21
    }

    Value = Raw;                          /* copy raw value */

    /* it seems that we got a systematic error */
    Value *= 100;
    19cc:	a4 e6       	ldi	r26, 0x64	; 100
    19ce:	b0 e0       	ldi	r27, 0x00	; 0
    19d0:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
    if (Mode & FLAG_10MS) Raw *= 10;      /* *10 for 10ms charging pulses */

    if (Raw > (UINT32_MAX / 1000))        /* scale down if C >4.3mF */
    {
      Raw /= 1000;                        /* scale down by 10^3 */
      Scale += 3;                         /* add 3 to the exponent */
    19d4:	1a ef       	ldi	r17, 0xFA	; 250
    19d6:	96 cf       	rjmp	.-212    	; 0x1904 <LargeCap+0x1f6>
    Raw *= Pulses;                        /* C = pulses * factor */
    if (Mode & FLAG_10MS) Raw *= 10;      /* *10 for 10ms charging pulses */

    if (Raw > (UINT32_MAX / 1000))        /* scale down if C >4.3mF */
    {
      Raw /= 1000;                        /* scale down by 10^3 */
    19d8:	c5 01       	movw	r24, r10
    19da:	b4 01       	movw	r22, r8
    19dc:	28 ee       	ldi	r18, 0xE8	; 232
    19de:	33 e0       	ldi	r19, 0x03	; 3
    19e0:	40 e0       	ldi	r20, 0x00	; 0
    19e2:	50 e0       	ldi	r21, 0x00	; 0
    19e4:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    19e8:	82 2e       	mov	r8, r18
    19ea:	93 2e       	mov	r9, r19
    19ec:	a4 2e       	mov	r10, r20
    19ee:	b5 2e       	mov	r11, r21
    }

    Value = Raw;                          /* copy raw value */

    /* it seems that we got a systematic error */
    Value *= 100;
    19f0:	a4 e6       	ldi	r26, 0x64	; 100
    19f2:	b0 e0       	ldi	r27, 0x00	; 0
    19f4:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
    if (Mode & FLAG_10MS) Raw *= 10;      /* *10 for 10ms charging pulses */

    if (Raw > (UINT32_MAX / 1000))        /* scale down if C >4.3mF */
    {
      Raw /= 1000;                        /* scale down by 10^3 */
      Scale += 3;                         /* add 3 to the exponent */
    19f8:	1a ef       	ldi	r17, 0xFA	; 250
    19fa:	8b cf       	rjmp	.-234    	; 0x1912 <LargeCap+0x204>
    Cap->Raw = Raw;
    Cap->Value = Value;       /* max. 4.3*10^6nF or 100*10^3F */ 
  }

  return Flag;
}
    19fc:	0f 90       	pop	r0
    19fe:	0f 90       	pop	r0
    1a00:	0f 90       	pop	r0
    1a02:	0f 90       	pop	r0
    1a04:	0f 90       	pop	r0
    1a06:	df 91       	pop	r29
    1a08:	cf 91       	pop	r28
    1a0a:	1f 91       	pop	r17
    1a0c:	0f 91       	pop	r16
    1a0e:	ff 90       	pop	r15
    1a10:	ef 90       	pop	r14
    1a12:	df 90       	pop	r13
    1a14:	cf 90       	pop	r12
    1a16:	bf 90       	pop	r11
    1a18:	af 90       	pop	r10
    1a1a:	9f 90       	pop	r9
    1a1c:	8f 90       	pop	r8
    1a1e:	7f 90       	pop	r7
    1a20:	6f 90       	pop	r6
    1a22:	5f 90       	pop	r5
    1a24:	4f 90       	pop	r4
    1a26:	3f 90       	pop	r3
    1a28:	2f 90       	pop	r2
    1a2a:	08 95       	ret

00001a2c <SmallCap>:
 *  - 1 if capacitance is too high
 *  - 0 on any problem
 */

uint8_t SmallCap(Capacitor_Type *Cap)
{
    1a2c:	8f 92       	push	r8
    1a2e:	9f 92       	push	r9
    1a30:	af 92       	push	r10
    1a32:	bf 92       	push	r11
    1a34:	cf 92       	push	r12
    1a36:	df 92       	push	r13
    1a38:	ef 92       	push	r14
    1a3a:	ff 92       	push	r15
    1a3c:	0f 93       	push	r16
    1a3e:	1f 93       	push	r17
    1a40:	cf 93       	push	r28
    1a42:	df 93       	push	r29
    1a44:	4c 01       	movw	r8, r24
  /*
   *  init hardware
   */

  /* prepare probes */
  DischargeProbes();                    /* try to discharge probes */
    1a46:	0e 94 a3 23 	call	0x4746	; 0x4746 <DischargeProbes>
  if (Check.Found == COMP_ERROR) return 0;     /* skip on error */
    1a4a:	80 91 09 01 	lds	r24, 0x0109
    1a4e:	81 30       	cpi	r24, 0x01	; 1
    1a50:	09 f4       	brne	.+2      	; 0x1a54 <SmallCap+0x28>
    1a52:	28 c1       	rjmp	.+592    	; 0x1ca4 <SmallCap+0x278>

  /* set probes: Gnd -- all probes / Gnd -- Rh -- probe-1 */
  R_PORT = 0;                           /* set resistor port to low */
    1a54:	15 b8       	out	0x05, r1	; 5
  /* set ADC probe pins to output mode */
  ADC_DDR = (1 << TP1) | (1 << TP2) | (1 << TP3);
    1a56:	97 e0       	ldi	r25, 0x07	; 7
    1a58:	97 b9       	out	0x07, r25	; 7
  ADC_PORT = 0;                         /* set ADC port to low */
    1a5a:	18 b8       	out	0x08, r1	; 8
  R_DDR = Probes.Rh_1;                  /* pull-down probe-1 via Rh */
    1a5c:	ef e8       	ldi	r30, 0x8F	; 143
    1a5e:	f1 e0       	ldi	r31, 0x01	; 1
    1a60:	84 81       	ldd	r24, Z+4	; 0x04
    1a62:	84 b9       	out	0x04, r24	; 4

  /* setup analog comparator */
  ADCSRB = (1 << ACME);                 /* use ADC multiplexer as negative input */
    1a64:	80 e4       	ldi	r24, 0x40	; 64
    1a66:	80 93 7b 00 	sts	0x007B, r24
  ACSR =  (1 << ACBG) | (1 << ACIC);    /* use bandgap as positive input, trigger timer1 */
    1a6a:	84 e4       	ldi	r24, 0x44	; 68
    1a6c:	80 bf       	out	0x30, r24	; 48
  ADMUX = (1 << REFS0) | Probes.Pin_1;  /* switch ADC multiplexer to probe 1 */
    1a6e:	80 81       	ld	r24, Z
    1a70:	80 64       	ori	r24, 0x40	; 64
    1a72:	80 93 7c 00 	sts	0x007C, r24
                                        /* and set AREF to Vcc */
  ADCSRA = ADC_CLOCK_DIV;               /* disable ADC, but keep clock dividers */
    1a76:	90 93 7a 00 	sts	0x007A, r25
    1a7a:	8f e1       	ldi	r24, 0x1F	; 31
    1a7c:	93 e0       	ldi	r25, 0x03	; 3
    1a7e:	01 97       	sbiw	r24, 0x01	; 1
    1a80:	f1 f7       	brne	.-4      	; 0x1a7e <SmallCap+0x52>
    1a82:	00 c0       	rjmp	.+0      	; 0x1a84 <SmallCap+0x58>
    1a84:	00 00       	nop
  _delay_us(200);

  /* setup timer */
  TCCR1A = 0;                           /* set default mode */
    1a86:	10 92 80 00 	sts	0x0080, r1
  TCCR1B = 0;                           /* set more timer modes */
    1a8a:	10 92 81 00 	sts	0x0081, r1
  /* timer stopped, falling edge detection, noise canceler disabled */
  TCNT1 = 0;                            /* set Counter1 to 0 */
    1a8e:	10 92 85 00 	sts	0x0085, r1
    1a92:	10 92 84 00 	sts	0x0084, r1
  /* clear all flags (input capture, compare A & B, overflow */
  TIFR1 = (1 << ICF1) | (1 << OCF1B) | (1 << OCF1A) | (1 << TOV1);
    1a96:	87 e2       	ldi	r24, 0x27	; 39
    1a98:	86 bb       	out	0x16, r24	; 22
  R_PORT = Probes.Rh_1;                 /* pull-up probe-1 via Rh */  
    1a9a:	84 81       	ldd	r24, Z+4	; 0x04
    1a9c:	85 b9       	out	0x05, r24	; 5
                                        
  /* enable timer */
  if (Check.Found == COMP_FET)
    1a9e:	80 91 09 01 	lds	r24, 0x0109
    1aa2:	86 31       	cpi	r24, 0x16	; 22
    1aa4:	61 f4       	brne	.+24     	; 0x1abe <SmallCap+0x92>
  {
    /* keep all probe pins pulled down but probe-1 */
    TempByte = (((1 << TP1) | (1 << TP2) | (1 << TP3)) & ~(1 << Probes.Pin_1));    
    1aa6:	81 e0       	ldi	r24, 0x01	; 1
    1aa8:	90 e0       	ldi	r25, 0x00	; 0
    1aaa:	00 90 8f 01 	lds	r0, 0x018F
    1aae:	02 c0       	rjmp	.+4      	; 0x1ab4 <SmallCap+0x88>
    1ab0:	88 0f       	add	r24, r24
    1ab2:	99 1f       	adc	r25, r25
    1ab4:	0a 94       	dec	r0
    1ab6:	e2 f7       	brpl	.-8      	; 0x1ab0 <SmallCap+0x84>
    1ab8:	80 95       	com	r24
    1aba:	87 70       	andi	r24, 0x07	; 7
    1abc:	02 c0       	rjmp	.+4      	; 0x1ac2 <SmallCap+0x96>
  }
  else
  {
    TempByte = Probes.ADC_2;            /* keep just probe-1 pulled down */
    1abe:	80 91 99 01 	lds	r24, 0x0199
  }

  /* start timer by setting clock prescaler (1/1 clock divider) */
  TCCR1B = (1 << CS10);
    1ac2:	91 e0       	ldi	r25, 0x01	; 1
    1ac4:	90 93 81 00 	sts	0x0081, r25
  ADC_DDR = TempByte;                   /* start charging DUT */
    1ac8:	87 b9       	out	0x07, r24	; 7
   *  Remark:
   *  The analog comparator has an Input Leakage Current of -50nA up to 50nA 
   *  at Vcc/2. The Input Offset is <10mV at Vcc/2.
   */

  Ticks2 = 0;                           /* reset timer overflow counter */
    1aca:	e1 2c       	mov	r14, r1
    1acc:	f1 2c       	mov	r15, r1

     /* detect timer overflow by checking the overflow flag */
     if (TempByte & (1 << TOV1))
     {
       /* happens at 65.536ms for 1MHz or 8.192ms for 8MHz */
       TIFR1 = (1 << TOV1);             /* reset flag */
    1ace:	81 e0       	ldi	r24, 0x01	; 1
   *  - detect timer overflows
   */

   while (1)
   {
     TempByte = TIFR1;                  /* get timer1 flags */
    1ad0:	96 b3       	in	r25, 0x16	; 22

     /* end loop if input capture flag is set (= same voltage) */
     if (TempByte & (1 << ICF1)) break;
    1ad2:	95 fd       	sbrc	r25, 5
    1ad4:	0d c0       	rjmp	.+26     	; 0x1af0 <SmallCap+0xc4>

     /* detect timer overflow by checking the overflow flag */
     if (TempByte & (1 << TOV1))
    1ad6:	90 ff       	sbrs	r25, 0
    1ad8:	fb cf       	rjmp	.-10     	; 0x1ad0 <SmallCap+0xa4>
     {
       /* happens at 65.536ms for 1MHz or 8.192ms for 8MHz */
       TIFR1 = (1 << TOV1);             /* reset flag */
    1ada:	86 bb       	out	0x16, r24	; 22
       wdt_reset();                     /* reset watchdog */
    1adc:	a8 95       	wdr
       Ticks2++;                        /* increase overflow counter */
    1ade:	9f ef       	ldi	r25, 0xFF	; 255
    1ae0:	e9 1a       	sub	r14, r25
    1ae2:	f9 0a       	sbc	r15, r25

       /* end loop if charging takes too long (13.1s) */
       if (Ticks2 == (CPU_FREQ / 5000)) break;
    1ae4:	a0 e8       	ldi	r26, 0x80	; 128
    1ae6:	ea 16       	cp	r14, r26
    1ae8:	ac e0       	ldi	r26, 0x0C	; 12
    1aea:	fa 06       	cpc	r15, r26
    1aec:	89 f7       	brne	.-30     	; 0x1ad0 <SmallCap+0xa4>
    1aee:	e2 c0       	rjmp	.+452    	; 0x1cb4 <SmallCap+0x288>
     }
   }

  /* stop counter */
  TCCR1B = 0;                           /* stop timer */
    1af0:	10 92 81 00 	sts	0x0081, r1
  TIFR1 = (1 << ICF1);                  /* reset Input Capture flag */
    1af4:	80 e2       	ldi	r24, 0x20	; 32
    1af6:	86 bb       	out	0x16, r24	; 22

  Ticks = ICR1;                         /* get counter value */
    1af8:	c0 90 86 00 	lds	r12, 0x0086
    1afc:	d0 90 87 00 	lds	r13, 0x0087

  /* disable charging */
  R_DDR = 0;                  /* set resistor port to HiZ mode */
    1b00:	14 b8       	out	0x04, r1	; 4

  /* catch missed timer overflow */
  if ((TCNT1 > Ticks) && (TempByte & (1 << TOV1)))
    1b02:	20 91 84 00 	lds	r18, 0x0084
    1b06:	30 91 85 00 	lds	r19, 0x0085
    1b0a:	c2 16       	cp	r12, r18
    1b0c:	d3 06       	cpc	r13, r19
    1b0e:	38 f4       	brcc	.+14     	; 0x1b1e <SmallCap+0xf2>
    1b10:	90 ff       	sbrs	r25, 0
    1b12:	05 c0       	rjmp	.+10     	; 0x1b1e <SmallCap+0xf2>
  {
    TIFR1 = (1 << TOV1);                /* reset overflow flag */
    1b14:	81 e0       	ldi	r24, 0x01	; 1
    1b16:	86 bb       	out	0x16, r24	; 22
    Ticks2++;                           /* increase overflow counter */
    1b18:	bf ef       	ldi	r27, 0xFF	; 255
    1b1a:	eb 1a       	sub	r14, r27
    1b1c:	fb 0a       	sbc	r15, r27
  }

  /* enable ADC again */
  ADCSRA = (1 << ADEN) | (1 << ADIF) | ADC_CLOCK_DIV;
    1b1e:	87 e9       	ldi	r24, 0x97	; 151
    1b20:	80 93 7a 00 	sts	0x007A, r24

  /* get voltage of DUT */
  U_c = ReadU(Probes.Pin_1);       /* get voltage of cap */
    1b24:	cf e8       	ldi	r28, 0x8F	; 143
    1b26:	d1 e0       	ldi	r29, 0x01	; 1
    1b28:	88 81       	ld	r24, Y
    1b2a:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    1b2e:	8c 01       	movw	r16, r24

  /* start discharging DUT */
  R_PORT = 0;                      /* pull down probe-2 via Rh */
    1b30:	15 b8       	out	0x05, r1	; 5
  R_DDR = Probes.Rh_1;             /* enable Rh for probe-1 again */
    1b32:	8c 81       	ldd	r24, Y+4	; 0x04
    1b34:	84 b9       	out	0x04, r24	; 4

  /* skip measurement if charging took too long */
  if (Ticks2 >= (CPU_FREQ / 5000)) Flag = 1;
    1b36:	c0 e8       	ldi	r28, 0x80	; 128
    1b38:	ec 16       	cp	r14, r28
    1b3a:	cc e0       	ldi	r28, 0x0C	; 12
    1b3c:	fc 06       	cpc	r15, r28
    1b3e:	08 f4       	brcc	.+2      	; 0x1b42 <SmallCap+0x116>
    1b40:	cb c0       	rjmp	.+406    	; 0x1cd8 <SmallCap+0x2ac>
    1b42:	b2 c0       	rjmp	.+356    	; 0x1ca8 <SmallCap+0x27c>
  if (Flag == 3)
  {
    /*  combine both counter values */
    Raw = (uint32_t)Ticks;                /* set lower 16 bits */
    Raw |= (uint32_t)Ticks2 << 16;        /* set upper 16 bits */
    if (Raw > 2) Raw -= 2;                /* subtract processing time overhead */
    1b44:	d2 e0       	ldi	r29, 0x02	; 2
    1b46:	cd 1a       	sub	r12, r29
    1b48:	d1 08       	sbc	r13, r1
    1b4a:	e1 08       	sbc	r14, r1
    1b4c:	f1 08       	sbc	r15, r1

    Scale = -12;                          /* default factor is for pF scale */
    if (Raw > (UINT32_MAX / 1000))        /* prevent overflow (4.3*10^6) */
    1b4e:	e8 e3       	ldi	r30, 0x38	; 56
    1b50:	ce 16       	cp	r12, r30
    1b52:	e9 e8       	ldi	r30, 0x89	; 137
    1b54:	de 06       	cpc	r13, r30
    1b56:	e1 e4       	ldi	r30, 0x41	; 65
    1b58:	ee 06       	cpc	r14, r30
    1b5a:	f1 04       	cpc	r15, r1
    1b5c:	08 f4       	brcc	.+2      	; 0x1b60 <SmallCap+0x134>
    1b5e:	d3 c0       	rjmp	.+422    	; 0x1d06 <SmallCap+0x2da>
    {
      Raw /= 1000;                        /* scale down by 10^3 */
    1b60:	c7 01       	movw	r24, r14
    1b62:	b6 01       	movw	r22, r12
    1b64:	28 ee       	ldi	r18, 0xE8	; 232
    1b66:	33 e0       	ldi	r19, 0x03	; 3
    1b68:	40 e0       	ldi	r20, 0x00	; 0
    1b6a:	50 e0       	ldi	r21, 0x00	; 0
    1b6c:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    1b70:	69 01       	movw	r12, r18
    1b72:	7a 01       	movw	r14, r20
      Scale += 3;                         /* add 3 to the exponent (nF) */
    }

    /* multiply with factor from table */
    Raw *= GetFactor(Config.Bandgap + NV.CompOffset, TABLE_SMALL_CAP);
    1b74:	20 91 a3 01 	lds	r18, 0x01A3
    1b78:	80 91 af 01 	lds	r24, 0x01AF
    1b7c:	90 91 b0 01 	lds	r25, 0x01B0
    1b80:	61 e0       	ldi	r22, 0x01	; 1
    1b82:	82 0f       	add	r24, r18
    1b84:	91 1d       	adc	r25, r1
    1b86:	27 fd       	sbrc	r18, 7
    1b88:	9a 95       	dec	r25
    1b8a:	0e 94 90 24 	call	0x4920	; 0x4920 <GetFactor>
    1b8e:	dc 01       	movw	r26, r24
    1b90:	a7 01       	movw	r20, r14
    1b92:	96 01       	movw	r18, r12
    1b94:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>

    /* divide by CPU frequency to get the time and multiply with table scale */
    Raw /= (CPU_FREQ / 10000);
    1b98:	20 e4       	ldi	r18, 0x40	; 64
    1b9a:	36 e0       	ldi	r19, 0x06	; 6
    1b9c:	40 e0       	ldi	r20, 0x00	; 0
    1b9e:	50 e0       	ldi	r21, 0x00	; 0
    1ba0:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
        Value = 0;                        /* set value to 0 */
      }
    }

    /* copy data */
    Cap->A = Probes.Pin_2;    /* pull-down probe pin */
    1ba4:	ef e8       	ldi	r30, 0x8F	; 143
    1ba6:	f1 e0       	ldi	r31, 0x01	; 1
    1ba8:	81 81       	ldd	r24, Z+1	; 0x01
    1baa:	d4 01       	movw	r26, r8
    1bac:	8c 93       	st	X, r24
    Cap->B = Probes.Pin_1;    /* pull-up probe pin */
    1bae:	80 81       	ld	r24, Z
    1bb0:	11 96       	adiw	r26, 0x01	; 1
    1bb2:	8c 93       	st	X, r24
    1bb4:	11 97       	sbiw	r26, 0x01	; 1
    Cap->Scale = Scale;       /* -12 or -9 */
    1bb6:	87 ef       	ldi	r24, 0xF7	; 247
    1bb8:	12 96       	adiw	r26, 0x02	; 2
    1bba:	8c 93       	st	X, r24
    Cap->Raw = Raw;
    1bbc:	e4 01       	movw	r28, r8
    1bbe:	2f 83       	std	Y+7, r18	; 0x07
    1bc0:	38 87       	std	Y+8, r19	; 0x08
    1bc2:	49 87       	std	Y+9, r20	; 0x09
    1bc4:	5a 87       	std	Y+10, r21	; 0x0a
    Cap->Value = Value;       /* max. 5.1*10^6pF or 125*10^3nF */
    1bc6:	2b 83       	std	Y+3, r18	; 0x03
    1bc8:	3c 83       	std	Y+4, r19	; 0x04
    1bca:	4d 83       	std	Y+5, r20	; 0x05
    1bcc:	5e 83       	std	Y+6, r21	; 0x06
     *  should keep the voltage stable long enough for the measurements. 
     *  Changed offsets will be used in next test run.
     */

    if (((Scale == -12) && (Value >= 100000)) ||
        ((Scale == -9) && (Value <= 20000)))
    1bce:	21 32       	cpi	r18, 0x21	; 33
    1bd0:	3e 44       	sbci	r19, 0x4E	; 78
    1bd2:	41 05       	cpc	r20, r1
    1bd4:	51 05       	cpc	r21, r1
    1bd6:	10 f1       	brcs	.+68     	; 0x1c1c <SmallCap+0x1f0>
      /* limit offset to a valid range of -50mV - 50mV */
      if ((Offset > -50) && (Offset < 50)) NV.CompOffset = Offset;
    }
  }

  return Flag;
    1bd8:	83 e0       	ldi	r24, 0x03	; 3
    1bda:	e2 c0       	rjmp	.+452    	; 0x1da0 <SmallCap+0x374>
    /* take care about zero offset if feasable */
    if (Scale == -12)                     /* pF scale */
    {
      if (Value >= NV.CapZero)            /* if value is larger than offset */
      {
        Value -= NV.CapZero;              /* substract offset */
    1bdc:	69 01       	movw	r12, r18
    1bde:	7a 01       	movw	r14, r20
    1be0:	c8 1a       	sub	r12, r24
    1be2:	d9 0a       	sbc	r13, r25
    1be4:	ea 0a       	sbc	r14, r26
    1be6:	fb 0a       	sbc	r15, r27
        Value = 0;                        /* set value to 0 */
      }
    }

    /* copy data */
    Cap->A = Probes.Pin_2;    /* pull-down probe pin */
    1be8:	ef e8       	ldi	r30, 0x8F	; 143
    1bea:	f1 e0       	ldi	r31, 0x01	; 1
    1bec:	61 81       	ldd	r22, Z+1	; 0x01
    1bee:	e4 01       	movw	r28, r8
    1bf0:	68 83       	st	Y, r22
    Cap->B = Probes.Pin_1;    /* pull-up probe pin */
    1bf2:	60 81       	ld	r22, Z
    1bf4:	69 83       	std	Y+1, r22	; 0x01
    Cap->Scale = Scale;       /* -12 or -9 */
    1bf6:	64 ef       	ldi	r22, 0xF4	; 244
    1bf8:	6a 83       	std	Y+2, r22	; 0x02
    Cap->Raw = Raw;
    1bfa:	2f 83       	std	Y+7, r18	; 0x07
    1bfc:	38 87       	std	Y+8, r19	; 0x08
    1bfe:	49 87       	std	Y+9, r20	; 0x09
    1c00:	5a 87       	std	Y+10, r21	; 0x0a
    Cap->Value = Value;       /* max. 5.1*10^6pF or 125*10^3nF */
    1c02:	cb 82       	std	Y+3, r12	; 0x03
    1c04:	dc 82       	std	Y+4, r13	; 0x04
    1c06:	ed 82       	std	Y+5, r14	; 0x05
    1c08:	fe 82       	std	Y+6, r15	; 0x06
     *  bandgap reference if C is 100nF up to 20F. The minimum of 100nF
     *  should keep the voltage stable long enough for the measurements. 
     *  Changed offsets will be used in next test run.
     */

    if (((Scale == -12) && (Value >= 100000)) ||
    1c0a:	d0 ea       	ldi	r29, 0xA0	; 160
    1c0c:	cd 16       	cp	r12, r29
    1c0e:	d6 e8       	ldi	r29, 0x86	; 134
    1c10:	dd 06       	cpc	r13, r29
    1c12:	d1 e0       	ldi	r29, 0x01	; 1
    1c14:	ed 06       	cpc	r14, r29
    1c16:	f1 04       	cpc	r15, r1
    1c18:	08 f4       	brcc	.+2      	; 0x1c1c <SmallCap+0x1f0>
    1c1a:	48 c0       	rjmp	.+144    	; 0x1cac <SmallCap+0x280>
       *  by measuring a voltage lower than the bandgap reference, one time
       *  with the bandgap as reference and a second time with Vcc as
       *  reference. The common voltage source is the cap we just measured.
       */

       while (ReadU(Probes.Pin_1) > 980)
    1c1c:	cf e8       	ldi	r28, 0x8F	; 143
    1c1e:	d1 e0       	ldi	r29, 0x01	; 1
    1c20:	88 81       	ld	r24, Y
    1c22:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    1c26:	85 3d       	cpi	r24, 0xD5	; 213
    1c28:	93 40       	sbci	r25, 0x03	; 3
    1c2a:	d0 f7       	brcc	.-12     	; 0x1c20 <SmallCap+0x1f4>
       {
         /* keep discharging */
       }

       R_DDR = 0;                       /* stop discharging */
    1c2c:	14 b8       	out	0x04, r1	; 4

       Config.AutoScale = 0;            /* disable auto scaling */
    1c2e:	0f 2e       	mov	r0, r31
    1c30:	fb ea       	ldi	r31, 0xAB	; 171
    1c32:	cf 2e       	mov	r12, r31
    1c34:	f1 e0       	ldi	r31, 0x01	; 1
    1c36:	df 2e       	mov	r13, r31
    1c38:	f0 2d       	mov	r31, r0
    1c3a:	d6 01       	movw	r26, r12
    1c3c:	12 96       	adiw	r26, 0x02	; 2
    1c3e:	1c 92       	st	X, r1
       Ticks = ReadU(Probes.Pin_1);     /* U_c with Vcc reference */
    1c40:	cf e8       	ldi	r28, 0x8F	; 143
    1c42:	d1 e0       	ldi	r29, 0x01	; 1
    1c44:	88 81       	ld	r24, Y
    1c46:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    1c4a:	7c 01       	movw	r14, r24
       Config.AutoScale = 1;            /* enable auto scaling again */
    1c4c:	81 e0       	ldi	r24, 0x01	; 1
    1c4e:	f6 01       	movw	r30, r12
    1c50:	82 83       	std	Z+2, r24	; 0x02
       Ticks2 = ReadU(Probes.Pin_1);    /* U_c with bandgap reference */
    1c52:	88 81       	ld	r24, Y
    1c54:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    1c58:	ac 01       	movw	r20, r24

       R_DDR = Probes.Rh_1;             /* resume discharging */
    1c5a:	8c 81       	ldd	r24, Y+4	; 0x04
    1c5c:	84 b9       	out	0x04, r24	; 4

       Offset = Ticks - Ticks2;
    1c5e:	d7 01       	movw	r26, r14
    1c60:	a4 1b       	sub	r26, r20
    1c62:	b5 0b       	sbc	r27, r21
       /* allow some offset caused by the different voltage resolutions
          (4.88 vs. 1.07) */
       if ((Offset < -4) || (Offset > 4))    /* offset too large */
    1c64:	cd 01       	movw	r24, r26
    1c66:	04 96       	adiw	r24, 0x04	; 4
    1c68:	09 97       	sbiw	r24, 0x09	; 9
    1c6a:	68 f0       	brcs	.+26     	; 0x1c86 <SmallCap+0x25a>
          *  - first get offset per mV: Offset / U_c
          *  - total offset for U_ref: (Offset / U_c) * U_ref
          */

         TempLong = Offset;
         TempLong *= Config.Bandgap;         /* * U_ref */
    1c6c:	20 91 af 01 	lds	r18, 0x01AF
    1c70:	30 91 b0 01 	lds	r19, 0x01B0
    1c74:	0e 94 dc 36 	call	0x6db8	; 0x6db8 <__usmulhisi3>
         TempLong /= Ticks2;                 /* / U_c */
    1c78:	9a 01       	movw	r18, r20
    1c7a:	40 e0       	ldi	r20, 0x00	; 0
    1c7c:	50 e0       	ldi	r21, 0x00	; 0
    1c7e:	0e 94 a8 36 	call	0x6d50	; 0x6d50 <__divmodsi4>

         NV.RefOffset = (int8_t)TempLong;
    1c82:	20 93 a2 01 	sts	0x01A2, r18
       *  MCU used actually U_bandgap - U_offset. We get that offset by
       *  comparing the bandgap reference with the voltage of the cap:
       *  U_c = U_bandgap - U_offset -> U_offset = U_c - U_bandgap
       */

      Offset = U_c - Config.Bandgap;
    1c86:	80 91 af 01 	lds	r24, 0x01AF
    1c8a:	90 91 b0 01 	lds	r25, 0x01B0
    1c8e:	08 1b       	sub	r16, r24
    1c90:	19 0b       	sbc	r17, r25

      /* limit offset to a valid range of -50mV - 50mV */
      if ((Offset > -50) && (Offset < 50)) NV.CompOffset = Offset;
    1c92:	c8 01       	movw	r24, r16
    1c94:	c1 96       	adiw	r24, 0x31	; 49
    1c96:	83 36       	cpi	r24, 0x63	; 99
    1c98:	91 05       	cpc	r25, r1
    1c9a:	50 f4       	brcc	.+20     	; 0x1cb0 <SmallCap+0x284>
    1c9c:	00 93 a3 01 	sts	0x01A3, r16
    }
  }

  return Flag;
    1ca0:	83 e0       	ldi	r24, 0x03	; 3
    1ca2:	7e c0       	rjmp	.+252    	; 0x1da0 <SmallCap+0x374>
   *  init hardware
   */

  /* prepare probes */
  DischargeProbes();                    /* try to discharge probes */
  if (Check.Found == COMP_ERROR) return 0;     /* skip on error */
    1ca4:	80 e0       	ldi	r24, 0x00	; 0
    1ca6:	7c c0       	rjmp	.+248    	; 0x1da0 <SmallCap+0x374>
  /* start discharging DUT */
  R_PORT = 0;                      /* pull down probe-2 via Rh */
  R_DDR = Probes.Rh_1;             /* enable Rh for probe-1 again */

  /* skip measurement if charging took too long */
  if (Ticks2 >= (CPU_FREQ / 5000)) Flag = 1;
    1ca8:	81 e0       	ldi	r24, 0x01	; 1
    1caa:	7a c0       	rjmp	.+244    	; 0x1da0 <SmallCap+0x374>
      /* limit offset to a valid range of -50mV - 50mV */
      if ((Offset > -50) && (Offset < 50)) NV.CompOffset = Offset;
    }
  }

  return Flag;
    1cac:	83 e0       	ldi	r24, 0x03	; 3
    1cae:	78 c0       	rjmp	.+240    	; 0x1da0 <SmallCap+0x374>
    1cb0:	83 e0       	ldi	r24, 0x03	; 3
    1cb2:	76 c0       	rjmp	.+236    	; 0x1da0 <SmallCap+0x374>
       if (Ticks2 == (CPU_FREQ / 5000)) break;
     }
   }

  /* stop counter */
  TCCR1B = 0;                           /* stop timer */
    1cb4:	10 92 81 00 	sts	0x0081, r1
  TIFR1 = (1 << ICF1);                  /* reset Input Capture flag */
    1cb8:	80 e2       	ldi	r24, 0x20	; 32
    1cba:	86 bb       	out	0x16, r24	; 22

  Ticks = ICR1;                         /* get counter value */
    1cbc:	c0 90 86 00 	lds	r12, 0x0086
    1cc0:	d0 90 87 00 	lds	r13, 0x0087

  /* disable charging */
  R_DDR = 0;                  /* set resistor port to HiZ mode */
    1cc4:	14 b8       	out	0x04, r1	; 4

  /* catch missed timer overflow */
  if ((TCNT1 > Ticks) && (TempByte & (1 << TOV1)))
    1cc6:	80 91 84 00 	lds	r24, 0x0084
    1cca:	90 91 85 00 	lds	r25, 0x0085
    1cce:	c8 16       	cp	r12, r24
    1cd0:	d9 06       	cpc	r13, r25
    1cd2:	08 f4       	brcc	.+2      	; 0x1cd6 <SmallCap+0x2aa>
    1cd4:	1f cf       	rjmp	.-450    	; 0x1b14 <SmallCap+0xe8>
    1cd6:	58 c0       	rjmp	.+176    	; 0x1d88 <SmallCap+0x35c>
   */

  if (Flag == 3)
  {
    /*  combine both counter values */
    Raw = (uint32_t)Ticks;                /* set lower 16 bits */
    1cd8:	c6 01       	movw	r24, r12
    1cda:	a0 e0       	ldi	r26, 0x00	; 0
    1cdc:	b0 e0       	ldi	r27, 0x00	; 0
    Raw |= (uint32_t)Ticks2 << 16;        /* set upper 16 bits */
    1cde:	a7 01       	movw	r20, r14
    1ce0:	60 e0       	ldi	r22, 0x00	; 0
    1ce2:	70 e0       	ldi	r23, 0x00	; 0
    1ce4:	ba 01       	movw	r22, r20
    1ce6:	55 27       	eor	r21, r21
    1ce8:	44 27       	eor	r20, r20
    1cea:	6a 01       	movw	r12, r20
    1cec:	7b 01       	movw	r14, r22
    1cee:	c8 2a       	or	r12, r24
    1cf0:	d9 2a       	or	r13, r25
    1cf2:	ea 2a       	or	r14, r26
    1cf4:	fb 2a       	or	r15, r27
    if (Raw > 2) Raw -= 2;                /* subtract processing time overhead */
    1cf6:	f3 e0       	ldi	r31, 0x03	; 3
    1cf8:	cf 16       	cp	r12, r31
    1cfa:	d1 04       	cpc	r13, r1
    1cfc:	e1 04       	cpc	r14, r1
    1cfe:	f1 04       	cpc	r15, r1
    1d00:	08 f0       	brcs	.+2      	; 0x1d04 <SmallCap+0x2d8>
    1d02:	20 cf       	rjmp	.-448    	; 0x1b44 <SmallCap+0x118>
    1d04:	24 cf       	rjmp	.-440    	; 0x1b4e <SmallCap+0x122>
      Raw /= 1000;                        /* scale down by 10^3 */
      Scale += 3;                         /* add 3 to the exponent (nF) */
    }

    /* multiply with factor from table */
    Raw *= GetFactor(Config.Bandgap + NV.CompOffset, TABLE_SMALL_CAP);
    1d06:	0f 2e       	mov	r0, r31
    1d08:	fb e9       	ldi	r31, 0x9B	; 155
    1d0a:	af 2e       	mov	r10, r31
    1d0c:	f1 e0       	ldi	r31, 0x01	; 1
    1d0e:	bf 2e       	mov	r11, r31
    1d10:	f0 2d       	mov	r31, r0
    1d12:	d5 01       	movw	r26, r10
    1d14:	18 96       	adiw	r26, 0x08	; 8
    1d16:	2c 91       	ld	r18, X
    1d18:	80 91 af 01 	lds	r24, 0x01AF
    1d1c:	90 91 b0 01 	lds	r25, 0x01B0
    1d20:	61 e0       	ldi	r22, 0x01	; 1
    1d22:	82 0f       	add	r24, r18
    1d24:	91 1d       	adc	r25, r1
    1d26:	27 fd       	sbrc	r18, 7
    1d28:	9a 95       	dec	r25
    1d2a:	0e 94 90 24 	call	0x4920	; 0x4920 <GetFactor>
    1d2e:	dc 01       	movw	r26, r24
    1d30:	a7 01       	movw	r20, r14
    1d32:	96 01       	movw	r18, r12
    1d34:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>

    /* divide by CPU frequency to get the time and multiply with table scale */
    Raw /= (CPU_FREQ / 10000);
    1d38:	20 e4       	ldi	r18, 0x40	; 64
    1d3a:	36 e0       	ldi	r19, 0x06	; 6
    1d3c:	40 e0       	ldi	r20, 0x00	; 0
    1d3e:	50 e0       	ldi	r21, 0x00	; 0
    1d40:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    Value = Raw;                          /* take raw value */

    /* take care about zero offset if feasable */
    if (Scale == -12)                     /* pF scale */
    {
      if (Value >= NV.CapZero)            /* if value is larger than offset */
    1d44:	e5 01       	movw	r28, r10
    1d46:	8e 81       	ldd	r24, Y+6	; 0x06
    1d48:	90 e0       	ldi	r25, 0x00	; 0
    1d4a:	a0 e0       	ldi	r26, 0x00	; 0
    1d4c:	b0 e0       	ldi	r27, 0x00	; 0
    1d4e:	28 17       	cp	r18, r24
    1d50:	39 07       	cpc	r19, r25
    1d52:	4a 07       	cpc	r20, r26
    1d54:	5b 07       	cpc	r21, r27
    1d56:	08 f0       	brcs	.+2      	; 0x1d5a <SmallCap+0x32e>
    1d58:	41 cf       	rjmp	.-382    	; 0x1bdc <SmallCap+0x1b0>
        Value = 0;                        /* set value to 0 */
      }
    }

    /* copy data */
    Cap->A = Probes.Pin_2;    /* pull-down probe pin */
    1d5a:	ef e8       	ldi	r30, 0x8F	; 143
    1d5c:	f1 e0       	ldi	r31, 0x01	; 1
    1d5e:	81 81       	ldd	r24, Z+1	; 0x01
    1d60:	d4 01       	movw	r26, r8
    1d62:	8c 93       	st	X, r24
    Cap->B = Probes.Pin_1;    /* pull-up probe pin */
    1d64:	80 81       	ld	r24, Z
    1d66:	11 96       	adiw	r26, 0x01	; 1
    1d68:	8c 93       	st	X, r24
    1d6a:	11 97       	sbiw	r26, 0x01	; 1
    Cap->Scale = Scale;       /* -12 or -9 */
    1d6c:	84 ef       	ldi	r24, 0xF4	; 244
    1d6e:	12 96       	adiw	r26, 0x02	; 2
    1d70:	8c 93       	st	X, r24
    Cap->Raw = Raw;
    1d72:	e4 01       	movw	r28, r8
    1d74:	2f 83       	std	Y+7, r18	; 0x07
    1d76:	38 87       	std	Y+8, r19	; 0x08
    1d78:	49 87       	std	Y+9, r20	; 0x09
    1d7a:	5a 87       	std	Y+10, r21	; 0x0a
    Cap->Value = Value;       /* max. 5.1*10^6pF or 125*10^3nF */
    1d7c:	1b 82       	std	Y+3, r1	; 0x03
    1d7e:	1c 82       	std	Y+4, r1	; 0x04
    1d80:	1d 82       	std	Y+5, r1	; 0x05
    1d82:	1e 82       	std	Y+6, r1	; 0x06
      /* limit offset to a valid range of -50mV - 50mV */
      if ((Offset > -50) && (Offset < 50)) NV.CompOffset = Offset;
    }
  }

  return Flag;
    1d84:	83 e0       	ldi	r24, 0x03	; 3
    1d86:	0c c0       	rjmp	.+24     	; 0x1da0 <SmallCap+0x374>
    TIFR1 = (1 << TOV1);                /* reset overflow flag */
    Ticks2++;                           /* increase overflow counter */
  }

  /* enable ADC again */
  ADCSRA = (1 << ADEN) | (1 << ADIF) | ADC_CLOCK_DIV;
    1d88:	87 e9       	ldi	r24, 0x97	; 151
    1d8a:	80 93 7a 00 	sts	0x007A, r24

  /* get voltage of DUT */
  U_c = ReadU(Probes.Pin_1);       /* get voltage of cap */
    1d8e:	cf e8       	ldi	r28, 0x8F	; 143
    1d90:	d1 e0       	ldi	r29, 0x01	; 1
    1d92:	88 81       	ld	r24, Y
    1d94:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>

  /* start discharging DUT */
  R_PORT = 0;                      /* pull down probe-2 via Rh */
    1d98:	15 b8       	out	0x05, r1	; 5
  R_DDR = Probes.Rh_1;             /* enable Rh for probe-1 again */
    1d9a:	8c 81       	ldd	r24, Y+4	; 0x04
    1d9c:	84 b9       	out	0x04, r24	; 4

  /* skip measurement if charging took too long */
  if (Ticks2 >= (CPU_FREQ / 5000)) Flag = 1;
    1d9e:	81 e0       	ldi	r24, 0x01	; 1
      if ((Offset > -50) && (Offset < 50)) NV.CompOffset = Offset;
    }
  }

  return Flag;
}
    1da0:	df 91       	pop	r29
    1da2:	cf 91       	pop	r28
    1da4:	1f 91       	pop	r17
    1da6:	0f 91       	pop	r16
    1da8:	ff 90       	pop	r15
    1daa:	ef 90       	pop	r14
    1dac:	df 90       	pop	r13
    1dae:	cf 90       	pop	r12
    1db0:	bf 90       	pop	r11
    1db2:	af 90       	pop	r10
    1db4:	9f 90       	pop	r9
    1db6:	8f 90       	pop	r8
    1db8:	08 95       	ret

00001dba <MeasureCap>:
 *  - Probe2: ID of probe to be pulled down [0-2]
 *  - ID: capacitor ID [0-2]
 */

void MeasureCap(uint8_t Probe1, uint8_t Probe2, uint8_t ID)
{
    1dba:	5f 92       	push	r5
    1dbc:	6f 92       	push	r6
    1dbe:	7f 92       	push	r7
    1dc0:	8f 92       	push	r8
    1dc2:	9f 92       	push	r9
    1dc4:	af 92       	push	r10
    1dc6:	bf 92       	push	r11
    1dc8:	cf 92       	push	r12
    1dca:	df 92       	push	r13
    1dcc:	ef 92       	push	r14
    1dce:	ff 92       	push	r15
    1dd0:	0f 93       	push	r16
    1dd2:	1f 93       	push	r17
    1dd4:	cf 93       	push	r28
    1dd6:	df 93       	push	r29
   *  init
   */

  /* reset cap data */
  Cap = &Caps[ID];
  Cap->A = 0;
    1dd8:	c4 2e       	mov	r12, r20
    1dda:	d1 2c       	mov	r13, r1
    1ddc:	9b e0       	ldi	r25, 0x0B	; 11
    1dde:	49 9f       	mul	r20, r25
    1de0:	f0 01       	movw	r30, r0
    1de2:	11 24       	eor	r1, r1
    1de4:	e5 5c       	subi	r30, 0xC5	; 197
    1de6:	fe 4f       	sbci	r31, 0xFE	; 254
    1de8:	10 82       	st	Z, r1
  Cap->B = 0;
    1dea:	11 82       	std	Z+1, r1	; 0x01
  Cap->Scale = -12;           /* pF by default */
    1dec:	94 ef       	ldi	r25, 0xF4	; 244
    1dee:	92 83       	std	Z+2, r25	; 0x02
  Cap->Raw = 0;
    1df0:	17 82       	std	Z+7, r1	; 0x07
    1df2:	10 86       	std	Z+8, r1	; 0x08
    1df4:	11 86       	std	Z+9, r1	; 0x09
    1df6:	12 86       	std	Z+10, r1	; 0x0a
  Cap->Value = 0;
    1df8:	13 82       	std	Z+3, r1	; 0x03
    1dfa:	14 82       	std	Z+4, r1	; 0x04
    1dfc:	15 82       	std	Z+5, r1	; 0x05
    1dfe:	16 82       	std	Z+6, r1	; 0x06

  if (Check.Found == COMP_ERROR) return;    /* skip check on any error */
    1e00:	90 91 09 01 	lds	r25, 0x0109
    1e04:	91 30       	cpi	r25, 0x01	; 1
    1e06:	09 f4       	brne	.+2      	; 0x1e0a <MeasureCap+0x50>
    1e08:	bc c0       	rjmp	.+376    	; 0x1f82 <MeasureCap+0x1c8>
    1e0a:	c6 2f       	mov	r28, r22
    1e0c:	d8 2f       	mov	r29, r24
  /*
   *  Normaly we would skip resistors, but a resistor < 10 Ohms could be
   *  also a large cap.
   */

  if (Check.Found == COMP_RESISTOR)
    1e0e:	9a 30       	cpi	r25, 0x0A	; 10
    1e10:	09 f0       	breq	.+2      	; 0x1e14 <MeasureCap+0x5a>
    1e12:	4c c0       	rjmp	.+152    	; 0x1eac <MeasureCap+0xf2>
  {
    Resistor = &Resistors[0];         /* pointer to first resistor */
    TempByte = 0;

    while (TempByte < Check.Resistors)       /* loop through all resistors */
    1e14:	80 91 0b 01 	lds	r24, 0x010B
    1e18:	88 23       	and	r24, r24
    1e1a:	09 f4       	brne	.+2      	; 0x1e1e <MeasureCap+0x64>
    1e1c:	b2 c0       	rjmp	.+356    	; 0x1f82 <MeasureCap+0x1c8>
    1e1e:	0f 2e       	mov	r0, r31
    1e20:	f2 e1       	ldi	r31, 0x12	; 18
    1e22:	af 2e       	mov	r10, r31
    1e24:	f1 e0       	ldi	r31, 0x01	; 1
    1e26:	bf 2e       	mov	r11, r31
    1e28:	f0 2d       	mov	r31, r0
    1e2a:	0f 2e       	mov	r0, r31
    1e2c:	f3 e1       	ldi	r31, 0x13	; 19
    1e2e:	8f 2e       	mov	r8, r31
    1e30:	f1 e0       	ldi	r31, 0x01	; 1
    1e32:	9f 2e       	mov	r9, r31
    1e34:	f0 2d       	mov	r31, r0
    1e36:	f1 2c       	mov	r15, r1
      if (((Resistor->A == Probe1) && (Resistor->B == Probe2)) ||
          ((Resistor->A == Probe2) && (Resistor->B == Probe1)))
      {
        /* check for low value < 10 Ohms */
        if (CmpValue(Resistor->Value, Resistor->Scale, 10UL, 0) == -1)
          TempByte = 99;                /* signal low resistance and end loop */
    1e38:	0f 2e       	mov	r0, r31
    1e3a:	f3 e6       	ldi	r31, 0x63	; 99
    1e3c:	5f 2e       	mov	r5, r31
    1e3e:	f0 2d       	mov	r31, r0
  if (Check.Found == COMP_RESISTOR)
  {
    Resistor = &Resistors[0];         /* pointer to first resistor */
    TempByte = 0;

    while (TempByte < Check.Resistors)       /* loop through all resistors */
    1e40:	0f 2e       	mov	r0, r31
    1e42:	f8 e0       	ldi	r31, 0x08	; 8
    1e44:	6f 2e       	mov	r6, r31
    1e46:	f1 e0       	ldi	r31, 0x01	; 1
    1e48:	7f 2e       	mov	r7, r31
    1e4a:	f0 2d       	mov	r31, r0
    1e4c:	d5 01       	movw	r26, r10
    1e4e:	f5 01       	movw	r30, r10
    1e50:	31 97       	sbiw	r30, 0x01	; 1
    {
      /* got matching pins */
      if (((Resistor->A == Probe1) && (Resistor->B == Probe2)) ||
    1e52:	80 81       	ld	r24, Z
    1e54:	8d 13       	cpse	r24, r29
    1e56:	04 c0       	rjmp	.+8      	; 0x1e60 <MeasureCap+0xa6>
    1e58:	f5 01       	movw	r30, r10
    1e5a:	90 81       	ld	r25, Z
    1e5c:	9c 17       	cp	r25, r28
    1e5e:	29 f0       	breq	.+10     	; 0x1e6a <MeasureCap+0xb0>
    1e60:	8c 13       	cpse	r24, r28
    1e62:	15 c0       	rjmp	.+42     	; 0x1e8e <MeasureCap+0xd4>
          ((Resistor->A == Probe2) && (Resistor->B == Probe1)))
    1e64:	8c 91       	ld	r24, X
    1e66:	8d 13       	cpse	r24, r29
    1e68:	12 c0       	rjmp	.+36     	; 0x1e8e <MeasureCap+0xd4>
      {
        /* check for low value < 10 Ohms */
        if (CmpValue(Resistor->Value, Resistor->Scale, 10UL, 0) == -1)
    1e6a:	12 96       	adiw	r26, 0x02	; 2
    1e6c:	6d 91       	ld	r22, X+
    1e6e:	7d 91       	ld	r23, X+
    1e70:	8d 91       	ld	r24, X+
    1e72:	9c 91       	ld	r25, X
    1e74:	15 97       	sbiw	r26, 0x05	; 5
    1e76:	e1 2c       	mov	r14, r1
    1e78:	0a e0       	ldi	r16, 0x0A	; 10
    1e7a:	10 e0       	ldi	r17, 0x00	; 0
    1e7c:	20 e0       	ldi	r18, 0x00	; 0
    1e7e:	30 e0       	ldi	r19, 0x00	; 0
    1e80:	d4 01       	movw	r26, r8
    1e82:	4c 91       	ld	r20, X
    1e84:	0e 94 ac 31 	call	0x6358	; 0x6358 <CmpValue>
    1e88:	8f 3f       	cpi	r24, 0xFF	; 255
    1e8a:	09 f4       	brne	.+2      	; 0x1e8e <MeasureCap+0xd4>
          TempByte = 99;                /* signal low resistance and end loop */
    1e8c:	f5 2c       	mov	r15, r5
      }

      TempByte++;      /* next one */
    1e8e:	f3 94       	inc	r15
    1e90:	b7 e0       	ldi	r27, 0x07	; 7
    1e92:	ab 0e       	add	r10, r27
    1e94:	b1 1c       	adc	r11, r1
    1e96:	e7 e0       	ldi	r30, 0x07	; 7
    1e98:	8e 0e       	add	r8, r30
    1e9a:	91 1c       	adc	r9, r1
  if (Check.Found == COMP_RESISTOR)
  {
    Resistor = &Resistors[0];         /* pointer to first resistor */
    TempByte = 0;

    while (TempByte < Check.Resistors)       /* loop through all resistors */
    1e9c:	d3 01       	movw	r26, r6
    1e9e:	13 96       	adiw	r26, 0x03	; 3
    1ea0:	8c 91       	ld	r24, X
    1ea2:	f8 16       	cp	r15, r24
    1ea4:	98 f2       	brcs	.-90     	; 0x1e4c <MeasureCap+0x92>
      TempByte++;      /* next one */
      Resistor++;      /* next one */  
    }

    /* we got a valid resistor */ 
    if (TempByte != 100) return;        /* skip this one */
    1ea6:	b4 e6       	ldi	r27, 0x64	; 100
    1ea8:	fb 12       	cpse	r15, r27
    1eaa:	6b c0       	rjmp	.+214    	; 0x1f82 <MeasureCap+0x1c8>
   *  - when Vf collides with the voltage of the capacitance measurement
   */

  Diode = &Diodes[0];         /* pointer to first diode */

  for (TempByte = 0; TempByte < Check.Diodes; TempByte++)
    1eac:	30 91 0c 01 	lds	r19, 0x010C
    1eb0:	33 23       	and	r19, r19
    1eb2:	b9 f0       	breq	.+46     	; 0x1ee2 <MeasureCap+0x128>
    1eb4:	ed e5       	ldi	r30, 0x5D	; 93
    1eb6:	f1 e0       	ldi	r31, 0x01	; 1
    1eb8:	90 e0       	ldi	r25, 0x00	; 0
  {
    /* got matching pins and low threshold voltage */
    if ((Diode->C == Probe2) &&
    1eba:	20 81       	ld	r18, Z
    1ebc:	2c 13       	cpse	r18, r28
    1ebe:	0d c0       	rjmp	.+26     	; 0x1eda <MeasureCap+0x120>
    1ec0:	af 01       	movw	r20, r30
    1ec2:	41 50       	subi	r20, 0x01	; 1
    1ec4:	51 09       	sbc	r21, r1
    1ec6:	da 01       	movw	r26, r20
    1ec8:	8c 91       	ld	r24, X
    1eca:	8d 13       	cpse	r24, r29
    1ecc:	06 c0       	rjmp	.+12     	; 0x1eda <MeasureCap+0x120>
        (Diode->A == Probe1) &&
    1ece:	41 81       	ldd	r20, Z+1	; 0x01
    1ed0:	52 81       	ldd	r21, Z+2	; 0x02
    1ed2:	4c 3d       	cpi	r20, 0xDC	; 220
    1ed4:	55 40       	sbci	r21, 0x05	; 5
    1ed6:	08 f4       	brcc	.+2      	; 0x1eda <MeasureCap+0x120>
    1ed8:	54 c0       	rjmp	.+168    	; 0x1f82 <MeasureCap+0x1c8>
   *  - when Vf collides with the voltage of the capacitance measurement
   */

  Diode = &Diodes[0];         /* pointer to first diode */

  for (TempByte = 0; TempByte < Check.Diodes; TempByte++)
    1eda:	9f 5f       	subi	r25, 0xFF	; 255
    1edc:	36 96       	adiw	r30, 0x06	; 6
    1ede:	93 13       	cpse	r25, r19
    1ee0:	ec cf       	rjmp	.-40     	; 0x1eba <MeasureCap+0x100>
  /*
   *  init
   */

  /* reset cap data */
  Cap = &Caps[ID];
    1ee2:	8b e0       	ldi	r24, 0x0B	; 11
    1ee4:	8c 9d       	mul	r24, r12
    1ee6:	80 01       	movw	r16, r0
    1ee8:	8d 9d       	mul	r24, r13
    1eea:	10 0d       	add	r17, r0
    1eec:	11 24       	eor	r1, r1
    1eee:	05 5c       	subi	r16, 0xC5	; 197
    1ef0:	1e 4f       	sbci	r17, 0xFE	; 254

  /*
   *  run measurements
   */

  UpdateProbes(Probe1, Probe2, 0);           /* update bitmasks and probes */
    1ef2:	40 e0       	ldi	r20, 0x00	; 0
    1ef4:	6c 2f       	mov	r22, r28
    1ef6:	8d 2f       	mov	r24, r29
    1ef8:	0e 94 04 23 	call	0x4608	; 0x4608 <UpdateProbes>

  /* first run measurement for large caps */ 
  TempByte = LargeCap(Cap);
    1efc:	c8 01       	movw	r24, r16
    1efe:	0e 94 87 0b 	call	0x170e	; 0x170e <LargeCap>

  /* if cap is too small run measurement for small caps */
  if (TempByte == 2)
    1f02:	82 30       	cpi	r24, 0x02	; 2
    1f04:	19 f4       	brne	.+6      	; 0x1f0c <MeasureCap+0x152>
  {
    TempByte = SmallCap(Cap);
    1f06:	c8 01       	movw	r24, r16
    1f08:	0e 94 16 0d 	call	0x1a2c	; 0x1a2c <SmallCap>
   *  check for plausibility
   */

  /* if there aren't any diodes in reverse direction which could be
     detected as capacitors by mistake */
  if (Check.Diodes == 0)
    1f0c:	80 91 0c 01 	lds	r24, 0x010C
    1f10:	81 11       	cpse	r24, r1
    1f12:	31 c0       	rjmp	.+98     	; 0x1f76 <MeasureCap+0x1bc>
  {
    /* low resistance might be a large cap */
    if (Check.Found == COMP_RESISTOR)
    1f14:	80 91 09 01 	lds	r24, 0x0109
    1f18:	8a 30       	cpi	r24, 0x0A	; 10
    1f1a:	79 f4       	brne	.+30     	; 0x1f3a <MeasureCap+0x180>
    {
      /* report capacitor only for a large C (> 4.3F) */
      if (Cap->Scale >= -6) Check.Found = COMP_CAPACITOR;
    1f1c:	8b e0       	ldi	r24, 0x0B	; 11
    1f1e:	8c 9d       	mul	r24, r12
    1f20:	f0 01       	movw	r30, r0
    1f22:	8d 9d       	mul	r24, r13
    1f24:	f0 0d       	add	r31, r0
    1f26:	11 24       	eor	r1, r1
    1f28:	e5 5c       	subi	r30, 0xC5	; 197
    1f2a:	fe 4f       	sbci	r31, 0xFE	; 254
    1f2c:	82 81       	ldd	r24, Z+2	; 0x02
    1f2e:	8a 3f       	cpi	r24, 0xFA	; 250
    1f30:	14 f1       	brlt	.+68     	; 0x1f76 <MeasureCap+0x1bc>
    1f32:	8b e0       	ldi	r24, 0x0B	; 11
    1f34:	80 93 09 01 	sts	0x0109, r24
    1f38:	1e c0       	rjmp	.+60     	; 0x1f76 <MeasureCap+0x1bc>
    }

    /* we consider values below 5pF being just ghosts */
    else if ((Cap->Scale > -12) || (Cap->Value >= 5UL))
    1f3a:	8b e0       	ldi	r24, 0x0B	; 11
    1f3c:	8c 9d       	mul	r24, r12
    1f3e:	f0 01       	movw	r30, r0
    1f40:	8d 9d       	mul	r24, r13
    1f42:	f0 0d       	add	r31, r0
    1f44:	11 24       	eor	r1, r1
    1f46:	e5 5c       	subi	r30, 0xC5	; 197
    1f48:	fe 4f       	sbci	r31, 0xFE	; 254
    1f4a:	82 81       	ldd	r24, Z+2	; 0x02
    1f4c:	85 3f       	cpi	r24, 0xF5	; 245
    1f4e:	84 f4       	brge	.+32     	; 0x1f70 <MeasureCap+0x1b6>
    1f50:	8b e0       	ldi	r24, 0x0B	; 11
    1f52:	8c 9d       	mul	r24, r12
    1f54:	f0 01       	movw	r30, r0
    1f56:	8d 9d       	mul	r24, r13
    1f58:	f0 0d       	add	r31, r0
    1f5a:	11 24       	eor	r1, r1
    1f5c:	e5 5c       	subi	r30, 0xC5	; 197
    1f5e:	fe 4f       	sbci	r31, 0xFE	; 254
    1f60:	83 81       	ldd	r24, Z+3	; 0x03
    1f62:	94 81       	ldd	r25, Z+4	; 0x04
    1f64:	a5 81       	ldd	r26, Z+5	; 0x05
    1f66:	b6 81       	ldd	r27, Z+6	; 0x06
    1f68:	05 97       	sbiw	r24, 0x05	; 5
    1f6a:	a1 05       	cpc	r26, r1
    1f6c:	b1 05       	cpc	r27, r1
    1f6e:	18 f0       	brcs	.+6      	; 0x1f76 <MeasureCap+0x1bc>
    {
      Check.Found = COMP_CAPACITOR;     /* report capacitor */
    1f70:	8b e0       	ldi	r24, 0x0B	; 11
    1f72:	80 93 09 01 	sts	0x0109, r24

  /*
   *  clean up
   */

  DischargeProbes();               /* discharge DUT */
    1f76:	0e 94 a3 23 	call	0x4746	; 0x4746 <DischargeProbes>

  /* reset all ports and pins */
  ADC_DDR = 0;                     /* set ADC port to input */
    1f7a:	17 b8       	out	0x07, r1	; 7
  ADC_PORT = 0;                    /* set ADC port low */
    1f7c:	18 b8       	out	0x08, r1	; 8
  R_DDR = 0;                       /* set resistor port to input */
    1f7e:	14 b8       	out	0x04, r1	; 4
  R_PORT = 0;                      /* set resistor port low */
    1f80:	15 b8       	out	0x05, r1	; 5
}
    1f82:	df 91       	pop	r29
    1f84:	cf 91       	pop	r28
    1f86:	1f 91       	pop	r17
    1f88:	0f 91       	pop	r16
    1f8a:	ff 90       	pop	r15
    1f8c:	ef 90       	pop	r14
    1f8e:	df 90       	pop	r13
    1f90:	cf 90       	pop	r12
    1f92:	bf 90       	pop	r11
    1f94:	af 90       	pop	r10
    1f96:	9f 90       	pop	r9
    1f98:	8f 90       	pop	r8
    1f9a:	7f 90       	pop	r7
    1f9c:	6f 90       	pop	r6
    1f9e:	5f 90       	pop	r5
    1fa0:	08 95       	ret

00001fa2 <LCD_NextLine>:
 *               but also wait for testkey/timeout
 *  - MODE_KEEP  keep first line when clearing the display
 */

void LCD_NextLine(void)
{
    1fa2:	cf 93       	push	r28
  uint8_t           Mode;          /* line mode */
  uint8_t           Line;          /* line number */

  Mode = UI.LineMode;              /* get current mode */
    1fa4:	e6 e2       	ldi	r30, 0x26	; 38
    1fa6:	f1 e0       	ldi	r31, 0x01	; 1
    1fa8:	c1 81       	ldd	r28, Z+1	; 0x01
  Line = UI.CharPos_Y;             /* get current line number */
    1faa:	63 81       	ldd	r22, Z+3	; 0x03

  /* check if we reached the last line */
  if (Line == UI.CharMax_Y)
    1fac:	85 81       	ldd	r24, Z+5	; 0x05
    1fae:	86 13       	cpse	r24, r22
    1fb0:	17 c0       	rjmp	.+46     	; 0x1fe0 <LCD_NextLine+0x3e>
  {
    if (Mode & MODE_KEY) WaitKey();     /* wait for key press */
    1fb2:	c0 fd       	sbrc	r28, 0
    1fb4:	0e 94 ca 33 	call	0x6794	; 0x6794 <WaitKey>

    /* clear screen */
    if (Mode & MODE_KEEP)          /* keep first line */
    1fb8:	c1 ff       	sbrs	r28, 1
    1fba:	0f c0       	rjmp	.+30     	; 0x1fda <LCD_NextLine+0x38>
    {
      Line = UI.CharMax_Y;         /* start at the last line */
    1fbc:	c0 91 2b 01 	lds	r28, 0x012B
      while (Line > 1)
    1fc0:	c2 30       	cpi	r28, 0x02	; 2
    1fc2:	30 f0       	brcs	.+12     	; 0x1fd0 <LCD_NextLine+0x2e>
      {
        LCD_ClearLine(Line);       /* clear line */
    1fc4:	8c 2f       	mov	r24, r28
    1fc6:	0e 94 25 30 	call	0x604a	; 0x604a <LCD_ClearLine>
        Line--;                    /* next line */
    1fca:	c1 50       	subi	r28, 0x01	; 1

    /* clear screen */
    if (Mode & MODE_KEEP)          /* keep first line */
    {
      Line = UI.CharMax_Y;         /* start at the last line */
      while (Line > 1)
    1fcc:	c1 30       	cpi	r28, 0x01	; 1
    1fce:	d1 f7       	brne	.-12     	; 0x1fc4 <LCD_NextLine+0x22>
      {
        LCD_ClearLine(Line);       /* clear line */
        Line--;                    /* next line */
      }

      LCD_Pos(1, 2);               /* move to second line */
    1fd0:	62 e0       	ldi	r22, 0x02	; 2
    1fd2:	81 e0       	ldi	r24, 0x01	; 1
    1fd4:	0e 94 08 30 	call	0x6010	; 0x6010 <LCD_Pos>
    1fd8:	07 c0       	rjmp	.+14     	; 0x1fe8 <LCD_NextLine+0x46>
    }
    else                           /* clear complete screen */
    {
      LCD_Clear();                 /* clear screen */
    1fda:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
    1fde:	04 c0       	rjmp	.+8      	; 0x1fe8 <LCD_NextLine+0x46>
    }
  }
  else
  {
    /* simply move to the next line */
    Line++;                        /* add one line */
    1fe0:	6f 5f       	subi	r22, 0xFF	; 255
    LCD_Pos(1, Line);              /* move to new line */
    1fe2:	81 e0       	ldi	r24, 0x01	; 1
    1fe4:	0e 94 08 30 	call	0x6010	; 0x6010 <LCD_Pos>
  }
}
    1fe8:	cf 91       	pop	r28
    1fea:	08 95       	ret

00001fec <LCD_EEString>:
 *  requires:
 *  - pointer to fixed string
 */

void LCD_EEString(const unsigned char *String)
{
    1fec:	cf 93       	push	r28
    1fee:	df 93       	push	r29
    1ff0:	ec 01       	movw	r28, r24
  unsigned char     Char;

  while (1)
  {
    Char = eeprom_read_byte(String);    /* read character */
    1ff2:	ce 01       	movw	r24, r28
    1ff4:	0e 94 18 37 	call	0x6e30	; 0x6e30 <eeprom_read_byte>

    /* check for end of string */
    if (Char == 0) break;
    1ff8:	88 23       	and	r24, r24
    1ffa:	21 f0       	breq	.+8      	; 0x2004 <LCD_EEString+0x18>

    LCD_Char(Char);                     /* send character */
    1ffc:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    String++;                           /* next one */
    2000:	21 96       	adiw	r28, 0x01	; 1
  }
    2002:	f7 cf       	rjmp	.-18     	; 0x1ff2 <LCD_EEString+0x6>
}
    2004:	df 91       	pop	r29
    2006:	cf 91       	pop	r28
    2008:	08 95       	ret

0000200a <LCD_ProbeNumber>:
 */
 
void LCD_ProbeNumber(unsigned char Probe)
{
  /* since TP1 is 0 we simply add the value to ASCII '1' */
  LCD_Char('1' + Probe);           /* send char */
    200a:	8f 5c       	subi	r24, 0xCF	; 207
    200c:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    2010:	08 95       	ret

00002012 <LCD_ClearLine2>:
 *  - cursor is set to first char of line
 */

void LCD_ClearLine2(void)
{
  LCD_ClearLine(2);           /* clear line #2 */
    2012:	82 e0       	ldi	r24, 0x02	; 2
    2014:	0e 94 25 30 	call	0x604a	; 0x604a <LCD_ClearLine>
  LCD_Pos(1, 2);              /* move to beginning of line #2 */
    2018:	62 e0       	ldi	r22, 0x02	; 2
    201a:	81 e0       	ldi	r24, 0x01	; 1
    201c:	0e 94 08 30 	call	0x6010	; 0x6010 <LCD_Pos>
    2020:	08 95       	ret

00002022 <LCD_Space>:
 *  display a space
 */

void LCD_Space(void)
{
  LCD_Char(' ');         /* print a space */
    2022:	80 e2       	ldi	r24, 0x20	; 32
    2024:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    2028:	08 95       	ret

0000202a <LCD_EEString_Space>:
 *  - pointer to fixed string
 */

void LCD_EEString_Space(const unsigned char *String)
{
  LCD_EEString(String);       /* display string */
    202a:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
  LCD_Space();                /* print space */
    202e:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
    2032:	08 95       	ret

00002034 <LCD_NextLine_Mode>:
 *  - Mode: mode flags
 */

void LCD_NextLine_Mode(uint8_t Mode)
{
  UI.LineMode = Mode;
    2034:	80 93 27 01 	sts	0x0127, r24
    2038:	08 95       	ret

0000203a <LCD_NextLine_EEString>:
 *  requires:
 *  - pointer to fixed string
 */

void LCD_NextLine_EEString(const unsigned char *String)
{
    203a:	cf 93       	push	r28
    203c:	df 93       	push	r29
    203e:	ec 01       	movw	r28, r24
  LCD_NextLine();
    2040:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <LCD_NextLine>
  LCD_EEString(String);       /* display string */
    2044:	ce 01       	movw	r24, r28
    2046:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
}
    204a:	df 91       	pop	r29
    204c:	cf 91       	pop	r28
    204e:	08 95       	ret

00002050 <LCD_NextLine_EEString_Space>:
 *  requires:
 *  - pointer to fixed string
 */

void LCD_NextLine_EEString_Space(const unsigned char *String)
{
    2050:	cf 93       	push	r28
    2052:	df 93       	push	r29
    2054:	ec 01       	movw	r28, r24
  LCD_NextLine();
    2056:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <LCD_NextLine>
  LCD_EEString(String);       /* display string */
    205a:	ce 01       	movw	r24, r28
    205c:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
  LCD_Space();                /* print space */
    2060:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
}
    2064:	df 91       	pop	r29
    2066:	cf 91       	pop	r28
    2068:	08 95       	ret

0000206a <ToolInfo>:
/*
 *  display probe pins used
 */

void ToolInfo(const unsigned char *String)
{
    206a:	0f 93       	push	r16
    206c:	1f 93       	push	r17
    206e:	cf 93       	push	r28
    2070:	df 93       	push	r29
    2072:	8c 01       	movw	r16, r24
  uint8_t           n = 0;
  uint8_t           Key = 0;

  LCD_ClearLine2();                /* info goes to line #2 */
    2074:	0e 94 09 10 	call	0x2012	; 0x2012 <LCD_ClearLine2>
 *  display probe pins used
 */

void ToolInfo(const unsigned char *String)
{
  uint8_t           n = 0;
    2078:	d0 e0       	ldi	r29, 0x00	; 0
  LCD_ClearLine2();                /* info goes to line #2 */

  /* blink text up to three times */
  while (n <= 2)
  {
    LCD_EEString_Space(Probes_str);     /* show text */
    207a:	8c e3       	ldi	r24, 0x3C	; 60
    207c:	91 e0       	ldi	r25, 0x01	; 1
    207e:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>
    LCD_EEString(String);
    2082:	c8 01       	movw	r24, r16
    2084:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
    Key = TestKey(700, 0);         /* wait 700ms */
    2088:	60 e0       	ldi	r22, 0x00	; 0
    208a:	8c eb       	ldi	r24, 0xBC	; 188
    208c:	92 e0       	ldi	r25, 0x02	; 2
    208e:	0e 94 58 33 	call	0x66b0	; 0x66b0 <TestKey>
    2092:	c8 2f       	mov	r28, r24

    LCD_ClearLine2();              /* clear line #2 */
    2094:	0e 94 09 10 	call	0x2012	; 0x2012 <LCD_ClearLine2>
    if (Key == 0) Key = TestKey(300, 0);      /* wait 300ms */
    2098:	c1 11       	cpse	r28, r1
    209a:	0a c0       	rjmp	.+20     	; 0x20b0 <ToolInfo+0x46>
    209c:	60 e0       	ldi	r22, 0x00	; 0
    209e:	8c e2       	ldi	r24, 0x2C	; 44
    20a0:	91 e0       	ldi	r25, 0x01	; 1
    20a2:	0e 94 58 33 	call	0x66b0	; 0x66b0 <TestKey>

    if (Key > 0) n = 3;            /* on key press end loop */
    20a6:	81 11       	cpse	r24, r1
    20a8:	03 c0       	rjmp	.+6      	; 0x20b0 <ToolInfo+0x46>
    n++;                           /* next run */
    20aa:	df 5f       	subi	r29, 0xFF	; 255
  uint8_t           Key = 0;

  LCD_ClearLine2();                /* info goes to line #2 */

  /* blink text up to three times */
  while (n <= 2)
    20ac:	d3 30       	cpi	r29, 0x03	; 3
    20ae:	28 f3       	brcs	.-54     	; 0x207a <ToolInfo+0x10>

    if (Key > 0) n = 3;            /* on key press end loop */
    n++;                           /* next run */
  }

  MilliSleep(250);                 /* smooth UI */
    20b0:	8a ef       	ldi	r24, 0xFA	; 250
    20b2:	90 e0       	ldi	r25, 0x00	; 0
    20b4:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>
}
    20b8:	df 91       	pop	r29
    20ba:	cf 91       	pop	r28
    20bc:	1f 91       	pop	r17
    20be:	0f 91       	pop	r16
    20c0:	08 95       	ret

000020c2 <PWM_Tool>:
 *  requires:
 *  - Freqency in Hz
 */

void PWM_Tool(uint16_t Frequency)
{
    20c2:	4f 92       	push	r4
    20c4:	5f 92       	push	r5
    20c6:	6f 92       	push	r6
    20c8:	7f 92       	push	r7
    20ca:	8f 92       	push	r8
    20cc:	9f 92       	push	r9
    20ce:	af 92       	push	r10
    20d0:	bf 92       	push	r11
    20d2:	cf 92       	push	r12
    20d4:	df 92       	push	r13
    20d6:	ef 92       	push	r14
    20d8:	ff 92       	push	r15
    20da:	0f 93       	push	r16
    20dc:	1f 93       	push	r17
    20de:	cf 93       	push	r28
    20e0:	df 93       	push	r29
    20e2:	6c 01       	movw	r12, r24
      8          500kHz    7.6Hz        125kHz
      64         62.5kHz   0.95Hz       15625Hz
      256        15625Hz   0.24Hz       3906.25Hz
  */

  ShortCircuit(0);                    /* make sure probes are not shorted */
    20e4:	80 e0       	ldi	r24, 0x00	; 0
    20e6:	0e 94 d0 33 	call	0x67a0	; 0x67a0 <ShortCircuit>
  LCD_Clear();
    20ea:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
  LCD_EEString_Space(PWM_str);        /* display: PWM */
    20ee:	80 e3       	ldi	r24, 0x30	; 48
    20f0:	91 e0       	ldi	r25, 0x01	; 1
    20f2:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>
  DisplayValue(Frequency, 0, 'H');    /* display frequency */
    20f6:	e1 2c       	mov	r14, r1
    20f8:	f1 2c       	mov	r15, r1
    20fa:	28 e4       	ldi	r18, 0x48	; 72
    20fc:	40 e0       	ldi	r20, 0x00	; 0
    20fe:	c7 01       	movw	r24, r14
    2100:	b6 01       	movw	r22, r12
    2102:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
  LCD_Char('z');                      /* make it Hz :-) */
    2106:	8a e7       	ldi	r24, 0x7A	; 122
    2108:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
  ToolInfo(PWM_Probes_str);           /* show probes used */
    210c:	88 e2       	ldi	r24, 0x28	; 40
    210e:	91 e0       	ldi	r25, 0x01	; 1
    2110:	0e 94 35 10 	call	0x206a	; 0x206a <ToolInfo>

  /* probes 1 and 3 are signal ground, probe 2 is signal output */
  ADC_PORT = 0;                         /* pull down directly: */
    2114:	18 b8       	out	0x08, r1	; 8
  ADC_DDR = (1 << TP1) | (1 << TP3);    /* probe 1 & 3 */
    2116:	85 e0       	ldi	r24, 0x05	; 5
    2118:	87 b9       	out	0x07, r24	; 7
  R_DDR = (1 << (TP2 * 2));             /* enable Rl for probe 2 */
    211a:	84 e0       	ldi	r24, 0x04	; 4
    211c:	84 b9       	out	0x04, r24	; 4
  R_PORT = 0;                           /* pull down probe 2 initially */
    211e:	15 b8       	out	0x05, r1	; 5
   *
   *    top = f_MCU / (2 * prescaler * f_PWM)
   */

  Value = CPU_FREQ / 2;
  Value /= Frequency;
    2120:	60 e0       	ldi	r22, 0x00	; 0
    2122:	72 e1       	ldi	r23, 0x12	; 18
    2124:	8a e7       	ldi	r24, 0x7A	; 122
    2126:	90 e0       	ldi	r25, 0x00	; 0
    2128:	a7 01       	movw	r20, r14
    212a:	96 01       	movw	r18, r12
    212c:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    2130:	29 01       	movw	r4, r18
    2132:	3a 01       	movw	r6, r20

  if (Value > 2000000)        /* low frequency (<20Hz @8MHz) */
    2134:	21 38       	cpi	r18, 0x81	; 129
    2136:	84 e8       	ldi	r24, 0x84	; 132
    2138:	38 07       	cpc	r19, r24
    213a:	8e e1       	ldi	r24, 0x1E	; 30
    213c:	48 07       	cpc	r20, r24
    213e:	51 05       	cpc	r21, r1
    2140:	30 f0       	brcs	.+12     	; 0x214e <PWM_Tool+0x8c>
  {
    Value /= 256;
    2142:	43 2e       	mov	r4, r19
    2144:	54 2e       	mov	r5, r20
    2146:	65 2e       	mov	r6, r21
    2148:	77 24       	eor	r7, r7
    Prescaler = (1 << CS12);                 /* 256 */
    214a:	24 e0       	ldi	r18, 0x04	; 4
    214c:	13 c0       	rjmp	.+38     	; 0x2174 <PWM_Tool+0xb2>
  }
  else if (Value > 16000)     /* mid-range frequency (<250Hz @8MHz) */
    214e:	21 38       	cpi	r18, 0x81	; 129
    2150:	ee e3       	ldi	r30, 0x3E	; 62
    2152:	3e 07       	cpc	r19, r30
    2154:	41 05       	cpc	r20, r1
    2156:	51 05       	cpc	r21, r1
    2158:	60 f0       	brcs	.+24     	; 0x2172 <PWM_Tool+0xb0>
  {
    Value /= 64;
    215a:	29 01       	movw	r4, r18
    215c:	3a 01       	movw	r6, r20
    215e:	68 94       	set
    2160:	15 f8       	bld	r1, 5
    2162:	76 94       	lsr	r7
    2164:	67 94       	ror	r6
    2166:	57 94       	ror	r5
    2168:	47 94       	ror	r4
    216a:	16 94       	lsr	r1
    216c:	d1 f7       	brne	.-12     	; 0x2162 <PWM_Tool+0xa0>
    Prescaler = (1 << CS11) | (1 << CS10);   /* 64 */
    216e:	23 e0       	ldi	r18, 0x03	; 3
    2170:	01 c0       	rjmp	.+2      	; 0x2174 <PWM_Tool+0xb2>
  }
  else                        /* high frequency */
  {
    Prescaler = (1 << CS10);                 /* 1 */
    2172:	21 e0       	ldi	r18, 0x01	; 1
   *  - top value by OCR1A
   *  - OC1B non-inverted output
   */

  Ratio = 50;                                /* default ratio is 50% */
  Toggle = (Top / 2) - 1;                    /* compare value for 50% */
    2174:	c2 01       	movw	r24, r4
    2176:	96 95       	lsr	r25
    2178:	87 95       	ror	r24
    217a:	01 97       	sbiw	r24, 0x01	; 1
  /* power save mode would disable timer1 */
  Config.SleepMode = SLEEP_MODE_IDLE;        /* change sleep mode to Idle */
    217c:	10 92 ab 01 	sts	0x01AB, r1

  TCCR1B = 0;                                /* disable timer */
    2180:	e1 e8       	ldi	r30, 0x81	; 129
    2182:	f0 e0       	ldi	r31, 0x00	; 0
    2184:	10 82       	st	Z, r1
  /* enable OC1B pin and set timer mode */
  TCCR1A = (1 << WGM11) | (1 << WGM10) | (1 << COM1B1);
    2186:	33 e2       	ldi	r19, 0x23	; 35
    2188:	30 93 80 00 	sts	0x0080, r19
  TCCR1B = (1 << WGM13);
    218c:	30 e1       	ldi	r19, 0x10	; 16
    218e:	30 83       	st	Z, r19
  TCNT1 = 0;                                 /* set counter to 0 */
    2190:	10 92 85 00 	sts	0x0085, r1
    2194:	10 92 84 00 	sts	0x0084, r1
  OCR1A = Top - 1;                           /* set top value (-1) */
    2198:	a2 01       	movw	r20, r4
    219a:	41 50       	subi	r20, 0x01	; 1
    219c:	51 09       	sbc	r21, r1
    219e:	50 93 89 00 	sts	0x0089, r21
    21a2:	40 93 88 00 	sts	0x0088, r20
  OCR1B = Toggle;                            /* set value to compare with */
    21a6:	90 93 8b 00 	sts	0x008B, r25
    21aa:	80 93 8a 00 	sts	0x008A, r24

  /* enable counter by setting clock prescaler */
  TCCR1B = (1 << WGM13) | Prescaler;
    21ae:	82 2f       	mov	r24, r18
    21b0:	80 61       	ori	r24, 0x10	; 16
    21b2:	80 83       	st	Z, r24
   *  - phase correct PWM
   *  - top value by OCR1A
   *  - OC1B non-inverted output
   */

  Ratio = 50;                                /* default ratio is 50% */
    21b4:	c2 e3       	ldi	r28, 0x32	; 50
    {
      if (Ratio >= 5) Ratio -= 5;         /* -5% and limit to 0% */
    }

    /* calculate toggle value: (top * (ratio / 100)) - 1 */
    Value = (uint32_t)Top * Ratio;
    21b6:	53 01       	movw	r10, r6
    21b8:	42 01       	movw	r8, r4
    21ba:	aa 24       	eor	r10, r10
    21bc:	bb 24       	eor	r11, r11
    Value /= 100;
    21be:	0f 2e       	mov	r0, r31
    21c0:	f4 e6       	ldi	r31, 0x64	; 100
    21c2:	cf 2e       	mov	r12, r31
    21c4:	d1 2c       	mov	r13, r1
    21c6:	e1 2c       	mov	r14, r1
    21c8:	f1 2c       	mov	r15, r1
    21ca:	f0 2d       	mov	r31, r0
    Toggle = (uint16_t)Value;
    Toggle--;

    OCR1B = Toggle;                     /* update compare value */
    21cc:	0a e8       	ldi	r16, 0x8A	; 138
    21ce:	10 e0       	ldi	r17, 0x00	; 0
   */

  while (Test > 0)
  {
    /* show current ratio */
    LCD_ClearLine2();
    21d0:	0e 94 09 10 	call	0x2012	; 0x2012 <LCD_ClearLine2>
    DisplayValue(Ratio, 0, '%');        /* show ratio in % */
    21d4:	8c 2f       	mov	r24, r28
    21d6:	90 e0       	ldi	r25, 0x00	; 0
    21d8:	a0 e0       	ldi	r26, 0x00	; 0
    21da:	b0 e0       	ldi	r27, 0x00	; 0
    21dc:	25 e2       	ldi	r18, 0x25	; 37
    21de:	40 e0       	ldi	r20, 0x00	; 0
    21e0:	bc 01       	movw	r22, r24
    21e2:	cd 01       	movw	r24, r26
    21e4:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
    #ifdef HW_ENCODER
    if (Test < 3)                       /* just for test button usage */
    #endif
    MilliSleep(500);                    /* smooth UI */
    21e8:	84 ef       	ldi	r24, 0xF4	; 244
    21ea:	91 e0       	ldi	r25, 0x01	; 1
    21ec:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>
        short key press -> increase ratio
        long key press -> decrease ratio
        two short key presses -> exit tool
     */

    Test = TestKey(0, 0);               /* wait for user feedback */
    21f0:	60 e0       	ldi	r22, 0x00	; 0
    21f2:	80 e0       	ldi	r24, 0x00	; 0
    21f4:	90 e0       	ldi	r25, 0x00	; 0
    21f6:	0e 94 58 33 	call	0x66b0	; 0x66b0 <TestKey>
    21fa:	d8 2f       	mov	r29, r24
    if (Test == 1)                      /* short key press */
    21fc:	81 30       	cpi	r24, 0x01	; 1
    21fe:	79 f4       	brne	.+30     	; 0x221e <PWM_Tool+0x15c>
    {
      MilliSleep(50);                   /* debounce button a little bit longer */
    2200:	82 e3       	ldi	r24, 0x32	; 50
    2202:	90 e0       	ldi	r25, 0x00	; 0
    2204:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>
      Prescaler = TestKey(200, 0);      /* check for second key press */
    2208:	60 e0       	ldi	r22, 0x00	; 0
    220a:	88 ec       	ldi	r24, 0xC8	; 200
    220c:	90 e0       	ldi	r25, 0x00	; 0
    220e:	0e 94 58 33 	call	0x66b0	; 0x66b0 <TestKey>
      if (Prescaler > 0)                /* second key press */
    2212:	81 11       	cpse	r24, r1
    2214:	31 c0       	rjmp	.+98     	; 0x2278 <PWM_Tool+0x1b6>
      {
        Test = 0;                         /* end loop */
      }
      else                              /* single key press */
      {
        if (Ratio <= 95) Ratio += 5;      /* +5% and limit to 100% */
    2216:	c0 36       	cpi	r28, 0x60	; 96
    2218:	f8 f4       	brcc	.+62     	; 0x2258 <PWM_Tool+0x196>
    221a:	cb 5f       	subi	r28, 0xFB	; 251
    221c:	1d c0       	rjmp	.+58     	; 0x2258 <PWM_Tool+0x196>
      if (Ratio >= 1) Ratio -= 1;         /* -1% and limit to 0% */
    }
    #endif
    else                                /* long key press */
    {
      if (Ratio >= 5) Ratio -= 5;         /* -5% and limit to 0% */
    221e:	c5 30       	cpi	r28, 0x05	; 5
    2220:	08 f0       	brcs	.+2      	; 0x2224 <PWM_Tool+0x162>
    2222:	c5 50       	subi	r28, 0x05	; 5
    }

    /* calculate toggle value: (top * (ratio / 100)) - 1 */
    Value = (uint32_t)Top * Ratio;
    2224:	ac 2f       	mov	r26, r28
    2226:	b0 e0       	ldi	r27, 0x00	; 0
    2228:	a5 01       	movw	r20, r10
    222a:	94 01       	movw	r18, r8
    222c:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
    Value /= 100;
    2230:	a7 01       	movw	r20, r14
    2232:	96 01       	movw	r18, r12
    2234:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    Toggle = (uint16_t)Value;
    Toggle--;
    2238:	21 50       	subi	r18, 0x01	; 1
    223a:	31 09       	sbc	r19, r1

    OCR1B = Toggle;                     /* update compare value */
    223c:	f8 01       	movw	r30, r16
    223e:	31 83       	std	Z+1, r19	; 0x01
    2240:	20 83       	st	Z, r18

  /*
   *  ratio control
   */

  while (Test > 0)
    2242:	d1 11       	cpse	r29, r1
    2244:	c5 cf       	rjmp	.-118    	; 0x21d0 <PWM_Tool+0x10e>

    OCR1B = Toggle;                     /* update compare value */
  }

  /* clean up */
  TCCR1B = 0;                 /* disable timer */
    2246:	10 92 81 00 	sts	0x0081, r1
  TCCR1A = 0;                 /* reset flags (also frees PB2) */
    224a:	10 92 80 00 	sts	0x0080, r1
  R_DDR = 0;                  /* set HiZ mode */
    224e:	14 b8       	out	0x04, r1	; 4
  Config.SleepMode = SLEEP_MODE_PWR_SAVE;    /* reset sleep mode to default */
    2250:	86 e0       	ldi	r24, 0x06	; 6
    2252:	80 93 ab 01 	sts	0x01AB, r24
    2256:	25 c0       	rjmp	.+74     	; 0x22a2 <PWM_Tool+0x1e0>
    {
      if (Ratio >= 5) Ratio -= 5;         /* -5% and limit to 0% */
    }

    /* calculate toggle value: (top * (ratio / 100)) - 1 */
    Value = (uint32_t)Top * Ratio;
    2258:	ac 2f       	mov	r26, r28
    225a:	b0 e0       	ldi	r27, 0x00	; 0
    225c:	a5 01       	movw	r20, r10
    225e:	94 01       	movw	r18, r8
    2260:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
    Value /= 100;
    2264:	a7 01       	movw	r20, r14
    2266:	96 01       	movw	r18, r12
    2268:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    Toggle = (uint16_t)Value;
    Toggle--;
    226c:	21 50       	subi	r18, 0x01	; 1
    226e:	31 09       	sbc	r19, r1

    OCR1B = Toggle;                     /* update compare value */
    2270:	f8 01       	movw	r30, r16
    2272:	31 83       	std	Z+1, r19	; 0x01
    2274:	20 83       	st	Z, r18
    2276:	ac cf       	rjmp	.-168    	; 0x21d0 <PWM_Tool+0x10e>
    {
      if (Ratio >= 5) Ratio -= 5;         /* -5% and limit to 0% */
    }

    /* calculate toggle value: (top * (ratio / 100)) - 1 */
    Value = (uint32_t)Top * Ratio;
    2278:	a3 01       	movw	r20, r6
    227a:	92 01       	movw	r18, r4
    227c:	44 27       	eor	r20, r20
    227e:	55 27       	eor	r21, r21
    2280:	ac 2f       	mov	r26, r28
    2282:	b0 e0       	ldi	r27, 0x00	; 0
    2284:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
    Value /= 100;
    2288:	24 e6       	ldi	r18, 0x64	; 100
    228a:	30 e0       	ldi	r19, 0x00	; 0
    228c:	40 e0       	ldi	r20, 0x00	; 0
    228e:	50 e0       	ldi	r21, 0x00	; 0
    2290:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    Toggle = (uint16_t)Value;
    Toggle--;
    2294:	21 50       	subi	r18, 0x01	; 1
    2296:	31 09       	sbc	r19, r1

    OCR1B = Toggle;                     /* update compare value */
    2298:	30 93 8b 00 	sts	0x008B, r19
    229c:	20 93 8a 00 	sts	0x008A, r18
    22a0:	d2 cf       	rjmp	.-92     	; 0x2246 <PWM_Tool+0x184>
  /* clean up */
  TCCR1B = 0;                 /* disable timer */
  TCCR1A = 0;                 /* reset flags (also frees PB2) */
  R_DDR = 0;                  /* set HiZ mode */
  Config.SleepMode = SLEEP_MODE_PWR_SAVE;    /* reset sleep mode to default */
}
    22a2:	df 91       	pop	r29
    22a4:	cf 91       	pop	r28
    22a6:	1f 91       	pop	r17
    22a8:	0f 91       	pop	r16
    22aa:	ff 90       	pop	r15
    22ac:	ef 90       	pop	r14
    22ae:	df 90       	pop	r13
    22b0:	cf 90       	pop	r12
    22b2:	bf 90       	pop	r11
    22b4:	af 90       	pop	r10
    22b6:	9f 90       	pop	r9
    22b8:	8f 90       	pop	r8
    22ba:	7f 90       	pop	r7
    22bc:	6f 90       	pop	r6
    22be:	5f 90       	pop	r5
    22c0:	4f 90       	pop	r4
    22c2:	08 95       	ret

000022c4 <ESR_Tool>:
/*
 *  ESR tool
 */

void ESR_Tool(void)
{
    22c4:	0f 93       	push	r16
    22c6:	1f 93       	push	r17
    22c8:	cf 93       	push	r28
    22ca:	df 93       	push	r29
  uint8_t           Run = 1;       /* control flag */
  uint8_t           Test;          /* temp. value */
  Capacitor_Type    *Cap;          /* pointer to cap */
  uint16_t          ESR;           /* ESR (in 0.01 Ohms) */

  Check.Diodes = 0;                /* disable diode check in cap measurement */
    22cc:	10 92 0c 01 	sts	0x010C, r1
  #ifdef HW_RELAY
  ADC_DDR = (1<<TP_REF);           /* short circuit probes */
  #endif

  /* show tool info */
  LCD_Clear();
    22d0:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
  LCD_EEString(ESR_str);           /* display: ESR */
    22d4:	88 e3       	ldi	r24, 0x38	; 56
    22d6:	91 e0       	ldi	r25, 0x01	; 1
    22d8:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
  ToolInfo(ESR_Probes_str);        /* show probes used */
    22dc:	84 e3       	ldi	r24, 0x34	; 52
    22de:	91 e0       	ldi	r25, 0x01	; 1
    22e0:	0e 94 35 10 	call	0x206a	; 0x206a <ToolInfo>
  LCD_Char('-');                   /* display "no value" */
    22e4:	8d e2       	ldi	r24, 0x2D	; 45
    22e6:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
      LCD_ClearLine2();                /* update line #2 */
      LCD_EEString(Running_str);       /* display: probing... */
      MeasureCap(TP2, TP1, 0);         /* probe 2 = Gnd, probe 1 = Vcc */
      LCD_ClearLine2();                /* update line #2 */
      
      if (Check.Found == COMP_CAPACITOR)     /* found capacitor */
    22ea:	c8 e0       	ldi	r28, 0x08	; 8
    22ec:	d1 e0       	ldi	r29, 0x01	; 1
      {
        /* show capacitance */
        DisplayValue(Cap->Value, Cap->Scale, 'F');
    22ee:	0b e3       	ldi	r16, 0x3B	; 59
    22f0:	11 e0       	ldi	r17, 0x01	; 1
    /*
     *  short or long key press -> measure
     *  two short key presses -> exit tool
     */

    Test = TestKey(0, 0);               /* wait for user feedback */
    22f2:	60 e0       	ldi	r22, 0x00	; 0
    22f4:	80 e0       	ldi	r24, 0x00	; 0
    22f6:	90 e0       	ldi	r25, 0x00	; 0
    22f8:	0e 94 58 33 	call	0x66b0	; 0x66b0 <TestKey>
    if (Test == 1)                      /* short key press */
    22fc:	81 30       	cpi	r24, 0x01	; 1
    22fe:	59 f4       	brne	.+22     	; 0x2316 <ESR_Tool+0x52>
    {
      MilliSleep(50);                   /* debounce button a little bit longer */
    2300:	82 e3       	ldi	r24, 0x32	; 50
    2302:	90 e0       	ldi	r25, 0x00	; 0
    2304:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>
      Test = TestKey(200, 0);           /* check for second key press */
    2308:	60 e0       	ldi	r22, 0x00	; 0
    230a:	88 ec       	ldi	r24, 0xC8	; 200
    230c:	90 e0       	ldi	r25, 0x00	; 0
    230e:	0e 94 58 33 	call	0x66b0	; 0x66b0 <TestKey>
      if (Test > 0)                     /* second key press */
    2312:	81 11       	cpse	r24, r1
    2314:	30 c0       	rjmp	.+96     	; 0x2376 <ESR_Tool+0xb2>
    {
      #ifdef HW_RELAY
      ADC_DDR = 0;                     /* remove short circuit */
      #endif

      LCD_ClearLine2();                /* update line #2 */
    2316:	0e 94 09 10 	call	0x2012	; 0x2012 <LCD_ClearLine2>
      LCD_EEString(Running_str);       /* display: probing... */
    231a:	82 ec       	ldi	r24, 0xC2	; 194
    231c:	92 e0       	ldi	r25, 0x02	; 2
    231e:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
      MeasureCap(TP2, TP1, 0);         /* probe 2 = Gnd, probe 1 = Vcc */
    2322:	40 e0       	ldi	r20, 0x00	; 0
    2324:	60 e0       	ldi	r22, 0x00	; 0
    2326:	81 e0       	ldi	r24, 0x01	; 1
    2328:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <MeasureCap>
      LCD_ClearLine2();                /* update line #2 */
    232c:	0e 94 09 10 	call	0x2012	; 0x2012 <LCD_ClearLine2>
      
      if (Check.Found == COMP_CAPACITOR)     /* found capacitor */
    2330:	99 81       	ldd	r25, Y+1	; 0x01
    2332:	9b 30       	cpi	r25, 0x0B	; 11
    2334:	e1 f4       	brne	.+56     	; 0x236e <ESR_Tool+0xaa>
      {
        /* show capacitance */
        DisplayValue(Cap->Value, Cap->Scale, 'F');
    2336:	f8 01       	movw	r30, r16
    2338:	63 81       	ldd	r22, Z+3	; 0x03
    233a:	74 81       	ldd	r23, Z+4	; 0x04
    233c:	85 81       	ldd	r24, Z+5	; 0x05
    233e:	96 81       	ldd	r25, Z+6	; 0x06
    2340:	26 e4       	ldi	r18, 0x46	; 70
    2342:	42 81       	ldd	r20, Z+2	; 0x02
    2344:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>

        /* show ESR */
        LCD_Space();
    2348:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
        ESR = MeasureESR(Cap);
    234c:	c8 01       	movw	r24, r16
    234e:	0e 94 00 0a 	call	0x1400	; 0x1400 <MeasureESR>
        if (ESR > 0)                    /* got valid ESR */
    2352:	00 97       	sbiw	r24, 0x00	; 0
    2354:	41 f0       	breq	.+16     	; 0x2366 <ESR_Tool+0xa2>
        {
          DisplayValue(ESR, -2, LCD_CHAR_OMEGA);
    2356:	bc 01       	movw	r22, r24
    2358:	80 e0       	ldi	r24, 0x00	; 0
    235a:	90 e0       	ldi	r25, 0x00	; 0
    235c:	24 e0       	ldi	r18, 0x04	; 4
    235e:	4e ef       	ldi	r20, 0xFE	; 254
    2360:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
    2364:	c6 cf       	rjmp	.-116    	; 0x22f2 <ESR_Tool+0x2e>
        }
        else                            /* no ESR */
        {
          LCD_Char('-');
    2366:	8d e2       	ldi	r24, 0x2D	; 45
    2368:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    236c:	c2 cf       	rjmp	.-124    	; 0x22f2 <ESR_Tool+0x2e>
        }
      }
      else                                   /* no capacitor */
      {
        LCD_Char('-');
    236e:	8d e2       	ldi	r24, 0x2D	; 45
    2370:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    2374:	be cf       	rjmp	.-132    	; 0x22f2 <ESR_Tool+0x2e>
  }

  #ifdef HW_RELAY
  ADC_DDR = 0;                     /* remove short circuit */
  #endif
}
    2376:	df 91       	pop	r29
    2378:	cf 91       	pop	r28
    237a:	1f 91       	pop	r17
    237c:	0f 91       	pop	r16
    237e:	08 95       	ret

00002380 <CheckEncoder>:
 *  requires:
 *  - pointer to encoder history
 */

uint8_t CheckEncoder(uint8_t *History)
{
    2380:	0f 93       	push	r16
    2382:	1f 93       	push	r17
    2384:	cf 93       	push	r28
    2386:	df 93       	push	r29
    2388:	8c 01       	movw	r16, r24
  uint8_t           Steps;                   /* encoder steps */
  uint8_t           Temp;                    /* temporary value */

  /* we assume: probe-1 = A / probe-2 = B / probe-3 = Common */
  /* setup probes: probe-1 -- Rl -- Vcc / probe-2 -- Rl -- Vcc / Gnd -- probe-3 */
  R_PORT = Probes.Rl_1 | Probes.Rl_2;   /* pullup via Rl */
    238a:	ef e8       	ldi	r30, 0x8F	; 143
    238c:	f1 e0       	ldi	r31, 0x01	; 1
    238e:	95 81       	ldd	r25, Z+5	; 0x05
    2390:	83 81       	ldd	r24, Z+3	; 0x03
    2392:	89 2b       	or	r24, r25
    2394:	85 b9       	out	0x05, r24	; 5
  R_DDR =  Probes.Rl_1 | Probes.Rl_2;   /* enable pull-up resistors */
    2396:	84 b9       	out	0x04, r24	; 4
  ADC_PORT = 0;                         /* pull down directly */
    2398:	18 b8       	out	0x08, r1	; 8
  ADC_DDR = Probes.ADC_3;               /* enable Gnd for probe-3 */
    239a:	83 85       	ldd	r24, Z+11	; 0x0b
    239c:	87 b9       	out	0x07, r24	; 7
    239e:	8f ec       	ldi	r24, 0xCF	; 207
    23a0:	97 e0       	ldi	r25, 0x07	; 7
    23a2:	01 97       	sbiw	r24, 0x01	; 1
    23a4:	f1 f7       	brne	.-4      	; 0x23a2 <CheckEncoder+0x22>
    23a6:	00 c0       	rjmp	.+0      	; 0x23a8 <CheckEncoder+0x28>
    23a8:	00 00       	nop
  _delay_us(500);                          /* settle time */

  /* get A & B signals */
  Temp = ADC_PIN;
    23aa:	26 b1       	in	r18, 0x06	; 6
  if (Temp & Probes.ADC_1) AB = 0b00000010;
    23ac:	91 85       	ldd	r25, Z+9	; 0x09
    23ae:	92 23       	and	r25, r18
    23b0:	11 f0       	breq	.+4      	; 0x23b6 <CheckEncoder+0x36>
    23b2:	c2 e0       	ldi	r28, 0x02	; 2
    23b4:	01 c0       	rjmp	.+2      	; 0x23b8 <CheckEncoder+0x38>

uint8_t CheckEncoder(uint8_t *History)
{
  uint8_t           Action = DIR_NONE;       /* return value */
  uint8_t           Old_AB;                  /* old AB state */
  uint8_t           AB = 0;                  /* new AB state */
    23b6:	c0 e0       	ldi	r28, 0x00	; 0
  _delay_us(500);                          /* settle time */

  /* get A & B signals */
  Temp = ADC_PIN;
  if (Temp & Probes.ADC_1) AB = 0b00000010;
  if (Temp & Probes.ADC_2) AB |= 0b00000001;
    23b8:	80 91 99 01 	lds	r24, 0x0199
    23bc:	82 23       	and	r24, r18
    23be:	09 f0       	breq	.+2      	; 0x23c2 <CheckEncoder+0x42>
    23c0:	c1 60       	ori	r28, 0x01	; 1

  R_DDR = 0;                  /* reset probes */
    23c2:	14 b8       	out	0x04, r1	; 4
  ADC_DDR = 0;
    23c4:	17 b8       	out	0x07, r1	; 7

  /* unpack history */
  Temp = *History;
    23c6:	f8 01       	movw	r30, r16
    23c8:	20 81       	ld	r18, Z
  Old_AB = Temp & 0b00000011;      /* old AB state, first 2 bits */
  Temp >>=2 ;                      /* move 2 bits */
    23ca:	92 2f       	mov	r25, r18
    23cc:	96 95       	lsr	r25
    23ce:	96 95       	lsr	r25
  Dir = Temp & 0b00000011;         /* direction, next 2 bits */
    23d0:	39 2f       	mov	r19, r25
    23d2:	33 70       	andi	r19, 0x03	; 3
  Temp >>= 2;                      /* move 2 bits */
    23d4:	96 95       	lsr	r25
    23d6:	96 95       	lsr	r25
  Steps = Temp;                    /* steps, remaining 4 bits */

  /* update state history */
  if (Dir == (DIR_RIGHT | DIR_LEFT))    /* first scan */
    23d8:	33 30       	cpi	r19, 0x03	; 3
    23da:	09 f4       	brne	.+2      	; 0x23de <CheckEncoder+0x5e>
    23dc:	41 c0       	rjmp	.+130    	; 0x2460 <CheckEncoder+0xe0>
  R_DDR = 0;                  /* reset probes */
  ADC_DDR = 0;

  /* unpack history */
  Temp = *History;
  Old_AB = Temp & 0b00000011;      /* old AB state, first 2 bits */
    23de:	23 70       	andi	r18, 0x03	; 3
    Old_AB = AB;              /* set as last state */
    Dir = DIR_NONE;           /* reset direction */
  }

  /* process signals */
  if (Old_AB != AB)           /* signals changed */
    23e0:	c2 17       	cp	r28, r18
    23e2:	09 f4       	brne	.+2      	; 0x23e6 <CheckEncoder+0x66>
    23e4:	40 c0       	rjmp	.+128    	; 0x2466 <CheckEncoder+0xe6>
  {
    /* check if only one bit has changed (Gray code) */
    Temp = AB ^ Old_AB;                 /* get bit difference */
    23e6:	8c 2f       	mov	r24, r28
    23e8:	82 27       	eor	r24, r18
    if (!(Temp & 0b00000001)) Temp >>= 1;
    23ea:	80 ff       	sbrs	r24, 0
    23ec:	86 95       	lsr	r24
    if (Temp == 1)                      /* valid change */
    23ee:	81 30       	cpi	r24, 0x01	; 1
    23f0:	e9 f5       	brne	.+122    	; 0x246c <CheckEncoder+0xec>
    {
      /* determine direction */
      /* Gray code: 00 01 11 10 */
      Temp = 0b10001101;                /* expected values for a right turn */
      Temp >>= (Old_AB * 2);            /* get expected value by shifting */
    23f2:	22 0f       	add	r18, r18
    23f4:	4d e8       	ldi	r20, 0x8D	; 141
    23f6:	50 e0       	ldi	r21, 0x00	; 0
    23f8:	02 c0       	rjmp	.+4      	; 0x23fe <CheckEncoder+0x7e>
    23fa:	55 95       	asr	r21
    23fc:	47 95       	ror	r20
    23fe:	2a 95       	dec	r18
    2400:	e2 f7       	brpl	.-8      	; 0x23fa <CheckEncoder+0x7a>
      Temp &= 0b00000011;               /* select value */
    2402:	43 70       	andi	r20, 0x03	; 3
      if (Temp == AB)                   /* value matches */
    2404:	4c 17       	cp	r20, r28
    2406:	11 f0       	breq	.+4      	; 0x240c <CheckEncoder+0x8c>
        Temp = DIR_RIGHT;               /* turn to the right */
      else                              /* value mismatches */
        Temp = DIR_LEFT;                /* turn to the left */
    2408:	d2 e0       	ldi	r29, 0x02	; 2
    240a:	01 c0       	rjmp	.+2      	; 0x240e <CheckEncoder+0x8e>
      /* Gray code: 00 01 11 10 */
      Temp = 0b10001101;                /* expected values for a right turn */
      Temp >>= (Old_AB * 2);            /* get expected value by shifting */
      Temp &= 0b00000011;               /* select value */
      if (Temp == AB)                   /* value matches */
        Temp = DIR_RIGHT;               /* turn to the right */
    240c:	d1 e0       	ldi	r29, 0x01	; 1
      else                              /* value mismatches */
        Temp = DIR_LEFT;                /* turn to the left */

      /* detection logic */
      if (Temp == Dir)                  /* turn in same direction */
    240e:	d3 13       	cpse	r29, r19
    2410:	30 c0       	rjmp	.+96     	; 0x2472 <CheckEncoder+0xf2>
      {
        Steps++;                        /* got another step */
    2412:	9f 5f       	subi	r25, 0xFF	; 255

        /* for proper detection we need 4 Gray code steps */
        if (Steps == 4)                 /* got 4 steps */
    2414:	94 30       	cpi	r25, 0x04	; 4
    2416:	81 f5       	brne	.+96     	; 0x2478 <CheckEncoder+0xf8>
        {
          LCD_ClearLine2();
    2418:	0e 94 09 10 	call	0x2012	; 0x2012 <LCD_ClearLine2>
           *  The turning direction determines A and B:
           *  - right: A = Probe #1 / B = Probe #2
           *  - left:  A = Probe #2 / B = Probe #1
           */

          if (Dir == DIR_RIGHT)         /* right */
    241c:	d1 30       	cpi	r29, 0x01	; 1
    241e:	51 f4       	brne	.+20     	; 0x2434 <CheckEncoder+0xb4>
          {
            Semi.A = Probes.Pin_1;
    2420:	e1 e8       	ldi	r30, 0x81	; 129
    2422:	f1 e0       	ldi	r31, 0x01	; 1
    2424:	af e8       	ldi	r26, 0x8F	; 143
    2426:	b1 e0       	ldi	r27, 0x01	; 1
    2428:	8c 91       	ld	r24, X
    242a:	80 83       	st	Z, r24
            Semi.B = Probes.Pin_2;
    242c:	11 96       	adiw	r26, 0x01	; 1
    242e:	8c 91       	ld	r24, X
    2430:	81 83       	std	Z+1, r24	; 0x01
    2432:	0a c0       	rjmp	.+20     	; 0x2448 <CheckEncoder+0xc8>
          }
          else                          /* left */
          {
            Semi.A = Probes.Pin_2;
    2434:	e1 e8       	ldi	r30, 0x81	; 129
    2436:	f1 e0       	ldi	r31, 0x01	; 1
    2438:	af e8       	ldi	r26, 0x8F	; 143
    243a:	b1 e0       	ldi	r27, 0x01	; 1
    243c:	11 96       	adiw	r26, 0x01	; 1
    243e:	8c 91       	ld	r24, X
    2440:	11 97       	sbiw	r26, 0x01	; 1
    2442:	80 83       	st	Z, r24
            Semi.B = Probes.Pin_1;
    2444:	8c 91       	ld	r24, X
    2446:	81 83       	std	Z+1, r24	; 0x01
          }

          Semi.C = Probes.Pin_3;        /* Common */
    2448:	80 91 91 01 	lds	r24, 0x0191
    244c:	80 93 83 01 	sts	0x0183, r24

          /* display pinout */
          Show_SemiPinout('A', 'B', 'C');
    2450:	43 e4       	ldi	r20, 0x43	; 67
    2452:	62 e4       	ldi	r22, 0x42	; 66
    2454:	81 e4       	ldi	r24, 0x41	; 65
    2456:	0e 94 07 1b 	call	0x360e	; 0x360e <Show_SemiPinout>

          Steps = 0;                      /* reset steps */
          Action = Temp;                  /* signal valid step */
    245a:	8d 2f       	mov	r24, r29
          Semi.C = Probes.Pin_3;        /* Common */

          /* display pinout */
          Show_SemiPinout('A', 'B', 'C');

          Steps = 0;                      /* reset steps */
    245c:	90 e0       	ldi	r25, 0x00	; 0
    245e:	0d c0       	rjmp	.+26     	; 0x247a <CheckEncoder+0xfa>

  /* update state history */
  if (Dir == (DIR_RIGHT | DIR_LEFT))    /* first scan */
  {
    Old_AB = AB;              /* set as last state */
    Dir = DIR_NONE;           /* reset direction */
    2460:	d0 e0       	ldi	r29, 0x00	; 0
 *  - pointer to encoder history
 */

uint8_t CheckEncoder(uint8_t *History)
{
  uint8_t           Action = DIR_NONE;       /* return value */
    2462:	80 e0       	ldi	r24, 0x00	; 0
    2464:	0a c0       	rjmp	.+20     	; 0x247a <CheckEncoder+0xfa>

  /* unpack history */
  Temp = *History;
  Old_AB = Temp & 0b00000011;      /* old AB state, first 2 bits */
  Temp >>=2 ;                      /* move 2 bits */
  Dir = Temp & 0b00000011;         /* direction, next 2 bits */
    2466:	d3 2f       	mov	r29, r19
 *  - pointer to encoder history
 */

uint8_t CheckEncoder(uint8_t *History)
{
  uint8_t           Action = DIR_NONE;       /* return value */
    2468:	80 e0       	ldi	r24, 0x00	; 0
    246a:	07 c0       	rjmp	.+14     	; 0x247a <CheckEncoder+0xfa>

      Dir = Temp;                  /* update direction */
    }
    else                                /* invalid change */
    {
      Dir = DIR_RIGHT | DIR_LEFT;       /* trigger reset of history */
    246c:	d3 e0       	ldi	r29, 0x03	; 3
 *  - pointer to encoder history
 */

uint8_t CheckEncoder(uint8_t *History)
{
  uint8_t           Action = DIR_NONE;       /* return value */
    246e:	80 e0       	ldi	r24, 0x00	; 0
    2470:	04 c0       	rjmp	.+8      	; 0x247a <CheckEncoder+0xfa>
          Action = Temp;                  /* signal valid step */
        }
      }
      else                         /* turn has changed direction */
      {
        Steps = 1;                 /* first step for new direction */
    2472:	91 e0       	ldi	r25, 0x01	; 1
 *  - pointer to encoder history
 */

uint8_t CheckEncoder(uint8_t *History)
{
  uint8_t           Action = DIR_NONE;       /* return value */
    2474:	80 e0       	ldi	r24, 0x00	; 0
    2476:	01 c0       	rjmp	.+2      	; 0x247a <CheckEncoder+0xfa>
    2478:	80 e0       	ldi	r24, 0x00	; 0
    }
  }

  /* pack new history */
  Temp = AB;             /* AB state, first 2 bits */
  Dir <<= 2;             /* direction, next 2 bits */
    247a:	dd 0f       	add	r29, r29
    247c:	dd 0f       	add	r29, r29
  Temp |= Dir;
  Steps <<= 4;           /* steps, remaining 4 bits */
    247e:	92 95       	swap	r25
    2480:	90 7f       	andi	r25, 0xF0	; 240
    2482:	9d 2b       	or	r25, r29
  Temp |= Steps;
    2484:	9c 2b       	or	r25, r28
  *History = Temp;       /* save new history */
    2486:	f8 01       	movw	r30, r16
    2488:	90 83       	st	Z, r25

  return Action;
}
    248a:	df 91       	pop	r29
    248c:	cf 91       	pop	r28
    248e:	1f 91       	pop	r17
    2490:	0f 91       	pop	r16
    2492:	08 95       	ret

00002494 <Encoder_Tool>:
/*
 *  rotary encoder check
 */

void Encoder_Tool(void)
{
    2494:	1f 93       	push	r17
    2496:	cf 93       	push	r28
    2498:	df 93       	push	r29
    249a:	00 d0       	rcall	.+0      	; 0x249c <Encoder_Tool+0x8>
    249c:	1f 92       	push	r1
    249e:	cd b7       	in	r28, 0x3d	; 61
    24a0:	de b7       	in	r29, 0x3e	; 62
   *  - 0000xx00 turning direction
   *  - xxxx0000 steps               
   */

  /* show info */
  LCD_Clear();
    24a2:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
  LCD_EEString(Encoder_str);       /* display: Rotary Encoder */
    24a6:	8a e1       	ldi	r24, 0x1A	; 26
    24a8:	92 e0       	ldi	r25, 0x02	; 2
    24aa:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>

  /* init array */
  for (Flag = 0; Flag <= 2; Flag++)
  {
    History[Flag] = (DIR_RIGHT | DIR_LEFT) << 2;
    24ae:	8c e0       	ldi	r24, 0x0C	; 12
    24b0:	89 83       	std	Y+1, r24	; 0x01
    24b2:	8a 83       	std	Y+2, r24	; 0x02
    24b4:	8b 83       	std	Y+3, r24	; 0x03
    24b6:	85 e0       	ldi	r24, 0x05	; 5
    }

    if (Flag > 0)             /* detected encoder */
    {
      TestKey(3000, 11);           /* let the user read */
      Flag = 5;                    /* reset flag */
    24b8:	15 e0       	ldi	r17, 0x05	; 5

  /* processing loop */
  Flag = 5;
  while (Flag < 10)
  {
    wdt_reset();
    24ba:	a8 95       	wdr

    if (Flag == 5)                 /* ask user to turn */
    24bc:	85 30       	cpi	r24, 0x05	; 5
    24be:	31 f4       	brne	.+12     	; 0x24cc <Encoder_Tool+0x38>
    {
      LCD_ClearLine2();
    24c0:	0e 94 09 10 	call	0x2012	; 0x2012 <LCD_ClearLine2>
      LCD_EEString(TurnRight_str);     /* display: Turn right! */
    24c4:	8e e0       	ldi	r24, 0x0E	; 14
    24c6:	92 e0       	ldi	r25, 0x02	; 2
    24c8:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
      Flag = 0;                        /* reset flag */
    }

    UpdateProbes(TP1, TP2, TP3);       /* check first pinout */
    24cc:	42 e0       	ldi	r20, 0x02	; 2
    24ce:	61 e0       	ldi	r22, 0x01	; 1
    24d0:	80 e0       	ldi	r24, 0x00	; 0
    24d2:	0e 94 04 23 	call	0x4608	; 0x4608 <UpdateProbes>
    Flag = CheckEncoder(&History[0]);
    24d6:	ce 01       	movw	r24, r28
    24d8:	01 96       	adiw	r24, 0x01	; 1
    24da:	0e 94 c0 11 	call	0x2380	; 0x2380 <CheckEncoder>

    if (Flag == 0)
    24de:	81 11       	cpse	r24, r1
    24e0:	15 c0       	rjmp	.+42     	; 0x250c <Encoder_Tool+0x78>
    {
      UpdateProbes(TP1, TP3, TP2);     /* check second pinout */
    24e2:	41 e0       	ldi	r20, 0x01	; 1
    24e4:	62 e0       	ldi	r22, 0x02	; 2
    24e6:	0e 94 04 23 	call	0x4608	; 0x4608 <UpdateProbes>
      Flag = CheckEncoder(&History[1]);
    24ea:	ce 01       	movw	r24, r28
    24ec:	02 96       	adiw	r24, 0x02	; 2
    24ee:	0e 94 c0 11 	call	0x2380	; 0x2380 <CheckEncoder>
    }

    if (Flag == 0)
    24f2:	81 11       	cpse	r24, r1
    24f4:	0b c0       	rjmp	.+22     	; 0x250c <Encoder_Tool+0x78>
    {    
      UpdateProbes(TP2, TP3, TP1);     /* check third pinout */
    24f6:	40 e0       	ldi	r20, 0x00	; 0
    24f8:	62 e0       	ldi	r22, 0x02	; 2
    24fa:	81 e0       	ldi	r24, 0x01	; 1
    24fc:	0e 94 04 23 	call	0x4608	; 0x4608 <UpdateProbes>
      Flag = CheckEncoder(&History[2]);
    2500:	ce 01       	movw	r24, r28
    2502:	03 96       	adiw	r24, 0x03	; 3
    2504:	0e 94 c0 11 	call	0x2380	; 0x2380 <CheckEncoder>
    }

    if (Flag > 0)             /* detected encoder */
    2508:	88 23       	and	r24, r24
    250a:	39 f0       	breq	.+14     	; 0x251a <Encoder_Tool+0x86>
    {
      TestKey(3000, 11);           /* let the user read */
    250c:	6b e0       	ldi	r22, 0x0B	; 11
    250e:	88 eb       	ldi	r24, 0xB8	; 184
    2510:	9b e0       	ldi	r25, 0x0B	; 11
    2512:	0e 94 58 33 	call	0x66b0	; 0x66b0 <TestKey>
      Flag = 5;                    /* reset flag */
    2516:	81 2f       	mov	r24, r17
    2518:	d0 cf       	rjmp	.-96     	; 0x24ba <Encoder_Tool+0x26>
    }
    else                      /* nothing found yet */
    {
      if (!(CONTROL_PIN & (1 << TEST_BUTTON)))   /* if key is pressed */
    251a:	4f 99       	sbic	0x09, 7	; 9
    251c:	ce cf       	rjmp	.-100    	; 0x24ba <Encoder_Tool+0x26>
      {
        MilliSleep(100);           /* smooth UI */
    251e:	84 e6       	ldi	r24, 0x64	; 100
    2520:	90 e0       	ldi	r25, 0x00	; 0
    2522:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>
        Flag = 10;                 /* end loop */
      }
    }
  }
}
    2526:	0f 90       	pop	r0
    2528:	0f 90       	pop	r0
    252a:	0f 90       	pop	r0
    252c:	df 91       	pop	r29
    252e:	cf 91       	pop	r28
    2530:	1f 91       	pop	r17
    2532:	08 95       	ret

00002534 <MeasureInductance>:
 *  - 1 if inductance is too high
 *  - 0 on any problem
 */

uint8_t MeasureInductance(uint32_t *Time, uint8_t Mode)
{
    2534:	1f 93       	push	r17
    2536:	cf 93       	push	r28
    2538:	df 93       	push	r29
  uint16_t          Ticks_L;       /* timer counter */
  uint16_t          Ticks_H;       /* timer overflow counter */
  uint32_t          Counter;       /* counter */

  /* sanity check */
  if (Time == NULL) return 0;
    253a:	00 97       	sbiw	r24, 0x00	; 0
    253c:	09 f4       	brne	.+2      	; 0x2540 <MeasureInductance+0xc>
    253e:	bd c0       	rjmp	.+378    	; 0x26ba <MeasureInductance+0x186>
    2540:	16 2f       	mov	r17, r22
    2542:	ec 01       	movw	r28, r24

  DischargeProbes();                    /* try to discharge probes */
    2544:	0e 94 a3 23 	call	0x4746	; 0x4746 <DischargeProbes>
  if (Check.Found == COMP_ERROR) return 0;
    2548:	80 91 09 01 	lds	r24, 0x0109
    254c:	81 30       	cpi	r24, 0x01	; 1
    254e:	09 f4       	brne	.+2      	; 0x2552 <MeasureInductance+0x1e>
    2550:	b6 c0       	rjmp	.+364    	; 0x26be <MeasureInductance+0x18a>
  /*
   *  init hardware
   */

  /* set probes: Gnd -- probe-1 / Gnd -- Rl -- probe-2 */
  R_PORT = 0;                           /* set resistor port to low */
    2552:	15 b8       	out	0x05, r1	; 5
  ADC_PORT = 0;                         /* set ADC port to low */
    2554:	18 b8       	out	0x08, r1	; 8

  if (Mode & MODE_LOW_CURRENT)     /* low current */
    2556:	10 ff       	sbrs	r17, 0
    2558:	07 c0       	rjmp	.+14     	; 0x2568 <MeasureInductance+0x34>
  {
    R_DDR = Probes.Rl_2;                /* pull down probe-2 via Rl */
    255a:	ef e8       	ldi	r30, 0x8F	; 143
    255c:	f1 e0       	ldi	r31, 0x01	; 1
    255e:	85 81       	ldd	r24, Z+5	; 0x05
    2560:	84 b9       	out	0x04, r24	; 4
    ADC_DDR = Probes.ADC_1;             /* pull down probe-1 directly */
    2562:	81 85       	ldd	r24, Z+9	; 0x09
    2564:	87 b9       	out	0x07, r24	; 7
    2566:	07 c0       	rjmp	.+14     	; 0x2576 <MeasureInductance+0x42>
  }
  else                             /* high current */
  {
    R_DDR = 0;                          /* disable probe resistors */
    2568:	14 b8       	out	0x04, r1	; 4
    /* pull down probe-1 and probe-2 directly */
    ADC_DDR = Probes.ADC_1 | Probes.ADC_2;
    256a:	ef e8       	ldi	r30, 0x8F	; 143
    256c:	f1 e0       	ldi	r31, 0x01	; 1
    256e:	92 85       	ldd	r25, Z+10	; 0x0a
    2570:	81 85       	ldd	r24, Z+9	; 0x09
    2572:	89 2b       	or	r24, r25
    2574:	87 b9       	out	0x07, r24	; 7
  }

  /* setup analog comparator */
  ADCSRB = (1 << ACME);                 /* use ADC multiplexer as negative input */
    2576:	80 e4       	ldi	r24, 0x40	; 64
    2578:	80 93 7b 00 	sts	0x007B, r24
  ACSR =  (1 << ACBG) | (1 << ACIC);    /* use bandgap as positive input, trigger timer1 */
    257c:	84 e4       	ldi	r24, 0x44	; 68
    257e:	80 bf       	out	0x30, r24	; 48
  ADMUX = (1 << REFS0) | Probes.Pin_2;  /* switch ADC multiplexer to probe-2 */
    2580:	80 91 90 01 	lds	r24, 0x0190
    2584:	80 64       	ori	r24, 0x40	; 64
    2586:	80 93 7c 00 	sts	0x007C, r24
                                        /* and set AREF to Vcc */
  ADCSRA = ADC_CLOCK_DIV;               /* disable ADC, but keep clock dividers */
    258a:	87 e0       	ldi	r24, 0x07	; 7
    258c:	80 93 7a 00 	sts	0x007A, r24
    2590:	8f e1       	ldi	r24, 0x1F	; 31
    2592:	93 e0       	ldi	r25, 0x03	; 3
    2594:	01 97       	sbiw	r24, 0x01	; 1
    2596:	f1 f7       	brne	.-4      	; 0x2594 <MeasureInductance+0x60>
    2598:	00 c0       	rjmp	.+0      	; 0x259a <MeasureInductance+0x66>
    259a:	00 00       	nop
  /*
   *  setup timer
   */

  Ticks_H = 0;                          /* reset timer overflow counter */
  TCCR1A = 0;                           /* set default mode */
    259c:	10 92 80 00 	sts	0x0080, r1
  TCCR1B = 0;                           /* set more timer modes */
    25a0:	10 92 81 00 	sts	0x0081, r1
  /* timer stopped, falling edge detection, noise canceler disabled */
  TCNT1 = 0;                            /* set Counter1 to 0 */
    25a4:	10 92 85 00 	sts	0x0085, r1
    25a8:	10 92 84 00 	sts	0x0084, r1
  /* clear all flags (input capture, compare A & B, overflow */
  TIFR1 = (1 << ICF1) | (1 << OCF1B) | (1 << OCF1A) | (1 << TOV1);
    25ac:	87 e2       	ldi	r24, 0x27	; 39
    25ae:	86 bb       	out	0x16, r24	; 22

  if (Mode & MODE_DELAYED_START)        /* delayed start */
    25b0:	f1 2f       	mov	r31, r17
    25b2:	f4 70       	andi	r31, 0x04	; 4
    25b4:	12 ff       	sbrs	r17, 2
    25b6:	0d c0       	rjmp	.+26     	; 0x25d2 <MeasureInductance+0x9e>
  {
    Test = (CPU_FREQ / 1000000);        /* MCU cycles per s */

    /* change probes: Gnd -- Rl -- probe-2 / probe-1 -- Vcc */
    ADC_PORT = Probes.ADC_1;            /* pull up probe-1 directly */
    25b8:	80 91 98 01 	lds	r24, 0x0198
    25bc:	88 b9       	out	0x08, r24	; 8
    25be:	90 e1       	ldi	r25, 0x10	; 16
     */

    while (Test > 0)
    {
      Test--;
      asm volatile("nop\n\t"::);
    25c0:	00 00       	nop
    25c2:	91 50       	subi	r25, 0x01	; 1
     *  - a loop run needs 4 cycles, the last loop run just 3
     *  - cycles burnt: <MCU cycles per s> * 4 - 1
     *    time delay: 4s - 1 MCU cycle
     */

    while (Test > 0)
    25c4:	e9 f7       	brne	.-6      	; 0x25c0 <MeasureInductance+0x8c>
    {
      Test--;
      asm volatile("nop\n\t"::);
    }

    TCCR1B |= (1 << CS10);              /* start timer (1/1 clock divider) */
    25c6:	a1 e8       	ldi	r26, 0x81	; 129
    25c8:	b0 e0       	ldi	r27, 0x00	; 0
    25ca:	8c 91       	ld	r24, X
    25cc:	81 60       	ori	r24, 0x01	; 1
    25ce:	8c 93       	st	X, r24
    25d0:	08 c0       	rjmp	.+16     	; 0x25e2 <MeasureInductance+0xae>
  }
  else                                  /* immediate start */
  {
    TCCR1B |= (1 << CS10);              /* start timer (1/1 clock divider) */
    25d2:	a1 e8       	ldi	r26, 0x81	; 129
    25d4:	b0 e0       	ldi	r27, 0x00	; 0
    25d6:	8c 91       	ld	r24, X
    25d8:	81 60       	ori	r24, 0x01	; 1
    25da:	8c 93       	st	X, r24
    /* change probes: Gnd -- Rl -- probe-2 / probe-1 -- Vcc */
    ADC_PORT = Probes.ADC_1;            /* pull up probe-1 directly */
    25dc:	80 91 98 01 	lds	r24, 0x0198
    25e0:	88 b9       	out	0x08, r24	; 8
  if (Mode & MODE_DELAYED_START)        /* delayed start */
  {
    Test = (CPU_FREQ / 1000000);        /* MCU cycles per s */

    /* change probes: Gnd -- Rl -- probe-2 / probe-1 -- Vcc */
    ADC_PORT = Probes.ADC_1;            /* pull up probe-1 directly */
    25e2:	20 e0       	ldi	r18, 0x00	; 0
    25e4:	30 e0       	ldi	r19, 0x00	; 0

    /* detect timer overflow by checking the overflow flag */
    if (Test & (1 << TOV1))
    {
      /* happens at 65.536ms for 1MHz or 8.192ms for 8MHz */
      TIFR1 = (1 << TOV1);              /* reset flag */
    25e6:	81 e0       	ldi	r24, 0x01	; 1
   *  - detect timer overflows
   */

  while (1)
  {
    Test = TIFR1;                       /* get timer1 flags */
    25e8:	96 b3       	in	r25, 0x16	; 22

    /* end loop if input capture flag is set (= same voltage) */
    if (Test & (1 << ICF1)) break;
    25ea:	95 fd       	sbrc	r25, 5
    25ec:	0a c0       	rjmp	.+20     	; 0x2602 <MeasureInductance+0xce>

    /* detect timer overflow by checking the overflow flag */
    if (Test & (1 << TOV1))
    25ee:	90 ff       	sbrs	r25, 0
    25f0:	fb cf       	rjmp	.-10     	; 0x25e8 <MeasureInductance+0xb4>
    {
      /* happens at 65.536ms for 1MHz or 8.192ms for 8MHz */
      TIFR1 = (1 << TOV1);              /* reset flag */
    25f2:	86 bb       	out	0x16, r24	; 22
      wdt_reset();                      /* reset watchdog */
    25f4:	a8 95       	wdr
      Ticks_H++;                        /* increase overflow counter */
    25f6:	2f 5f       	subi	r18, 0xFF	; 255
    25f8:	3f 4f       	sbci	r19, 0xFF	; 255

      /* if it takes too long (0.26s) */
      if (Ticks_H == (CPU_FREQ / 250000))
    25fa:	20 34       	cpi	r18, 0x40	; 64
    25fc:	31 05       	cpc	r19, r1
    25fe:	a1 f7       	brne	.-24     	; 0x25e8 <MeasureInductance+0xb4>
    2600:	60 c0       	rjmp	.+192    	; 0x26c2 <MeasureInductance+0x18e>
      }
    }
  }

  /* stop counter */
  TCCR1B = 0;                           /* stop timer */
    2602:	10 92 81 00 	sts	0x0081, r1
  TIFR1 = (1 << ICF1);                  /* reset Input Capture flag */
    2606:	80 e2       	ldi	r24, 0x20	; 32
    2608:	86 bb       	out	0x16, r24	; 22

  Ticks_L = ICR1;                       /* get counter value */
    260a:	40 91 86 00 	lds	r20, 0x0086
    260e:	50 91 87 00 	lds	r21, 0x0087

  /* prepare cut off: Gnd -- Rl -- probe-2 / probe-1 -- Rl -- Gnd */
  R_DDR = Probes.Rl_2 | Probes.Rl_1;  
    2612:	af e8       	ldi	r26, 0x8F	; 143
    2614:	b1 e0       	ldi	r27, 0x01	; 1
    2616:	13 96       	adiw	r26, 0x03	; 3
    2618:	6c 91       	ld	r22, X
    261a:	13 97       	sbiw	r26, 0x03	; 3
    261c:	15 96       	adiw	r26, 0x05	; 5
    261e:	8c 91       	ld	r24, X
    2620:	86 2b       	or	r24, r22
    2622:	84 b9       	out	0x04, r24	; 4

  /* stop current flow */
  ADC_DDR = 0;
    2624:	17 b8       	out	0x07, r1	; 7

  /* catch missed timer overflow */
  if ((TCNT1 > Ticks_L) && (Test & (1 << TOV1)))
    2626:	60 91 84 00 	lds	r22, 0x0084
    262a:	70 91 85 00 	lds	r23, 0x0085
    262e:	46 17       	cp	r20, r22
    2630:	57 07       	cpc	r21, r23
    2632:	50 f4       	brcc	.+20     	; 0x2648 <MeasureInductance+0x114>
    2634:	90 ff       	sbrs	r25, 0
    2636:	0a c0       	rjmp	.+20     	; 0x264c <MeasureInductance+0x118>
 *  - 0 on any problem
 */

uint8_t MeasureInductance(uint32_t *Time, uint8_t Mode)
{
  uint8_t           Flag = 3;      /* return value */
    2638:	e3 e0       	ldi	r30, 0x03	; 3
    263a:	01 c0       	rjmp	.+2      	; 0x263e <MeasureInductance+0x10a>
      Ticks_H++;                        /* increase overflow counter */

      /* if it takes too long (0.26s) */
      if (Ticks_H == (CPU_FREQ / 250000))
      {
        Flag = 0;             /* signal timeout */
    263c:	e0 e0       	ldi	r30, 0x00	; 0
  ADC_DDR = 0;

  /* catch missed timer overflow */
  if ((TCNT1 > Ticks_L) && (Test & (1 << TOV1)))
  {
    TIFR1 = (1 << TOV1);                /* reset overflow flag */
    263e:	81 e0       	ldi	r24, 0x01	; 1
    2640:	86 bb       	out	0x16, r24	; 22
    Ticks_H++;                          /* increase overflow counter */
    2642:	2f 5f       	subi	r18, 0xFF	; 255
    2644:	3f 4f       	sbci	r19, 0xFF	; 255
    2646:	03 c0       	rjmp	.+6      	; 0x264e <MeasureInductance+0x11a>
 *  - 0 on any problem
 */

uint8_t MeasureInductance(uint32_t *Time, uint8_t Mode)
{
  uint8_t           Flag = 3;      /* return value */
    2648:	e3 e0       	ldi	r30, 0x03	; 3
    264a:	01 c0       	rjmp	.+2      	; 0x264e <MeasureInductance+0x11a>
    264c:	e3 e0       	ldi	r30, 0x03	; 3
    TIFR1 = (1 << TOV1);                /* reset overflow flag */
    Ticks_H++;                          /* increase overflow counter */
  }

  /* enable ADC again */
  ADCSRA = (1 << ADEN) | (1 << ADIF) | ADC_CLOCK_DIV;
    264e:	87 e9       	ldi	r24, 0x97	; 151
    2650:	80 93 7a 00 	sts	0x007A, r24
  /*
   *  process counters
   */

  /* combine both counter values */
  Counter = (uint32_t)Ticks_L;          /* lower 16 bits */
    2654:	60 e0       	ldi	r22, 0x00	; 0
    2656:	70 e0       	ldi	r23, 0x00	; 0
  Counter |= (uint32_t)Ticks_H << 16;   /* upper 16 bits */
    2658:	c9 01       	movw	r24, r18
    265a:	a0 e0       	ldi	r26, 0x00	; 0
    265c:	b0 e0       	ldi	r27, 0x00	; 0
    265e:	dc 01       	movw	r26, r24
    2660:	99 27       	eor	r25, r25
    2662:	88 27       	eor	r24, r24
    2664:	84 2b       	or	r24, r20
    2666:	95 2b       	or	r25, r21
    2668:	a6 2b       	or	r26, r22
    266a:	b7 2b       	or	r27, r23

  Offset = -3;                /* subtract processing overhead */

  if (Mode & MODE_DELAYED_START)             /* delayed start */
    266c:	f1 11       	cpse	r31, r1
    266e:	45 c0       	rjmp	.+138    	; 0x26fa <MeasureInductance+0x1c6>
    2670:	4b c0       	rjmp	.+150    	; 0x2708 <MeasureInductance+0x1d4>
  }
  else                        /* negative offset */
  {
    Offset *= -1;                            /* make it positive */
    if (Counter < Offset) Counter = 0;       /* prevent underflow */
    else Counter -= Offset;                  /* subtract offset */
    2672:	bc 01       	movw	r22, r24
    2674:	cd 01       	movw	r24, r26
    2676:	64 50       	subi	r22, 0x04	; 4
    2678:	71 09       	sbc	r23, r1
    267a:	81 09       	sbc	r24, r1
    267c:	91 09       	sbc	r25, r1
  }

  /* convert counter (MCU cycles) to time (in ns) */
  if (Counter > 0)
    267e:	61 15       	cp	r22, r1
    2680:	71 05       	cpc	r23, r1
    2682:	81 05       	cpc	r24, r1
    2684:	91 05       	cpc	r25, r1
    2686:	69 f0       	breq	.+26     	; 0x26a2 <MeasureInductance+0x16e>
  {
    Counter *= (1000000000 / CPU_FREQ);      /* divide by frequeny and scale to ns */
    2688:	ae e3       	ldi	r26, 0x3E	; 62
    268a:	b0 e0       	ldi	r27, 0x00	; 0
    268c:	9b 01       	movw	r18, r22
    268e:	ac 01       	movw	r20, r24
    2690:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
  }

  if (Counter <= 100) Flag = 2;         /* signal "inductance too low" */
    2694:	65 36       	cpi	r22, 0x65	; 101
    2696:	71 05       	cpc	r23, r1
    2698:	81 05       	cpc	r24, r1
    269a:	91 05       	cpc	r25, r1
    269c:	40 f4       	brcc	.+16     	; 0x26ae <MeasureInductance+0x17a>
    269e:	e2 e0       	ldi	r30, 0x02	; 2
    26a0:	06 c0       	rjmp	.+12     	; 0x26ae <MeasureInductance+0x17a>
    26a2:	e2 e0       	ldi	r30, 0x02	; 2
    26a4:	04 c0       	rjmp	.+8      	; 0x26ae <MeasureInductance+0x17a>
    26a6:	60 e0       	ldi	r22, 0x00	; 0
    26a8:	70 e0       	ldi	r23, 0x00	; 0
    26aa:	cb 01       	movw	r24, r22
    26ac:	e2 e0       	ldi	r30, 0x02	; 2
  *Time = Counter;                      /* save time */
    26ae:	68 83       	st	Y, r22
    26b0:	79 83       	std	Y+1, r23	; 0x01
    26b2:	8a 83       	std	Y+2, r24	; 0x02
    26b4:	9b 83       	std	Y+3, r25	; 0x03

  return Flag;
    26b6:	8e 2f       	mov	r24, r30
    26b8:	2d c0       	rjmp	.+90     	; 0x2714 <MeasureInductance+0x1e0>
  uint16_t          Ticks_L;       /* timer counter */
  uint16_t          Ticks_H;       /* timer overflow counter */
  uint32_t          Counter;       /* counter */

  /* sanity check */
  if (Time == NULL) return 0;
    26ba:	80 e0       	ldi	r24, 0x00	; 0
    26bc:	2b c0       	rjmp	.+86     	; 0x2714 <MeasureInductance+0x1e0>

  DischargeProbes();                    /* try to discharge probes */
  if (Check.Found == COMP_ERROR) return 0;
    26be:	80 e0       	ldi	r24, 0x00	; 0
    26c0:	29 c0       	rjmp	.+82     	; 0x2714 <MeasureInductance+0x1e0>
      }
    }
  }

  /* stop counter */
  TCCR1B = 0;                           /* stop timer */
    26c2:	10 92 81 00 	sts	0x0081, r1
  TIFR1 = (1 << ICF1);                  /* reset Input Capture flag */
    26c6:	80 e2       	ldi	r24, 0x20	; 32
    26c8:	86 bb       	out	0x16, r24	; 22

  Ticks_L = ICR1;                       /* get counter value */
    26ca:	40 91 86 00 	lds	r20, 0x0086
    26ce:	50 91 87 00 	lds	r21, 0x0087

  /* prepare cut off: Gnd -- Rl -- probe-2 / probe-1 -- Rl -- Gnd */
  R_DDR = Probes.Rl_2 | Probes.Rl_1;  
    26d2:	af e8       	ldi	r26, 0x8F	; 143
    26d4:	b1 e0       	ldi	r27, 0x01	; 1
    26d6:	13 96       	adiw	r26, 0x03	; 3
    26d8:	9c 91       	ld	r25, X
    26da:	13 97       	sbiw	r26, 0x03	; 3
    26dc:	15 96       	adiw	r26, 0x05	; 5
    26de:	8c 91       	ld	r24, X
    26e0:	89 2b       	or	r24, r25
    26e2:	84 b9       	out	0x04, r24	; 4

  /* stop current flow */
  ADC_DDR = 0;
    26e4:	17 b8       	out	0x07, r1	; 7

  /* catch missed timer overflow */
  if ((TCNT1 > Ticks_L) && (Test & (1 << TOV1)))
    26e6:	80 91 84 00 	lds	r24, 0x0084
    26ea:	90 91 85 00 	lds	r25, 0x0085
    26ee:	48 17       	cp	r20, r24
    26f0:	59 07       	cpc	r21, r25
    26f2:	08 f4       	brcc	.+2      	; 0x26f6 <MeasureInductance+0x1c2>
    26f4:	a3 cf       	rjmp	.-186    	; 0x263c <MeasureInductance+0x108>
      Ticks_H++;                        /* increase overflow counter */

      /* if it takes too long (0.26s) */
      if (Ticks_H == (CPU_FREQ / 250000))
      {
        Flag = 0;             /* signal timeout */
    26f6:	e0 e0       	ldi	r30, 0x00	; 0
    26f8:	aa cf       	rjmp	.-172    	; 0x264e <MeasureInductance+0x11a>
    Offset -= 1;              /* timer started one cycle too early */
  }

  if (Offset >= 0)            /* positive offet */
  {
    Counter += Offset;
    26fa:	bc 01       	movw	r22, r24
    26fc:	cd 01       	movw	r24, r26
    26fe:	64 5c       	subi	r22, 0xC4	; 196
    2700:	7f 4f       	sbci	r23, 0xFF	; 255
    2702:	8f 4f       	sbci	r24, 0xFF	; 255
    2704:	9f 4f       	sbci	r25, 0xFF	; 255
    2706:	bb cf       	rjmp	.-138    	; 0x267e <MeasureInductance+0x14a>
  }
  else                        /* negative offset */
  {
    Offset *= -1;                            /* make it positive */
    if (Counter < Offset) Counter = 0;       /* prevent underflow */
    2708:	84 30       	cpi	r24, 0x04	; 4
    270a:	91 05       	cpc	r25, r1
    270c:	a1 05       	cpc	r26, r1
    270e:	b1 05       	cpc	r27, r1
    2710:	50 f2       	brcs	.-108    	; 0x26a6 <MeasureInductance+0x172>
    2712:	af cf       	rjmp	.-162    	; 0x2672 <MeasureInductance+0x13e>

  if (Counter <= 100) Flag = 2;         /* signal "inductance too low" */
  *Time = Counter;                      /* save time */

  return Flag;
}
    2714:	df 91       	pop	r29
    2716:	cf 91       	pop	r28
    2718:	1f 91       	pop	r17
    271a:	08 95       	ret

0000271c <MeasureInductor>:
 *  - 1 on success
 *  - 0 on any error
 */

uint8_t MeasureInductor(Resistor_Type *Resistor)
{
    271c:	4f 92       	push	r4
    271e:	5f 92       	push	r5
    2720:	6f 92       	push	r6
    2722:	7f 92       	push	r7
    2724:	8f 92       	push	r8
    2726:	9f 92       	push	r9
    2728:	af 92       	push	r10
    272a:	bf 92       	push	r11
    272c:	cf 92       	push	r12
    272e:	df 92       	push	r13
    2730:	ef 92       	push	r14
    2732:	ff 92       	push	r15
    2734:	0f 93       	push	r16
    2736:	1f 93       	push	r17
    2738:	cf 93       	push	r28
    273a:	df 93       	push	r29
    273c:	cd b7       	in	r28, 0x3d	; 61
    273e:	de b7       	in	r29, 0x3e	; 62
    2740:	28 97       	sbiw	r28, 0x08	; 8
    2742:	0f b6       	in	r0, 0x3f	; 63
    2744:	f8 94       	cli
    2746:	de bf       	out	0x3e, r29	; 62
    2748:	0f be       	out	0x3f, r0	; 63
    274a:	cd bf       	out	0x3d, r28	; 61
  uint32_t          Value;         /* value */
  uint32_t          Time1;         /* time #1 */
  uint32_t          Time2;         /* time #2 */

  /* reset data */
  Inductor.Scale = 0;
    274c:	e6 ea       	ldi	r30, 0xA6	; 166
    274e:	f1 e0       	ldi	r31, 0x01	; 1
    2750:	10 82       	st	Z, r1
  Inductor.Value = 0;
    2752:	11 82       	std	Z+1, r1	; 0x01
    2754:	12 82       	std	Z+2, r1	; 0x02
    2756:	13 82       	std	Z+3, r1	; 0x03
    2758:	14 82       	std	Z+4, r1	; 0x04

  /* sanity check */
  if (Resistor == NULL) return Test;
    275a:	00 97       	sbiw	r24, 0x00	; 0
    275c:	09 f4       	brne	.+2      	; 0x2760 <MeasureInductor+0x44>
    275e:	f5 c0       	rjmp	.+490    	; 0x294a <MeasureInductor+0x22e>
    2760:	6c 01       	movw	r12, r24

  /* limit resistor to 2k (feasibilty & prevent variable overflow) */ 
  if (CmpValue(Resistor->Value, Resistor->Scale, 2000, 0) >= 0) return Test;
    2762:	fc 01       	movw	r30, r24
    2764:	63 81       	ldd	r22, Z+3	; 0x03
    2766:	74 81       	ldd	r23, Z+4	; 0x04
    2768:	85 81       	ldd	r24, Z+5	; 0x05
    276a:	96 81       	ldd	r25, Z+6	; 0x06
    276c:	e1 2c       	mov	r14, r1
    276e:	00 ed       	ldi	r16, 0xD0	; 208
    2770:	17 e0       	ldi	r17, 0x07	; 7
    2772:	20 e0       	ldi	r18, 0x00	; 0
    2774:	30 e0       	ldi	r19, 0x00	; 0
    2776:	42 81       	ldd	r20, Z+2	; 0x02
    2778:	0e 94 ac 31 	call	0x6358	; 0x6358 <CmpValue>
    277c:	88 23       	and	r24, r24
    277e:	0c f0       	brlt	.+2      	; 0x2782 <MeasureInductor+0x66>
    2780:	e6 c0       	rjmp	.+460    	; 0x294e <MeasureInductor+0x232>
   *    of large inductors and keep smaller time
   *  - in case of a small inductance run in high current mode (implies
   *    immediate mode only)
   */

  UpdateProbes(Resistor->A, Resistor->B, 0);      /* update probes */
    2782:	40 e0       	ldi	r20, 0x00	; 0
    2784:	f6 01       	movw	r30, r12
    2786:	61 81       	ldd	r22, Z+1	; 0x01
    2788:	80 81       	ld	r24, Z
    278a:	0e 94 04 23 	call	0x4608	; 0x4608 <UpdateProbes>

  Mode = MODE_LOW_CURRENT;
  Test = MeasureInductance(&Time1, Mode);
    278e:	61 e0       	ldi	r22, 0x01	; 1
    2790:	ce 01       	movw	r24, r28
    2792:	01 96       	adiw	r24, 0x01	; 1
    2794:	0e 94 9a 12 	call	0x2534	; 0x2534 <MeasureInductance>
 
  if (Test == 2)                   /* inductance too low */
    2798:	82 30       	cpi	r24, 0x02	; 2
    279a:	b1 f4       	brne	.+44     	; 0x27c8 <MeasureInductor+0xac>
  {
    /* if resistance < 40 Ohms we may run the high current test */
    if (CmpValue(Resistor->Value, Resistor->Scale, 40, 0) < 0)
    279c:	f6 01       	movw	r30, r12
    279e:	63 81       	ldd	r22, Z+3	; 0x03
    27a0:	74 81       	ldd	r23, Z+4	; 0x04
    27a2:	85 81       	ldd	r24, Z+5	; 0x05
    27a4:	96 81       	ldd	r25, Z+6	; 0x06
    27a6:	08 e2       	ldi	r16, 0x28	; 40
    27a8:	10 e0       	ldi	r17, 0x00	; 0
    27aa:	20 e0       	ldi	r18, 0x00	; 0
    27ac:	30 e0       	ldi	r19, 0x00	; 0
    27ae:	42 81       	ldd	r20, Z+2	; 0x02
    27b0:	0e 94 ac 31 	call	0x6358	; 0x6358 <CmpValue>
    27b4:	88 23       	and	r24, r24
    27b6:	0c f0       	brlt	.+2      	; 0x27ba <MeasureInductor+0x9e>
    27b8:	ce c0       	rjmp	.+412    	; 0x2956 <MeasureInductor+0x23a>
    {
      Mode = MODE_HIGH_CURRENT;
      Test = MeasureInductance(&Time1, Mode);
    27ba:	62 e0       	ldi	r22, 0x02	; 2
    27bc:	ce 01       	movw	r24, r28
    27be:	01 96       	adiw	r24, 0x01	; 1
    27c0:	0e 94 9a 12 	call	0x2534	; 0x2534 <MeasureInductance>
  if (Test == 2)                   /* inductance too low */
  {
    /* if resistance < 40 Ohms we may run the high current test */
    if (CmpValue(Resistor->Value, Resistor->Scale, 40, 0) < 0)
    {
      Mode = MODE_HIGH_CURRENT;
    27c4:	12 e0       	ldi	r17, 0x02	; 2
    27c6:	1c c0       	rjmp	.+56     	; 0x2800 <MeasureInductor+0xe4>
      Test = MeasureInductance(&Time1, Mode);
    }
  }
  else if (Test == 3)              /* valid time */
    27c8:	83 30       	cpi	r24, 0x03	; 3
    27ca:	09 f0       	breq	.+2      	; 0x27ce <MeasureInductor+0xb2>
    27cc:	c4 c0       	rjmp	.+392    	; 0x2956 <MeasureInductor+0x23a>
  {
    /* let's run the delayed mode */
    Mode = MODE_LOW_CURRENT | MODE_DELAYED_START;
    Test = MeasureInductance(&Time2, Mode);
    27ce:	65 e0       	ldi	r22, 0x05	; 5
    27d0:	ce 01       	movw	r24, r28
    27d2:	05 96       	adiw	r24, 0x05	; 5
    27d4:	0e 94 9a 12 	call	0x2534	; 0x2534 <MeasureInductance>
    if (Time1 > Time2) Time1 = Time2;        /* lower value wins */
    27d8:	4d 81       	ldd	r20, Y+5	; 0x05
    27da:	5e 81       	ldd	r21, Y+6	; 0x06
    27dc:	6f 81       	ldd	r22, Y+7	; 0x07
    27de:	78 85       	ldd	r23, Y+8	; 0x08
    27e0:	89 80       	ldd	r8, Y+1	; 0x01
    27e2:	9a 80       	ldd	r9, Y+2	; 0x02
    27e4:	ab 80       	ldd	r10, Y+3	; 0x03
    27e6:	bc 80       	ldd	r11, Y+4	; 0x04
    27e8:	48 15       	cp	r20, r8
    27ea:	59 05       	cpc	r21, r9
    27ec:	6a 05       	cpc	r22, r10
    27ee:	7b 05       	cpc	r23, r11
    27f0:	30 f4       	brcc	.+12     	; 0x27fe <MeasureInductor+0xe2>
    27f2:	49 83       	std	Y+1, r20	; 0x01
    27f4:	5a 83       	std	Y+2, r21	; 0x02
    27f6:	6b 83       	std	Y+3, r22	; 0x03
    27f8:	7c 83       	std	Y+4, r23	; 0x04
    }
  }
  else if (Test == 3)              /* valid time */
  {
    /* let's run the delayed mode */
    Mode = MODE_LOW_CURRENT | MODE_DELAYED_START;
    27fa:	15 e0       	ldi	r17, 0x05	; 5
    27fc:	01 c0       	rjmp	.+2      	; 0x2800 <MeasureInductor+0xe4>
    27fe:	15 e0       	ldi	r17, 0x05	; 5
    Test = MeasureInductance(&Time2, Mode);
    if (Time1 > Time2) Time1 = Time2;        /* lower value wins */
  }  

  if (Test != 3) Test = 0;         /* measurements failed */
    2800:	83 30       	cpi	r24, 0x03	; 3
    2802:	09 f0       	breq	.+2      	; 0x2806 <MeasureInductor+0xea>
    2804:	a6 c0       	rjmp	.+332    	; 0x2952 <MeasureInductor+0x236>
    /*
     *  resistances
     */

    /* total resistance (in 0.1 Ohms) */
    R_total = RescaleValue(Resistor->Value, Resistor->Scale, -1);  /* R_L */
    2806:	f6 01       	movw	r30, r12
    2808:	63 81       	ldd	r22, Z+3	; 0x03
    280a:	74 81       	ldd	r23, Z+4	; 0x04
    280c:	85 81       	ldd	r24, Z+5	; 0x05
    280e:	96 81       	ldd	r25, Z+6	; 0x06
    2810:	2f ef       	ldi	r18, 0xFF	; 255
    2812:	42 81       	ldd	r20, Z+2	; 0x02
    2814:	0e 94 2c 32 	call	0x6458	; 0x6458 <RescaleValue>
    R_total += NV.RiH + NV.RiL;
    2818:	ab e9       	ldi	r26, 0x9B	; 155
    281a:	b1 e0       	ldi	r27, 0x01	; 1
    281c:	ed 91       	ld	r30, X+
    281e:	fc 91       	ld	r31, X
    2820:	11 97       	sbiw	r26, 0x01	; 1
    2822:	12 96       	adiw	r26, 0x02	; 2
    2824:	8d 90       	ld	r8, X+
    2826:	9c 90       	ld	r9, X
    2828:	13 97       	sbiw	r26, 0x03	; 3
    282a:	8e 0e       	add	r8, r30
    282c:	9f 1e       	adc	r9, r31
    282e:	68 0d       	add	r22, r8
    2830:	79 1d       	adc	r23, r9

    /* shunt resistance (in 0.1 Ohms) */
    Factor = NV.RiL;

    if (Mode & MODE_LOW_CURRENT)        /* low current measurement mode */
    2832:	10 ff       	sbrs	r17, 0
    2834:	04 c0       	rjmp	.+8      	; 0x283e <MeasureInductor+0x122>
    {
      /* add R_l */
      R_total += (R_LOW * 10);
    2836:	60 57       	subi	r22, 0x70	; 112
    2838:	75 4e       	sbci	r23, 0xE5	; 229
      Factor += (R_LOW * 10);
    283a:	e0 57       	subi	r30, 0x70	; 112
    283c:	f5 4e       	sbci	r31, 0xE5	; 229
     *  ratio and factor
     *  - ratio = ((U_ref * R_total) / (5V * R_shunt)) * 10^3
     */

    /* calculate ratio */
    Value = Config.Bandgap + NV.CompOffset;       /* = U_ref (in mV) */
    283e:	80 91 a3 01 	lds	r24, 0x01A3
    2842:	a0 91 af 01 	lds	r26, 0x01AF
    2846:	b0 91 b0 01 	lds	r27, 0x01B0
    284a:	a8 0f       	add	r26, r24
    284c:	b1 1d       	adc	r27, r1
    284e:	87 fd       	sbrc	r24, 7
    2850:	ba 95       	dec	r27
    Value *= R_total;                             /* * R_total (in 0.1 Ohms) */
    2852:	4b 01       	movw	r8, r22
    2854:	a1 2c       	mov	r10, r1
    2856:	b1 2c       	mov	r11, r1
    2858:	a5 01       	movw	r20, r10
    285a:	94 01       	movw	r18, r8
    285c:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
    Value /= Factor;                              /* / R_shunt (in 0.1 Ohms) */
    2860:	9f 01       	movw	r18, r30
    2862:	40 e0       	ldi	r20, 0x00	; 0
    2864:	50 e0       	ldi	r21, 0x00	; 0
    2866:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    Value /= 5;                                   /* / 5000mV, * 10^3 */
    286a:	ca 01       	movw	r24, r20
    286c:	b9 01       	movw	r22, r18
    286e:	25 e0       	ldi	r18, 0x05	; 5
    2870:	30 e0       	ldi	r19, 0x00	; 0
    2872:	40 e0       	ldi	r20, 0x00	; 0
    2874:	50 e0       	ldi	r21, 0x00	; 0
    2876:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>

    /* get ratio based factor */
    Factor = GetFactor((uint16_t)Value, TABLE_INDUCTOR);
    287a:	63 e0       	ldi	r22, 0x03	; 3
    287c:	c9 01       	movw	r24, r18
    287e:	0e 94 90 24 	call	0x4920	; 0x4920 <GetFactor>
    2882:	7c 01       	movw	r14, r24
    *  calculate inductance
    *  L = t_stop * R_total * factor
    */

    Scale = -9;               /* nH by default */
    Value = Time1;            /* t_stop (in ns) */
    2884:	29 81       	ldd	r18, Y+1	; 0x01
    2886:	3a 81       	ldd	r19, Y+2	; 0x02
    2888:	4b 81       	ldd	r20, Y+3	; 0x03
    288a:	5c 81       	ldd	r21, Y+4	; 0x04

    while (Value > 100000)    /* re-scale to prevent overflow */
    288c:	21 3a       	cpi	r18, 0xA1	; 161
    288e:	f6 e8       	ldi	r31, 0x86	; 134
    2890:	3f 07       	cpc	r19, r31
    2892:	f1 e0       	ldi	r31, 0x01	; 1
    2894:	4f 07       	cpc	r20, r31
    2896:	51 05       	cpc	r21, r1
    2898:	d8 f0       	brcs	.+54     	; 0x28d0 <MeasureInductor+0x1b4>
    289a:	17 ef       	ldi	r17, 0xF7	; 247
    {
      Value += 5;             /* for automagic rounding */
      Value /= 10;            /* scale down by 10^1 */
    289c:	0f 2e       	mov	r0, r31
    289e:	fa e0       	ldi	r31, 0x0A	; 10
    28a0:	4f 2e       	mov	r4, r31
    28a2:	51 2c       	mov	r5, r1
    28a4:	61 2c       	mov	r6, r1
    28a6:	71 2c       	mov	r7, r1
    28a8:	f0 2d       	mov	r31, r0
    Scale = -9;               /* nH by default */
    Value = Time1;            /* t_stop (in ns) */

    while (Value > 100000)    /* re-scale to prevent overflow */
    {
      Value += 5;             /* for automagic rounding */
    28aa:	ca 01       	movw	r24, r20
    28ac:	b9 01       	movw	r22, r18
    28ae:	6b 5f       	subi	r22, 0xFB	; 251
    28b0:	7f 4f       	sbci	r23, 0xFF	; 255
    28b2:	8f 4f       	sbci	r24, 0xFF	; 255
    28b4:	9f 4f       	sbci	r25, 0xFF	; 255
      Value /= 10;            /* scale down by 10^1 */
    28b6:	a3 01       	movw	r20, r6
    28b8:	92 01       	movw	r18, r4
    28ba:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
      Scale++;                /* increase exponent by 1 */
    28be:	1f 5f       	subi	r17, 0xFF	; 255
    */

    Scale = -9;               /* nH by default */
    Value = Time1;            /* t_stop (in ns) */

    while (Value > 100000)    /* re-scale to prevent overflow */
    28c0:	21 3a       	cpi	r18, 0xA1	; 161
    28c2:	86 e8       	ldi	r24, 0x86	; 134
    28c4:	38 07       	cpc	r19, r24
    28c6:	81 e0       	ldi	r24, 0x01	; 1
    28c8:	48 07       	cpc	r20, r24
    28ca:	51 05       	cpc	r21, r1
    28cc:	70 f7       	brcc	.-36     	; 0x28aa <MeasureInductor+0x18e>
    28ce:	01 c0       	rjmp	.+2      	; 0x28d2 <MeasureInductor+0x1b6>
   /*
    *  calculate inductance
    *  L = t_stop * R_total * factor
    */

    Scale = -9;               /* nH by default */
    28d0:	17 ef       	ldi	r17, 0xF7	; 247
      Value += 5;             /* for automagic rounding */
      Value /= 10;            /* scale down by 10^1 */
      Scale++;                /* increase exponent by 1 */
    }

    Value *= Factor;          /* * factor (in 10^-3) */
    28d2:	d7 01       	movw	r26, r14
    28d4:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
    28d8:	9b 01       	movw	r18, r22
    28da:	ac 01       	movw	r20, r24

    while (Value > 100000)    /* re-scale to prevent overflow */
    28dc:	61 3a       	cpi	r22, 0xA1	; 161
    28de:	76 48       	sbci	r23, 0x86	; 134
    28e0:	81 40       	sbci	r24, 0x01	; 1
    28e2:	91 05       	cpc	r25, r1
    28e4:	c8 f0       	brcs	.+50     	; 0x2918 <MeasureInductor+0x1fc>
    {
      Value += 5;             /* for automagic rounding */
      Value /= 10;            /* scale down by 10^1 */
    28e6:	0f 2e       	mov	r0, r31
    28e8:	fa e0       	ldi	r31, 0x0A	; 10
    28ea:	cf 2e       	mov	r12, r31
    28ec:	d1 2c       	mov	r13, r1
    28ee:	e1 2c       	mov	r14, r1
    28f0:	f1 2c       	mov	r15, r1
    28f2:	f0 2d       	mov	r31, r0

    Value *= Factor;          /* * factor (in 10^-3) */

    while (Value > 100000)    /* re-scale to prevent overflow */
    {
      Value += 5;             /* for automagic rounding */
    28f4:	ca 01       	movw	r24, r20
    28f6:	b9 01       	movw	r22, r18
    28f8:	6b 5f       	subi	r22, 0xFB	; 251
    28fa:	7f 4f       	sbci	r23, 0xFF	; 255
    28fc:	8f 4f       	sbci	r24, 0xFF	; 255
    28fe:	9f 4f       	sbci	r25, 0xFF	; 255
      Value /= 10;            /* scale down by 10^1 */
    2900:	a7 01       	movw	r20, r14
    2902:	96 01       	movw	r18, r12
    2904:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
      Scale++;                /* increase exponent by 1 */
    2908:	1f 5f       	subi	r17, 0xFF	; 255
      Scale++;                /* increase exponent by 1 */
    }

    Value *= Factor;          /* * factor (in 10^-3) */

    while (Value > 100000)    /* re-scale to prevent overflow */
    290a:	21 3a       	cpi	r18, 0xA1	; 161
    290c:	f6 e8       	ldi	r31, 0x86	; 134
    290e:	3f 07       	cpc	r19, r31
    2910:	f1 e0       	ldi	r31, 0x01	; 1
    2912:	4f 07       	cpc	r20, r31
    2914:	51 05       	cpc	r21, r1
    2916:	70 f7       	brcc	.-36     	; 0x28f4 <MeasureInductor+0x1d8>
      Value += 5;             /* for automagic rounding */
      Value /= 10;            /* scale down by 10^1 */
      Scale++;                /* increase exponent by 1 */
    }

    Value *= R_total;         /* * R_total (in 0.1 Ohms) */
    2918:	c5 01       	movw	r24, r10
    291a:	b4 01       	movw	r22, r8
    291c:	0e 94 4e 36 	call	0x6c9c	; 0x6c9c <__mulsi3>
    Value /= 10000;           /* /1o for 1 Ohms, /1000 for factor */

    /* update data */
    Inductor.Scale = Scale;
    2920:	0f 2e       	mov	r0, r31
    2922:	f6 ea       	ldi	r31, 0xA6	; 166
    2924:	ef 2e       	mov	r14, r31
    2926:	f1 e0       	ldi	r31, 0x01	; 1
    2928:	ff 2e       	mov	r15, r31
    292a:	f0 2d       	mov	r31, r0
    292c:	f7 01       	movw	r30, r14
    292e:	10 83       	st	Z, r17
      Value /= 10;            /* scale down by 10^1 */
      Scale++;                /* increase exponent by 1 */
    }

    Value *= R_total;         /* * R_total (in 0.1 Ohms) */
    Value /= 10000;           /* /1o for 1 Ohms, /1000 for factor */
    2930:	20 e1       	ldi	r18, 0x10	; 16
    2932:	37 e2       	ldi	r19, 0x27	; 39
    2934:	40 e0       	ldi	r20, 0x00	; 0
    2936:	50 e0       	ldi	r21, 0x00	; 0
    2938:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>

    /* update data */
    Inductor.Scale = Scale;
    Inductor.Value = Value;
    293c:	f7 01       	movw	r30, r14
    293e:	21 83       	std	Z+1, r18	; 0x01
    2940:	32 83       	std	Z+2, r19	; 0x02
    2942:	43 83       	std	Z+3, r20	; 0x03
    2944:	54 83       	std	Z+4, r21	; 0x04
    Test = 1;                 /* signal success */
    2946:	81 e0       	ldi	r24, 0x01	; 1
    2948:	07 c0       	rjmp	.+14     	; 0x2958 <MeasureInductor+0x23c>
  /* reset data */
  Inductor.Scale = 0;
  Inductor.Value = 0;

  /* sanity check */
  if (Resistor == NULL) return Test;
    294a:	80 e0       	ldi	r24, 0x00	; 0
    294c:	05 c0       	rjmp	.+10     	; 0x2958 <MeasureInductor+0x23c>

  /* limit resistor to 2k (feasibilty & prevent variable overflow) */ 
  if (CmpValue(Resistor->Value, Resistor->Scale, 2000, 0) >= 0) return Test;
    294e:	80 e0       	ldi	r24, 0x00	; 0
    2950:	03 c0       	rjmp	.+6      	; 0x2958 <MeasureInductor+0x23c>
    Mode = MODE_LOW_CURRENT | MODE_DELAYED_START;
    Test = MeasureInductance(&Time2, Mode);
    if (Time1 > Time2) Time1 = Time2;        /* lower value wins */
  }  

  if (Test != 3) Test = 0;         /* measurements failed */
    2952:	80 e0       	ldi	r24, 0x00	; 0
    2954:	01 c0       	rjmp	.+2      	; 0x2958 <MeasureInductor+0x23c>
    2956:	80 e0       	ldi	r24, 0x00	; 0
    Inductor.Value = Value;
    Test = 1;                 /* signal success */
  }

  return Test;
}
    2958:	28 96       	adiw	r28, 0x08	; 8
    295a:	0f b6       	in	r0, 0x3f	; 63
    295c:	f8 94       	cli
    295e:	de bf       	out	0x3e, r29	; 62
    2960:	0f be       	out	0x3f, r0	; 63
    2962:	cd bf       	out	0x3d, r28	; 61
    2964:	df 91       	pop	r29
    2966:	cf 91       	pop	r28
    2968:	1f 91       	pop	r17
    296a:	0f 91       	pop	r16
    296c:	ff 90       	pop	r15
    296e:	ef 90       	pop	r14
    2970:	df 90       	pop	r13
    2972:	cf 90       	pop	r12
    2974:	bf 90       	pop	r11
    2976:	af 90       	pop	r10
    2978:	9f 90       	pop	r9
    297a:	8f 90       	pop	r8
    297c:	7f 90       	pop	r7
    297e:	6f 90       	pop	r6
    2980:	5f 90       	pop	r5
    2982:	4f 90       	pop	r4
    2984:	08 95       	ret

00002986 <DisplayHexDigit>:
  /*
   *  0-9: ascii 48-57
   *  A-F: ascii 65-70
   */

  if (Digit < 10) Digit += 48;     /* 0-9 */
    2986:	8a 30       	cpi	r24, 0x0A	; 10
    2988:	10 f4       	brcc	.+4      	; 0x298e <DisplayHexDigit+0x8>
    298a:	80 5d       	subi	r24, 0xD0	; 208
    298c:	01 c0       	rjmp	.+2      	; 0x2990 <DisplayHexDigit+0xa>
  else Digit += (65 - 10);         /* A-F */
    298e:	89 5c       	subi	r24, 0xC9	; 201
  LCD_Char(Digit);  
    2990:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    2994:	08 95       	ret

00002996 <DisplayHex>:
 *  requires:
 *  - value to display
 */

void DisplayHex(uint8_t Value)
{
    2996:	cf 93       	push	r28
    2998:	c8 2f       	mov	r28, r24
  uint8_t           Digit;

  /* first digit */
  Digit = Value / 16;
  DisplayHexDigit(Digit);
    299a:	82 95       	swap	r24
    299c:	8f 70       	andi	r24, 0x0F	; 15
    299e:	0e 94 c3 14 	call	0x2986	; 0x2986 <DisplayHexDigit>

  /* second digit */
  Digit = Value % 16;
  DisplayHexDigit(Digit);
    29a2:	8c 2f       	mov	r24, r28
    29a4:	8f 70       	andi	r24, 0x0F	; 15
    29a6:	0e 94 c3 14 	call	0x2986	; 0x2986 <DisplayHexDigit>
}
    29aa:	cf 91       	pop	r28
    29ac:	08 95       	ret

000029ae <PulseCheck>:
{
  uint8_t           Flag;          /* return value */
  uint8_t           Ref2;          /* reference value */

  /* define tolerance based on value */
  if (Ref > 10)          /* long pulse */
    29ae:	6b 30       	cpi	r22, 0x0B	; 11
    29b0:	58 f4       	brcc	.+22     	; 0x29c8 <PulseCheck+0x1a>
  }
  else                   /* short pulse */
  {
    Flag = 1;                      /* default: 1 unit */

    if (IR_RelaxTime & IR_RELAX_SHORT)  /* relax timing */
    29b2:	90 91 00 01 	lds	r25, 0x0100
    29b6:	90 ff       	sbrs	r25, 0
    29b8:	02 c0       	rjmp	.+4      	; 0x29be <PulseCheck+0x10>
    {
      Flag = 3;                    /* increase to 3 units */
    29ba:	93 e0       	ldi	r25, 0x03	; 3
    29bc:	01 c0       	rjmp	.+2      	; 0x29c0 <PulseCheck+0x12>
  {
    Flag = 3;                      /* default: 3 units */
  }
  else                   /* short pulse */
  {
    Flag = 1;                      /* default: 1 unit */
    29be:	91 e0       	ldi	r25, 0x01	; 1
    29c0:	69 17       	cp	r22, r25
    29c2:	18 f4       	brcc	.+6      	; 0x29ca <PulseCheck+0x1c>
    29c4:	96 2f       	mov	r25, r22
    29c6:	01 c0       	rjmp	.+2      	; 0x29ca <PulseCheck+0x1c>
  uint8_t           Ref2;          /* reference value */

  /* define tolerance based on value */
  if (Ref > 10)          /* long pulse */
  {
    Flag = 3;                      /* default: 3 units */
    29c8:	93 e0       	ldi	r25, 0x03	; 3
    if (Flag > Ref) Flag = Ref;    /* prevent underflow */
  }

  Ref2 = Ref;
  Ref2 += Flag;               /* upper limit */
  Ref -= Flag;                /* lower limit */
    29ca:	26 2f       	mov	r18, r22
    29cc:	29 1b       	sub	r18, r25

  Flag = 0;                   /* reset flag */

  /* check if pulse duration is within allowed time window */
  if ((PulseWidth >= Ref) && (PulseWidth <= Ref2))
    29ce:	82 17       	cp	r24, r18
    29d0:	30 f0       	brcs	.+12     	; 0x29de <PulseCheck+0x30>

    if (Flag > Ref) Flag = Ref;    /* prevent underflow */
  }

  Ref2 = Ref;
  Ref2 += Flag;               /* upper limit */
    29d2:	69 0f       	add	r22, r25
  Ref -= Flag;                /* lower limit */

  Flag = 0;                   /* reset flag */

  /* check if pulse duration is within allowed time window */
  if ((PulseWidth >= Ref) && (PulseWidth <= Ref2))
    29d4:	91 e0       	ldi	r25, 0x01	; 1
    29d6:	68 17       	cp	r22, r24
    29d8:	18 f4       	brcc	.+6      	; 0x29e0 <PulseCheck+0x32>
    29da:	90 e0       	ldi	r25, 0x00	; 0
    29dc:	01 c0       	rjmp	.+2      	; 0x29e0 <PulseCheck+0x32>

  Ref2 = Ref;
  Ref2 += Flag;               /* upper limit */
  Ref -= Flag;                /* lower limit */

  Flag = 0;                   /* reset flag */
    29de:	90 e0       	ldi	r25, 0x00	; 0
  {
    Flag = 1;
  }

  return Flag;
}
    29e0:	89 2f       	mov	r24, r25
    29e2:	08 95       	ret

000029e4 <BiPhase_Demod>:
 *  - 0 for any error
 *  - number of bits
 */

uint8_t BiPhase_Demod(uint8_t *PulseWidth, uint8_t Pulses, uint8_t Mode, uint8_t Clock)
{
    29e4:	2f 92       	push	r2
    29e6:	3f 92       	push	r3
    29e8:	4f 92       	push	r4
    29ea:	5f 92       	push	r5
    29ec:	6f 92       	push	r6
    29ee:	7f 92       	push	r7
    29f0:	8f 92       	push	r8
    29f2:	9f 92       	push	r9
    29f4:	af 92       	push	r10
    29f6:	bf 92       	push	r11
    29f8:	cf 92       	push	r12
    29fa:	df 92       	push	r13
    29fc:	ef 92       	push	r14
    29fe:	ff 92       	push	r15
    2a00:	0f 93       	push	r16
    2a02:	1f 93       	push	r17
    2a04:	cf 93       	push	r28
    2a06:	df 93       	push	r29
    2a08:	8c 01       	movw	r16, r24
    2a0a:	e6 2e       	mov	r14, r22
    2a0c:	62 2e       	mov	r6, r18
   *    0: pulse pause 
   *    1: pause pulse
   */

  /* take care about heading pause */
  if (Mode & IR_PRE_PAUSE) PrePulse = 1;
    2a0e:	42 fb       	bst	r20, 2
    2a10:	88 24       	eor	r8, r8
    2a12:	80 f8       	bld	r8, 0

  while (Counter <= Pulses)   /* process all data items */
    2a14:	66 23       	and	r22, r22
    2a16:	09 f4       	brne	.+2      	; 0x2a1a <BiPhase_Demod+0x36>
    2a18:	7e c0       	rjmp	.+252    	; 0x2b16 <BiPhase_Demod+0x132>
    /* check for pulse duration */
    if (PulseCheck(Time, Clock))             /* half clock cycle */
    {
      /* do nothing */
    }
    else if (PulseCheck(Time, Clock * 2))    /* full clock cycle */
    2a1a:	22 2e       	mov	r2, r18
    2a1c:	22 0c       	add	r2, r2
    2a1e:	c2 e0       	ldi	r28, 0x02	; 2
    2a20:	41 2c       	mov	r4, r1
    2a22:	d0 e0       	ldi	r29, 0x00	; 0
    2a24:	0f 2e       	mov	r0, r31
    2a26:	f2 e0       	ldi	r31, 0x02	; 2
    2a28:	af 2e       	mov	r10, r31
    2a2a:	f1 e0       	ldi	r31, 0x01	; 1
    2a2c:	bf 2e       	mov	r11, r31
    2a2e:	f0 2d       	mov	r31, r0
    2a30:	c1 2c       	mov	r12, r1
    2a32:	99 24       	eor	r9, r9
    2a34:	93 94       	inc	r9

  while (Counter <= Pulses)   /* process all data items */
  {
    Time = *PulseWidth;       /* get duration */
    Dir = 0;                  /* reset pulse change direction */
    Width = 1;                /* reset pulse width */
    2a36:	55 24       	eor	r5, r5
    2a38:	53 94       	inc	r5
    {
      Width++;                /* double pulse */
    }
    else
    {
      Flag = 0;               /* signal error */
    2a3a:	71 2c       	mov	r7, r1
    if (Dir)                  /* got a pulse change */
    {
      Bits++;                      /* got another bit */
      Data <<= 1;                  /* shift left for new bit */

      if (Mode & IR_THOMAS)        /* Thomas */
    2a3c:	42 70       	andi	r20, 0x02	; 2
    2a3e:	34 2e       	mov	r3, r20
    2a40:	02 c0       	rjmp	.+4      	; 0x2a46 <BiPhase_Demod+0x62>
      if (PrePulse == 2)         /* first half of cycle */
      {
        /* assume that pause follows and simulate it */
        *PulseWidth = Clock;     /* half cycle */
        PulseWidth--;            /* stay here */
        Pulses++;                /* add trailing pause */
    2a42:	ec 2e       	mov	r14, r28
    2a44:	cf 5f       	subi	r28, 0xFF	; 255
    2a46:	ff 24       	eor	r15, r15
    2a48:	fa 94       	dec	r15
    2a4a:	fc 0e       	add	r15, r28
  /* take care about heading pause */
  if (Mode & IR_PRE_PAUSE) PrePulse = 1;

  while (Counter <= Pulses)   /* process all data items */
  {
    Time = *PulseWidth;       /* get duration */
    2a4c:	f8 01       	movw	r30, r16
    2a4e:	d0 80       	ld	r13, Z
    Dir = 0;                  /* reset pulse change direction */
    Width = 1;                /* reset pulse width */

    /* check for pulse duration */
    if (PulseCheck(Time, Clock))             /* half clock cycle */
    2a50:	66 2d       	mov	r22, r6
    2a52:	8d 2d       	mov	r24, r13
    2a54:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    2a58:	81 11       	cpse	r24, r1
    2a5a:	09 c0       	rjmp	.+18     	; 0x2a6e <BiPhase_Demod+0x8a>
    {
      /* do nothing */
    }
    else if (PulseCheck(Time, Clock * 2))    /* full clock cycle */
    2a5c:	62 2d       	mov	r22, r2
    2a5e:	8d 2d       	mov	r24, r13
    2a60:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    2a64:	81 11       	cpse	r24, r1
    2a66:	05 c0       	rjmp	.+10     	; 0x2a72 <BiPhase_Demod+0x8e>

  while (Counter <= Pulses)   /* process all data items */
  {
    Time = *PulseWidth;       /* get duration */
    Dir = 0;                  /* reset pulse change direction */
    Width = 1;                /* reset pulse width */
    2a68:	85 2d       	mov	r24, r5
    {
      Width++;                /* double pulse */
    }
    else
    {
      Flag = 0;               /* signal error */
    2a6a:	97 2c       	mov	r9, r7
    2a6c:	03 c0       	rjmp	.+6      	; 0x2a74 <BiPhase_Demod+0x90>

  while (Counter <= Pulses)   /* process all data items */
  {
    Time = *PulseWidth;       /* get duration */
    Dir = 0;                  /* reset pulse change direction */
    Width = 1;                /* reset pulse width */
    2a6e:	85 2d       	mov	r24, r5
    2a70:	01 c0       	rjmp	.+2      	; 0x2a74 <BiPhase_Demod+0x90>
    {
      /* do nothing */
    }
    else if (PulseCheck(Time, Clock * 2))    /* full clock cycle */
    {
      Width++;                /* double pulse */
    2a72:	82 e0       	ldi	r24, 0x02	; 2
    else
    {
      Flag = 0;               /* signal error */
    }

    if (Counter % 2 == 0)     /* pause */
    2a74:	f0 fc       	sbrc	r15, 0
    2a76:	12 c0       	rjmp	.+36     	; 0x2a9c <BiPhase_Demod+0xb8>
    {
      if (PrePulse == 2)      /* prior pulse */
    2a78:	f2 e0       	ldi	r31, 0x02	; 2
    2a7a:	8f 12       	cpse	r8, r31
    2a7c:	0a c0       	rjmp	.+20     	; 0x2a92 <BiPhase_Demod+0xae>
      {
        Dir = 1;              /* H/L change */

        if (Width == 1)       /* second half of clock cycle */
    2a7e:	85 2c       	mov	r8, r5
    2a80:	81 30       	cpi	r24, 0x01	; 1
    2a82:	09 f4       	brne	.+2      	; 0x2a86 <BiPhase_Demod+0xa2>
    2a84:	87 2c       	mov	r8, r7
    }

    /* process pulse change */
    if (Dir)                  /* got a pulse change */
    {
      Bits++;                      /* got another bit */
    2a86:	df 5f       	subi	r29, 0xFF	; 255
      Data <<= 1;                  /* shift left for new bit */
    2a88:	cc 0c       	add	r12, r12

      if (Mode & IR_THOMAS)        /* Thomas */
    2a8a:	31 10       	cpse	r3, r1
    2a8c:	13 c0       	rjmp	.+38     	; 0x2ab4 <BiPhase_Demod+0xd0>

    if (Counter % 2 == 0)     /* pause */
    {
      if (PrePulse == 2)      /* prior pulse */
      {
        Dir = 1;              /* H/L change */
    2a8e:	85 2d       	mov	r24, r5
    2a90:	15 c0       	rjmp	.+42     	; 0x2abc <BiPhase_Demod+0xd8>
          PrePulse = 1;       /* first half of the next clock cycle */
        }
      }
      else                    /* new clock cycle */
      {
        if (Width == 1)       /* first half of clock cycle */
    2a92:	81 30       	cpi	r24, 0x01	; 1
    2a94:	09 f4       	brne	.+2      	; 0x2a98 <BiPhase_Demod+0xb4>
    2a96:	58 c0       	rjmp	.+176    	; 0x2b48 <BiPhase_Demod+0x164>
        {
          PrePulse = 1;       /* first half of clock cycle */
        }
        else                  /* full clock cycle */
        {
          Flag = 0;           /* signal error */
    2a98:	97 2c       	mov	r9, r7
    2a9a:	25 c0       	rjmp	.+74     	; 0x2ae6 <BiPhase_Demod+0x102>
        }
      }
    }
    else                      /* pulse */
    {
      if (PrePulse == 1)      /* prior pause */
    2a9c:	91 e0       	ldi	r25, 0x01	; 1
    2a9e:	89 12       	cpse	r8, r25
    2aa0:	04 c0       	rjmp	.+8      	; 0x2aaa <BiPhase_Demod+0xc6>
      {
        Dir = 2;              /* L/H change */

        if (Width == 1)       /* second half of clock cycle */
    2aa2:	81 30       	cpi	r24, 0x01	; 1
    2aa4:	09 f0       	breq	.+2      	; 0x2aa8 <BiPhase_Demod+0xc4>
    2aa6:	56 c0       	rjmp	.+172    	; 0x2b54 <BiPhase_Demod+0x170>
    2aa8:	59 c0       	rjmp	.+178    	; 0x2b5c <BiPhase_Demod+0x178>
          PrePulse = 2;       /* first half of the next clock cycle */
        }
      }
      else                    /* new clock cycle */
      {
        if (Width == 1)       /* first half of clock cycle */
    2aaa:	81 30       	cpi	r24, 0x01	; 1
    2aac:	09 f4       	brne	.+2      	; 0x2ab0 <BiPhase_Demod+0xcc>
    2aae:	4e c0       	rjmp	.+156    	; 0x2b4c <BiPhase_Demod+0x168>
        {
          PrePulse = 2;       /* first half of clock cycle */
        }
        else                  /* full clock cycle */
        {
          Flag = 0;           /* signal error */
    2ab0:	97 2c       	mov	r9, r7
    2ab2:	19 c0       	rjmp	.+50     	; 0x2ae6 <BiPhase_Demod+0x102>

      if (Mode & IR_THOMAS)        /* Thomas */
      {
        if (Dir == 1)              /* H/L is 1 */
        {
          Data |= 0b00000001;      /* set bit */
    2ab4:	ec 2d       	mov	r30, r12
    2ab6:	e1 60       	ori	r30, 0x01	; 1
    2ab8:	ce 2e       	mov	r12, r30
    2aba:	05 c0       	rjmp	.+10     	; 0x2ac6 <BiPhase_Demod+0xe2>
        }
      }
      else                         /* IEEE */
      {
        if (Dir == 2)              /* L/H is 1 */
    2abc:	82 30       	cpi	r24, 0x02	; 2
    2abe:	19 f4       	brne	.+6      	; 0x2ac6 <BiPhase_Demod+0xe2>
        {
          Data |= 0b00000001;      /* set bit */
    2ac0:	fc 2d       	mov	r31, r12
    2ac2:	f1 60       	ori	r31, 0x01	; 1
    2ac4:	cf 2e       	mov	r12, r31
        }
      }

      if (Bits == 8)          /* got a byte */
    2ac6:	d8 30       	cpi	r29, 0x08	; 8
    2ac8:	71 f4       	brne	.+28     	; 0x2ae6 <BiPhase_Demod+0x102>
      {
        *Code = Data;         /* save code byte */
    2aca:	f5 01       	movw	r30, r10
    2acc:	c0 82       	st	Z, r12
        Bytes++;              /* got another byte */
    2ace:	43 94       	inc	r4
        Data = 0;             /* reset code byte */
        Bits = 0;             /* reset bit counter */

        if (Bytes < IR_CODE_BYTES)      /* prevent overflow */
    2ad0:	f5 e0       	ldi	r31, 0x05	; 5
    2ad2:	f4 15       	cp	r31, r4
    2ad4:	30 f0       	brcs	.+12     	; 0x2ae2 <BiPhase_Demod+0xfe>
        {
          Code++;             /* next code byte */
    2ad6:	8f ef       	ldi	r24, 0xFF	; 255
    2ad8:	a8 1a       	sub	r10, r24
    2ada:	b8 0a       	sbc	r11, r24
      if (Bits == 8)          /* got a byte */
      {
        *Code = Data;         /* save code byte */
        Bytes++;              /* got another byte */
        Data = 0;             /* reset code byte */
        Bits = 0;             /* reset bit counter */
    2adc:	d7 2d       	mov	r29, r7

      if (Bits == 8)          /* got a byte */
      {
        *Code = Data;         /* save code byte */
        Bytes++;              /* got another byte */
        Data = 0;             /* reset code byte */
    2ade:	c7 2c       	mov	r12, r7
    2ae0:	02 c0       	rjmp	.+4      	; 0x2ae6 <BiPhase_Demod+0x102>
        Bits = 0;             /* reset bit counter */
    2ae2:	d7 2d       	mov	r29, r7

      if (Bits == 8)          /* got a byte */
      {
        *Code = Data;         /* save code byte */
        Bytes++;              /* got another byte */
        Data = 0;             /* reset code byte */
    2ae4:	c7 2c       	mov	r12, r7
        }
      }
    }

    /* special case: missing pause at end */
    if (Counter == Pulses)       /* last pause/pulse */
    2ae6:	fe 10       	cpse	r15, r14
    2ae8:	0b c0       	rjmp	.+22     	; 0x2b00 <BiPhase_Demod+0x11c>
    {
      /* only for pulse */
      if (PrePulse == 2)         /* first half of cycle */
    2aea:	92 e0       	ldi	r25, 0x02	; 2
    2aec:	89 12       	cpse	r8, r25
    2aee:	07 c0       	rjmp	.+14     	; 0x2afe <BiPhase_Demod+0x11a>
      {
        /* assume that pause follows and simulate it */
        *PulseWidth = Clock;     /* half cycle */
    2af0:	f8 01       	movw	r30, r16
    2af2:	60 82       	st	Z, r6
        PulseWidth--;            /* stay here */
        Pulses++;                /* add trailing pause */
      }
    }

    if (Flag == 0)            /* error */
    2af4:	91 10       	cpse	r9, r1
    2af6:	a5 cf       	rjmp	.-182    	; 0x2a42 <BiPhase_Demod+0x5e>
      /* only for pulse */
      if (PrePulse == 2)         /* first half of cycle */
      {
        /* assume that pause follows and simulate it */
        *PulseWidth = Clock;     /* half cycle */
        PulseWidth--;            /* stay here */
    2af8:	01 50       	subi	r16, 0x01	; 1
    2afa:	11 09       	sbc	r17, r1
    2afc:	03 c0       	rjmp	.+6      	; 0x2b04 <BiPhase_Demod+0x120>
    2afe:	ef 2c       	mov	r14, r15
        Pulses++;                /* add trailing pause */
      }
    }

    if (Flag == 0)            /* error */
    2b00:	91 10       	cpse	r9, r1
    2b02:	01 c0       	rjmp	.+2      	; 0x2b06 <BiPhase_Demod+0x122>
    {
      Pulses = 0;             /* end loop */
    2b04:	e7 2c       	mov	r14, r7
    }

    PulseWidth++;             /* next one */
    2b06:	0f 5f       	subi	r16, 0xFF	; 255
    2b08:	1f 4f       	sbci	r17, 0xFF	; 255
   */

  /* take care about heading pause */
  if (Mode & IR_PRE_PAUSE) PrePulse = 1;

  while (Counter <= Pulses)   /* process all data items */
    2b0a:	ec 16       	cp	r14, r28
    2b0c:	08 f0       	brcs	.+2      	; 0x2b10 <BiPhase_Demod+0x12c>
    2b0e:	9a cf       	rjmp	.-204    	; 0x2a44 <BiPhase_Demod+0x60>
    PulseWidth++;             /* next one */
    Counter++;                /* next one */
  }

  /* check result */
  if (Flag)                   /* success */
    2b10:	99 20       	and	r9, r9
    2b12:	79 f0       	breq	.+30     	; 0x2b32 <BiPhase_Demod+0x14e>
    2b14:	09 c0       	rjmp	.+18     	; 0x2b28 <BiPhase_Demod+0x144>
   */

  /* take care about heading pause */
  if (Mode & IR_PRE_PAUSE) PrePulse = 1;

  while (Counter <= Pulses)   /* process all data items */
    2b16:	41 2c       	mov	r4, r1
    2b18:	d0 e0       	ldi	r29, 0x00	; 0
    2b1a:	0f 2e       	mov	r0, r31
    2b1c:	f2 e0       	ldi	r31, 0x02	; 2
    2b1e:	af 2e       	mov	r10, r31
    2b20:	f1 e0       	ldi	r31, 0x01	; 1
    2b22:	bf 2e       	mov	r11, r31
    2b24:	f0 2d       	mov	r31, r0
    2b26:	c1 2c       	mov	r12, r1
  }

  /* check result */
  if (Flag)                   /* success */
  {
    Flag = Bytes * 8;         /* return number of bits */
    2b28:	94 2c       	mov	r9, r4
    2b2a:	99 0c       	add	r9, r9
    2b2c:	99 0c       	add	r9, r9
    2b2e:	99 0c       	add	r9, r9
    Flag += Bits;
    2b30:	9d 0e       	add	r9, r29
  }

  /* shift remaining bits to left end of current byte */
  if (Bits > 0)                 /* some bits left */
    2b32:	dd 23       	and	r29, r29
    2b34:	d1 f0       	breq	.+52     	; 0x2b6a <BiPhase_Demod+0x186>
  {
    while (Bits < 8)
    2b36:	d8 30       	cpi	r29, 0x08	; 8
    2b38:	20 f4       	brcc	.+8      	; 0x2b42 <BiPhase_Demod+0x15e>
    {
      Data <<= 1;               /* shift left */
    2b3a:	cc 0c       	add	r12, r12
      Bits++;                   /* next bit */
    2b3c:	df 5f       	subi	r29, 0xFF	; 255
  }

  /* shift remaining bits to left end of current byte */
  if (Bits > 0)                 /* some bits left */
  {
    while (Bits < 8)
    2b3e:	d8 30       	cpi	r29, 0x08	; 8
    2b40:	e1 f7       	brne	.-8      	; 0x2b3a <BiPhase_Demod+0x156>
    {
      Data <<= 1;               /* shift left */
      Bits++;                   /* next bit */
    }

    *Code = Data;               /* save code byte */
    2b42:	f5 01       	movw	r30, r10
    2b44:	c0 82       	st	Z, r12
    2b46:	11 c0       	rjmp	.+34     	; 0x2b6a <BiPhase_Demod+0x186>
      }
      else                    /* new clock cycle */
      {
        if (Width == 1)       /* first half of clock cycle */
        {
          PrePulse = 1;       /* first half of clock cycle */
    2b48:	85 2c       	mov	r8, r5
    2b4a:	cd cf       	rjmp	.-102    	; 0x2ae6 <BiPhase_Demod+0x102>
      }
      else                    /* new clock cycle */
      {
        if (Width == 1)       /* first half of clock cycle */
        {
          PrePulse = 2;       /* first half of clock cycle */
    2b4c:	68 94       	set
    2b4e:	88 24       	eor	r8, r8
    2b50:	81 f8       	bld	r8, 1
    2b52:	c9 cf       	rjmp	.-110    	; 0x2ae6 <BiPhase_Demod+0x102>
        {
          PrePulse = 0;       /* clock cycle done */
        }
        else                  /* full clock cycle */
        {
          PrePulse = 2;       /* first half of the next clock cycle */
    2b54:	68 94       	set
    2b56:	88 24       	eor	r8, r8
    2b58:	81 f8       	bld	r8, 1
    2b5a:	01 c0       	rjmp	.+2      	; 0x2b5e <BiPhase_Demod+0x17a>
      {
        Dir = 2;              /* L/H change */

        if (Width == 1)       /* second half of clock cycle */
        {
          PrePulse = 0;       /* clock cycle done */
    2b5c:	87 2c       	mov	r8, r7
    }

    /* process pulse change */
    if (Dir)                  /* got a pulse change */
    {
      Bits++;                      /* got another bit */
    2b5e:	df 5f       	subi	r29, 0xFF	; 255
      Data <<= 1;                  /* shift left for new bit */
    2b60:	cc 0c       	add	r12, r12

      if (Mode & IR_THOMAS)        /* Thomas */
    2b62:	31 10       	cpse	r3, r1
    2b64:	b0 cf       	rjmp	.-160    	; 0x2ac6 <BiPhase_Demod+0xe2>
    2b66:	82 e0       	ldi	r24, 0x02	; 2
    2b68:	a9 cf       	rjmp	.-174    	; 0x2abc <BiPhase_Demod+0xd8>

    *Code = Data;               /* save code byte */
  }

  return Flag;
}
    2b6a:	89 2d       	mov	r24, r9
    2b6c:	df 91       	pop	r29
    2b6e:	cf 91       	pop	r28
    2b70:	1f 91       	pop	r17
    2b72:	0f 91       	pop	r16
    2b74:	ff 90       	pop	r15
    2b76:	ef 90       	pop	r14
    2b78:	df 90       	pop	r13
    2b7a:	cf 90       	pop	r12
    2b7c:	bf 90       	pop	r11
    2b7e:	af 90       	pop	r10
    2b80:	9f 90       	pop	r9
    2b82:	8f 90       	pop	r8
    2b84:	7f 90       	pop	r7
    2b86:	6f 90       	pop	r6
    2b88:	5f 90       	pop	r5
    2b8a:	4f 90       	pop	r4
    2b8c:	3f 90       	pop	r3
    2b8e:	2f 90       	pop	r2
    2b90:	08 95       	ret

00002b92 <PxM_Demod>:
 *  - 0 for any error
 *  - number of bits
 */

uint8_t PxM_Demod(uint8_t *PulseWidth, uint8_t Pulses, uint8_t tS, uint8_t t0, uint8_t t1)
{
    2b92:	5f 92       	push	r5
    2b94:	6f 92       	push	r6
    2b96:	7f 92       	push	r7
    2b98:	8f 92       	push	r8
    2b9a:	9f 92       	push	r9
    2b9c:	af 92       	push	r10
    2b9e:	bf 92       	push	r11
    2ba0:	cf 92       	push	r12
    2ba2:	df 92       	push	r13
    2ba4:	ef 92       	push	r14
    2ba6:	ff 92       	push	r15
    2ba8:	0f 93       	push	r16
    2baa:	1f 93       	push	r17
    2bac:	cf 93       	push	r28
    2bae:	df 93       	push	r29
   *  - two pause times to encode 0/1
   *  - last item is pulse
   *  - odd number of data items
   */

  while (Counter <= Pulses)   /* process all data items */
    2bb0:	66 23       	and	r22, r22
    2bb2:	09 f4       	brne	.+2      	; 0x2bb6 <PxM_Demod+0x24>
    2bb4:	46 c0       	rjmp	.+140    	; 0x2c42 <PxM_Demod+0xb0>
    2bb6:	50 2e       	mov	r5, r16
    2bb8:	82 2e       	mov	r8, r18
    2bba:	94 2e       	mov	r9, r20
    2bbc:	c6 2e       	mov	r12, r22
    2bbe:	e8 2e       	mov	r14, r24
    2bc0:	f9 2e       	mov	r15, r25
    2bc2:	61 2c       	mov	r6, r1
    2bc4:	d0 e0       	ldi	r29, 0x00	; 0
    2bc6:	0f 2e       	mov	r0, r31
    2bc8:	f2 e0       	ldi	r31, 0x02	; 2
    2bca:	af 2e       	mov	r10, r31
    2bcc:	f1 e0       	ldi	r31, 0x01	; 1
    2bce:	bf 2e       	mov	r11, r31
    2bd0:	f0 2d       	mov	r31, r0
    2bd2:	10 e0       	ldi	r17, 0x00	; 0
    2bd4:	c1 e0       	ldi	r28, 0x01	; 1
    2bd6:	01 e0       	ldi	r16, 0x01	; 1
    }
    else                      /* item with fixed time */
    {
      if (! PulseCheck(Time, tS))  /* time doesn't matches */
      {
        Flag = 0;                  /* signal error */
    2bd8:	71 2c       	mov	r7, r1
   *  - odd number of data items
   */

  while (Counter <= Pulses)   /* process all data items */
  {
    Time = *PulseWidth;       /* get duration */
    2bda:	f7 01       	movw	r30, r14
    2bdc:	d1 90       	ld	r13, Z+
    2bde:	7f 01       	movw	r14, r30

    if (Counter % 2 == 0)     /* item with variable time */
    2be0:	c0 fd       	sbrc	r28, 0
    2be2:	1f c0       	rjmp	.+62     	; 0x2c22 <PxM_Demod+0x90>
    {
      Bits++;                           /* got another bit */
    2be4:	df 5f       	subi	r29, 0xFF	; 255
      Data <<= 1;                       /* shift left for new bit */
    2be6:	11 0f       	add	r17, r17

      if (PulseCheck(Time, t0))         /* 0 */
    2be8:	68 2d       	mov	r22, r8
    2bea:	8d 2d       	mov	r24, r13
    2bec:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    2bf0:	81 11       	cpse	r24, r1
    2bf2:	09 c0       	rjmp	.+18     	; 0x2c06 <PxM_Demod+0x74>
      {
        /* set 0 ;) */
      }
      else if (PulseCheck(Time, t1))    /* 1 */
    2bf4:	65 2d       	mov	r22, r5
    2bf6:	8d 2d       	mov	r24, r13
    2bf8:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    2bfc:	88 23       	and	r24, r24
    2bfe:	11 f0       	breq	.+4      	; 0x2c04 <PxM_Demod+0x72>
      {
        Data |= 0b00000001;             /* set bit */
    2c00:	11 60       	ori	r17, 0x01	; 1
    2c02:	01 c0       	rjmp	.+2      	; 0x2c06 <PxM_Demod+0x74>
      }
      else                              /* invalid pulse */
      {
        Flag = 0;                       /* signal error */
    2c04:	07 2d       	mov	r16, r7
      }

      if (Bits == 8)          /* got a byte */
    2c06:	d8 30       	cpi	r29, 0x08	; 8
    2c08:	b1 f4       	brne	.+44     	; 0x2c36 <PxM_Demod+0xa4>
      {
        *Code = Data;         /* save code byte */
    2c0a:	f5 01       	movw	r30, r10
    2c0c:	10 83       	st	Z, r17
        Bytes++;              /* got another byte */
    2c0e:	63 94       	inc	r6
        Data = 0;             /* reset code byte */
        Bits = 0;             /* reset bit counter */

        if (Bytes < IR_CODE_BYTES)      /* prevent overflow */
    2c10:	f5 e0       	ldi	r31, 0x05	; 5
    2c12:	f6 15       	cp	r31, r6
    2c14:	70 f0       	brcs	.+28     	; 0x2c32 <PxM_Demod+0xa0>
        {
          Code++;             /* next code byte */
    2c16:	8f ef       	ldi	r24, 0xFF	; 255
    2c18:	a8 1a       	sub	r10, r24
    2c1a:	b8 0a       	sbc	r11, r24
      if (Bits == 8)          /* got a byte */
      {
        *Code = Data;         /* save code byte */
        Bytes++;              /* got another byte */
        Data = 0;             /* reset code byte */
        Bits = 0;             /* reset bit counter */
    2c1c:	d7 2d       	mov	r29, r7

      if (Bits == 8)          /* got a byte */
      {
        *Code = Data;         /* save code byte */
        Bytes++;              /* got another byte */
        Data = 0;             /* reset code byte */
    2c1e:	17 2d       	mov	r17, r7
    2c20:	0a c0       	rjmp	.+20     	; 0x2c36 <PxM_Demod+0xa4>
        }
      }
    }
    else                      /* item with fixed time */
    {
      if (! PulseCheck(Time, tS))  /* time doesn't matches */
    2c22:	69 2d       	mov	r22, r9
    2c24:	8d 2d       	mov	r24, r13
    2c26:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    2c2a:	81 11       	cpse	r24, r1
    2c2c:	04 c0       	rjmp	.+8      	; 0x2c36 <PxM_Demod+0xa4>
      {
        Flag = 0;                  /* signal error */
    2c2e:	07 2d       	mov	r16, r7
    2c30:	02 c0       	rjmp	.+4      	; 0x2c36 <PxM_Demod+0xa4>
      if (Bits == 8)          /* got a byte */
      {
        *Code = Data;         /* save code byte */
        Bytes++;              /* got another byte */
        Data = 0;             /* reset code byte */
        Bits = 0;             /* reset bit counter */
    2c32:	d7 2d       	mov	r29, r7

      if (Bits == 8)          /* got a byte */
      {
        *Code = Data;         /* save code byte */
        Bytes++;              /* got another byte */
        Data = 0;             /* reset code byte */
    2c34:	17 2d       	mov	r17, r7
      DisplayValue(Time, 0, 0);         /* display pulse duration */
    }
    #endif

    PulseWidth++;             /* next one */
    Counter++;                /* next one */
    2c36:	cf 5f       	subi	r28, 0xFF	; 255
   *  - two pause times to encode 0/1
   *  - last item is pulse
   *  - odd number of data items
   */

  while (Counter <= Pulses)   /* process all data items */
    2c38:	cc 16       	cp	r12, r28
    2c3a:	78 f6       	brcc	.-98     	; 0x2bda <PxM_Demod+0x48>
    PulseWidth++;             /* next one */
    Counter++;                /* next one */
  }

  /* check result */
  if (Flag)                   /* success */
    2c3c:	00 23       	and	r16, r16
    2c3e:	79 f0       	breq	.+30     	; 0x2c5e <PxM_Demod+0xcc>
    2c40:	09 c0       	rjmp	.+18     	; 0x2c54 <PxM_Demod+0xc2>
  uint8_t           Counter = 1;   /* pulse counter */
  uint8_t           Time;          /* pulse duration */
  uint8_t           Data = 0;      /* code byte */
  uint8_t           *Code;         /* pointer to code data */
  uint8_t           Bits = 0;      /* counter */
  uint8_t           Bytes = 0;     /* counter */
    2c42:	61 2c       	mov	r6, r1
  uint8_t           Flag = 1;      /* return value & control flag */
  uint8_t           Counter = 1;   /* pulse counter */
  uint8_t           Time;          /* pulse duration */
  uint8_t           Data = 0;      /* code byte */
  uint8_t           *Code;         /* pointer to code data */
  uint8_t           Bits = 0;      /* counter */
    2c44:	d0 e0       	ldi	r29, 0x00	; 0
  uint8_t           Bytes = 0;     /* counter */

  Code = &IR_Code[0];              /* set start address */
    2c46:	0f 2e       	mov	r0, r31
    2c48:	f2 e0       	ldi	r31, 0x02	; 2
    2c4a:	af 2e       	mov	r10, r31
    2c4c:	f1 e0       	ldi	r31, 0x01	; 1
    2c4e:	bf 2e       	mov	r11, r31
    2c50:	f0 2d       	mov	r31, r0
uint8_t PxM_Demod(uint8_t *PulseWidth, uint8_t Pulses, uint8_t tS, uint8_t t0, uint8_t t1)
{
  uint8_t           Flag = 1;      /* return value & control flag */
  uint8_t           Counter = 1;   /* pulse counter */
  uint8_t           Time;          /* pulse duration */
  uint8_t           Data = 0;      /* code byte */
    2c52:	10 e0       	ldi	r17, 0x00	; 0
  }

  /* check result */
  if (Flag)                   /* success */
  {
    Flag = Bytes * 8;         /* return number of bits */
    2c54:	06 2d       	mov	r16, r6
    2c56:	00 0f       	add	r16, r16
    2c58:	00 0f       	add	r16, r16
    2c5a:	00 0f       	add	r16, r16
    Flag += Bits;
    2c5c:	0d 0f       	add	r16, r29
  }

  /* shift remaining bits to left end of current byte */
  if (Bits > 0)                 /* some bits left */
    2c5e:	dd 23       	and	r29, r29
    2c60:	41 f0       	breq	.+16     	; 0x2c72 <PxM_Demod+0xe0>
  {
    while (Bits < 8)
    2c62:	d8 30       	cpi	r29, 0x08	; 8
    2c64:	20 f4       	brcc	.+8      	; 0x2c6e <PxM_Demod+0xdc>
    {
      Data <<= 1;               /* shift left */
    2c66:	11 0f       	add	r17, r17
      Bits++;                   /* next bit */
    2c68:	df 5f       	subi	r29, 0xFF	; 255
  }

  /* shift remaining bits to left end of current byte */
  if (Bits > 0)                 /* some bits left */
  {
    while (Bits < 8)
    2c6a:	d8 30       	cpi	r29, 0x08	; 8
    2c6c:	e1 f7       	brne	.-8      	; 0x2c66 <PxM_Demod+0xd4>
    {
      Data <<= 1;               /* shift left */
      Bits++;                   /* next bit */
    }

    *Code = Data;               /* save code byte */
    2c6e:	f5 01       	movw	r30, r10
    2c70:	10 83       	st	Z, r17
  }

  return Flag;
}
    2c72:	80 2f       	mov	r24, r16
    2c74:	df 91       	pop	r29
    2c76:	cf 91       	pop	r28
    2c78:	1f 91       	pop	r17
    2c7a:	0f 91       	pop	r16
    2c7c:	ff 90       	pop	r15
    2c7e:	ef 90       	pop	r14
    2c80:	df 90       	pop	r13
    2c82:	cf 90       	pop	r12
    2c84:	bf 90       	pop	r11
    2c86:	af 90       	pop	r10
    2c88:	9f 90       	pop	r9
    2c8a:	8f 90       	pop	r8
    2c8c:	7f 90       	pop	r7
    2c8e:	6f 90       	pop	r6
    2c90:	5f 90       	pop	r5
    2c92:	08 95       	ret

00002c94 <SpecialBiPhasePulse>:
 *  returns:
 *  - number of special pulses
 */

uint8_t SpecialBiPhasePulse(uint8_t *PulseWidth, uint8_t Pulses, uint8_t Offset, uint8_t Normal, uint8_t Special)
{
    2c94:	7f 92       	push	r7
    2c96:	8f 92       	push	r8
    2c98:	9f 92       	push	r9
    2c9a:	af 92       	push	r10
    2c9c:	bf 92       	push	r11
    2c9e:	cf 92       	push	r12
    2ca0:	df 92       	push	r13
    2ca2:	ef 92       	push	r14
    2ca4:	ff 92       	push	r15
    2ca6:	0f 93       	push	r16
    2ca8:	1f 93       	push	r17
    2caa:	cf 93       	push	r28
    2cac:	df 93       	push	r29
    2cae:	ec 01       	movw	r28, r24
    2cb0:	e4 2e       	mov	r14, r20
    2cb2:	b2 2e       	mov	r11, r18
    2cb4:	90 2e       	mov	r9, r16
  uint8_t           Mixed;         /* duration of mixed pulse */
  uint8_t           Time;          /* pulse duration */
  uint8_t           Cycles = 0;    /* half cycles */
  uint8_t           n = 0;         /* counter */

  Mixed = Normal + Special;        /* mixed pulse */
    2cb6:	82 2e       	mov	r8, r18
    2cb8:	80 0e       	add	r8, r16

  while (Pulses > 0)
    2cba:	66 23       	and	r22, r22
    2cbc:	a9 f1       	breq	.+106    	; 0x2d28 <SpecialBiPhasePulse+0x94>
        Flag++;

      }
      else if (PulseCheck(Time, Mixed)) /* mixed pulse */
      {
        *PulseWidth = 2 * Normal;       /* adjust to normal double pulse */
    2cbe:	72 2e       	mov	r7, r18
    2cc0:	77 0c       	add	r7, r7
    2cc2:	cc 24       	eor	r12, r12
    2cc4:	ca 94       	dec	r12
    2cc6:	c6 0e       	add	r12, r22
    2cc8:	d1 2c       	mov	r13, r1
    2cca:	8f ef       	ldi	r24, 0xFF	; 255
    2ccc:	c8 1a       	sub	r12, r24
    2cce:	d8 0a       	sbc	r13, r24
    2cd0:	cc 0e       	add	r12, r28
    2cd2:	dd 1e       	adc	r13, r29
    2cd4:	00 e0       	ldi	r16, 0x00	; 0
    2cd6:	10 e0       	ldi	r17, 0x00	; 0
    2cd8:	a1 2c       	mov	r10, r1

  Mixed = Normal + Special;        /* mixed pulse */

  while (Pulses > 0)
  {
    Time = *PulseWidth;       /* get duration */
    2cda:	f8 80       	ld	r15, Y

    if (Cycles <= Offset)     /* offset not reached yet */
    2cdc:	e1 16       	cp	r14, r17
    2cde:	58 f0       	brcs	.+22     	; 0x2cf6 <SpecialBiPhasePulse+0x62>
    {
      if (PulseCheck(Time, Normal))     /* normal pulse */
    2ce0:	6b 2d       	mov	r22, r11
    2ce2:	8f 2d       	mov	r24, r15
    2ce4:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    2ce8:	88 23       	and	r24, r24
    2cea:	11 f0       	breq	.+4      	; 0x2cf0 <SpecialBiPhasePulse+0x5c>
      {
        Cycles++;
    2cec:	1f 5f       	subi	r17, 0xFF	; 255
    2cee:	01 c0       	rjmp	.+2      	; 0x2cf2 <SpecialBiPhasePulse+0x5e>
      }
      else                              /* double or mixed pulse */
      {
        Cycles += 2;
    2cf0:	1e 5f       	subi	r17, 0xFE	; 254
      }
    }

    if (Cycles > Offset)      /* reached offset */
    2cf2:	e1 16       	cp	r14, r17
    2cf4:	a0 f4       	brcc	.+40     	; 0x2d1e <SpecialBiPhasePulse+0x8a>
    {
      if (PulseCheck(Time, Special))    /* special pulse */
    2cf6:	69 2d       	mov	r22, r9
    2cf8:	8f 2d       	mov	r24, r15
    2cfa:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    2cfe:	88 23       	and	r24, r24
    2d00:	19 f0       	breq	.+6      	; 0x2d08 <SpecialBiPhasePulse+0x74>
      {
        *PulseWidth = Normal;           /* adjust to normal */
    2d02:	b8 82       	st	Y, r11
        Flag++;
    2d04:	a3 94       	inc	r10
    2d06:	08 c0       	rjmp	.+16     	; 0x2d18 <SpecialBiPhasePulse+0x84>

      }
      else if (PulseCheck(Time, Mixed)) /* mixed pulse */
    2d08:	68 2d       	mov	r22, r8
    2d0a:	8f 2d       	mov	r24, r15
    2d0c:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    2d10:	88 23       	and	r24, r24
    2d12:	11 f0       	breq	.+4      	; 0x2d18 <SpecialBiPhasePulse+0x84>
      {
        *PulseWidth = 2 * Normal;       /* adjust to normal double pulse */
    2d14:	78 82       	st	Y, r7
        Flag++;
    2d16:	a3 94       	inc	r10
      }

      n++;                         /* increase counter */
    2d18:	0f 5f       	subi	r16, 0xFF	; 255
      if (n == 2) Pulses = 1;      /* end loop for pulse pair */
    2d1a:	02 30       	cpi	r16, 0x02	; 2
    2d1c:	31 f0       	breq	.+12     	; 0x2d2a <SpecialBiPhasePulse+0x96>
    }

    Pulses--;                 /* next pulse */
    PulseWidth++;
    2d1e:	21 96       	adiw	r28, 0x01	; 1
  uint8_t           Cycles = 0;    /* half cycles */
  uint8_t           n = 0;         /* counter */

  Mixed = Normal + Special;        /* mixed pulse */

  while (Pulses > 0)
    2d20:	cc 15       	cp	r28, r12
    2d22:	dd 05       	cpc	r29, r13
    2d24:	d1 f6       	brne	.-76     	; 0x2cda <SpecialBiPhasePulse+0x46>
    2d26:	01 c0       	rjmp	.+2      	; 0x2d2a <SpecialBiPhasePulse+0x96>
 *  - number of special pulses
 */

uint8_t SpecialBiPhasePulse(uint8_t *PulseWidth, uint8_t Pulses, uint8_t Offset, uint8_t Normal, uint8_t Special)
{
  uint8_t           Flag = 0;      /* return value */
    2d28:	a1 2c       	mov	r10, r1
    Pulses--;                 /* next pulse */
    PulseWidth++;
  }

  return(Flag);
}
    2d2a:	8a 2d       	mov	r24, r10
    2d2c:	df 91       	pop	r29
    2d2e:	cf 91       	pop	r28
    2d30:	1f 91       	pop	r17
    2d32:	0f 91       	pop	r16
    2d34:	ff 90       	pop	r15
    2d36:	ef 90       	pop	r14
    2d38:	df 90       	pop	r13
    2d3a:	cf 90       	pop	r12
    2d3c:	bf 90       	pop	r11
    2d3e:	af 90       	pop	r10
    2d40:	9f 90       	pop	r9
    2d42:	8f 90       	pop	r8
    2d44:	7f 90       	pop	r7
    2d46:	08 95       	ret

00002d48 <Codebits>:
   *  MSB: first bit from IR_Code goes to highest bit #
   *       last bit from IR_Code goes to bit #0 
   */

  /* determine start position in IR_Code */
  StartBit--;                      /* align */
    2d48:	81 50       	subi	r24, 0x01	; 1
  CodeByte = StartBit / 8;         /* start byte (0-) */
  CodeBit = StartBit % 8;          /* start bit in byte (0-) */
    2d4a:	58 2f       	mov	r21, r24
    2d4c:	57 70       	andi	r21, 0x07	; 7
   *       last bit from IR_Code goes to bit #0 
   */

  /* determine start position in IR_Code */
  StartBit--;                      /* align */
  CodeByte = StartBit / 8;         /* start byte (0-) */
    2d4e:	86 95       	lsr	r24
    2d50:	86 95       	lsr	r24
    2d52:	86 95       	lsr	r24
  CodeBit = StartBit % 8;          /* start bit in byte (0-) */
  Code = &IR_Code[CodeByte];       /* set start address */  
    2d54:	e8 2f       	mov	r30, r24
    2d56:	f0 e0       	ldi	r31, 0x00	; 0
    2d58:	ee 5f       	subi	r30, 0xFE	; 254
    2d5a:	fe 4f       	sbci	r31, 0xFE	; 254
  Temp = *Code;                    /* copy code byte */
    2d5c:	90 81       	ld	r25, Z

  /* shift start bit to bit #7 */
  n = CodeBit;                /* number of positions to shift */
  while (n > 0)
    2d5e:	55 23       	and	r21, r21
    2d60:	21 f0       	breq	.+8      	; 0x2d6a <Codebits+0x22>
    2d62:	25 2f       	mov	r18, r21
  {
    Temp <<= 1;               /* shift left */
    2d64:	99 0f       	add	r25, r25
    n--;                      /* next bit */
    2d66:	21 50       	subi	r18, 0x01	; 1
  Code = &IR_Code[CodeByte];       /* set start address */  
  Temp = *Code;                    /* copy code byte */

  /* shift start bit to bit #7 */
  n = CodeBit;                /* number of positions to shift */
  while (n > 0)
    2d68:	e9 f7       	brne	.-6      	; 0x2d64 <Codebits+0x1c>
    Temp <<= 1;               /* shift left */
    n--;                      /* next bit */
  }

  /* get bits */
  CodeBit = 8 - CodeBit;      /* remaining bits in first byte */
    2d6a:	38 e0       	ldi	r19, 0x08	; 8
    2d6c:	35 1b       	sub	r19, r21
  n = 1;
  while (n <= Bits)
    2d6e:	66 23       	and	r22, r22
    2d70:	c1 f0       	breq	.+48     	; 0x2da2 <Codebits+0x5a>
    2d72:	21 e0       	ldi	r18, 0x01	; 1
    2d74:	80 e0       	ldi	r24, 0x00	; 0
  {
    Data <<= 1;               /* shift destination left */
    2d76:	88 0f       	add	r24, r24

    if (Temp & 0b10000000)    /* bit set */
    2d78:	99 23       	and	r25, r25
    2d7a:	0c f4       	brge	.+2      	; 0x2d7e <Codebits+0x36>
    {
      Data |= 0b00000001;     /* set bit */
    2d7c:	81 60       	ori	r24, 0x01	; 1
    }

    Temp <<= 1;               /* shift source left */
    2d7e:	99 0f       	add	r25, r25

    if (n == CodeBit)         /* byte overflow */
    2d80:	23 13       	cpse	r18, r19
    2d82:	02 c0       	rjmp	.+4      	; 0x2d88 <Codebits+0x40>
    {
      Code++;                 /* next byte */
      Temp = *Code;           /* copy code byte */
    2d84:	91 81       	ldd	r25, Z+1	; 0x01

    Temp <<= 1;               /* shift source left */

    if (n == CodeBit)         /* byte overflow */
    {
      Code++;                 /* next byte */
    2d86:	31 96       	adiw	r30, 0x01	; 1
      Temp = *Code;           /* copy code byte */
      /* CodeBit += 8; */
    }

    n++;                      /* next bit */
    2d88:	2f 5f       	subi	r18, 0xFF	; 255
  }

  /* get bits */
  CodeBit = 8 - CodeBit;      /* remaining bits in first byte */
  n = 1;
  while (n <= Bits)
    2d8a:	62 17       	cp	r22, r18
    2d8c:	a0 f7       	brcc	.-24     	; 0x2d76 <Codebits+0x2e>
    2d8e:	0b c0       	rjmp	.+22     	; 0x2da6 <Codebits+0x5e>

    n++;                      /* next bit */
  }

  /* post processing */
  if (Mode == IR_LSB)         /* LSB mode */
    2d90:	98 2f       	mov	r25, r24
    2d92:	80 e0       	ldi	r24, 0x00	; 0
    Data = 0;                      /* Data becomes destination */
    n = Bits;                      /* number of bits to process */

    while (n > 0)
    {
      Data <<= 1;                  /* shift destination left */
    2d94:	88 0f       	add	r24, r24

      if (Temp & 0b00000001)       /* if bit in source is set */
    2d96:	90 fd       	sbrc	r25, 0
      {
        Data |= 0b00000001;        /* set it in destination too */
    2d98:	81 60       	ori	r24, 0x01	; 1
      }

      Temp >>= 1;                  /* shift source right */
    2d9a:	96 95       	lsr	r25
      n--;                         /* next bit */
    2d9c:	61 50       	subi	r22, 0x01	; 1
    /* reverse bit sequence */
    Temp = Data;                   /* Temp becomes source */
    Data = 0;                      /* Data becomes destination */
    n = Bits;                      /* number of bits to process */

    while (n > 0)
    2d9e:	d1 f7       	brne	.-12     	; 0x2d94 <Codebits+0x4c>
    2da0:	08 95       	ret
 *  - code byte
 */

uint8_t Codebits(uint8_t StartBit, uint8_t Bits, uint8_t Mode)
{
  uint8_t           Data = 0;      /* return value */
    2da2:	80 e0       	ldi	r24, 0x00	; 0
    2da4:	08 95       	ret

    n++;                      /* next bit */
  }

  /* post processing */
  if (Mode == IR_LSB)         /* LSB mode */
    2da6:	41 30       	cpi	r20, 0x01	; 1
    2da8:	99 f3       	breq	.-26     	; 0x2d90 <Codebits+0x48>
      n--;                         /* next bit */
    }
  } 

  return Data;
}
    2daa:	08 95       	ret

00002dac <IR_Decode>:
 *  - pointer to array of pulse duration data
 *  - number of pulses (pauses/pulses)
 */

void IR_Decode(uint8_t *PulseWidth, uint8_t Pulses)
{
    2dac:	bf 92       	push	r11
    2dae:	cf 92       	push	r12
    2db0:	df 92       	push	r13
    2db2:	ef 92       	push	r14
    2db4:	ff 92       	push	r15
    2db6:	0f 93       	push	r16
    2db8:	1f 93       	push	r17
    2dba:	cf 93       	push	r28
    2dbc:	df 93       	push	r29
    2dbe:	7c 01       	movw	r14, r24
    2dc0:	d6 2f       	mov	r29, r22
  uint8_t           Address;       /* RC address */
  uint8_t           Command;       /* RC command */
  uint8_t           Extras = 0;    /* RC extra stuff */
  uint8_t           Data = Pulses; /* temporary value */

  if (Pulses < 2) return;     /* not enough pulses */
    2dc2:	62 30       	cpi	r22, 0x02	; 2
    2dc4:	08 f4       	brcc	.+2      	; 0x2dc8 <IR_Decode+0x1c>
    2dc6:	6d c3       	rjmp	.+1754   	; 0x34a2 <IR_Decode+0x6f6>

  if (IR_State == 0)          /* no multi packet */
    2dc8:	90 91 01 01 	lds	r25, 0x0101
    2dcc:	91 11       	cpse	r25, r1
    2dce:	02 c0       	rjmp	.+4      	; 0x2dd4 <IR_Decode+0x28>
  {
    LCD_NextLine();           /* display result in a new line */
    2dd0:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <LCD_NextLine>
  /*
   *  figure out IR protocol by checking the start pulse-pause pair
   */

  Pulse = PulseWidth;         /* first pulse */
  Time1 = *Pulse;             /* duration of first pulse */
    2dd4:	f7 01       	movw	r30, r14
    2dd6:	10 81       	ld	r17, Z
  Pulse++;                    /* first pause */
  Time2 = *Pulse;             /* duration of first pause */
    2dd8:	d1 80       	ldd	r13, Z+1	; 0x01
   *    <start><address:8><inverted address:8><command:8><inverted command:8><end pulse>
   *  - extended format:
   *    <start><low address:8><high address:8><command:8><inverted command:8><end pulse>
   */

  if (PulseCheck(Time1, 180))           /* pulse 9ms */
    2dda:	64 eb       	ldi	r22, 0xB4	; 180
    2ddc:	81 2f       	mov	r24, r17
    2dde:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    2de2:	88 23       	and	r24, r24
    2de4:	09 f4       	brne	.+2      	; 0x2de8 <IR_Decode+0x3c>
    2de6:	4d c0       	rjmp	.+154    	; 0x2e82 <IR_Decode+0xd6>
  {
    if (PulseCheck(Time2, 90))          /* pause 4.5ms */
    2de8:	6a e5       	ldi	r22, 0x5A	; 90
    2dea:	8d 2d       	mov	r24, r13
    2dec:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    2df0:	88 23       	and	r24, r24
    2df2:	61 f1       	breq	.+88     	; 0x2e4c <IR_Decode+0xa0>
    {
      LCD_EEString_Space(IR_NEC_str);   /* display protocol */
    2df4:	83 e0       	ldi	r24, 0x03	; 3
    2df6:	91 e0       	ldi	r25, 0x01	; 1
    2df8:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>
      Flag = 1;                         /* detected protocol */
      PulseWidth += 2;                  /* skip start pulse */
      Pulses -= 2;
      Bits = PxM_Demod(PulseWidth, Pulses, 11, 11, 33);
    2dfc:	01 e2       	ldi	r16, 0x21	; 33
    2dfe:	2b e0       	ldi	r18, 0x0B	; 11
    2e00:	4b e0       	ldi	r20, 0x0B	; 11
    2e02:	6e ef       	ldi	r22, 0xFE	; 254
    2e04:	6d 0f       	add	r22, r29
    2e06:	c7 01       	movw	r24, r14
    2e08:	02 96       	adiw	r24, 0x02	; 2
    2e0a:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <PxM_Demod>

      if (Bits == 32)              /* we expect 32 bits */
    2e0e:	80 32       	cpi	r24, 0x20	; 32
    2e10:	09 f0       	breq	.+2      	; 0x2e14 <IR_Decode+0x68>
    2e12:	e7 c2       	rjmp	.+1486   	; 0x33e2 <IR_Decode+0x636>
      {
        Address = Codebits(1, 8, IR_LSB);    /* address */
    2e14:	41 e0       	ldi	r20, 0x01	; 1
    2e16:	68 e0       	ldi	r22, 0x08	; 8
    2e18:	81 e0       	ldi	r24, 0x01	; 1
    2e1a:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    2e1e:	c8 2e       	mov	r12, r24
        Extras = Codebits(9, 8, IR_LSB);     /* inverted address */
    2e20:	41 e0       	ldi	r20, 0x01	; 1
    2e22:	68 e0       	ldi	r22, 0x08	; 8
    2e24:	89 e0       	ldi	r24, 0x09	; 9
    2e26:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    2e2a:	c8 2f       	mov	r28, r24
        Command = Codebits(17, 8, IR_LSB);   /* command */
    2e2c:	41 e0       	ldi	r20, 0x01	; 1
    2e2e:	68 e0       	ldi	r22, 0x08	; 8
    2e30:	81 e1       	ldi	r24, 0x11	; 17
    2e32:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    2e36:	b8 2e       	mov	r11, r24

        /* determine protocol version */
        Data = ~Extras;                 /* invert */
    2e38:	dc 2f       	mov	r29, r28
    2e3a:	d0 95       	com	r29
        if (Address != Data)            /* address is not inverted */
    2e3c:	cd 16       	cp	r12, r29
    2e3e:	09 f4       	brne	.+2      	; 0x2e42 <IR_Decode+0x96>
    2e40:	06 c3       	rjmp	.+1548   	; 0x344e <IR_Decode+0x6a2>
        {
          /* extended format with 16 bit address */
          DisplayHex(Extras);           /* display high address */
    2e42:	8c 2f       	mov	r24, r28
    2e44:	0e 94 cb 14 	call	0x2996	; 0x2996 <DisplayHex>
        }

        Flag = 3;             /* confirmed + standard ouput */
    2e48:	c3 e0       	ldi	r28, 0x03	; 3
    2e4a:	81 c2       	rjmp	.+1282   	; 0x334e <IR_Decode+0x5a2>
      }
    }
    else if (PulseCheck(Time2, 45))          /* pause 2.25ms */
    2e4c:	6d e2       	ldi	r22, 0x2D	; 45
    2e4e:	8d 2d       	mov	r24, r13
    2e50:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    2e54:	88 23       	and	r24, r24
    2e56:	09 f4       	brne	.+2      	; 0x2e5a <IR_Decode+0xae>
    2e58:	c6 c2       	rjmp	.+1420   	; 0x33e6 <IR_Decode+0x63a>
    {
      /* check for repeat sequence */
      if (Pulses == 3)                       /* just 3 pulses */
    2e5a:	d3 30       	cpi	r29, 0x03	; 3
    2e5c:	09 f0       	breq	.+2      	; 0x2e60 <IR_Decode+0xb4>
    2e5e:	c5 c2       	rjmp	.+1418   	; 0x33ea <IR_Decode+0x63e>
      {
        PulseWidth += 2;                     /* skip start pulse */
        if (PulseCheck(*PulseWidth, 11))     /* pulse 560s */
    2e60:	6b e0       	ldi	r22, 0x0B	; 11
    2e62:	f7 01       	movw	r30, r14
    2e64:	82 81       	ldd	r24, Z+2	; 0x02
    2e66:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    2e6a:	88 23       	and	r24, r24
    2e6c:	09 f4       	brne	.+2      	; 0x2e70 <IR_Decode+0xc4>
    2e6e:	bf c2       	rjmp	.+1406   	; 0x33ee <IR_Decode+0x642>
        {
          LCD_EEString_Space(IR_NEC_str);    /* display protocol */
    2e70:	83 e0       	ldi	r24, 0x03	; 3
    2e72:	91 e0       	ldi	r25, 0x01	; 1
    2e74:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>
          LCD_Char('R');
    2e78:	82 e5       	ldi	r24, 0x52	; 82
    2e7a:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
          Flag = 2;                          /* confirmed */
    2e7e:	c2 e0       	ldi	r28, 0x02	; 2
    2e80:	66 c2       	rjmp	.+1228   	; 0x334e <IR_Decode+0x5a2>
   *  - PDM: pulse 500s, pause 0=500s 1=1500s
   *  - bit mode: LSB
   *  - format: <start><address:8><sync><command:8><end pulse>
   */

  else if (PulseCheck(Time1, 160))      /* pulse 8ms */
    2e82:	60 ea       	ldi	r22, 0xA0	; 160
    2e84:	81 2f       	mov	r24, r17
    2e86:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    2e8a:	88 23       	and	r24, r24
    2e8c:	e1 f1       	breq	.+120    	; 0x2f06 <IR_Decode+0x15a>
  {
    if (PulseCheck(Time2, 80))          /* pause 4ms */
    2e8e:	60 e5       	ldi	r22, 0x50	; 80
    2e90:	8d 2d       	mov	r24, r13
    2e92:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    2e96:	88 23       	and	r24, r24
    2e98:	09 f4       	brne	.+2      	; 0x2e9c <IR_Decode+0xf0>
    2e9a:	ab c2       	rjmp	.+1366   	; 0x33f2 <IR_Decode+0x646>
    {
      LCD_EEString_Space(IR_Proton_str);     /* display protocol */
    2e9c:	8e ef       	ldi	r24, 0xFE	; 254
    2e9e:	90 e0       	ldi	r25, 0x00	; 0
    2ea0:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>
      Flag = 1;                         /* detected protocol */
      PulseWidth += 2;                  /* skip start pulse */
      Pulses -= 2;
    2ea4:	8e ef       	ldi	r24, 0xFE	; 254
    2ea6:	8d 0f       	add	r24, r29

      if (Pulses > 18)        /* enough pulses for 1st part and sync */
    2ea8:	83 31       	cpi	r24, 0x13	; 19
    2eaa:	08 f4       	brcc	.+2      	; 0x2eae <IR_Decode+0x102>
    2eac:	a4 c2       	rjmp	.+1352   	; 0x33f6 <IR_Decode+0x64a>
      {
        /* first part */
        Bits = PxM_Demod(PulseWidth, 16, 11, 11, 30);
    2eae:	0e e1       	ldi	r16, 0x1E	; 30
    2eb0:	2b e0       	ldi	r18, 0x0B	; 11
    2eb2:	4b e0       	ldi	r20, 0x0B	; 11
    2eb4:	60 e1       	ldi	r22, 0x10	; 16
    2eb6:	c7 01       	movw	r24, r14
    2eb8:	02 96       	adiw	r24, 0x02	; 2
    2eba:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <PxM_Demod>

        if (Bits == 8)             /* we expect 8 bits */
    2ebe:	88 30       	cpi	r24, 0x08	; 8
    2ec0:	09 f0       	breq	.+2      	; 0x2ec4 <IR_Decode+0x118>
    2ec2:	9b c2       	rjmp	.+1334   	; 0x33fa <IR_Decode+0x64e>
        {
          Address = Codebits(1, 8, IR_LSB);       /* address */
    2ec4:	41 e0       	ldi	r20, 0x01	; 1
    2ec6:	68 e0       	ldi	r22, 0x08	; 8
    2ec8:	81 e0       	ldi	r24, 0x01	; 1
    2eca:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    2ece:	c8 2e       	mov	r12, r24
          PulseWidth += 17;        /* 16 pulses + terminating pulse */
          Pulses -= 17;

          /* check for separator after first part */
          if (PulseCheck(*PulseWidth, 80))     /* pause 4ms */
    2ed0:	60 e5       	ldi	r22, 0x50	; 80
    2ed2:	f7 01       	movw	r30, r14
    2ed4:	83 89       	ldd	r24, Z+19	; 0x13
    2ed6:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    2eda:	88 23       	and	r24, r24
    2edc:	09 f4       	brne	.+2      	; 0x2ee0 <IR_Decode+0x134>
    2ede:	8f c2       	rjmp	.+1310   	; 0x33fe <IR_Decode+0x652>
          {
            PulseWidth++;               /* skip pause */
            Pulses--;

            /* second part */
            Bits = PxM_Demod(PulseWidth, Pulses, 11, 11, 30);
    2ee0:	2b e0       	ldi	r18, 0x0B	; 11
    2ee2:	4b e0       	ldi	r20, 0x0B	; 11
    2ee4:	6c ee       	ldi	r22, 0xEC	; 236
    2ee6:	6d 0f       	add	r22, r29
    2ee8:	c7 01       	movw	r24, r14
    2eea:	44 96       	adiw	r24, 0x14	; 20
    2eec:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <PxM_Demod>

            if (Bits == 8)             /* we expect 8 bits */
    2ef0:	88 30       	cpi	r24, 0x08	; 8
    2ef2:	09 f0       	breq	.+2      	; 0x2ef6 <IR_Decode+0x14a>
    2ef4:	86 c2       	rjmp	.+1292   	; 0x3402 <IR_Decode+0x656>
            {
              Command = Codebits(1, 8, IR_LSB);   /* command */
    2ef6:	41 e0       	ldi	r20, 0x01	; 1
    2ef8:	68 e0       	ldi	r22, 0x08	; 8
    2efa:	81 e0       	ldi	r24, 0x01	; 1
    2efc:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    2f00:	b8 2e       	mov	r11, r24

              Flag = 3;            /* confirmed + standard output */
    2f02:	c3 e0       	ldi	r28, 0x03	; 3
    2f04:	24 c2       	rjmp	.+1096   	; 0x334e <IR_Decode+0x5a2>
   *  - PDM: pulse 525s, pause 0=525s 1=1575s
   *  - bit mode: LSB
   *  - format: <start><address:8><command:8><end pulse>
   */

  else if (PulseCheck(Time1, 168))      /* pulse 8.4ms */
    2f06:	68 ea       	ldi	r22, 0xA8	; 168
    2f08:	81 2f       	mov	r24, r17
    2f0a:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    2f0e:	88 23       	and	r24, r24
    2f10:	29 f1       	breq	.+74     	; 0x2f5c <IR_Decode+0x1b0>
  {
    if (PulseCheck(Time2, 84))          /* pause 4.2ms */
    2f12:	64 e5       	ldi	r22, 0x54	; 84
    2f14:	8d 2d       	mov	r24, r13
    2f16:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    2f1a:	88 23       	and	r24, r24
    2f1c:	09 f4       	brne	.+2      	; 0x2f20 <IR_Decode+0x174>
    2f1e:	73 c2       	rjmp	.+1254   	; 0x3406 <IR_Decode+0x65a>
    {
      LCD_EEString_Space(IR_JVC_str);   /* display protocol */
    2f20:	84 e1       	ldi	r24, 0x14	; 20
    2f22:	91 e0       	ldi	r25, 0x01	; 1
    2f24:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>
      Flag = 1;                         /* detected protocol */
      PulseWidth += 2;                  /* skip start pulse */
      Pulses -= 2;
      Bits = PxM_Demod(PulseWidth, Pulses, 11, 11, 32);
    2f28:	00 e2       	ldi	r16, 0x20	; 32
    2f2a:	2b e0       	ldi	r18, 0x0B	; 11
    2f2c:	4b e0       	ldi	r20, 0x0B	; 11
    2f2e:	6e ef       	ldi	r22, 0xFE	; 254
    2f30:	6d 0f       	add	r22, r29
    2f32:	c7 01       	movw	r24, r14
    2f34:	02 96       	adiw	r24, 0x02	; 2
    2f36:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <PxM_Demod>

      if (Bits == 16)              /* we expect 16 bits */
    2f3a:	80 31       	cpi	r24, 0x10	; 16
    2f3c:	09 f0       	breq	.+2      	; 0x2f40 <IR_Decode+0x194>
    2f3e:	65 c2       	rjmp	.+1226   	; 0x340a <IR_Decode+0x65e>
      {
        Address = Codebits(1, 8, IR_LSB);    /* address */
    2f40:	41 e0       	ldi	r20, 0x01	; 1
    2f42:	68 e0       	ldi	r22, 0x08	; 8
    2f44:	81 e0       	ldi	r24, 0x01	; 1
    2f46:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    2f4a:	c8 2e       	mov	r12, r24
        Command = Codebits(9, 8, IR_LSB);    /* command */
    2f4c:	41 e0       	ldi	r20, 0x01	; 1
    2f4e:	68 e0       	ldi	r22, 0x08	; 8
    2f50:	89 e0       	ldi	r24, 0x09	; 9
    2f52:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    2f56:	b8 2e       	mov	r11, r24

        Flag = 3;             /* confirmed + standard ouput */
    2f58:	c3 e0       	ldi	r28, 0x03	; 3
    2f5a:	f9 c1       	rjmp	.+1010   	; 0x334e <IR_Decode+0x5a2>
   *  - parity: (OEM-1 0-3) ^ (OEM-1 4-7) ^ (OEM-2 0-3) ^ (OEM-2 4-7)
   *  - checksum: (system 0-3) ^ (product 0-3) ^ (product 4-7)
   *              ^ (function 0-3) ^ (function 4-7) ^ (x 0-3)
   */

  else if (PulseCheck(Time1, 70))       /* pulse 3.5ms */
    2f5c:	66 e4       	ldi	r22, 0x46	; 70
    2f5e:	81 2f       	mov	r24, r17
    2f60:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    2f64:	88 23       	and	r24, r24
    2f66:	09 f4       	brne	.+2      	; 0x2f6a <IR_Decode+0x1be>
    2f68:	75 c0       	rjmp	.+234    	; 0x3054 <IR_Decode+0x2a8>
  {
    /* Matsushita / Emerson */ 
    if (PulseCheck(Time2, 70))          /* pause 3.5ms */
    2f6a:	66 e4       	ldi	r22, 0x46	; 70
    2f6c:	8d 2d       	mov	r24, r13
    2f6e:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    2f72:	88 23       	and	r24, r24
    2f74:	f1 f0       	breq	.+60     	; 0x2fb2 <IR_Decode+0x206>
    {
      LCD_EEString_Space(IR_Matsushita_str); /* display protocol */
    2f76:	8b e0       	ldi	r24, 0x0B	; 11
    2f78:	91 e0       	ldi	r25, 0x01	; 1
    2f7a:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>
      Flag++;                           /* detected protocol */
      PulseWidth += 2;                  /* skip start pulse */
      Pulses -= 2;
      Bits = PxM_Demod(PulseWidth, Pulses, 17, 17, 52);
    2f7e:	04 e3       	ldi	r16, 0x34	; 52
    2f80:	21 e1       	ldi	r18, 0x11	; 17
    2f82:	41 e1       	ldi	r20, 0x11	; 17
    2f84:	6e ef       	ldi	r22, 0xFE	; 254
    2f86:	6d 0f       	add	r22, r29
    2f88:	c7 01       	movw	r24, r14
    2f8a:	02 96       	adiw	r24, 0x02	; 2
    2f8c:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <PxM_Demod>

      if (Bits == 24)              /* we expect 24 bits */
    2f90:	88 31       	cpi	r24, 0x18	; 24
    2f92:	09 f0       	breq	.+2      	; 0x2f96 <IR_Decode+0x1ea>
    2f94:	3c c2       	rjmp	.+1144   	; 0x340e <IR_Decode+0x662>
      {
        Address = Codebits(1, 6, IR_LSB);    /* address */
    2f96:	41 e0       	ldi	r20, 0x01	; 1
    2f98:	66 e0       	ldi	r22, 0x06	; 6
    2f9a:	81 e0       	ldi	r24, 0x01	; 1
    2f9c:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    2fa0:	c8 2e       	mov	r12, r24
        Command = Codebits(7, 6, IR_LSB);    /* command */
    2fa2:	41 e0       	ldi	r20, 0x01	; 1
    2fa4:	66 e0       	ldi	r22, 0x06	; 6
    2fa6:	87 e0       	ldi	r24, 0x07	; 7
    2fa8:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    2fac:	b8 2e       	mov	r11, r24
        /* todo: check inverted address and command */

        Flag = 3;             /* confirmed + standard ouput */
    2fae:	c3 e0       	ldi	r28, 0x03	; 3
    2fb0:	ce c1       	rjmp	.+924    	; 0x334e <IR_Decode+0x5a2>
      }
    }

    /* Kaseikyo */
    else if (PulseCheck(Time2, 34))     /* pause 1728s */
    2fb2:	62 e2       	ldi	r22, 0x22	; 34
    2fb4:	8d 2d       	mov	r24, r13
    2fb6:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    2fba:	88 23       	and	r24, r24
    2fbc:	09 f4       	brne	.+2      	; 0x2fc0 <IR_Decode+0x214>
    2fbe:	29 c2       	rjmp	.+1106   	; 0x3412 <IR_Decode+0x666>
    {
      LCD_EEString_Space(IR_Kaseikyo_str);   /* display protocol */
    2fc0:	80 e1       	ldi	r24, 0x10	; 16
    2fc2:	91 e0       	ldi	r25, 0x01	; 1
    2fc4:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>
      Flag = 1;                         /* detected protocol */
      PulseWidth += 2;                  /* skip start pulse */
      Pulses -= 2;
      IR_RelaxTime = IR_RELAX_SHORT;
    2fc8:	81 e0       	ldi	r24, 0x01	; 1
    2fca:	80 93 00 01 	sts	0x0100, r24
      Bits = PxM_Demod(PulseWidth, Pulses, 8, 8, 26);
    2fce:	0a e1       	ldi	r16, 0x1A	; 26
    2fd0:	28 e0       	ldi	r18, 0x08	; 8
    2fd2:	48 e0       	ldi	r20, 0x08	; 8
    2fd4:	6e ef       	ldi	r22, 0xFE	; 254
    2fd6:	6d 0f       	add	r22, r29
    2fd8:	c7 01       	movw	r24, r14
    2fda:	02 96       	adiw	r24, 0x02	; 2
    2fdc:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <PxM_Demod>
      IR_RelaxTime = 0;
    2fe0:	10 92 00 01 	sts	0x0100, r1

      if (Bits == 48)              /* we expect 48 bits */
    2fe4:	80 33       	cpi	r24, 0x30	; 48
    2fe6:	09 f0       	breq	.+2      	; 0x2fea <IR_Decode+0x23e>
    2fe8:	16 c2       	rjmp	.+1068   	; 0x3416 <IR_Decode+0x66a>
      {
        Address = Codebits(1, 8, IR_LSB);    /* OEM 1 */
    2fea:	41 e0       	ldi	r20, 0x01	; 1
    2fec:	68 e0       	ldi	r22, 0x08	; 8
    2fee:	81 e0       	ldi	r24, 0x01	; 1
    2ff0:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    2ff4:	f8 2e       	mov	r15, r24
        Extras = Codebits(9, 8, IR_LSB);     /* OEM 2 */
    2ff6:	41 e0       	ldi	r20, 0x01	; 1
    2ff8:	68 e0       	ldi	r22, 0x08	; 8
    2ffa:	89 e0       	ldi	r24, 0x09	; 9
    2ffc:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    3000:	c8 2f       	mov	r28, r24

        DisplayHex(Address);       /* display OEM 1 */
    3002:	8f 2d       	mov	r24, r15
    3004:	0e 94 cb 14 	call	0x2996	; 0x2996 <DisplayHex>
        DisplayHex(Extras);        /* display OEM 2 */
    3008:	8c 2f       	mov	r24, r28
    300a:	0e 94 cb 14 	call	0x2996	; 0x2996 <DisplayHex>
        LCD_Char(':');
    300e:	8a e3       	ldi	r24, 0x3A	; 58
    3010:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>

        Address = Codebits(21, 4, IR_LSB);   /* system */
    3014:	41 e0       	ldi	r20, 0x01	; 1
    3016:	64 e0       	ldi	r22, 0x04	; 4
    3018:	85 e1       	ldi	r24, 0x15	; 21
    301a:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    301e:	c8 2e       	mov	r12, r24
        Extras = Codebits(25, 8, IR_LSB);    /* product */
    3020:	41 e0       	ldi	r20, 0x01	; 1
    3022:	68 e0       	ldi	r22, 0x08	; 8
    3024:	89 e1       	ldi	r24, 0x19	; 25
    3026:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    302a:	c8 2f       	mov	r28, r24
        Command = Codebits(33, 8, IR_LSB);   /* command */      
    302c:	41 e0       	ldi	r20, 0x01	; 1
    302e:	68 e0       	ldi	r22, 0x08	; 8
    3030:	81 e2       	ldi	r24, 0x21	; 33
    3032:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    3036:	b8 2e       	mov	r11, r24

        DisplayHexDigit(Address);  /* display system */
    3038:	8c 2d       	mov	r24, r12
    303a:	0e 94 c3 14 	call	0x2986	; 0x2986 <DisplayHexDigit>
        DisplayHex(Extras);        /* display product */
    303e:	8c 2f       	mov	r24, r28
    3040:	0e 94 cb 14 	call	0x2996	; 0x2996 <DisplayHex>
        LCD_Char(':');
    3044:	8a e3       	ldi	r24, 0x3A	; 58
    3046:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
        DisplayHex(Command);       /* display command */
    304a:	8b 2d       	mov	r24, r11
    304c:	0e 94 cb 14 	call	0x2996	; 0x2996 <DisplayHex>

        Flag = 2;                  /* confirmed */
    3050:	c2 e0       	ldi	r28, 0x02	; 2
    3052:	7d c1       	rjmp	.+762    	; 0x334e <IR_Decode+0x5a2>
   *  - format packet #1: <start><start "1":1><all 1s:9>
   *  - format packet #2: <start><start "1":1><command:9>
   *  - format packet #3: <start><start "1":1><all 1s:9>
   */

  else if (PulseCheck(Time1, 11))       /* pulse 512s */
    3054:	6b e0       	ldi	r22, 0x0B	; 11
    3056:	81 2f       	mov	r24, r17
    3058:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    305c:	88 23       	and	r24, r24
    305e:	09 f4       	brne	.+2      	; 0x3062 <IR_Decode+0x2b6>
    3060:	50 c0       	rjmp	.+160    	; 0x3102 <IR_Decode+0x356>
  {
    if (PulseCheck(Time2, 52))          /* pause 2560s */
    3062:	64 e3       	ldi	r22, 0x34	; 52
    3064:	8d 2d       	mov	r24, r13
    3066:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    306a:	88 23       	and	r24, r24
    306c:	09 f4       	brne	.+2      	; 0x3070 <IR_Decode+0x2c4>
    306e:	d5 c1       	rjmp	.+938    	; 0x341a <IR_Decode+0x66e>
    {
      Flag = 1;                         /* detected protocol */
      PulseWidth += 2;                  /* skip start pulse */
      Pulses -= 2;

      Bits = BiPhase_Demod(PulseWidth, Pulses, IR_THOMAS, 11);
    3070:	2b e0       	ldi	r18, 0x0B	; 11
    3072:	42 e0       	ldi	r20, 0x02	; 2
    3074:	6e ef       	ldi	r22, 0xFE	; 254
    3076:	6d 0f       	add	r22, r29
    3078:	c7 01       	movw	r24, r14
    307a:	02 96       	adiw	r24, 0x02	; 2
    307c:	0e 94 f2 14 	call	0x29e4	; 0x29e4 <BiPhase_Demod>

      if (Bits == 10)              /* we expect 10 bits */
    3080:	8a 30       	cpi	r24, 0x0A	; 10
    3082:	a1 f5       	brne	.+104    	; 0x30ec <IR_Decode+0x340>
      {
        /* todo: check start bit */
        Command = Codebits(2, 8, IR_LSB);    /* command LSB */
    3084:	41 e0       	ldi	r20, 0x01	; 1
    3086:	68 e0       	ldi	r22, 0x08	; 8
    3088:	82 e0       	ldi	r24, 0x02	; 2
    308a:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    308e:	b8 2e       	mov	r11, r24
        Extras = Codebits(10, 1, IR_LSB);    /* command MSB */
    3090:	41 e0       	ldi	r20, 0x01	; 1
    3092:	61 e0       	ldi	r22, 0x01	; 1
    3094:	8a e0       	ldi	r24, 0x0A	; 10
    3096:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    309a:	c8 2f       	mov	r28, r24
        /*
         *  multi packet logic
         */

        /* check for all "1"s */
        if ((Command == 0b11111111) && (Extras == 0b00000001))
    309c:	ff ef       	ldi	r31, 0xFF	; 255
    309e:	bf 12       	cpse	r11, r31
    30a0:	10 c0       	rjmp	.+32     	; 0x30c2 <IR_Decode+0x316>
    30a2:	81 30       	cpi	r24, 0x01	; 1
    30a4:	71 f4       	brne	.+28     	; 0x30c2 <IR_Decode+0x316>
        {
          /* packet #1 or #3: all 1s */
          if (IR_State == 0)            /* packet #1 */
    30a6:	80 91 01 01 	lds	r24, 0x0101
    30aa:	81 11       	cpse	r24, r1
    30ac:	05 c0       	rjmp	.+10     	; 0x30b8 <IR_Decode+0x30c>
          {
            IR_State = 1;               /* got packet #1 */
    30ae:	81 e0       	ldi	r24, 0x01	; 1
    30b0:	80 93 01 01 	sts	0x0101, r24
      {
        /* todo: check start bit */
        Command = Codebits(2, 8, IR_LSB);    /* command LSB */
        Extras = Codebits(10, 1, IR_LSB);    /* command MSB */

        Flag = 4;             /* confirmed multi packet */
    30b4:	c4 e0       	ldi	r28, 0x04	; 4
    30b6:	4b c1       	rjmp	.+662    	; 0x334e <IR_Decode+0x5a2>
          /* packet #1 or #3: all 1s */
          if (IR_State == 0)            /* packet #1 */
          {
            IR_State = 1;               /* got packet #1 */
          }
          else if (IR_State == 2)       /* packet #3 */
    30b8:	82 30       	cpi	r24, 0x02	; 2
    30ba:	09 f0       	breq	.+2      	; 0x30be <IR_Decode+0x312>
    30bc:	ca c1       	rjmp	.+916    	; 0x3452 <IR_Decode+0x6a6>
          {
            Flag = 2;                   /* confirmed */
    30be:	c2 e0       	ldi	r28, 0x02	; 2
    30c0:	46 c1       	rjmp	.+652    	; 0x334e <IR_Decode+0x5a2>
          /* else: packet missing/broken */
        }
        else
        {
          /* packet #2: command */
          if (IR_State == 2)          /* repeated packet */
    30c2:	80 91 01 01 	lds	r24, 0x0101
    30c6:	82 30       	cpi	r24, 0x02	; 2
    30c8:	11 f4       	brne	.+4      	; 0x30ce <IR_Decode+0x322>
          {
            LCD_NextLine();           /* display result in a new line */
    30ca:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <LCD_NextLine>
          }

          LCD_EEString_Space(IR_Motorola_str);    /* display protocol */
    30ce:	87 e0       	ldi	r24, 0x07	; 7
    30d0:	91 e0       	ldi	r25, 0x01	; 1
    30d2:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>
          DisplayHexDigit(Extras);      /* display command MSB */
    30d6:	8c 2f       	mov	r24, r28
    30d8:	0e 94 c3 14 	call	0x2986	; 0x2986 <DisplayHexDigit>
          DisplayHex(Command);          /* display command LSB */
    30dc:	8b 2d       	mov	r24, r11
    30de:	0e 94 cb 14 	call	0x2996	; 0x2996 <DisplayHex>

          IR_State = 2;                 /* got packet #2 */
    30e2:	82 e0       	ldi	r24, 0x02	; 2
    30e4:	80 93 01 01 	sts	0x0101, r24
      {
        /* todo: check start bit */
        Command = Codebits(2, 8, IR_LSB);    /* command LSB */
        Extras = Codebits(10, 1, IR_LSB);    /* command MSB */

        Flag = 4;             /* confirmed multi packet */
    30e8:	c4 e0       	ldi	r28, 0x04	; 4
    30ea:	31 c1       	rjmp	.+610    	; 0x334e <IR_Decode+0x5a2>
          IR_State = 2;                 /* got packet #2 */
        }
      }
      else                              /* broken packet */
      {
        if (IR_State <= 1)         /* not for third packet */
    30ec:	80 91 01 01 	lds	r24, 0x0101
    30f0:	82 30       	cpi	r24, 0x02	; 2
    30f2:	08 f0       	brcs	.+2      	; 0x30f6 <IR_Decode+0x34a>
    30f4:	94 c1       	rjmp	.+808    	; 0x341e <IR_Decode+0x672>
        {
          /* for the "?" */
          LCD_EEString_Space(IR_Motorola_str);    /* display protocol */        
    30f6:	87 e0       	ldi	r24, 0x07	; 7
    30f8:	91 e0       	ldi	r25, 0x01	; 1
    30fa:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>

  else if (PulseCheck(Time1, 11))       /* pulse 512s */
  {
    if (PulseCheck(Time2, 52))          /* pause 2560s */
    {
      Flag = 1;                         /* detected protocol */
    30fe:	c1 e0       	ldi	r28, 0x01	; 1
    3100:	23 c1       	rjmp	.+582    	; 0x3348 <IR_Decode+0x59c>
   *  - old format: <start><manufacturer code:12><command:8><end pulse>
   *  - 32 bit format (TC9012):
   *    <start><custom:8><copy of custom:8><data:8><inverted data:8><end pulse>
   */

  else if (PulseCheck(Time1, 89))       /* pulse 4.5ms */
    3102:	69 e5       	ldi	r22, 0x59	; 89
    3104:	81 2f       	mov	r24, r17
    3106:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    310a:	88 23       	and	r24, r24
    310c:	29 f1       	breq	.+74     	; 0x3158 <IR_Decode+0x3ac>
  {
    if (PulseCheck(Time2, 89))          /* pause 4.5ms */
    310e:	69 e5       	ldi	r22, 0x59	; 89
    3110:	8d 2d       	mov	r24, r13
    3112:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    3116:	88 23       	and	r24, r24
    3118:	09 f4       	brne	.+2      	; 0x311c <IR_Decode+0x370>
    311a:	83 c1       	rjmp	.+774    	; 0x3422 <IR_Decode+0x676>
    {
      LCD_EEString_Space(IR_Samsung_str); /* display protocol */
    311c:	8f ee       	ldi	r24, 0xEF	; 239
    311e:	90 e0       	ldi	r25, 0x00	; 0
    3120:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>
      Flag++;                           /* detected protocol */
      PulseWidth += 2;                  /* skip start pulse */
      Pulses -= 2;
      Bits = PxM_Demod(PulseWidth, Pulses, 11, 11, 34);
    3124:	02 e2       	ldi	r16, 0x22	; 34
    3126:	2b e0       	ldi	r18, 0x0B	; 11
    3128:	4b e0       	ldi	r20, 0x0B	; 11
    312a:	6e ef       	ldi	r22, 0xFE	; 254
    312c:	6d 0f       	add	r22, r29
    312e:	c7 01       	movw	r24, r14
    3130:	02 96       	adiw	r24, 0x02	; 2
    3132:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <PxM_Demod>

      if (Bits == 32)              /* we expect 32 bits */
    3136:	80 32       	cpi	r24, 0x20	; 32
    3138:	09 f0       	breq	.+2      	; 0x313c <IR_Decode+0x390>
    313a:	75 c1       	rjmp	.+746    	; 0x3426 <IR_Decode+0x67a>
      {
        Address = Codebits(1, 8, IR_LSB);    /* address */
    313c:	41 e0       	ldi	r20, 0x01	; 1
    313e:	68 e0       	ldi	r22, 0x08	; 8
    3140:	81 e0       	ldi	r24, 0x01	; 1
    3142:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    3146:	c8 2e       	mov	r12, r24
        Command = Codebits(17, 8, IR_LSB);   /* command */
    3148:	41 e0       	ldi	r20, 0x01	; 1
    314a:	68 e0       	ldi	r22, 0x08	; 8
    314c:	81 e1       	ldi	r24, 0x11	; 17
    314e:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    3152:	b8 2e       	mov	r11, r24
        /* todo: check copy of address and inverted command */

        Flag = 3;                  /* confirmed + standard ouput */
    3154:	c3 e0       	ldi	r28, 0x03	; 3
    3156:	fb c0       	rjmp	.+502    	; 0x334e <IR_Decode+0x5a2>
   *  - 12 bit format: <start><command:7><address:5>
   *  - 15 bit format: <start><command:7><address:8>
   *  - 20 bit format: <start><command:7><address:5><extended:8>
   */

  else if (PulseCheck(Time1, 48))       /* pulse 2.4ms */
    3158:	60 e3       	ldi	r22, 0x30	; 48
    315a:	81 2f       	mov	r24, r17
    315c:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    3160:	88 23       	and	r24, r24
    3162:	09 f4       	brne	.+2      	; 0x3166 <IR_Decode+0x3ba>
    3164:	4c c0       	rjmp	.+152    	; 0x31fe <IR_Decode+0x452>
  {
    if (PulseCheck(Time2, 12))          /* pause 600s */
    3166:	6c e0       	ldi	r22, 0x0C	; 12
    3168:	8d 2d       	mov	r24, r13
    316a:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    316e:	88 23       	and	r24, r24
    3170:	09 f4       	brne	.+2      	; 0x3174 <IR_Decode+0x3c8>
    3172:	5b c1       	rjmp	.+694    	; 0x342a <IR_Decode+0x67e>
    {
      LCD_EEString(IR_SIRC_str);        /* display protocol */
    3174:	84 ee       	ldi	r24, 0xE4	; 228
    3176:	90 e0       	ldi	r25, 0x00	; 0
    3178:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
      Flag = 1;                         /* detected protocol */
      PulseWidth += 1;                  /* skip start pulse */
      Pulses -= 1;
    317c:	6f ef       	ldi	r22, 0xFF	; 255
    317e:	6d 0f       	add	r22, r29
      Bits = PxM_Demod(PulseWidth, Pulses, 12, 12, 24);
    3180:	08 e1       	ldi	r16, 0x18	; 24
    3182:	2c e0       	ldi	r18, 0x0C	; 12
    3184:	4c e0       	ldi	r20, 0x0C	; 12
    3186:	c7 01       	movw	r24, r14
    3188:	01 96       	adiw	r24, 0x01	; 1
    318a:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <PxM_Demod>
    318e:	c8 2f       	mov	r28, r24

      /* 12, 15 or 20 bit format */
      Data = 5;                    /* 5 bit address */
      if (Bits == 12)
    3190:	8c 30       	cpi	r24, 0x0C	; 12
    3192:	09 f4       	brne	.+2      	; 0x3196 <IR_Decode+0x3ea>
    3194:	62 c1       	rjmp	.+708    	; 0x345a <IR_Decode+0x6ae>
      {
        Flag = 2;                  /* confirmed */
      }
      else if (Bits == 15)
    3196:	8f 30       	cpi	r24, 0x0F	; 15
    3198:	09 f4       	brne	.+2      	; 0x319c <IR_Decode+0x3f0>
    319a:	61 c1       	rjmp	.+706    	; 0x345e <IR_Decode+0x6b2>
      {
        Data = 8;                  /* 8 bit address */
        Flag = 2;                  /* confirmed */
      }
      else if (Bits == 20)
    319c:	84 31       	cpi	r24, 0x14	; 20
    319e:	09 f0       	breq	.+2      	; 0x31a2 <IR_Decode+0x3f6>
    31a0:	0f c1       	rjmp	.+542    	; 0x33c0 <IR_Decode+0x614>
      {
        Extras = Codebits(13, 8, IR_LSB);    /* extended */
    31a2:	41 e0       	ldi	r20, 0x01	; 1
    31a4:	68 e0       	ldi	r22, 0x08	; 8
    31a6:	8d e0       	ldi	r24, 0x0D	; 13
    31a8:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    31ac:	d8 2f       	mov	r29, r24
        Flag = 2;                  /* confirmed */
      }

      Command = Codebits(1, 7, IR_LSB);      /* command */
    31ae:	41 e0       	ldi	r20, 0x01	; 1
    31b0:	67 e0       	ldi	r22, 0x07	; 7
    31b2:	81 e0       	ldi	r24, 0x01	; 1
    31b4:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    31b8:	b8 2e       	mov	r11, r24
      Address = Codebits(8, Data, IR_LSB);   /* address */
    31ba:	41 e0       	ldi	r20, 0x01	; 1
    31bc:	65 e0       	ldi	r22, 0x05	; 5
    31be:	88 e0       	ldi	r24, 0x08	; 8
    31c0:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    31c4:	c8 2e       	mov	r12, r24

      /* display format */
      if (Flag == 2)          /* valid packet */
      {
        DisplayValue(Bits, 0, 0);
    31c6:	6c 2f       	mov	r22, r28
    31c8:	70 e0       	ldi	r23, 0x00	; 0
    31ca:	80 e0       	ldi	r24, 0x00	; 0
    31cc:	90 e0       	ldi	r25, 0x00	; 0
    31ce:	20 e0       	ldi	r18, 0x00	; 0
    31d0:	40 e0       	ldi	r20, 0x00	; 0
    31d2:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
      }

      LCD_Space();            /* display space */
    31d6:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>

      /* display data */
      if (Flag == 2)          /* valid packet */
      {
        DisplayHex(Address);       /* display address */
    31da:	8c 2d       	mov	r24, r12
    31dc:	0e 94 cb 14 	call	0x2996	; 0x2996 <DisplayHex>
        LCD_Char(':');
    31e0:	8a e3       	ldi	r24, 0x3A	; 58
    31e2:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
        DisplayHex(Command);       /* display command */
    31e6:	8b 2d       	mov	r24, r11
    31e8:	0e 94 cb 14 	call	0x2996	; 0x2996 <DisplayHex>

        if (Bits == 20)            /* 20 bit format */
        {
          LCD_Char(':');
    31ec:	8a e3       	ldi	r24, 0x3A	; 58
    31ee:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
          DisplayHex(Extras);      /* display extended data */
    31f2:	8d 2f       	mov	r24, r29
    31f4:	0e 94 cb 14 	call	0x2996	; 0x2996 <DisplayHex>
      PulseWidth += 1;                  /* skip start pulse */
      Pulses -= 1;
      Bits = PxM_Demod(PulseWidth, Pulses, 12, 12, 24);

      /* 12, 15 or 20 bit format */
      Data = 5;                    /* 5 bit address */
    31f8:	d5 e0       	ldi	r29, 0x05	; 5
        DisplayHex(Command);       /* display command */

        if (Bits == 20)            /* 20 bit format */
        {
          LCD_Char(':');
          DisplayHex(Extras);      /* display extended data */
    31fa:	c2 e0       	ldi	r28, 0x02	; 2
    31fc:	a8 c0       	rjmp	.+336    	; 0x334e <IR_Decode+0x5a2>
   *    <address:5><command:8><expansion:1><check:1><end pulse>
   *  - format packet #2:
   *    <address:5><inverted command:8><inverted expansion:1><inverted check:1><end pulse>
   */

  else if (PulseCheck(Time1, 6))        /* pulse 320s */
    31fe:	66 e0       	ldi	r22, 0x06	; 6
    3200:	81 2f       	mov	r24, r17
    3202:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    3206:	88 23       	and	r24, r24
    3208:	c9 f1       	breq	.+114    	; 0x327c <IR_Decode+0x4d0>
  {
    /* pause 680s or 1680s */
    if ((PulseCheck(Time2, 14)) || (PulseCheck(Time2, 35)))
    320a:	6e e0       	ldi	r22, 0x0E	; 14
    320c:	8d 2d       	mov	r24, r13
    320e:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    3212:	81 11       	cpse	r24, r1
    3214:	07 c0       	rjmp	.+14     	; 0x3224 <IR_Decode+0x478>
    3216:	63 e2       	ldi	r22, 0x23	; 35
    3218:	8d 2d       	mov	r24, r13
    321a:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    321e:	88 23       	and	r24, r24
    3220:	09 f4       	brne	.+2      	; 0x3224 <IR_Decode+0x478>
    3222:	05 c1       	rjmp	.+522    	; 0x342e <IR_Decode+0x682>
    {
      Flag = 1;                         /* detected protocol */

      Bits = PxM_Demod(PulseWidth, Pulses, 6, 14, 35);
    3224:	03 e2       	ldi	r16, 0x23	; 35
    3226:	2e e0       	ldi	r18, 0x0E	; 14
    3228:	46 e0       	ldi	r20, 0x06	; 6
    322a:	6d 2f       	mov	r22, r29
    322c:	c7 01       	movw	r24, r14
    322e:	0e 94 c9 15 	call	0x2b92	; 0x2b92 <PxM_Demod>

      if (Bits == 15)              /* we expect 15 bits */
    3232:	8f 30       	cpi	r24, 0x0F	; 15
    3234:	09 f0       	breq	.+2      	; 0x3238 <IR_Decode+0x48c>
    3236:	fd c0       	rjmp	.+506    	; 0x3432 <IR_Decode+0x686>
      {
        if (IR_State == 0)         /* packet #1 */
    3238:	80 91 01 01 	lds	r24, 0x0101
    323c:	81 11       	cpse	r24, r1
    323e:	0b c1       	rjmp	.+534    	; 0x3456 <IR_Decode+0x6aa>
        {
          Address = Codebits(1, 5, IR_LSB);    /* address */
    3240:	41 e0       	ldi	r20, 0x01	; 1
    3242:	65 e0       	ldi	r22, 0x05	; 5
    3244:	81 e0       	ldi	r24, 0x01	; 1
    3246:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    324a:	c8 2e       	mov	r12, r24
          Command = Codebits(6, 8, IR_LSB);    /* command */
    324c:	41 e0       	ldi	r20, 0x01	; 1
    324e:	68 e0       	ldi	r22, 0x08	; 8
    3250:	86 e0       	ldi	r24, 0x06	; 6
    3252:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    3256:	b8 2e       	mov	r11, r24
          /* todo: expansion & check bits */

          LCD_EEString_Space(IR_Sharp_str);      /* display protocol */
    3258:	89 ee       	ldi	r24, 0xE9	; 233
    325a:	90 e0       	ldi	r25, 0x00	; 0
    325c:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>
          DisplayHex(Address);
    3260:	8c 2d       	mov	r24, r12
    3262:	0e 94 cb 14 	call	0x2996	; 0x2996 <DisplayHex>
          LCD_Char(':');
    3266:	8a e3       	ldi	r24, 0x3A	; 58
    3268:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
          DisplayHex(Command);
    326c:	8b 2d       	mov	r24, r11
    326e:	0e 94 cb 14 	call	0x2996	; 0x2996 <DisplayHex>

          IR_State = 1;                 /* got packet #1 */
    3272:	81 e0       	ldi	r24, 0x01	; 1
    3274:	80 93 01 01 	sts	0x0101, r24
          Flag = 4;                     /* multi packet  */
    3278:	c4 e0       	ldi	r28, 0x04	; 4
    327a:	69 c0       	rjmp	.+210    	; 0x334e <IR_Decode+0x5a2>
   *    1: pause 889s, pulse 889s
   *  - bit mode: MSB
   *  - format: <s1 "1":1><s2 "1":1><toggle:1><address:5><command:6>
   */

  else if (PulseCheck(Time1, 17))       /* pulse 889s */
    327c:	61 e1       	ldi	r22, 0x11	; 17
    327e:	81 2f       	mov	r24, r17
    3280:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    3284:	88 23       	and	r24, r24
    3286:	11 f1       	breq	.+68     	; 0x32cc <IR_Decode+0x520>
  {
    if (PulseCheck(Time2, 17))          /* pause 889s */
    3288:	61 e1       	ldi	r22, 0x11	; 17
    328a:	8d 2d       	mov	r24, r13
    328c:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    3290:	88 23       	and	r24, r24
    3292:	09 f4       	brne	.+2      	; 0x3296 <IR_Decode+0x4ea>
    3294:	d0 c0       	rjmp	.+416    	; 0x3436 <IR_Decode+0x68a>
    {
      LCD_EEString_Space(IR_RC5_str);   /* display protocol */
    3296:	89 ef       	ldi	r24, 0xF9	; 249
    3298:	90 e0       	ldi	r25, 0x00	; 0
    329a:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>
      Flag = 1;                         /* detected protocol */
      Bits = BiPhase_Demod(PulseWidth, Pulses, IR_IEEE | IR_PRE_PAUSE, 17);
    329e:	21 e1       	ldi	r18, 0x11	; 17
    32a0:	45 e0       	ldi	r20, 0x05	; 5
    32a2:	6d 2f       	mov	r22, r29
    32a4:	c7 01       	movw	r24, r14
    32a6:	0e 94 f2 14 	call	0x29e4	; 0x29e4 <BiPhase_Demod>

      if (Bits == 14)              /* we expect 14 bits */
    32aa:	8e 30       	cpi	r24, 0x0E	; 14
    32ac:	09 f0       	breq	.+2      	; 0x32b0 <IR_Decode+0x504>
    32ae:	c5 c0       	rjmp	.+394    	; 0x343a <IR_Decode+0x68e>
      {
        Address = Codebits(4, 5, IR_MSB);    /* address */
    32b0:	42 e0       	ldi	r20, 0x02	; 2
    32b2:	65 e0       	ldi	r22, 0x05	; 5
    32b4:	84 e0       	ldi	r24, 0x04	; 4
    32b6:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    32ba:	c8 2e       	mov	r12, r24
        Command = Codebits(9, 6, IR_MSB);    /* command */
    32bc:	42 e0       	ldi	r20, 0x02	; 2
    32be:	66 e0       	ldi	r22, 0x06	; 6
    32c0:	89 e0       	ldi	r24, 0x09	; 9
    32c2:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    32c6:	b8 2e       	mov	r11, r24

        Flag = 3;             /* confirmed + standard ouput */
    32c8:	c3 e0       	ldi	r28, 0x03	; 3
    32ca:	41 c0       	rjmp	.+130    	; 0x334e <IR_Decode+0x5a2>
   *  - bit mode: MSB
   *  - format (Mode 0, 16 bit):
   *    <start><start bit "1":1><mode:3><toggle:1><address:8><command:8>
   */

  else if (PulseCheck(Time1, 53))       /* pulse 2664s */
    32cc:	65 e3       	ldi	r22, 0x35	; 53
    32ce:	81 2f       	mov	r24, r17
    32d0:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    32d4:	88 23       	and	r24, r24
    32d6:	09 f4       	brne	.+2      	; 0x32da <IR_Decode+0x52e>
    32d8:	b2 c0       	rjmp	.+356    	; 0x343e <IR_Decode+0x692>
  {
    if (PulseCheck(Time2, 17))          /* pause 888s */
    32da:	61 e1       	ldi	r22, 0x11	; 17
    32dc:	8d 2d       	mov	r24, r13
    32de:	0e 94 d7 14 	call	0x29ae	; 0x29ae <PulseCheck>
    32e2:	88 23       	and	r24, r24
    32e4:	09 f4       	brne	.+2      	; 0x32e8 <IR_Decode+0x53c>
    32e6:	ad c0       	rjmp	.+346    	; 0x3442 <IR_Decode+0x696>
    {
      LCD_EEString_Space(IR_RC6_str);   /* display protocol */
    32e8:	84 ef       	ldi	r24, 0xF4	; 244
    32ea:	90 e0       	ldi	r25, 0x00	; 0
    32ec:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>

      Flag = 1;                         /* detected protocol */
      PulseWidth += 2;                  /* skip start pulse */
    32f0:	82 e0       	ldi	r24, 0x02	; 2
    32f2:	e8 0e       	add	r14, r24
    32f4:	f1 1c       	adc	r15, r1
      Pulses -= 2;
    32f6:	ce ef       	ldi	r28, 0xFE	; 254
    32f8:	cd 0f       	add	r28, r29

      /* convert toggle bit to standard timing */
      Data = SpecialBiPhasePulse(PulseWidth, Pulses, 8, 8, 17);
    32fa:	01 e1       	ldi	r16, 0x11	; 17
    32fc:	28 e0       	ldi	r18, 0x08	; 8
    32fe:	48 e0       	ldi	r20, 0x08	; 8
    3300:	6c 2f       	mov	r22, r28
    3302:	c7 01       	movw	r24, r14
    3304:	0e 94 4a 16 	call	0x2c94	; 0x2c94 <SpecialBiPhasePulse>
    3308:	d8 2f       	mov	r29, r24

      if (Data == 2)               /* we expect 1 special bit (= 2 pulses) */
    330a:	82 30       	cpi	r24, 0x02	; 2
    330c:	09 f0       	breq	.+2      	; 0x3310 <IR_Decode+0x564>
    330e:	9b c0       	rjmp	.+310    	; 0x3446 <IR_Decode+0x69a>
      {
        IR_RelaxTime = IR_RELAX_SHORT;
    3310:	81 e0       	ldi	r24, 0x01	; 1
    3312:	80 93 00 01 	sts	0x0100, r24
        Bits = BiPhase_Demod(PulseWidth, Pulses, IR_THOMAS, 8);
    3316:	28 e0       	ldi	r18, 0x08	; 8
    3318:	42 e0       	ldi	r20, 0x02	; 2
    331a:	6c 2f       	mov	r22, r28
    331c:	c7 01       	movw	r24, r14
    331e:	0e 94 f2 14 	call	0x29e4	; 0x29e4 <BiPhase_Demod>
        IR_RelaxTime = 0;
    3322:	10 92 00 01 	sts	0x0100, r1

        if (Bits == 21)       /* we expect 21 bits */
    3326:	85 31       	cpi	r24, 0x15	; 21
    3328:	09 f0       	breq	.+2      	; 0x332c <IR_Decode+0x580>
    332a:	8f c0       	rjmp	.+286    	; 0x344a <IR_Decode+0x69e>
        {
          Address = Codebits(6, 8, IR_MSB);       /* address */
    332c:	42 e0       	ldi	r20, 0x02	; 2
    332e:	68 e0       	ldi	r22, 0x08	; 8
    3330:	86 e0       	ldi	r24, 0x06	; 6
    3332:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    3336:	c8 2e       	mov	r12, r24
          Command = Codebits(14, 8, IR_MSB);      /* command */
    3338:	42 e0       	ldi	r20, 0x02	; 2
    333a:	68 e0       	ldi	r22, 0x08	; 8
    333c:	8e e0       	ldi	r24, 0x0E	; 14
    333e:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    3342:	b8 2e       	mov	r11, r24

          Flag = 3;             /* confirmed + standard ouput */
    3344:	c3 e0       	ldi	r28, 0x03	; 3
    3346:	03 c0       	rjmp	.+6      	; 0x334e <IR_Decode+0x5a2>
  }


  if (Flag <= 1)              /* some issue: unknown protocol/broken frame */
  {
    LCD_Char('?');    
    3348:	8f e3       	ldi	r24, 0x3F	; 63
    334a:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
  }

  if (Flag == 0)              /* unknown protocol */
    334e:	c1 11       	cpse	r28, r1
    3350:	21 c0       	rjmp	.+66     	; 0x3394 <IR_Decode+0x5e8>
  {
    LCD_Space();
    3352:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
    DisplayValue(Data, 0, 0);      /* display number of pulses */
    3356:	6d 2f       	mov	r22, r29
    3358:	70 e0       	ldi	r23, 0x00	; 0
    335a:	80 e0       	ldi	r24, 0x00	; 0
    335c:	90 e0       	ldi	r25, 0x00	; 0
    335e:	20 e0       	ldi	r18, 0x00	; 0
    3360:	40 e0       	ldi	r20, 0x00	; 0
    3362:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
    LCD_Char(':');
    3366:	8a e3       	ldi	r24, 0x3A	; 58
    3368:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    DisplayValue(Time1, 0, 0);     /* display time units of first pulse */
    336c:	61 2f       	mov	r22, r17
    336e:	70 e0       	ldi	r23, 0x00	; 0
    3370:	80 e0       	ldi	r24, 0x00	; 0
    3372:	90 e0       	ldi	r25, 0x00	; 0
    3374:	20 e0       	ldi	r18, 0x00	; 0
    3376:	40 e0       	ldi	r20, 0x00	; 0
    3378:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
    LCD_Char('-');
    337c:	8d e2       	ldi	r24, 0x2D	; 45
    337e:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    DisplayValue(Time2, 0, 0);     /* display time units of first pause */
    3382:	6d 2d       	mov	r22, r13
    3384:	70 e0       	ldi	r23, 0x00	; 0
    3386:	80 e0       	ldi	r24, 0x00	; 0
    3388:	90 e0       	ldi	r25, 0x00	; 0
    338a:	20 e0       	ldi	r18, 0x00	; 0
    338c:	40 e0       	ldi	r20, 0x00	; 0
    338e:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
    3392:	0f c0       	rjmp	.+30     	; 0x33b2 <IR_Decode+0x606>
    Pulse++;
    DisplayValue(*Pulse, 0, 0);
    #endif
  }

  if (Flag == 3)              /* known protocol & standard output */
    3394:	c3 30       	cpi	r28, 0x03	; 3
    3396:	51 f4       	brne	.+20     	; 0x33ac <IR_Decode+0x600>
  {
    DisplayHex(Address);      /* display address */
    3398:	8c 2d       	mov	r24, r12
    339a:	0e 94 cb 14 	call	0x2996	; 0x2996 <DisplayHex>
    LCD_Char(':');
    339e:	8a e3       	ldi	r24, 0x3A	; 58
    33a0:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    DisplayHex(Command);      /* display command */
    33a4:	8b 2d       	mov	r24, r11
    33a6:	0e 94 cb 14 	call	0x2996	; 0x2996 <DisplayHex>
    33aa:	03 c0       	rjmp	.+6      	; 0x33b2 <IR_Decode+0x606>
  }

  if (Flag < 4)               /* protocol done */
    33ac:	c4 30       	cpi	r28, 0x04	; 4
    33ae:	08 f0       	brcs	.+2      	; 0x33b2 <IR_Decode+0x606>
    33b0:	78 c0       	rjmp	.+240    	; 0x34a2 <IR_Decode+0x6f6>
  {
    IR_State = 0;             /* reset state for multi packet protocols */
    33b2:	10 92 01 01 	sts	0x0101, r1

    /* slow down display updates and try to skip early repeats */
    MilliSleep(200);          /* don't proceed too soon */
    33b6:	88 ec       	ldi	r24, 0xC8	; 200
    33b8:	90 e0       	ldi	r25, 0x00	; 0
    33ba:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>
    33be:	71 c0       	rjmp	.+226    	; 0x34a2 <IR_Decode+0x6f6>
      {
        Extras = Codebits(13, 8, IR_LSB);    /* extended */
        Flag = 2;                  /* confirmed */
      }

      Command = Codebits(1, 7, IR_LSB);      /* command */
    33c0:	41 e0       	ldi	r20, 0x01	; 1
    33c2:	67 e0       	ldi	r22, 0x07	; 7
    33c4:	81 e0       	ldi	r24, 0x01	; 1
    33c6:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    33ca:	b8 2e       	mov	r11, r24
      Address = Codebits(8, Data, IR_LSB);   /* address */
    33cc:	41 e0       	ldi	r20, 0x01	; 1
    33ce:	65 e0       	ldi	r22, 0x05	; 5
    33d0:	88 e0       	ldi	r24, 0x08	; 8
    33d2:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    33d6:	c8 2e       	mov	r12, r24
      if (Flag == 2)          /* valid packet */
      {
        DisplayValue(Bits, 0, 0);
      }

      LCD_Space();            /* display space */
    33d8:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
      PulseWidth += 1;                  /* skip start pulse */
      Pulses -= 1;
      Bits = PxM_Demod(PulseWidth, Pulses, 12, 12, 24);

      /* 12, 15 or 20 bit format */
      Data = 5;                    /* 5 bit address */
    33dc:	d5 e0       	ldi	r29, 0x05	; 5
  else if (PulseCheck(Time1, 48))       /* pulse 2.4ms */
  {
    if (PulseCheck(Time2, 12))          /* pause 600s */
    {
      LCD_EEString(IR_SIRC_str);        /* display protocol */
      Flag = 1;                         /* detected protocol */
    33de:	c1 e0       	ldi	r28, 0x01	; 1
    33e0:	b3 cf       	rjmp	.-154    	; 0x3348 <IR_Decode+0x59c>
  if (PulseCheck(Time1, 180))           /* pulse 9ms */
  {
    if (PulseCheck(Time2, 90))          /* pause 4.5ms */
    {
      LCD_EEString_Space(IR_NEC_str);   /* display protocol */
      Flag = 1;                         /* detected protocol */
    33e2:	c1 e0       	ldi	r28, 0x01	; 1
    33e4:	b1 cf       	rjmp	.-158    	; 0x3348 <IR_Decode+0x59c>
 *  - number of pulses (pauses/pulses)
 */

void IR_Decode(uint8_t *PulseWidth, uint8_t Pulses)
{
  uint8_t           Flag = 0;
    33e6:	c0 e0       	ldi	r28, 0x00	; 0
    33e8:	af cf       	rjmp	.-162    	; 0x3348 <IR_Decode+0x59c>
    33ea:	c0 e0       	ldi	r28, 0x00	; 0
    33ec:	ad cf       	rjmp	.-166    	; 0x3348 <IR_Decode+0x59c>
    33ee:	c0 e0       	ldi	r28, 0x00	; 0
    33f0:	ab cf       	rjmp	.-170    	; 0x3348 <IR_Decode+0x59c>
    33f2:	c0 e0       	ldi	r28, 0x00	; 0
    33f4:	a9 cf       	rjmp	.-174    	; 0x3348 <IR_Decode+0x59c>
  else if (PulseCheck(Time1, 160))      /* pulse 8ms */
  {
    if (PulseCheck(Time2, 80))          /* pause 4ms */
    {
      LCD_EEString_Space(IR_Proton_str);     /* display protocol */
      Flag = 1;                         /* detected protocol */
    33f6:	c1 e0       	ldi	r28, 0x01	; 1
    33f8:	a7 cf       	rjmp	.-178    	; 0x3348 <IR_Decode+0x59c>
    33fa:	c1 e0       	ldi	r28, 0x01	; 1
    33fc:	a5 cf       	rjmp	.-182    	; 0x3348 <IR_Decode+0x59c>
    33fe:	c1 e0       	ldi	r28, 0x01	; 1
    3400:	a3 cf       	rjmp	.-186    	; 0x3348 <IR_Decode+0x59c>
    3402:	c1 e0       	ldi	r28, 0x01	; 1
    3404:	a1 cf       	rjmp	.-190    	; 0x3348 <IR_Decode+0x59c>
 *  - number of pulses (pauses/pulses)
 */

void IR_Decode(uint8_t *PulseWidth, uint8_t Pulses)
{
  uint8_t           Flag = 0;
    3406:	c0 e0       	ldi	r28, 0x00	; 0
    3408:	9f cf       	rjmp	.-194    	; 0x3348 <IR_Decode+0x59c>
  else if (PulseCheck(Time1, 168))      /* pulse 8.4ms */
  {
    if (PulseCheck(Time2, 84))          /* pause 4.2ms */
    {
      LCD_EEString_Space(IR_JVC_str);   /* display protocol */
      Flag = 1;                         /* detected protocol */
    340a:	c1 e0       	ldi	r28, 0x01	; 1
    340c:	9d cf       	rjmp	.-198    	; 0x3348 <IR_Decode+0x59c>
  {
    /* Matsushita / Emerson */ 
    if (PulseCheck(Time2, 70))          /* pause 3.5ms */
    {
      LCD_EEString_Space(IR_Matsushita_str); /* display protocol */
      Flag++;                           /* detected protocol */
    340e:	c1 e0       	ldi	r28, 0x01	; 1
    3410:	9b cf       	rjmp	.-202    	; 0x3348 <IR_Decode+0x59c>
 *  - number of pulses (pauses/pulses)
 */

void IR_Decode(uint8_t *PulseWidth, uint8_t Pulses)
{
  uint8_t           Flag = 0;
    3412:	c0 e0       	ldi	r28, 0x00	; 0
    3414:	99 cf       	rjmp	.-206    	; 0x3348 <IR_Decode+0x59c>

    /* Kaseikyo */
    else if (PulseCheck(Time2, 34))     /* pause 1728s */
    {
      LCD_EEString_Space(IR_Kaseikyo_str);   /* display protocol */
      Flag = 1;                         /* detected protocol */
    3416:	c1 e0       	ldi	r28, 0x01	; 1
    3418:	97 cf       	rjmp	.-210    	; 0x3348 <IR_Decode+0x59c>
 *  - number of pulses (pauses/pulses)
 */

void IR_Decode(uint8_t *PulseWidth, uint8_t Pulses)
{
  uint8_t           Flag = 0;
    341a:	c0 e0       	ldi	r28, 0x00	; 0
    341c:	95 cf       	rjmp	.-214    	; 0x3348 <IR_Decode+0x59c>

  else if (PulseCheck(Time1, 11))       /* pulse 512s */
  {
    if (PulseCheck(Time2, 52))          /* pause 2560s */
    {
      Flag = 1;                         /* detected protocol */
    341e:	c1 e0       	ldi	r28, 0x01	; 1
    3420:	93 cf       	rjmp	.-218    	; 0x3348 <IR_Decode+0x59c>
 *  - number of pulses (pauses/pulses)
 */

void IR_Decode(uint8_t *PulseWidth, uint8_t Pulses)
{
  uint8_t           Flag = 0;
    3422:	c0 e0       	ldi	r28, 0x00	; 0
    3424:	91 cf       	rjmp	.-222    	; 0x3348 <IR_Decode+0x59c>
  else if (PulseCheck(Time1, 89))       /* pulse 4.5ms */
  {
    if (PulseCheck(Time2, 89))          /* pause 4.5ms */
    {
      LCD_EEString_Space(IR_Samsung_str); /* display protocol */
      Flag++;                           /* detected protocol */
    3426:	c1 e0       	ldi	r28, 0x01	; 1
    3428:	8f cf       	rjmp	.-226    	; 0x3348 <IR_Decode+0x59c>
 *  - number of pulses (pauses/pulses)
 */

void IR_Decode(uint8_t *PulseWidth, uint8_t Pulses)
{
  uint8_t           Flag = 0;
    342a:	c0 e0       	ldi	r28, 0x00	; 0
    342c:	8d cf       	rjmp	.-230    	; 0x3348 <IR_Decode+0x59c>
    342e:	c0 e0       	ldi	r28, 0x00	; 0
    3430:	8b cf       	rjmp	.-234    	; 0x3348 <IR_Decode+0x59c>
  else if (PulseCheck(Time1, 6))        /* pulse 320s */
  {
    /* pause 680s or 1680s */
    if ((PulseCheck(Time2, 14)) || (PulseCheck(Time2, 35)))
    {
      Flag = 1;                         /* detected protocol */
    3432:	c1 e0       	ldi	r28, 0x01	; 1
    3434:	89 cf       	rjmp	.-238    	; 0x3348 <IR_Decode+0x59c>
 *  - number of pulses (pauses/pulses)
 */

void IR_Decode(uint8_t *PulseWidth, uint8_t Pulses)
{
  uint8_t           Flag = 0;
    3436:	c0 e0       	ldi	r28, 0x00	; 0
    3438:	87 cf       	rjmp	.-242    	; 0x3348 <IR_Decode+0x59c>
  else if (PulseCheck(Time1, 17))       /* pulse 889s */
  {
    if (PulseCheck(Time2, 17))          /* pause 889s */
    {
      LCD_EEString_Space(IR_RC5_str);   /* display protocol */
      Flag = 1;                         /* detected protocol */
    343a:	c1 e0       	ldi	r28, 0x01	; 1
    343c:	85 cf       	rjmp	.-246    	; 0x3348 <IR_Decode+0x59c>
 *  - number of pulses (pauses/pulses)
 */

void IR_Decode(uint8_t *PulseWidth, uint8_t Pulses)
{
  uint8_t           Flag = 0;
    343e:	c0 e0       	ldi	r28, 0x00	; 0
    3440:	83 cf       	rjmp	.-250    	; 0x3348 <IR_Decode+0x59c>
    3442:	c0 e0       	ldi	r28, 0x00	; 0
    3444:	81 cf       	rjmp	.-254    	; 0x3348 <IR_Decode+0x59c>
  {
    if (PulseCheck(Time2, 17))          /* pause 888s */
    {
      LCD_EEString_Space(IR_RC6_str);   /* display protocol */

      Flag = 1;                         /* detected protocol */
    3446:	c1 e0       	ldi	r28, 0x01	; 1
    3448:	7f cf       	rjmp	.-258    	; 0x3348 <IR_Decode+0x59c>
    344a:	c1 e0       	ldi	r28, 0x01	; 1
    344c:	7d cf       	rjmp	.-262    	; 0x3348 <IR_Decode+0x59c>
        {
          /* extended format with 16 bit address */
          DisplayHex(Extras);           /* display high address */
        }

        Flag = 3;             /* confirmed + standard ouput */
    344e:	c3 e0       	ldi	r28, 0x03	; 3
    3450:	7e cf       	rjmp	.-260    	; 0x334e <IR_Decode+0x5a2>
      {
        /* todo: check start bit */
        Command = Codebits(2, 8, IR_LSB);    /* command LSB */
        Extras = Codebits(10, 1, IR_LSB);    /* command MSB */

        Flag = 4;             /* confirmed multi packet */
    3452:	c4 e0       	ldi	r28, 0x04	; 4
    3454:	7c cf       	rjmp	.-264    	; 0x334e <IR_Decode+0x5a2>
          Flag = 4;                     /* multi packet  */
        }
        else                       /* packet #2 */
        {
          /* we don't check the inverted command and extra bits */
          Flag = 2;                     /* confirmed */
    3456:	c2 e0       	ldi	r28, 0x02	; 2
    3458:	7a cf       	rjmp	.-268    	; 0x334e <IR_Decode+0x5a2>
      PulseWidth += 1;                  /* skip start pulse */
      Pulses -= 1;
      Bits = PxM_Demod(PulseWidth, Pulses, 12, 12, 24);

      /* 12, 15 or 20 bit format */
      Data = 5;                    /* 5 bit address */
    345a:	d5 e0       	ldi	r29, 0x05	; 5
    345c:	01 c0       	rjmp	.+2      	; 0x3460 <IR_Decode+0x6b4>
      {
        Flag = 2;                  /* confirmed */
      }
      else if (Bits == 15)
      {
        Data = 8;                  /* 8 bit address */
    345e:	d8 e0       	ldi	r29, 0x08	; 8
      {
        Extras = Codebits(13, 8, IR_LSB);    /* extended */
        Flag = 2;                  /* confirmed */
      }

      Command = Codebits(1, 7, IR_LSB);      /* command */
    3460:	41 e0       	ldi	r20, 0x01	; 1
    3462:	67 e0       	ldi	r22, 0x07	; 7
    3464:	81 e0       	ldi	r24, 0x01	; 1
    3466:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    346a:	b8 2e       	mov	r11, r24
      Address = Codebits(8, Data, IR_LSB);   /* address */
    346c:	41 e0       	ldi	r20, 0x01	; 1
    346e:	6d 2f       	mov	r22, r29
    3470:	88 e0       	ldi	r24, 0x08	; 8
    3472:	0e 94 a4 16 	call	0x2d48	; 0x2d48 <Codebits>
    3476:	c8 2e       	mov	r12, r24

      /* display format */
      if (Flag == 2)          /* valid packet */
      {
        DisplayValue(Bits, 0, 0);
    3478:	6c 2f       	mov	r22, r28
    347a:	70 e0       	ldi	r23, 0x00	; 0
    347c:	80 e0       	ldi	r24, 0x00	; 0
    347e:	90 e0       	ldi	r25, 0x00	; 0
    3480:	20 e0       	ldi	r18, 0x00	; 0
    3482:	40 e0       	ldi	r20, 0x00	; 0
    3484:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
      }

      LCD_Space();            /* display space */
    3488:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>

      /* display data */
      if (Flag == 2)          /* valid packet */
      {
        DisplayHex(Address);       /* display address */
    348c:	8c 2d       	mov	r24, r12
    348e:	0e 94 cb 14 	call	0x2996	; 0x2996 <DisplayHex>
        LCD_Char(':');
    3492:	8a e3       	ldi	r24, 0x3A	; 58
    3494:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
        DisplayHex(Command);       /* display command */
    3498:	8b 2d       	mov	r24, r11
    349a:	0e 94 cb 14 	call	0x2996	; 0x2996 <DisplayHex>
    349e:	c2 e0       	ldi	r28, 0x02	; 2
    34a0:	56 cf       	rjmp	.-340    	; 0x334e <IR_Decode+0x5a2>
    IR_State = 0;             /* reset state for multi packet protocols */

    /* slow down display updates and try to skip early repeats */
    MilliSleep(200);          /* don't proceed too soon */
  }
} 
    34a2:	df 91       	pop	r29
    34a4:	cf 91       	pop	r28
    34a6:	1f 91       	pop	r17
    34a8:	0f 91       	pop	r16
    34aa:	ff 90       	pop	r15
    34ac:	ef 90       	pop	r14
    34ae:	df 90       	pop	r13
    34b0:	cf 90       	pop	r12
    34b2:	bf 90       	pop	r11
    34b4:	08 95       	ret

000034b6 <IR_Detector>:
 *    probe #2  Vs/+5V (limit current by Rl)
 *    probe #3  Out/Data (inverted)
 */

void IR_Detector(void)
{
    34b6:	8f 92       	push	r8
    34b8:	9f 92       	push	r9
    34ba:	af 92       	push	r10
    34bc:	bf 92       	push	r11
    34be:	cf 92       	push	r12
    34c0:	df 92       	push	r13
    34c2:	ef 92       	push	r14
    34c4:	ff 92       	push	r15
    34c6:	0f 93       	push	r16
    34c8:	1f 93       	push	r17
    34ca:	cf 93       	push	r28
    34cc:	df 93       	push	r29
    34ce:	cd b7       	in	r28, 0x3d	; 61
    34d0:	de b7       	in	r29, 0x3e	; 62
    34d2:	c4 56       	subi	r28, 0x64	; 100
    34d4:	d1 09       	sbc	r29, r1
    34d6:	0f b6       	in	r0, 0x3f	; 63
    34d8:	f8 94       	cli
    34da:	de bf       	out	0x3e, r29	; 62
    34dc:	0f be       	out	0x3f, r0	; 63
    34de:	cd bf       	out	0x3d, r28	; 61
  uint8_t           Period = 0;         /* pulse duration */
  uint8_t           *Pulse = NULL;      /* pointer to pulse data */
  uint8_t           PulseWidth[MAX_PULSES];  /* pulse duration data */     

  /* inform user */
  ShortCircuit(0);                      /* make sure probes are not shorted */
    34e0:	80 e0       	ldi	r24, 0x00	; 0
    34e2:	0e 94 d0 33 	call	0x67a0	; 0x67a0 <ShortCircuit>
  LCD_Clear();
    34e6:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
  LCD_EEString(IR_Detector_str);        /* display: IR detector */
    34ea:	89 ef       	ldi	r24, 0xF9	; 249
    34ec:	91 e0       	ldi	r25, 0x01	; 1
    34ee:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
  LCD_NextLine_Mode(MODE_KEEP);         /* line mode: keep first line */
    34f2:	82 e0       	ldi	r24, 0x02	; 2
    34f4:	0e 94 1a 10 	call	0x2034	; 0x2034 <LCD_NextLine_Mode>
  LCD_NextLine_EEString(IR_Probes_str); /* display pinout */
    34f8:	88 e1       	ldi	r24, 0x18	; 24
    34fa:	91 e0       	ldi	r25, 0x01	; 1
    34fc:	0e 94 1d 10 	call	0x203a	; 0x203a <LCD_NextLine_EEString>
  R_DDR = (2 << (TP3 * 2));             /* enable Rh for probe-3 */
  R_PORT = 0;                           /* pull down probe-3 */
  #else
  /* safe mode with current limiting resistor for Vs */
  /* set probes: probe-1 -- Gnd / probe-2 -- Rl -- Vcc / probe-3 (HiZ) -- Rh -- Gnd */
  ADC_PORT = 0;                         /* pull down directly: */
    3500:	18 b8       	out	0x08, r1	; 8
  ADC_DDR = (1 << TP1);                 /* probe-1 */
    3502:	81 e0       	ldi	r24, 0x01	; 1
    3504:	87 b9       	out	0x07, r24	; 7
  /* pull up probe-2 via Rl, pull down probe-3 via Rh */
  R_DDR = (1 << (TP2 * 2)) | (2 << (TP3 * 2));    /* enable resistors */
    3506:	84 e2       	ldi	r24, 0x24	; 36
    3508:	84 b9       	out	0x04, r24	; 4
  R_PORT = (1 << (TP2 * 2));              /* pull up probe-2, pull down probe-3 */
    350a:	84 e0       	ldi	r24, 0x04	; 4
    350c:	85 b9       	out	0x05, r24	; 5
void IR_Detector(void)
{
  /* maximum number of pauses/pulses: 2 start + (2 * 48) data + 1 stop */
  #define MAX_PULSES          100

  uint8_t           Run = 1;            /* loop control */
    350e:	01 e0       	ldi	r16, 0x01	; 1
    3510:	11 e0       	ldi	r17, 0x01	; 1
    3512:	0c c0       	rjmp	.+24     	; 0x352c <IR_Detector+0x76>
    {
      n = 0;                            /* end this loop */
    }
    else
    {
      Flag = TestKey(100, 0);           /* wait 100ms for key press */
    3514:	60 e0       	ldi	r22, 0x00	; 0
    3516:	84 e6       	ldi	r24, 0x64	; 100
    3518:	90 e0       	ldi	r25, 0x00	; 0
    351a:	0e 94 58 33 	call	0x66b0	; 0x66b0 <TestKey>
      if (Flag)                         /* key pressed */
    351e:	81 11       	cpse	r24, r1
    3520:	03 c0       	rjmp	.+6      	; 0x3528 <IR_Detector+0x72>
  #endif


  /* wait for IR receiver module or key press */
  n = 1;
  while (n)
    3522:	11 11       	cpse	r17, r1
    3524:	03 c0       	rjmp	.+6      	; 0x352c <IR_Detector+0x76>
    3526:	04 c0       	rjmp	.+8      	; 0x3530 <IR_Detector+0x7a>
    else
    {
      Flag = TestKey(100, 0);           /* wait 100ms for key press */
      if (Flag)                         /* key pressed */
      {
        Run = 0;                        /* skip decoder loop */
    3528:	00 e0       	ldi	r16, 0x00	; 0
    352a:	02 c0       	rjmp	.+4      	; 0x3530 <IR_Detector+0x7a>

  /* wait for IR receiver module or key press */
  n = 1;
  while (n)
  {
    if (ADC_PIN & (1 << TP3))           /* check for high level */
    352c:	32 9b       	sbis	0x06, 2	; 6
    352e:	f2 cf       	rjmp	.-28     	; 0x3514 <IR_Detector+0x5e>
        n = 0;                          /* end this loop */
      }
    }
  }

  LCD_ClearLine2();                /* clear line #2 */
    3530:	0e 94 09 10 	call	0x2012	; 0x2012 <LCD_ClearLine2>
  LCD_Pos(1, 1);                   /* move to first line */
    3534:	61 e0       	ldi	r22, 0x01	; 1
    3536:	81 e0       	ldi	r24, 0x01	; 1
    3538:	0e 94 08 30 	call	0x6010	; 0x6010 <LCD_Pos>
   *  Since we deal with data pulses in the range of 0.5 up to 10ms
   *  we sample data every 50s and log how long each pulse or pause
   *  lasts. Timeout at 12ms.
   */

  while (Run > 0)
    353c:	00 23       	and	r16, r16
    353e:	09 f4       	brne	.+2      	; 0x3542 <IR_Detector+0x8c>
    3540:	52 c0       	rjmp	.+164    	; 0x35e6 <IR_Detector+0x130>
    3542:	c1 2c       	mov	r12, r1
    3544:	d1 2c       	mov	r13, r1
    3546:	b1 2c       	mov	r11, r1
    3548:	e1 2c       	mov	r14, r1
    354a:	f1 2c       	mov	r15, r1

      /* check test button */
      while (!(CONTROL_PIN & (1 << TEST_BUTTON)))
      {
        MilliSleep(50);                 /* take a nap */
        Run = 0;                        /* end loop */
    354c:	a1 2c       	mov	r10, r1
    else if (Run == 4)        /* check for test key */
    {
      Run = 1;                          /* switch back to waiting mode */

      /* check test button */
      while (!(CONTROL_PIN & (1 << TEST_BUTTON)))
    354e:	88 24       	eor	r8, r8
    3550:	83 94       	inc	r8
    3552:	68 94       	set
    3554:	99 24       	eor	r9, r9
    3556:	91 f8       	bld	r9, 1
   */

  while (Run > 0)
  {
    /* data logic is inverted by IR receiver */
    Flag = ADC_PIN & (1 << TP3);       /* poll data pin */
    3558:	16 b1       	in	r17, 0x06	; 6
    355a:	14 70       	andi	r17, 0x04	; 4

    if (Run == 1)             /* wait for IR */
    355c:	01 30       	cpi	r16, 0x01	; 1
    355e:	19 f4       	brne	.+6      	; 0x3566 <IR_Detector+0xb0>
    {
      if (!Flag)              /* low: H / IR signal */
    3560:	11 23       	and	r17, r17
    3562:	a9 f0       	breq	.+42     	; 0x358e <IR_Detector+0xd8>
    3564:	3c c0       	rjmp	.+120    	; 0x35de <IR_Detector+0x128>
        Run = 4;              /* check for test key */
      }
    }
    else                      /* sample IR */
    {
      if (Flag == OldFlag)    /* same pause/pulse */
    3566:	1f 11       	cpse	r17, r15
    3568:	07 c0       	rjmp	.+14     	; 0x3578 <IR_Detector+0xc2>
      {
        Period++;             /* add one sampling period */
    356a:	b3 94       	inc	r11

        if (Period > 240)     /* 12ms timeout */
    356c:	80 ef       	ldi	r24, 0xF0	; 240
    356e:	8b 15       	cp	r24, r11
    3570:	58 f4       	brcc	.+22     	; 0x3588 <IR_Detector+0xd2>
        {
          Run = 3;            /* switch to decoding mode */

          if (!Flag)          /* IR signal or removed receiver module */
    3572:	11 23       	and	r17, r17
    3574:	99 f1       	breq	.+102    	; 0x35dc <IR_Detector+0x126>
    3576:	1d c0       	rjmp	.+58     	; 0x35b2 <IR_Detector+0xfc>
      }
      else                    /* new pause/pulse */
      {
        OldFlag = Flag;       /* update flag */

        if (Pulses < MAX_PULSES)   /* prevent overflow */
    3578:	93 e6       	ldi	r25, 0x63	; 99
    357a:	9e 15       	cp	r25, r14
    357c:	d0 f0       	brcs	.+52     	; 0x35b2 <IR_Detector+0xfc>
        {
          Pulses++;             /* got another one */
    357e:	e3 94       	inc	r14
          *Pulse = Period;      /* save duration */
    3580:	f6 01       	movw	r30, r12
    3582:	b1 92       	st	Z+, r11
    3584:	6f 01       	movw	r12, r30
          Pulse++;              /* next one */
          Period = 0;           /* reset duration */
    3586:	ba 2c       	mov	r11, r10
          Run = 3;              /* switch to decoding mode */
        }
      }
    }

    if (Run == 2)             /* sampling mode */
    3588:	02 30       	cpi	r16, 0x02	; 2
    358a:	89 f4       	brne	.+34     	; 0x35ae <IR_Detector+0xf8>
    358c:	05 c0       	rjmp	.+10     	; 0x3598 <IR_Detector+0xe2>
      {
        Run = 2;              /* start sampling */
        OldFlag = Flag;       /* first one is always a pulse */
        Pulses = 0;           /* reset pulse counter */
        Period = 0;           /* reset duration */
        Pulse = &PulseWidth[0];    /* set start address */
    358e:	ce 01       	movw	r24, r28
    3590:	01 96       	adiw	r24, 0x01	; 1
    3592:	6c 01       	movw	r12, r24
      if (!Flag)              /* low: H / IR signal */
      {
        Run = 2;              /* start sampling */
        OldFlag = Flag;       /* first one is always a pulse */
        Pulses = 0;           /* reset pulse counter */
        Period = 0;           /* reset duration */
    3594:	ba 2c       	mov	r11, r10
    {
      if (!Flag)              /* low: H / IR signal */
      {
        Run = 2;              /* start sampling */
        OldFlag = Flag;       /* first one is always a pulse */
        Pulses = 0;           /* reset pulse counter */
    3596:	ea 2c       	mov	r14, r10
    3598:	95 ed       	ldi	r25, 0xD5	; 213
    359a:	9a 95       	dec	r25
    359c:	f1 f7       	brne	.-4      	; 0x359a <IR_Detector+0xe4>
    359e:	00 00       	nop
    35a0:	82 e2       	ldi	r24, 0x22	; 34

      n = Cycles;
      while (n > 0)
      {
        n--;
        asm volatile("nop\n\t"::);
    35a2:	00 00       	nop
    35a4:	81 50       	subi	r24, 0x01	; 1
       *  - a loop run needs 4 cycles, the last loop run just 3
       *  - time delay: 10s - 1 MCU cycle
       */

      n = Cycles;
      while (n > 0)
    35a6:	e9 f7       	brne	.-6      	; 0x35a2 <IR_Detector+0xec>
    35a8:	f1 2e       	mov	r15, r17
    35aa:	09 2d       	mov	r16, r9
    35ac:	13 c0       	rjmp	.+38     	; 0x35d4 <IR_Detector+0x11e>
      {
        n--;
        asm volatile("nop\n\t"::);
      }
    }
    else if (Run == 3)        /* decode mode */
    35ae:	03 30       	cpi	r16, 0x03	; 3
    35b0:	81 f4       	brne	.+32     	; 0x35d2 <IR_Detector+0x11c>
    {
      IR_Decode(&PulseWidth[0], Pulses);     /* try to decode */
    35b2:	6e 2d       	mov	r22, r14
    35b4:	ce 01       	movw	r24, r28
    35b6:	01 96       	adiw	r24, 0x01	; 1
    35b8:	0e 94 d6 16 	call	0x2dac	; 0x2dac <IR_Decode>
    35bc:	f1 2e       	mov	r15, r17
      Run = 1;                          /* switch back to waiting mode */
    35be:	08 2d       	mov	r16, r8
    35c0:	09 c0       	rjmp	.+18     	; 0x35d4 <IR_Detector+0x11e>
      Run = 1;                          /* switch back to waiting mode */

      /* check test button */
      while (!(CONTROL_PIN & (1 << TEST_BUTTON)))
      {
        MilliSleep(50);                 /* take a nap */
    35c2:	82 e3       	ldi	r24, 0x32	; 50
    35c4:	90 e0       	ldi	r25, 0x00	; 0
    35c6:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>
    else if (Run == 4)        /* check for test key */
    {
      Run = 1;                          /* switch back to waiting mode */

      /* check test button */
      while (!(CONTROL_PIN & (1 << TEST_BUTTON)))
    35ca:	4f 9b       	sbis	0x09, 7	; 9
    35cc:	fa cf       	rjmp	.-12     	; 0x35c2 <IR_Detector+0x10c>
      {
        MilliSleep(50);                 /* take a nap */
        Run = 0;                        /* end loop */
    35ce:	0a 2d       	mov	r16, r10
    35d0:	01 c0       	rjmp	.+2      	; 0x35d4 <IR_Detector+0x11e>
    35d2:	f1 2e       	mov	r15, r17
      }
    }

    wdt_reset();            /* reset watchdog */
    35d4:	a8 95       	wdr
   *  Since we deal with data pulses in the range of 0.5 up to 10ms
   *  we sample data every 50s and log how long each pulse or pause
   *  lasts. Timeout at 12ms.
   */

  while (Run > 0)
    35d6:	01 11       	cpse	r16, r1
    35d8:	bf cf       	rjmp	.-130    	; 0x3558 <IR_Detector+0xa2>
    35da:	05 c0       	rjmp	.+10     	; 0x35e6 <IR_Detector+0x130>
    35dc:	f1 2e       	mov	r15, r17
    else if (Run == 4)        /* check for test key */
    {
      Run = 1;                          /* switch back to waiting mode */

      /* check test button */
      while (!(CONTROL_PIN & (1 << TEST_BUTTON)))
    35de:	4f 9b       	sbis	0x09, 7	; 9
    35e0:	f0 cf       	rjmp	.-32     	; 0x35c2 <IR_Detector+0x10c>
    35e2:	08 2d       	mov	r16, r8
    35e4:	f7 cf       	rjmp	.-18     	; 0x35d4 <IR_Detector+0x11e>

    wdt_reset();            /* reset watchdog */
  }

  #undef MAX_PULSES
}
    35e6:	cc 59       	subi	r28, 0x9C	; 156
    35e8:	df 4f       	sbci	r29, 0xFF	; 255
    35ea:	0f b6       	in	r0, 0x3f	; 63
    35ec:	f8 94       	cli
    35ee:	de bf       	out	0x3e, r29	; 62
    35f0:	0f be       	out	0x3f, r0	; 63
    35f2:	cd bf       	out	0x3d, r28	; 61
    35f4:	df 91       	pop	r29
    35f6:	cf 91       	pop	r28
    35f8:	1f 91       	pop	r17
    35fa:	0f 91       	pop	r16
    35fc:	ff 90       	pop	r15
    35fe:	ef 90       	pop	r14
    3600:	df 90       	pop	r13
    3602:	cf 90       	pop	r12
    3604:	bf 90       	pop	r11
    3606:	af 90       	pop	r10
    3608:	9f 90       	pop	r9
    360a:	8f 90       	pop	r8
    360c:	08 95       	ret

0000360e <Show_SemiPinout>:
 *  - character for pin B
 *  - character for pin C
 */

void Show_SemiPinout(uint8_t A, uint8_t B, uint8_t C)
{
    360e:	8f 92       	push	r8
    3610:	9f 92       	push	r9
    3612:	af 92       	push	r10
    3614:	bf 92       	push	r11
    3616:	df 92       	push	r13
    3618:	ef 92       	push	r14
    361a:	ff 92       	push	r15
    361c:	0f 93       	push	r16
    361e:	1f 93       	push	r17
    3620:	cf 93       	push	r28
    3622:	df 93       	push	r29
    3624:	00 d0       	rcall	.+0      	; 0x3626 <Show_SemiPinout+0x18>
    3626:	00 d0       	rcall	.+0      	; 0x3628 <Show_SemiPinout+0x1a>
    3628:	00 d0       	rcall	.+0      	; 0x362a <Show_SemiPinout+0x1c>
    362a:	cd b7       	in	r28, 0x3d	; 61
    362c:	de b7       	in	r29, 0x3e	; 62
  uint8_t           i, j;     /* counter */
  unsigned char     Pin[3];   /* component pins */
  unsigned char     ID[3];    /* component pin IDs */

  /* copy probe pin numbers */
  Pin[0] = Semi.A;
    362e:	e1 e8       	ldi	r30, 0x81	; 129
    3630:	f1 e0       	ldi	r31, 0x01	; 1
    3632:	90 81       	ld	r25, Z
    3634:	99 83       	std	Y+1, r25	; 0x01
  Pin[1] = Semi.B;
    3636:	91 81       	ldd	r25, Z+1	; 0x01
    3638:	9a 83       	std	Y+2, r25	; 0x02
  Pin[2] = Semi.C;
    363a:	92 81       	ldd	r25, Z+2	; 0x02
    363c:	9b 83       	std	Y+3, r25	; 0x03

  /* copy pin characters/IDs */
  ID[0] = A;
    363e:	8c 83       	std	Y+4, r24	; 0x04
  ID[1] = B;
    3640:	6d 83       	std	Y+5, r22	; 0x05
  ID[2] = C;
    3642:	4e 83       	std	Y+6, r20	; 0x06

  /* display: 123 */
  for (i = 0; i <= 2; i++)
  {
    LCD_ProbeNumber(i);
    3644:	80 e0       	ldi	r24, 0x00	; 0
    3646:	0e 94 05 10 	call	0x200a	; 0x200a <LCD_ProbeNumber>
    364a:	81 e0       	ldi	r24, 0x01	; 1
    364c:	0e 94 05 10 	call	0x200a	; 0x200a <LCD_ProbeNumber>
    3650:	82 e0       	ldi	r24, 0x02	; 2
    3652:	0e 94 05 10 	call	0x200a	; 0x200a <LCD_ProbeNumber>
  }

  /* display: = */
  LCD_Char('=');
    3656:	8d e3       	ldi	r24, 0x3D	; 61
    3658:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>

  /* display pin IDs */
  for (i = 0; i <= 2; i++)         /* loop through probe pins */
    365c:	d1 2c       	mov	r13, r1
    365e:	4e 01       	movw	r8, r28
    3660:	84 e0       	ldi	r24, 0x04	; 4
    3662:	88 0e       	add	r8, r24
    3664:	91 1c       	adc	r9, r1
    3666:	54 01       	movw	r10, r8
    3668:	13 c0       	rjmp	.+38     	; 0x3690 <Show_SemiPinout+0x82>
  {
    for (j = 0; j <= 2; j++)       /* loop through component pins */
    {
      if (i == Pin[j])        /* probe pin matches */
    366a:	f8 01       	movw	r30, r16
    366c:	81 91       	ld	r24, Z+
    366e:	8f 01       	movw	r16, r30
    3670:	8d 11       	cpse	r24, r13
    3672:	04 c0       	rjmp	.+8      	; 0x367c <Show_SemiPinout+0x6e>
      {
        LCD_Char(ID[j]);           /* show ID */
    3674:	f7 01       	movw	r30, r14
    3676:	80 81       	ld	r24, Z
    3678:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    367c:	ff ef       	ldi	r31, 0xFF	; 255
    367e:	ef 1a       	sub	r14, r31
    3680:	ff 0a       	sbc	r15, r31
  LCD_Char('=');

  /* display pin IDs */
  for (i = 0; i <= 2; i++)         /* loop through probe pins */
  {
    for (j = 0; j <= 2; j++)       /* loop through component pins */
    3682:	0a 15       	cp	r16, r10
    3684:	1b 05       	cpc	r17, r11
    3686:	89 f7       	brne	.-30     	; 0x366a <Show_SemiPinout+0x5c>

  /* display: = */
  LCD_Char('=');

  /* display pin IDs */
  for (i = 0; i <= 2; i++)         /* loop through probe pins */
    3688:	d3 94       	inc	r13
    368a:	83 e0       	ldi	r24, 0x03	; 3
    368c:	d8 16       	cp	r13, r24
    368e:	29 f0       	breq	.+10     	; 0x369a <Show_SemiPinout+0x8c>
    3690:	8e 01       	movw	r16, r28
    3692:	0f 5f       	subi	r16, 0xFF	; 255
    3694:	1f 4f       	sbci	r17, 0xFF	; 255
    3696:	74 01       	movw	r14, r8
    3698:	e8 cf       	rjmp	.-48     	; 0x366a <Show_SemiPinout+0x5c>
      {
        LCD_Char(ID[j]);           /* show ID */
      }
    }
  }
}
    369a:	26 96       	adiw	r28, 0x06	; 6
    369c:	0f b6       	in	r0, 0x3f	; 63
    369e:	f8 94       	cli
    36a0:	de bf       	out	0x3e, r29	; 62
    36a2:	0f be       	out	0x3f, r0	; 63
    36a4:	cd bf       	out	0x3d, r28	; 61
    36a6:	df 91       	pop	r29
    36a8:	cf 91       	pop	r28
    36aa:	1f 91       	pop	r17
    36ac:	0f 91       	pop	r16
    36ae:	ff 90       	pop	r15
    36b0:	ef 90       	pop	r14
    36b2:	df 90       	pop	r13
    36b4:	bf 90       	pop	r11
    36b6:	af 90       	pop	r10
    36b8:	9f 90       	pop	r9
    36ba:	8f 90       	pop	r8
    36bc:	08 95       	ret

000036be <Show_Fail>:
 */

void Show_Fail(void)
{
  /* display info */
  LCD_EEString(Failed1_str);            /* display: No component */
    36be:	8c ea       	ldi	r24, 0xAC	; 172
    36c0:	92 e0       	ldi	r25, 0x02	; 2
    36c2:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
  LCD_NextLine_EEString(Failed2_str);   /* display: found!*/  
    36c6:	85 ea       	ldi	r24, 0xA5	; 165
    36c8:	92 e0       	ldi	r25, 0x02	; 2
    36ca:	0e 94 1d 10 	call	0x203a	; 0x203a <LCD_NextLine_EEString>

  RunsMissed++;               /* increase counter */
    36ce:	80 91 8e 01 	lds	r24, 0x018E
    36d2:	8f 5f       	subi	r24, 0xFF	; 255
    36d4:	80 93 8e 01 	sts	0x018E, r24
  RunsPassed = 0;             /* reset counter */
    36d8:	10 92 80 01 	sts	0x0180, r1
    36dc:	08 95       	ret

000036de <Show_Error>:
/*
 *  show error
 */

void Show_Error()
{
    36de:	cf 93       	push	r28
    36e0:	df 93       	push	r29
  if (Check.Type == TYPE_DISCHARGE)     /* discharge failed */
    36e2:	80 91 0a 01 	lds	r24, 0x010A
    36e6:	81 30       	cpi	r24, 0x01	; 1
    36e8:	c1 f4       	brne	.+48     	; 0x371a <Show_Error+0x3c>
  {
    LCD_EEString(DischargeFailed_str);  /* display: Battery? */
    36ea:	88 e4       	ldi	r24, 0x48	; 72
    36ec:	92 e0       	ldi	r25, 0x02	; 2
    36ee:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>

    /* display probe number and remaining voltage */
    LCD_NextLine();
    36f2:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <LCD_NextLine>
    LCD_ProbeNumber(Check.Probe);
    36f6:	c8 e0       	ldi	r28, 0x08	; 8
    36f8:	d1 e0       	ldi	r29, 0x01	; 1
    36fa:	8d 81       	ldd	r24, Y+5	; 0x05
    36fc:	0e 94 05 10 	call	0x200a	; 0x200a <LCD_ProbeNumber>
    LCD_Char(':');
    3700:	8a e3       	ldi	r24, 0x3A	; 58
    3702:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    LCD_Space();
    3706:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
    DisplayValue(Check.U, -3, 'V');
    370a:	6e 81       	ldd	r22, Y+6	; 0x06
    370c:	7f 81       	ldd	r23, Y+7	; 0x07
    370e:	80 e0       	ldi	r24, 0x00	; 0
    3710:	90 e0       	ldi	r25, 0x00	; 0
    3712:	26 e5       	ldi	r18, 0x56	; 86
    3714:	4d ef       	ldi	r20, 0xFD	; 253
    3716:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
  }
}
    371a:	df 91       	pop	r29
    371c:	cf 91       	pop	r28
    371e:	08 95       	ret

00003720 <Show_SingleResistor>:
 *  - ID1 pin ID character
 *  - ID2 pin ID character
 */

void Show_SingleResistor(uint8_t ID1, uint8_t ID2)
{
    3720:	cf 93       	push	r28
    3722:	c6 2f       	mov	r28, r22
  Resistor_Type     *Resistor;     /* pointer to resistor */

  Resistor = &Resistors[0];        /* pointer to first resistor */

  /* show pinout */
  LCD_Char(ID1);
    3724:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
  LCD_EEString(Resistor_str);
    3728:	83 ed       	ldi	r24, 0xD3	; 211
    372a:	90 e0       	ldi	r25, 0x00	; 0
    372c:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
  LCD_Char(ID2); 
    3730:	8c 2f       	mov	r24, r28
    3732:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>

  /* show resistance value */
  LCD_Space();
    3736:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
  DisplayValue(Resistor->Value, Resistor->Scale, LCD_CHAR_OMEGA);
    373a:	e1 e1       	ldi	r30, 0x11	; 17
    373c:	f1 e0       	ldi	r31, 0x01	; 1
    373e:	63 81       	ldd	r22, Z+3	; 0x03
    3740:	74 81       	ldd	r23, Z+4	; 0x04
    3742:	85 81       	ldd	r24, Z+5	; 0x05
    3744:	96 81       	ldd	r25, Z+6	; 0x06
    3746:	24 e0       	ldi	r18, 0x04	; 4
    3748:	42 81       	ldd	r20, Z+2	; 0x02
    374a:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
}
    374e:	cf 91       	pop	r28
    3750:	08 95       	ret

00003752 <Show_Resistor>:
/*
 *  show resistor(s)
 */

void Show_Resistor(void)
{
    3752:	cf 92       	push	r12
    3754:	df 92       	push	r13
    3756:	ef 92       	push	r14
    3758:	ff 92       	push	r15
    375a:	0f 93       	push	r16
    375c:	1f 93       	push	r17
    375e:	cf 93       	push	r28
    3760:	df 93       	push	r29
  Resistor_Type     *R2;           /* pointer to resistor #2 */
  uint8_t           Pin;           /* ID of common pin */

  R1 = &Resistors[0];              /* pointer to first resistor */

  if (Check.Resistors == 1)        /* single resistor */
    3762:	80 91 0b 01 	lds	r24, 0x010B
    3766:	81 30       	cpi	r24, 0x01	; 1
    3768:	39 f4       	brne	.+14     	; 0x3778 <Show_Resistor+0x26>
  {
    R2 = NULL;                     /* disable second resistor */
    Pin = R1->A;                   /* make B the first pin */
    376a:	f0 90 11 01 	lds	r15, 0x0111

  R1 = &Resistors[0];              /* pointer to first resistor */

  if (Check.Resistors == 1)        /* single resistor */
  {
    R2 = NULL;                     /* disable second resistor */
    376e:	c0 e0       	ldi	r28, 0x00	; 0
    3770:	d0 e0       	ldi	r29, 0x00	; 0
{
  Resistor_Type     *R1;           /* pointer to resistor #1 */
  Resistor_Type     *R2;           /* pointer to resistor #2 */
  uint8_t           Pin;           /* ID of common pin */

  R1 = &Resistors[0];              /* pointer to first resistor */
    3772:	01 e1       	ldi	r16, 0x11	; 17
    3774:	11 e0       	ldi	r17, 0x01	; 1
    3776:	57 c0       	rjmp	.+174    	; 0x3826 <Show_Resistor+0xd4>
  else                             /* multiple resistors */
  {
    R2 = R1;
    R2++;                          /* pointer to second resistor */

    if (Check.Resistors == 3)      /* three resistors */
    3778:	83 30       	cpi	r24, 0x03	; 3
    377a:	09 f0       	breq	.+2      	; 0x377e <Show_Resistor+0x2c>
    377c:	47 c0       	rjmp	.+142    	; 0x380c <Show_Resistor+0xba>
       */

      Rmax = R1;                   /* starting point */
      for (Pin = 1; Pin <= 2; Pin++)
      {
        if (CmpValue(R2->Value, R2->Scale, Rmax->Value, Rmax->Scale) == 1)
    377e:	e1 e1       	ldi	r30, 0x11	; 17
    3780:	f1 e0       	ldi	r31, 0x01	; 1
    3782:	03 81       	ldd	r16, Z+3	; 0x03
    3784:	14 81       	ldd	r17, Z+4	; 0x04
    3786:	25 81       	ldd	r18, Z+5	; 0x05
    3788:	36 81       	ldd	r19, Z+6	; 0x06
    378a:	62 85       	ldd	r22, Z+10	; 0x0a
    378c:	73 85       	ldd	r23, Z+11	; 0x0b
    378e:	84 85       	ldd	r24, Z+12	; 0x0c
    3790:	95 85       	ldd	r25, Z+13	; 0x0d
    3792:	e2 80       	ldd	r14, Z+2	; 0x02
    3794:	41 85       	ldd	r20, Z+9	; 0x09
    3796:	0e 94 ac 31 	call	0x6358	; 0x6358 <CmpValue>
    379a:	81 30       	cpi	r24, 0x01	; 1
    379c:	39 f4       	brne	.+14     	; 0x37ac <Show_Resistor+0x5a>
    379e:	0f 2e       	mov	r0, r31
    37a0:	f8 e1       	ldi	r31, 0x18	; 24
    37a2:	cf 2e       	mov	r12, r31
    37a4:	f1 e0       	ldi	r31, 0x01	; 1
    37a6:	df 2e       	mov	r13, r31
    37a8:	f0 2d       	mov	r31, r0
    37aa:	06 c0       	rjmp	.+12     	; 0x37b8 <Show_Resistor+0x66>
    37ac:	0f 2e       	mov	r0, r31
    37ae:	f1 e1       	ldi	r31, 0x11	; 17
    37b0:	cf 2e       	mov	r12, r31
    37b2:	f1 e0       	ldi	r31, 0x01	; 1
    37b4:	df 2e       	mov	r13, r31
    37b6:	f0 2d       	mov	r31, r0
    37b8:	d6 01       	movw	r26, r12
    37ba:	13 96       	adiw	r26, 0x03	; 3
    37bc:	0d 91       	ld	r16, X+
    37be:	1d 91       	ld	r17, X+
    37c0:	2d 91       	ld	r18, X+
    37c2:	3c 91       	ld	r19, X
    37c4:	16 97       	sbiw	r26, 0x06	; 6
    37c6:	e1 e1       	ldi	r30, 0x11	; 17
    37c8:	f1 e0       	ldi	r31, 0x01	; 1
    37ca:	61 89       	ldd	r22, Z+17	; 0x11
    37cc:	72 89       	ldd	r23, Z+18	; 0x12
    37ce:	83 89       	ldd	r24, Z+19	; 0x13
    37d0:	94 89       	ldd	r25, Z+20	; 0x14
    37d2:	12 96       	adiw	r26, 0x02	; 2
    37d4:	ec 90       	ld	r14, X
    37d6:	40 89       	ldd	r20, Z+16	; 0x10
    37d8:	0e 94 ac 31 	call	0x6358	; 0x6358 <CmpValue>
    37dc:	81 30       	cpi	r24, 0x01	; 1
    37de:	09 f4       	brne	.+2      	; 0x37e2 <Show_Resistor+0x90>
    37e0:	7b c0       	rjmp	.+246    	; 0x38d8 <Show_Resistor+0x186>

        R2++;                 /* next one */
      }

      /* get the two smaller resistors */
      if (R1 == Rmax) R1++;
    37e2:	b1 e1       	ldi	r27, 0x11	; 17
    37e4:	cb 16       	cp	r12, r27
    37e6:	b1 e0       	ldi	r27, 0x01	; 1
    37e8:	db 06       	cpc	r13, r27
    37ea:	19 f0       	breq	.+6      	; 0x37f2 <Show_Resistor+0xa0>
{
  Resistor_Type     *R1;           /* pointer to resistor #1 */
  Resistor_Type     *R2;           /* pointer to resistor #2 */
  uint8_t           Pin;           /* ID of common pin */

  R1 = &Resistors[0];              /* pointer to first resistor */
    37ec:	01 e1       	ldi	r16, 0x11	; 17
    37ee:	11 e0       	ldi	r17, 0x01	; 1
    37f0:	02 c0       	rjmp	.+4      	; 0x37f6 <Show_Resistor+0xa4>

        R2++;                 /* next one */
      }

      /* get the two smaller resistors */
      if (R1 == Rmax) R1++;
    37f2:	08 e1       	ldi	r16, 0x18	; 24
    37f4:	11 e0       	ldi	r17, 0x01	; 1
      R2 = R1;
      R2++;
    37f6:	e8 01       	movw	r28, r16
    37f8:	27 96       	adiw	r28, 0x07	; 7
      if (R2 == Rmax) R2++;
    37fa:	cc 16       	cp	r12, r28
    37fc:	dd 06       	cpc	r13, r29
    37fe:	51 f4       	brne	.+20     	; 0x3814 <Show_Resistor+0xc2>
    3800:	02 c0       	rjmp	.+4      	; 0x3806 <Show_Resistor+0xb4>

        R2++;                 /* next one */
      }

      /* get the two smaller resistors */
      if (R1 == Rmax) R1++;
    3802:	08 e1       	ldi	r16, 0x18	; 24
    3804:	11 e0       	ldi	r17, 0x01	; 1
      R2 = R1;
      R2++;
      if (R2 == Rmax) R2++;
    3806:	e8 01       	movw	r28, r16
    3808:	2e 96       	adiw	r28, 0x0e	; 14
    380a:	04 c0       	rjmp	.+8      	; 0x3814 <Show_Resistor+0xc2>
    Pin = R1->A;                   /* make B the first pin */
  }
  else                             /* multiple resistors */
  {
    R2 = R1;
    R2++;                          /* pointer to second resistor */
    380c:	c8 e1       	ldi	r28, 0x18	; 24
    380e:	d1 e0       	ldi	r29, 0x01	; 1
{
  Resistor_Type     *R1;           /* pointer to resistor #1 */
  Resistor_Type     *R2;           /* pointer to resistor #2 */
  uint8_t           Pin;           /* ID of common pin */

  R1 = &Resistors[0];              /* pointer to first resistor */
    3810:	01 e1       	ldi	r16, 0x11	; 17
    3812:	11 e0       	ldi	r17, 0x01	; 1
      R2++;
      if (R2 == Rmax) R2++;
    }

    /* find common pin of both resistors */
    if ((R1->A == R2->A) || (R1->A == R2->B)) Pin = R1->A;
    3814:	f8 01       	movw	r30, r16
    3816:	80 81       	ld	r24, Z
    3818:	f8 80       	ld	r15, Y
    381a:	8f 15       	cp	r24, r15
    381c:	59 f0       	breq	.+22     	; 0x3834 <Show_Resistor+0xe2>
    381e:	f9 80       	ldd	r15, Y+1	; 0x01
    3820:	8f 15       	cp	r24, r15
    3822:	41 f0       	breq	.+16     	; 0x3834 <Show_Resistor+0xe2>
    else Pin = R1->B;
    3824:	f1 80       	ldd	r15, Z+1	; 0x01
  /*
   *  display the pins
   */

  /* first resistor */
  if (R1->A != Pin) LCD_ProbeNumber(R1->A);
    3826:	d8 01       	movw	r26, r16
    3828:	8c 91       	ld	r24, X
    382a:	8f 15       	cp	r24, r15
    382c:	19 f0       	breq	.+6      	; 0x3834 <Show_Resistor+0xe2>
    382e:	0e 94 05 10 	call	0x200a	; 0x200a <LCD_ProbeNumber>
    3832:	04 c0       	rjmp	.+8      	; 0x383c <Show_Resistor+0xea>
  else LCD_ProbeNumber(R1->B);
    3834:	f8 01       	movw	r30, r16
    3836:	81 81       	ldd	r24, Z+1	; 0x01
    3838:	0e 94 05 10 	call	0x200a	; 0x200a <LCD_ProbeNumber>
  LCD_EEString(Resistor_str);
    383c:	83 ed       	ldi	r24, 0xD3	; 211
    383e:	90 e0       	ldi	r25, 0x00	; 0
    3840:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
  LCD_ProbeNumber(Pin);
    3844:	8f 2d       	mov	r24, r15
    3846:	0e 94 05 10 	call	0x200a	; 0x200a <LCD_ProbeNumber>

  if (R2)           /* second resistor */
    384a:	20 97       	sbiw	r28, 0x00	; 0
    384c:	a1 f1       	breq	.+104    	; 0x38b6 <Show_Resistor+0x164>
  {
    LCD_EEString(Resistor_str);
    384e:	83 ed       	ldi	r24, 0xD3	; 211
    3850:	90 e0       	ldi	r25, 0x00	; 0
    3852:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
    if (R2->A != Pin) LCD_ProbeNumber(R2->A);
    3856:	88 81       	ld	r24, Y
    3858:	8f 15       	cp	r24, r15
    385a:	19 f0       	breq	.+6      	; 0x3862 <Show_Resistor+0x110>
    385c:	0e 94 05 10 	call	0x200a	; 0x200a <LCD_ProbeNumber>
    3860:	11 c0       	rjmp	.+34     	; 0x3884 <Show_Resistor+0x132>
    else LCD_ProbeNumber(R2->B);
    3862:	89 81       	ldd	r24, Y+1	; 0x01
    3864:	0e 94 05 10 	call	0x200a	; 0x200a <LCD_ProbeNumber>
    3868:	0d c0       	rjmp	.+26     	; 0x3884 <Show_Resistor+0x132>
  else                   /* single resistor */
  {
    /* get inductance and display if relevant */
    if (MeasureInductor(R1) == 1)
    {
      LCD_Space();
    386a:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
      DisplayValue(Inductor.Value, Inductor.Scale, 'H');
    386e:	e6 ea       	ldi	r30, 0xA6	; 166
    3870:	f1 e0       	ldi	r31, 0x01	; 1
    3872:	61 81       	ldd	r22, Z+1	; 0x01
    3874:	72 81       	ldd	r23, Z+2	; 0x02
    3876:	83 81       	ldd	r24, Z+3	; 0x03
    3878:	94 81       	ldd	r25, Z+4	; 0x04
    387a:	28 e4       	ldi	r18, 0x48	; 72
    387c:	40 81       	ld	r20, Z
    387e:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
    3882:	33 c0       	rjmp	.+102    	; 0x38ea <Show_Resistor+0x198>
  /*
   *  display the values
   */

  /* first resistor */
  LCD_NextLine();
    3884:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <LCD_NextLine>
  DisplayValue(R1->Value, R1->Scale, LCD_CHAR_OMEGA);
    3888:	d8 01       	movw	r26, r16
    388a:	13 96       	adiw	r26, 0x03	; 3
    388c:	6d 91       	ld	r22, X+
    388e:	7d 91       	ld	r23, X+
    3890:	8d 91       	ld	r24, X+
    3892:	9c 91       	ld	r25, X
    3894:	16 97       	sbiw	r26, 0x06	; 6
    3896:	24 e0       	ldi	r18, 0x04	; 4
    3898:	12 96       	adiw	r26, 0x02	; 2
    389a:	4c 91       	ld	r20, X
    389c:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>

  if (R2)                /* second resistor */
  {
    LCD_Space();
    38a0:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
    DisplayValue(R2->Value, R2->Scale, LCD_CHAR_OMEGA);
    38a4:	6b 81       	ldd	r22, Y+3	; 0x03
    38a6:	7c 81       	ldd	r23, Y+4	; 0x04
    38a8:	8d 81       	ldd	r24, Y+5	; 0x05
    38aa:	9e 81       	ldd	r25, Y+6	; 0x06
    38ac:	24 e0       	ldi	r18, 0x04	; 4
    38ae:	4a 81       	ldd	r20, Y+2	; 0x02
    38b0:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
    38b4:	1a c0       	rjmp	.+52     	; 0x38ea <Show_Resistor+0x198>
  /*
   *  display the values
   */

  /* first resistor */
  LCD_NextLine();
    38b6:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <LCD_NextLine>
  DisplayValue(R1->Value, R1->Scale, LCD_CHAR_OMEGA);
    38ba:	f8 01       	movw	r30, r16
    38bc:	63 81       	ldd	r22, Z+3	; 0x03
    38be:	74 81       	ldd	r23, Z+4	; 0x04
    38c0:	85 81       	ldd	r24, Z+5	; 0x05
    38c2:	96 81       	ldd	r25, Z+6	; 0x06
    38c4:	24 e0       	ldi	r18, 0x04	; 4
    38c6:	42 81       	ldd	r20, Z+2	; 0x02
    38c8:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
  }
  #ifdef SW_INDUCTOR
  else                   /* single resistor */
  {
    /* get inductance and display if relevant */
    if (MeasureInductor(R1) == 1)
    38cc:	c8 01       	movw	r24, r16
    38ce:	0e 94 8e 13 	call	0x271c	; 0x271c <MeasureInductor>
    38d2:	81 30       	cpi	r24, 0x01	; 1
    38d4:	51 f4       	brne	.+20     	; 0x38ea <Show_Resistor+0x198>
    38d6:	c9 cf       	rjmp	.-110    	; 0x386a <Show_Resistor+0x118>

        R2++;                 /* next one */
      }

      /* get the two smaller resistors */
      if (R1 == Rmax) R1++;
    38d8:	8f e1       	ldi	r24, 0x1F	; 31
    38da:	91 e0       	ldi	r25, 0x01	; 1
    38dc:	f1 e0       	ldi	r31, 0x01	; 1
    38de:	81 31       	cpi	r24, 0x11	; 17
    38e0:	9f 07       	cpc	r25, r31
    38e2:	09 f4       	brne	.+2      	; 0x38e6 <Show_Resistor+0x194>
    38e4:	8e cf       	rjmp	.-228    	; 0x3802 <Show_Resistor+0xb0>
        if (CmpValue(R2->Value, R2->Scale, Rmax->Value, Rmax->Scale) == 1)
        {
          Rmax = R2;          /* update largest one */
        }

        R2++;                 /* next one */
    38e6:	6c 01       	movw	r12, r24
    38e8:	81 cf       	rjmp	.-254    	; 0x37ec <Show_Resistor+0x9a>
      LCD_Space();
      DisplayValue(Inductor.Value, Inductor.Scale, 'H');
    }
  }
  #endif
}
    38ea:	df 91       	pop	r29
    38ec:	cf 91       	pop	r28
    38ee:	1f 91       	pop	r17
    38f0:	0f 91       	pop	r16
    38f2:	ff 90       	pop	r15
    38f4:	ef 90       	pop	r14
    38f6:	df 90       	pop	r13
    38f8:	cf 90       	pop	r12
    38fa:	08 95       	ret

000038fc <Show_Capacitor>:
/*
 *  show capacitor
 */

void Show_Capacitor(void)
{
    38fc:	ef 92       	push	r14
    38fe:	0f 93       	push	r16
    3900:	1f 93       	push	r17
    3902:	cf 93       	push	r28
    3904:	df 93       	push	r29

  for (Counter = 1; Counter <= 2; Counter++) 
  {
    Cap++;                         /* next cap */

    if (CmpValue(Cap->Value, Cap->Scale, MaxCap->Value, MaxCap->Scale) == 1)
    3906:	eb e3       	ldi	r30, 0x3B	; 59
    3908:	f1 e0       	ldi	r31, 0x01	; 1
    390a:	03 81       	ldd	r16, Z+3	; 0x03
    390c:	14 81       	ldd	r17, Z+4	; 0x04
    390e:	25 81       	ldd	r18, Z+5	; 0x05
    3910:	36 81       	ldd	r19, Z+6	; 0x06
    3912:	66 85       	ldd	r22, Z+14	; 0x0e
    3914:	77 85       	ldd	r23, Z+15	; 0x0f
    3916:	80 89       	ldd	r24, Z+16	; 0x10
    3918:	91 89       	ldd	r25, Z+17	; 0x11
    391a:	e2 80       	ldd	r14, Z+2	; 0x02
    391c:	45 85       	ldd	r20, Z+13	; 0x0d
    391e:	0e 94 ac 31 	call	0x6358	; 0x6358 <CmpValue>
    3922:	81 30       	cpi	r24, 0x01	; 1
    3924:	19 f4       	brne	.+6      	; 0x392c <Show_Capacitor+0x30>
  MaxCap = &Caps[0];               /* pointer to first cap */
  Cap = MaxCap;

  for (Counter = 1; Counter <= 2; Counter++) 
  {
    Cap++;                         /* next cap */
    3926:	c6 e4       	ldi	r28, 0x46	; 70
    3928:	d1 e0       	ldi	r29, 0x01	; 1
    392a:	02 c0       	rjmp	.+4      	; 0x3930 <Show_Capacitor+0x34>
  uint16_t          ESR;           /* ESR (in 0.01 Ohms) */
  #endif
  uint8_t           Counter;       /* loop counter */

  /* find largest cap */
  MaxCap = &Caps[0];               /* pointer to first cap */
    392c:	cb e3       	ldi	r28, 0x3B	; 59
    392e:	d1 e0       	ldi	r29, 0x01	; 1

  for (Counter = 1; Counter <= 2; Counter++) 
  {
    Cap++;                         /* next cap */

    if (CmpValue(Cap->Value, Cap->Scale, MaxCap->Value, MaxCap->Scale) == 1)
    3930:	0b 81       	ldd	r16, Y+3	; 0x03
    3932:	1c 81       	ldd	r17, Y+4	; 0x04
    3934:	2d 81       	ldd	r18, Y+5	; 0x05
    3936:	3e 81       	ldd	r19, Y+6	; 0x06
    3938:	eb e3       	ldi	r30, 0x3B	; 59
    393a:	f1 e0       	ldi	r31, 0x01	; 1
    393c:	61 8d       	ldd	r22, Z+25	; 0x19
    393e:	72 8d       	ldd	r23, Z+26	; 0x1a
    3940:	83 8d       	ldd	r24, Z+27	; 0x1b
    3942:	94 8d       	ldd	r25, Z+28	; 0x1c
    3944:	ea 80       	ldd	r14, Y+2	; 0x02
    3946:	40 8d       	ldd	r20, Z+24	; 0x18
    3948:	0e 94 ac 31 	call	0x6358	; 0x6358 <CmpValue>
    394c:	81 30       	cpi	r24, 0x01	; 1
    394e:	11 f4       	brne	.+4      	; 0x3954 <Show_Capacitor+0x58>
  MaxCap = &Caps[0];               /* pointer to first cap */
  Cap = MaxCap;

  for (Counter = 1; Counter <= 2; Counter++) 
  {
    Cap++;                         /* next cap */
    3950:	c1 e5       	ldi	r28, 0x51	; 81
    3952:	d1 e0       	ldi	r29, 0x01	; 1
      MaxCap = Cap;
    }
  }

  /* display pinout */
  LCD_ProbeNumber(MaxCap->A);      /* display pin #1 */
    3954:	88 81       	ld	r24, Y
    3956:	0e 94 05 10 	call	0x200a	; 0x200a <LCD_ProbeNumber>
  LCD_EEString(Cap_str);           /* display capacitor symbol */
    395a:	80 ee       	ldi	r24, 0xE0	; 224
    395c:	90 e0       	ldi	r25, 0x00	; 0
    395e:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
  LCD_ProbeNumber(MaxCap->B);      /* display pin #2 */
    3962:	89 81       	ldd	r24, Y+1	; 0x01
    3964:	0e 94 05 10 	call	0x200a	; 0x200a <LCD_ProbeNumber>

  /* show capacitance */
  LCD_NextLine();                  /* move to next line */
    3968:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <LCD_NextLine>
  DisplayValue(MaxCap->Value, MaxCap->Scale, 'F');
    396c:	6b 81       	ldd	r22, Y+3	; 0x03
    396e:	7c 81       	ldd	r23, Y+4	; 0x04
    3970:	8d 81       	ldd	r24, Y+5	; 0x05
    3972:	9e 81       	ldd	r25, Y+6	; 0x06
    3974:	26 e4       	ldi	r18, 0x46	; 70
    3976:	4a 81       	ldd	r20, Y+2	; 0x02
    3978:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>

  #ifdef SW_ESR
  /* show ESR */
  ESR = MeasureESR(MaxCap);        /* measure ESR */
    397c:	ce 01       	movw	r24, r28
    397e:	0e 94 00 0a 	call	0x1400	; 0x1400 <MeasureESR>
    3982:	ec 01       	movw	r28, r24
  if (ESR > 0)                     /* if successfull */
    3984:	89 2b       	or	r24, r25
    3986:	49 f0       	breq	.+18     	; 0x399a <Show_Capacitor+0x9e>
  {
//    LCD_NextLine_EEString_Space(ESR_str);    /* display: ESR */
    LCD_Space();
    3988:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
    DisplayValue(ESR, -2, LCD_CHAR_OMEGA);   /* display ESR */
    398c:	be 01       	movw	r22, r28
    398e:	80 e0       	ldi	r24, 0x00	; 0
    3990:	90 e0       	ldi	r25, 0x00	; 0
    3992:	24 e0       	ldi	r18, 0x04	; 4
    3994:	4e ef       	ldi	r20, 0xFE	; 254
    3996:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
  }
  #endif
}
    399a:	df 91       	pop	r29
    399c:	cf 91       	pop	r28
    399e:	1f 91       	pop	r17
    39a0:	0f 91       	pop	r16
    39a2:	ef 90       	pop	r14
    39a4:	08 95       	ret

000039a6 <Show_Diode_Cap>:
 */

void Show_Diode_Cap(Diode_Type *Diode)
{
  /* sanity check */
  if (Diode == NULL) return;
    39a6:	00 97       	sbiw	r24, 0x00	; 0
    39a8:	81 f0       	breq	.+32     	; 0x39ca <Show_Diode_Cap+0x24>
    39aa:	fc 01       	movw	r30, r24

  /* get capacitance (opposite of flow direction) */
  MeasureCap(Diode->C, Diode->A, 0);
    39ac:	40 e0       	ldi	r20, 0x00	; 0
    39ae:	60 81       	ld	r22, Z
    39b0:	81 81       	ldd	r24, Z+1	; 0x01
    39b2:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <MeasureCap>

  /* and show capacitance */
  DisplayValue(Caps[0].Value, Caps[0].Scale, 'F');
    39b6:	eb e3       	ldi	r30, 0x3B	; 59
    39b8:	f1 e0       	ldi	r31, 0x01	; 1
    39ba:	63 81       	ldd	r22, Z+3	; 0x03
    39bc:	74 81       	ldd	r23, Z+4	; 0x04
    39be:	85 81       	ldd	r24, Z+5	; 0x05
    39c0:	96 81       	ldd	r25, Z+6	; 0x06
    39c2:	26 e4       	ldi	r18, 0x46	; 70
    39c4:	42 81       	ldd	r20, Z+2	; 0x02
    39c6:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
    39ca:	08 95       	ret

000039cc <Show_Diode>:
/*
 *  show diode
 */

void Show_Diode(void)
{
    39cc:	bf 92       	push	r11
    39ce:	cf 92       	push	r12
    39d0:	df 92       	push	r13
    39d2:	ef 92       	push	r14
    39d4:	ff 92       	push	r15
    39d6:	0f 93       	push	r16
    39d8:	1f 93       	push	r17
    39da:	cf 93       	push	r28
    39dc:	df 93       	push	r29

  /*
   *  figure out which diodes to display
   */

  if (Check.Diodes == 1)           /* single diode */
    39de:	80 91 0c 01 	lds	r24, 0x010C
    39e2:	81 30       	cpi	r24, 0x01	; 1
    39e4:	a1 f4       	brne	.+40     	; 0x3a0e <Show_Diode+0x42>
  {
    C = D1->C;                     /* make anode first pin */
    39e6:	00 91 5d 01 	lds	r16, 0x015D
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
  uint8_t           R_Pin2 = 5;    /* B_E resistor's pin #2 */
    39ea:	0f 2e       	mov	r0, r31
    39ec:	f5 e0       	ldi	r31, 0x05	; 5
    39ee:	bf 2e       	mov	r11, r31
    39f0:	f0 2d       	mov	r31, r0
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
    39f2:	0f 2e       	mov	r0, r31
    39f4:	f5 e0       	ldi	r31, 0x05	; 5
    39f6:	df 2e       	mov	r13, r31
    39f8:	f0 2d       	mov	r31, r0
void Show_Diode(void)
{
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
    39fa:	15 e0       	ldi	r17, 0x05	; 5
 */

void Show_Diode(void)
{
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
    39fc:	c0 e0       	ldi	r28, 0x00	; 0
    39fe:	d0 e0       	ldi	r29, 0x00	; 0
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
  uint8_t           R_Pin2 = 5;    /* B_E resistor's pin #2 */
  uint16_t          I_leak;        /* leakage current */

  D1 = &Diodes[0];                 /* pointer to first diode */
    3a00:	0f 2e       	mov	r0, r31
    3a02:	fc e5       	ldi	r31, 0x5C	; 92
    3a04:	ef 2e       	mov	r14, r31
    3a06:	f1 e0       	ldi	r31, 0x01	; 1
    3a08:	ff 2e       	mov	r15, r31
    3a0a:	f0 2d       	mov	r31, r0
    3a0c:	67 c1       	rjmp	.+718    	; 0x3cdc <Show_Diode+0x310>

  if (Check.Diodes == 1)           /* single diode */
  {
    C = D1->C;                     /* make anode first pin */
  }
  else if (Check.Diodes == 2)      /* two diodes */
    3a0e:	82 30       	cpi	r24, 0x02	; 2
    3a10:	31 f5       	brne	.+76     	; 0x3a5e <Show_Diode+0x92>
  {
    D2 = D1;
    D2++;                          /* pointer to second diode */

    if (D1->A == D2->A)            /* common anode */
    3a12:	ec e5       	ldi	r30, 0x5C	; 92
    3a14:	f1 e0       	ldi	r31, 0x01	; 1
    3a16:	10 81       	ld	r17, Z
    3a18:	b6 80       	ldd	r11, Z+6	; 0x06
    3a1a:	1b 11       	cpse	r17, r11
    3a1c:	06 c0       	rjmp	.+12     	; 0x3a2a <Show_Diode+0x5e>
    {
      A = D1->A;                   /* save common anode */

      /* possible PNP BJT with low value B-E resistor and flyback diode */
      R_Pin1 = D1->C;
    3a1e:	d1 80       	ldd	r13, Z+1	; 0x01
      R_Pin2 = D2->C;
    3a20:	b7 80       	ldd	r11, Z+7	; 0x07
{
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
    3a22:	05 e0       	ldi	r16, 0x05	; 5

void Show_Diode(void)
{
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
    3a24:	cc 24       	eor	r12, r12
    3a26:	c3 94       	inc	r12
    3a28:	86 c0       	rjmp	.+268    	; 0x3b36 <Show_Diode+0x16a>

      /* possible PNP BJT with low value B-E resistor and flyback diode */
      R_Pin1 = D1->C;
      R_Pin2 = D2->C;
    }
    else if (D1->C == D2->C)       /* common cathode */
    3a2a:	ec e5       	ldi	r30, 0x5C	; 92
    3a2c:	f1 e0       	ldi	r31, 0x01	; 1
    3a2e:	81 81       	ldd	r24, Z+1	; 0x01
    3a30:	07 81       	ldd	r16, Z+7	; 0x07
    3a32:	80 17       	cp	r24, r16
    3a34:	09 f4       	brne	.+2      	; 0x3a38 <Show_Diode+0x6c>
    3a36:	35 c1       	rjmp	.+618    	; 0x3ca2 <Show_Diode+0x2d6>

      /* possible NPN BJT with low value B-E resistor and flyback diode */
      R_Pin1 = D1->A;
      R_Pin2 = D2->A;
    }
    else if ((D1->A == D2->C) && (D1->C == D2->A))   /* anti-parallel */
    3a38:	10 13       	cpse	r17, r16
    3a3a:	3e c1       	rjmp	.+636    	; 0x3cb8 <Show_Diode+0x2ec>
    3a3c:	b8 16       	cp	r11, r24
    3a3e:	09 f4       	brne	.+2      	; 0x3a42 <Show_Diode+0x76>
    3a40:	70 c0       	rjmp	.+224    	; 0x3b22 <Show_Diode+0x156>
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
  uint8_t           R_Pin2 = 5;    /* B_E resistor's pin #2 */
    3a42:	0f 2e       	mov	r0, r31
    3a44:	f5 e0       	ldi	r31, 0x05	; 5
    3a46:	bf 2e       	mov	r11, r31
    3a48:	f0 2d       	mov	r31, r0
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
    3a4a:	0f 2e       	mov	r0, r31
    3a4c:	f5 e0       	ldi	r31, 0x05	; 5
    3a4e:	df 2e       	mov	r13, r31
    3a50:	f0 2d       	mov	r31, r0
{
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
    3a52:	05 e0       	ldi	r16, 0x05	; 5
void Show_Diode(void)
{
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
    3a54:	15 e0       	ldi	r17, 0x05	; 5
    C = D1->C;                     /* make anode first pin */
  }
  else if (Check.Diodes == 2)      /* two diodes */
  {
    D2 = D1;
    D2++;                          /* pointer to second diode */
    3a56:	c2 e6       	ldi	r28, 0x62	; 98
    3a58:	d1 e0       	ldi	r29, 0x01	; 1
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
  uint8_t           R_Pin2 = 5;    /* B_E resistor's pin #2 */
  uint16_t          I_leak;        /* leakage current */

  D1 = &Diodes[0];                 /* pointer to first diode */
    3a5a:	7f 01       	movw	r14, r30
    3a5c:	3f c1       	rjmp	.+638    	; 0x3cdc <Show_Diode+0x310>
      A = D1->A;                   /* anode and cathode */
      C = A;                       /* are the same */
      CapFlag = 0;                 /* skip capacitance */
    }
  }
  else if (Check.Diodes == 3)      /* three diodes */
    3a5e:	83 30       	cpi	r24, 0x03	; 3
    3a60:	09 f0       	breq	.+2      	; 0x3a64 <Show_Diode+0x98>
    3a62:	53 c0       	rjmp	.+166    	; 0x3b0a <Show_Diode+0x13e>
    3a64:	20 e0       	ldi	r18, 0x00	; 0
    3a66:	cc e5       	ldi	r28, 0x5C	; 92
    3a68:	d1 e0       	ldi	r29, 0x01	; 1
     *  - Only once the cathode of diode #1 matches the anode of diode #2.
     */

    for (n = 0; n <= 2; n++)       /* loop for first diode */
    {
      D1 = &Diodes[n];             /* get pointer of first diode */
    3a6a:	f1 2c       	mov	r15, r1
    3a6c:	50 e0       	ldi	r21, 0x00	; 0
    3a6e:	62 2f       	mov	r22, r18
    3a70:	70 e0       	ldi	r23, 0x00	; 0
    3a72:	fe 01       	movw	r30, r28
    3a74:	8f 2d       	mov	r24, r15
    3a76:	95 2f       	mov	r25, r21
      {
        D2 = &Diodes[m];           /* get pointer of second diode */

        if (n != m)                /* don't check same diode :-) */
        {
          if (D1->C == D2->A)      /* got match */
    3a78:	db 01       	movw	r26, r22
    3a7a:	aa 0f       	add	r26, r26
    3a7c:	bb 1f       	adc	r27, r27
    3a7e:	a6 0f       	add	r26, r22
    3a80:	b7 1f       	adc	r27, r23
    3a82:	aa 0f       	add	r26, r26
    3a84:	bb 1f       	adc	r27, r27
    3a86:	a3 5a       	subi	r26, 0xA3	; 163
    3a88:	be 4f       	sbci	r27, 0xFE	; 254
    {
      D1 = &Diodes[n];             /* get pointer of first diode */

      for (m = 0; m <= 2; m++)     /* loop for second diode */
      {
        D2 = &Diodes[m];           /* get pointer of second diode */
    3a8a:	8c 01       	movw	r16, r24

        if (n != m)                /* don't check same diode :-) */
    3a8c:	28 17       	cp	r18, r24
    3a8e:	29 f0       	breq	.+10     	; 0x3a9a <Show_Diode+0xce>
        {
          if (D1->C == D2->A)      /* got match */
    3a90:	4c 91       	ld	r20, X
    3a92:	30 81       	ld	r19, Z
    3a94:	43 13       	cpse	r20, r19
    3a96:	02 c0       	rjmp	.+4      	; 0x3a9c <Show_Diode+0xd0>
    3a98:	0a c0       	rjmp	.+20     	; 0x3aae <Show_Diode+0xe2>
    3a9a:	28 2f       	mov	r18, r24
    3a9c:	01 96       	adiw	r24, 0x01	; 1
    3a9e:	36 96       	adiw	r30, 0x06	; 6

    for (n = 0; n <= 2; n++)       /* loop for first diode */
    {
      D1 = &Diodes[n];             /* get pointer of first diode */

      for (m = 0; m <= 2; m++)     /* loop for second diode */
    3aa0:	83 30       	cpi	r24, 0x03	; 3
    3aa2:	91 05       	cpc	r25, r1
    3aa4:	91 f7       	brne	.-28     	; 0x3a8a <Show_Diode+0xbe>
     *  Two diodes in series are detected as a virtual third diode:
     *  - Check for any possible way the 2 diodes could be connected in series.
     *  - Only once the cathode of diode #1 matches the anode of diode #2.
     */

    for (n = 0; n <= 2; n++)       /* loop for first diode */
    3aa6:	2f 5f       	subi	r18, 0xFF	; 255
    3aa8:	23 30       	cpi	r18, 0x03	; 3
    3aaa:	08 f3       	brcs	.-62     	; 0x3a6e <Show_Diode+0xa2>
    3aac:	01 c0       	rjmp	.+2      	; 0x3ab0 <Show_Diode+0xe4>
    3aae:	26 e0       	ldi	r18, 0x06	; 6
    {
      D1 = &Diodes[n];             /* get pointer of first diode */
    3ab0:	7b 01       	movw	r14, r22
    3ab2:	ee 0c       	add	r14, r14
    3ab4:	ff 1c       	adc	r15, r15
    3ab6:	e6 0e       	add	r14, r22
    3ab8:	f7 1e       	adc	r15, r23
    3aba:	c7 01       	movw	r24, r14
    3abc:	88 0f       	add	r24, r24
    3abe:	99 1f       	adc	r25, r25
    3ac0:	ac 01       	movw	r20, r24
    3ac2:	44 5a       	subi	r20, 0xA4	; 164
    3ac4:	5e 4f       	sbci	r21, 0xFE	; 254
    3ac6:	7a 01       	movw	r14, r20

      for (m = 0; m <= 2; m++)     /* loop for second diode */
      {
        D2 = &Diodes[m];           /* get pointer of second diode */
    3ac8:	e8 01       	movw	r28, r16
    3aca:	cc 0f       	add	r28, r28
    3acc:	dd 1f       	adc	r29, r29
    3ace:	c0 0f       	add	r28, r16
    3ad0:	d1 1f       	adc	r29, r17
    3ad2:	cc 0f       	add	r28, r28
    3ad4:	dd 1f       	adc	r29, r29
    3ad6:	c4 5a       	subi	r28, 0xA4	; 164
    3ad8:	de 4f       	sbci	r29, 0xFE	; 254
          }
        }
      }
    }

    if (n < 5) D2 = NULL;          /* no match found */
    3ada:	25 30       	cpi	r18, 0x05	; 5
    3adc:	10 f4       	brcc	.+4      	; 0x3ae2 <Show_Diode+0x116>
    3ade:	c0 e0       	ldi	r28, 0x00	; 0
    3ae0:	d0 e0       	ldi	r29, 0x00	; 0
    C = D1->C;                     /* cathode of first diode */
    3ae2:	fb 01       	movw	r30, r22
    3ae4:	ee 0f       	add	r30, r30
    3ae6:	ff 1f       	adc	r31, r31
    3ae8:	e6 0f       	add	r30, r22
    3aea:	f7 1f       	adc	r31, r23
    3aec:	ee 0f       	add	r30, r30
    3aee:	ff 1f       	adc	r31, r31
    3af0:	e4 5a       	subi	r30, 0xA4	; 164
    3af2:	fe 4f       	sbci	r31, 0xFE	; 254
    3af4:	01 81       	ldd	r16, Z+1	; 0x01
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
  uint8_t           R_Pin2 = 5;    /* B_E resistor's pin #2 */
    3af6:	0f 2e       	mov	r0, r31
    3af8:	f5 e0       	ldi	r31, 0x05	; 5
    3afa:	bf 2e       	mov	r11, r31
    3afc:	f0 2d       	mov	r31, r0
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
    3afe:	0f 2e       	mov	r0, r31
    3b00:	f5 e0       	ldi	r31, 0x05	; 5
    3b02:	df 2e       	mov	r13, r31
    3b04:	f0 2d       	mov	r31, r0
      }
    }

    if (n < 5) D2 = NULL;          /* no match found */
    C = D1->C;                     /* cathode of first diode */
    A = 3;                         /* in series mode */
    3b06:	13 e0       	ldi	r17, 0x03	; 3
    3b08:	e9 c0       	rjmp	.+466    	; 0x3cdc <Show_Diode+0x310>
  }
  else                             /* too much diodes */
  {
    LCD_EEString(Diode_AC_str);         /* display: -|>|- */
    3b0a:	8c ed       	ldi	r24, 0xDC	; 220
    3b0c:	90 e0       	ldi	r25, 0x00	; 0
    3b0e:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
    LCD_Space();                        /* display space */
    3b12:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
    LCD_Char(Check.Diodes + '0');       /* display number of diodes found */
    3b16:	80 91 0c 01 	lds	r24, 0x010C
    3b1a:	80 5d       	subi	r24, 0xD0	; 208
    3b1c:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    return;
    3b20:	36 c1       	rjmp	.+620    	; 0x3d8e <Show_Diode+0x3c2>
      R_Pin2 = D2->A;
    }
    else if ((D1->A == D2->C) && (D1->C == D2->A))   /* anti-parallel */
    {
      A = D1->A;                   /* anode and cathode */
      C = A;                       /* are the same */
    3b22:	01 2f       	mov	r16, r17
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
  uint8_t           R_Pin2 = 5;    /* B_E resistor's pin #2 */
    3b24:	0f 2e       	mov	r0, r31
    3b26:	f5 e0       	ldi	r31, 0x05	; 5
    3b28:	bf 2e       	mov	r11, r31
    3b2a:	f0 2d       	mov	r31, r0
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
    3b2c:	0f 2e       	mov	r0, r31
    3b2e:	f5 e0       	ldi	r31, 0x05	; 5
    3b30:	df 2e       	mov	r13, r31
    3b32:	f0 2d       	mov	r31, r0
    }
    else if ((D1->A == D2->C) && (D1->C == D2->A))   /* anti-parallel */
    {
      A = D1->A;                   /* anode and cathode */
      C = A;                       /* are the same */
      CapFlag = 0;                 /* skip capacitance */
    3b34:	c1 2c       	mov	r12, r1
  /*
   *  display pins 
   */

  /* first Diode */
  if (A < 3) LCD_ProbeNumber(D1->C);       /* common anode */
    3b36:	13 30       	cpi	r17, 0x03	; 3
    3b38:	a0 f4       	brcc	.+40     	; 0x3b62 <Show_Diode+0x196>
    3b3a:	80 91 5d 01 	lds	r24, 0x015D
    3b3e:	0e 94 05 10 	call	0x200a	; 0x200a <LCD_ProbeNumber>
  else LCD_ProbeNumber(D1->A);             /* common cathode */

  if (A < 3) LCD_EEString(Diode_CA_str);   /* common anode */
    3b42:	88 ed       	ldi	r24, 0xD8	; 216
    3b44:	90 e0       	ldi	r25, 0x00	; 0
    3b46:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
  else LCD_EEString(Diode_AC_str);         /* common cathode */

  if (A < 3) LCD_ProbeNumber(A);           /* common anode */
    3b4a:	81 2f       	mov	r24, r17
    3b4c:	0e 94 05 10 	call	0x200a	; 0x200a <LCD_ProbeNumber>
    3b50:	c2 e6       	ldi	r28, 0x62	; 98
    3b52:	d1 e0       	ldi	r29, 0x01	; 1
    3b54:	0f 2e       	mov	r0, r31
    3b56:	fc e5       	ldi	r31, 0x5C	; 92
    3b58:	ef 2e       	mov	r14, r31
    3b5a:	f1 e0       	ldi	r31, 0x01	; 1
    3b5c:	ff 2e       	mov	r15, r31
    3b5e:	f0 2d       	mov	r31, r0
    3b60:	13 c0       	rjmp	.+38     	; 0x3b88 <Show_Diode+0x1bc>
    3b62:	c2 e6       	ldi	r28, 0x62	; 98
    3b64:	d1 e0       	ldi	r29, 0x01	; 1
    3b66:	0f 2e       	mov	r0, r31
    3b68:	fc e5       	ldi	r31, 0x5C	; 92
    3b6a:	ef 2e       	mov	r14, r31
    3b6c:	f1 e0       	ldi	r31, 0x01	; 1
    3b6e:	ff 2e       	mov	r15, r31
    3b70:	f0 2d       	mov	r31, r0
   *  display pins 
   */

  /* first Diode */
  if (A < 3) LCD_ProbeNumber(D1->C);       /* common anode */
  else LCD_ProbeNumber(D1->A);             /* common cathode */
    3b72:	f7 01       	movw	r30, r14
    3b74:	80 81       	ld	r24, Z
    3b76:	0e 94 05 10 	call	0x200a	; 0x200a <LCD_ProbeNumber>

  if (A < 3) LCD_EEString(Diode_CA_str);   /* common anode */
  else LCD_EEString(Diode_AC_str);         /* common cathode */
    3b7a:	8c ed       	ldi	r24, 0xDC	; 220
    3b7c:	90 e0       	ldi	r25, 0x00	; 0
    3b7e:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>

  if (A < 3) LCD_ProbeNumber(A);           /* common anode */
  else LCD_ProbeNumber(C);                 /* common cathode */
    3b82:	80 2f       	mov	r24, r16
    3b84:	0e 94 05 10 	call	0x200a	; 0x200a <LCD_ProbeNumber>

  if (D2)           /* second diode */
    3b88:	20 97       	sbiw	r28, 0x00	; 0
    3b8a:	09 f4       	brne	.+2      	; 0x3b8e <Show_Diode+0x1c2>
    3b8c:	ce c0       	rjmp	.+412    	; 0x3d2a <Show_Diode+0x35e>
  {
    if (A <= 3) LCD_EEString(Diode_AC_str);  /* common anode or in series */
    3b8e:	14 30       	cpi	r17, 0x04	; 4
    3b90:	38 f4       	brcc	.+14     	; 0x3ba0 <Show_Diode+0x1d4>
    3b92:	8c ed       	ldi	r24, 0xDC	; 220
    3b94:	90 e0       	ldi	r25, 0x00	; 0
    3b96:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
    else LCD_EEString(Diode_CA_str);         /* common cathode */

    if (A == C) LCD_ProbeNumber(D2->A);           /* anti parallel */
    3b9a:	10 13       	cpse	r17, r16
    3b9c:	0b c0       	rjmp	.+22     	; 0x3bb4 <Show_Diode+0x1e8>
    3b9e:	06 c0       	rjmp	.+12     	; 0x3bac <Show_Diode+0x1e0>
  else LCD_ProbeNumber(C);                 /* common cathode */

  if (D2)           /* second diode */
  {
    if (A <= 3) LCD_EEString(Diode_AC_str);  /* common anode or in series */
    else LCD_EEString(Diode_CA_str);         /* common cathode */
    3ba0:	88 ed       	ldi	r24, 0xD8	; 216
    3ba2:	90 e0       	ldi	r25, 0x00	; 0
    3ba4:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>

    if (A == C) LCD_ProbeNumber(D2->A);           /* anti parallel */
    3ba8:	10 13       	cpse	r17, r16
    3baa:	08 c0       	rjmp	.+16     	; 0x3bbc <Show_Diode+0x1f0>
    3bac:	88 81       	ld	r24, Y
    3bae:	0e 94 05 10 	call	0x200a	; 0x200a <LCD_ProbeNumber>
    3bb2:	a7 c0       	rjmp	.+334    	; 0x3d02 <Show_Diode+0x336>
    else if (A <= 3) LCD_ProbeNumber(D2->C);      /* common anode or in series */
    3bb4:	89 81       	ldd	r24, Y+1	; 0x01
    3bb6:	0e 94 05 10 	call	0x200a	; 0x200a <LCD_ProbeNumber>
    3bba:	a3 c0       	rjmp	.+326    	; 0x3d02 <Show_Diode+0x336>
    else LCD_ProbeNumber(D2->A);                  /* common cathode */
    3bbc:	88 81       	ld	r24, Y
    3bbe:	0e 94 05 10 	call	0x200a	; 0x200a <LCD_ProbeNumber>
    3bc2:	9f c0       	rjmp	.+318    	; 0x3d02 <Show_Diode+0x336>
  if (R_Pin1 < 5)                  /* possible BJT */
  {
    if (CheckSingleResistor(R_Pin1, R_Pin2) == 1) /* found B-E resistor */
    {
      /* show: PNP/NPN? */
      LCD_Space();
    3bc4:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
      if (A < 3) LCD_EEString(PNP_str);
    3bc8:	13 30       	cpi	r17, 0x03	; 3
    3bca:	28 f4       	brcc	.+10     	; 0x3bd6 <Show_Diode+0x20a>
    3bcc:	82 eb       	ldi	r24, 0xB2	; 178
    3bce:	91 e0       	ldi	r25, 0x01	; 1
    3bd0:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
    3bd4:	04 c0       	rjmp	.+8      	; 0x3bde <Show_Diode+0x212>
      else LCD_EEString(NPN_str);
    3bd6:	86 eb       	ldi	r24, 0xB6	; 182
    3bd8:	91 e0       	ldi	r25, 0x01	; 1
    3bda:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
      LCD_Char('?');
    3bde:	8f e3       	ldi	r24, 0x3F	; 63
    3be0:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>

      LCD_NextLine();                     /* go to line #2 */
    3be4:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <LCD_NextLine>
      R_Pin1 += '1';                      /* convert to character */
      R_Pin2 += '1';
    3be8:	61 e3       	ldi	r22, 0x31	; 49
    3bea:	6b 0d       	add	r22, r11
      Show_SingleResistor(R_Pin1, R_Pin2);   /* show resistor */
    3bec:	81 e3       	ldi	r24, 0x31	; 49
    3bee:	8d 0d       	add	r24, r13
    3bf0:	0e 94 90 1b 	call	0x3720	; 0x3720 <Show_SingleResistor>
   *  - reverse leakage current (for single diodes)
   *  - capacitance (not for anti-parallel diodes)
   */

  /* display Uf */
  LCD_NextLine_EEString_Space(Vf_str);  /* display: Vf */
    3bf4:	8a e9       	ldi	r24, 0x9A	; 154
    3bf6:	91 e0       	ldi	r25, 0x01	; 1
    3bf8:	0e 94 28 10 	call	0x2050	; 0x2050 <LCD_NextLine_EEString_Space>

  /* first diode */
  DisplayValue(D1->V_f, -3, 'V');
    3bfc:	f7 01       	movw	r30, r14
    3bfe:	62 81       	ldd	r22, Z+2	; 0x02
    3c00:	73 81       	ldd	r23, Z+3	; 0x03
    3c02:	80 e0       	ldi	r24, 0x00	; 0
    3c04:	90 e0       	ldi	r25, 0x00	; 0
    3c06:	26 e5       	ldi	r18, 0x56	; 86
    3c08:	4d ef       	ldi	r20, 0xFD	; 253
    3c0a:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>

  LCD_Space();
    3c0e:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>

  /* display low current Uf and reverse leakage current for a single diode */
  if (D2 == NULL)                       /* single diode */
    3c12:	20 97       	sbiw	r28, 0x00	; 0
    3c14:	69 f5       	brne	.+90     	; 0x3c70 <Show_Diode+0x2a4>

      LCD_NextLine();                     /* go to line #2 */
      R_Pin1 += '1';                      /* convert to character */
      R_Pin2 += '1';
      Show_SingleResistor(R_Pin1, R_Pin2);   /* show resistor */
      CapFlag = 0;                        /* skip capacitance */
    3c16:	c1 2c       	mov	r12, r1

  /* display low current Uf and reverse leakage current for a single diode */
  if (D2 == NULL)                       /* single diode */
  {
    /* display low current Uf if it's quite low (Ge/Schottky diode) */
    if (D1->V_f2 < 250)
    3c18:	f7 01       	movw	r30, r14
    3c1a:	84 81       	ldd	r24, Z+4	; 0x04
    3c1c:	95 81       	ldd	r25, Z+5	; 0x05
    3c1e:	8a 3f       	cpi	r24, 0xFA	; 250
    3c20:	91 05       	cpc	r25, r1
    3c22:	78 f4       	brcc	.+30     	; 0x3c42 <Show_Diode+0x276>
    {
      LCD_Char('(');
    3c24:	88 e2       	ldi	r24, 0x28	; 40
    3c26:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
      DisplayValue(D1->V_f2, 0, 0);
    3c2a:	f7 01       	movw	r30, r14
    3c2c:	64 81       	ldd	r22, Z+4	; 0x04
    3c2e:	75 81       	ldd	r23, Z+5	; 0x05
    3c30:	80 e0       	ldi	r24, 0x00	; 0
    3c32:	90 e0       	ldi	r25, 0x00	; 0
    3c34:	20 e0       	ldi	r18, 0x00	; 0
    3c36:	40 e0       	ldi	r20, 0x00	; 0
    3c38:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
      LCD_Char(')');
    3c3c:	89 e2       	ldi	r24, 0x29	; 41
    3c3e:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    }

    /* reverse leakage current */
    UpdateProbes(D1->C, D1->A, 0);      /* reverse diode */
    3c42:	40 e0       	ldi	r20, 0x00	; 0
    3c44:	f7 01       	movw	r30, r14
    3c46:	60 81       	ld	r22, Z
    3c48:	81 81       	ldd	r24, Z+1	; 0x01
    3c4a:	0e 94 04 23 	call	0x4608	; 0x4608 <UpdateProbes>
    I_leak = GetLeakageCurrent();       /* get current (in A) */
    3c4e:	0e 94 12 2b 	call	0x5624	; 0x5624 <GetLeakageCurrent>
    3c52:	8c 01       	movw	r16, r24
    if (I_leak > 0)                     /* show if not zero */
    3c54:	89 2b       	or	r24, r25
    3c56:	a9 f0       	breq	.+42     	; 0x3c82 <Show_Diode+0x2b6>
    {
      LCD_NextLine_EEString_Space(I_R_str);  /* display: I_R */
    3c58:	80 e9       	ldi	r24, 0x90	; 144
    3c5a:	91 e0       	ldi	r25, 0x01	; 1
    3c5c:	0e 94 28 10 	call	0x2050	; 0x2050 <LCD_NextLine_EEString_Space>
      DisplayValue(I_leak, -6, 'A');    /* display current */
    3c60:	b8 01       	movw	r22, r16
    3c62:	80 e0       	ldi	r24, 0x00	; 0
    3c64:	90 e0       	ldi	r25, 0x00	; 0
    3c66:	21 e4       	ldi	r18, 0x41	; 65
    3c68:	4a ef       	ldi	r20, 0xFA	; 250
    3c6a:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
    3c6e:	09 c0       	rjmp	.+18     	; 0x3c82 <Show_Diode+0x2b6>

      LCD_NextLine();                     /* go to line #2 */
      R_Pin1 += '1';                      /* convert to character */
      R_Pin2 += '1';
      Show_SingleResistor(R_Pin1, R_Pin2);   /* show resistor */
      CapFlag = 0;                        /* skip capacitance */
    3c70:	c1 2c       	mov	r12, r1
    }
  }
  else                                  /* two diodes */
  {
    /* show Uf of second diode */
    DisplayValue(D2->V_f, -3, 'V');
    3c72:	6a 81       	ldd	r22, Y+2	; 0x02
    3c74:	7b 81       	ldd	r23, Y+3	; 0x03
    3c76:	80 e0       	ldi	r24, 0x00	; 0
    3c78:	90 e0       	ldi	r25, 0x00	; 0
    3c7a:	26 e5       	ldi	r18, 0x56	; 86
    3c7c:	4d ef       	ldi	r20, 0xFD	; 253
    3c7e:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
  }

  /* display capacitance */
  if (CapFlag == 1)                     /* if requested */ 
    3c82:	f1 e0       	ldi	r31, 0x01	; 1
    3c84:	cf 12       	cpse	r12, r31
    3c86:	83 c0       	rjmp	.+262    	; 0x3d8e <Show_Diode+0x3c2>
  {
    LCD_NextLine_EEString_Space(DiodeCap_str);  /* display: C */
    3c88:	88 e9       	ldi	r24, 0x98	; 152
    3c8a:	91 e0       	ldi	r25, 0x01	; 1
    3c8c:	0e 94 28 10 	call	0x2050	; 0x2050 <LCD_NextLine_EEString_Space>
    Show_Diode_Cap(D1);                 /* first diode */
    3c90:	c7 01       	movw	r24, r14
    3c92:	0e 94 d3 1c 	call	0x39a6	; 0x39a6 <Show_Diode_Cap>
    LCD_Space();
    3c96:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
    Show_Diode_Cap(D2);                 /* second diode (optional) */
    3c9a:	ce 01       	movw	r24, r28
    3c9c:	0e 94 d3 1c 	call	0x39a6	; 0x39a6 <Show_Diode_Cap>
    3ca0:	76 c0       	rjmp	.+236    	; 0x3d8e <Show_Diode+0x3c2>
    else if (D1->C == D2->C)       /* common cathode */
    {
      C = D1->C;                   /* save common cathode */

      /* possible NPN BJT with low value B-E resistor and flyback diode */
      R_Pin1 = D1->A;
    3ca2:	d1 2e       	mov	r13, r17
void Show_Diode(void)
{
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
    3ca4:	15 e0       	ldi	r17, 0x05	; 5
    C = D1->C;                     /* make anode first pin */
  }
  else if (Check.Diodes == 2)      /* two diodes */
  {
    D2 = D1;
    D2++;                          /* pointer to second diode */
    3ca6:	c2 e6       	ldi	r28, 0x62	; 98
    3ca8:	d1 e0       	ldi	r29, 0x01	; 1
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
  uint8_t           R_Pin2 = 5;    /* B_E resistor's pin #2 */
  uint16_t          I_leak;        /* leakage current */

  D1 = &Diodes[0];                 /* pointer to first diode */
    3caa:	0f 2e       	mov	r0, r31
    3cac:	fc e5       	ldi	r31, 0x5C	; 92
    3cae:	ef 2e       	mov	r14, r31
    3cb0:	f1 e0       	ldi	r31, 0x01	; 1
    3cb2:	ff 2e       	mov	r15, r31
    3cb4:	f0 2d       	mov	r31, r0
    3cb6:	12 c0       	rjmp	.+36     	; 0x3cdc <Show_Diode+0x310>
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
  uint8_t           R_Pin2 = 5;    /* B_E resistor's pin #2 */
    3cb8:	0f 2e       	mov	r0, r31
    3cba:	f5 e0       	ldi	r31, 0x05	; 5
    3cbc:	bf 2e       	mov	r11, r31
    3cbe:	f0 2d       	mov	r31, r0
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
    3cc0:	0f 2e       	mov	r0, r31
    3cc2:	f5 e0       	ldi	r31, 0x05	; 5
    3cc4:	df 2e       	mov	r13, r31
    3cc6:	f0 2d       	mov	r31, r0
{
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
  uint8_t           C = 5;         /* ID of common cothode */
    3cc8:	05 e0       	ldi	r16, 0x05	; 5
void Show_Diode(void)
{
  Diode_Type        *D1;           /* pointer to diode #1 */
  Diode_Type        *D2 = NULL;    /* pointer to diode #2 */
  uint8_t           CapFlag = 1;   /* flag for capacitance output */
  uint8_t           A = 5;         /* ID of common anode */
    3cca:	15 e0       	ldi	r17, 0x05	; 5
    C = D1->C;                     /* make anode first pin */
  }
  else if (Check.Diodes == 2)      /* two diodes */
  {
    D2 = D1;
    D2++;                          /* pointer to second diode */
    3ccc:	c2 e6       	ldi	r28, 0x62	; 98
    3cce:	d1 e0       	ldi	r29, 0x01	; 1
  uint8_t           C = 5;         /* ID of common cothode */
  uint8_t           R_Pin1 = 5;    /* B_E resistor's pin #1 */
  uint8_t           R_Pin2 = 5;    /* B_E resistor's pin #2 */
  uint16_t          I_leak;        /* leakage current */

  D1 = &Diodes[0];                 /* pointer to first diode */
    3cd0:	0f 2e       	mov	r0, r31
    3cd2:	fc e5       	ldi	r31, 0x5C	; 92
    3cd4:	ef 2e       	mov	r14, r31
    3cd6:	f1 e0       	ldi	r31, 0x01	; 1
    3cd8:	ff 2e       	mov	r15, r31
    3cda:	f0 2d       	mov	r31, r0
    3cdc:	cc 24       	eor	r12, r12
    3cde:	c3 94       	inc	r12
    3ce0:	48 cf       	rjmp	.-368    	; 0x3b72 <Show_Diode+0x1a6>
   *  - reverse leakage current (for single diodes)
   *  - capacitance (not for anti-parallel diodes)
   */

  /* display Uf */
  LCD_NextLine_EEString_Space(Vf_str);  /* display: Vf */
    3ce2:	8a e9       	ldi	r24, 0x9A	; 154
    3ce4:	91 e0       	ldi	r25, 0x01	; 1
    3ce6:	0e 94 28 10 	call	0x2050	; 0x2050 <LCD_NextLine_EEString_Space>

  /* first diode */
  DisplayValue(D1->V_f, -3, 'V');
    3cea:	f7 01       	movw	r30, r14
    3cec:	62 81       	ldd	r22, Z+2	; 0x02
    3cee:	73 81       	ldd	r23, Z+3	; 0x03
    3cf0:	80 e0       	ldi	r24, 0x00	; 0
    3cf2:	90 e0       	ldi	r25, 0x00	; 0
    3cf4:	26 e5       	ldi	r18, 0x56	; 86
    3cf6:	4d ef       	ldi	r20, 0xFD	; 253
    3cf8:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>

  LCD_Space();
    3cfc:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
    3d00:	b8 cf       	rjmp	.-144    	; 0x3c72 <Show_Diode+0x2a6>
    else if (A <= 3) LCD_ProbeNumber(D2->C);      /* common anode or in series */
    else LCD_ProbeNumber(D2->A);                  /* common cathode */
  }

  /* check for B-E resistor for possible BJT */
  if (R_Pin1 < 5)                  /* possible BJT */
    3d02:	f4 e0       	ldi	r31, 0x04	; 4
    3d04:	fd 15       	cp	r31, r13
    3d06:	68 f3       	brcs	.-38     	; 0x3ce2 <Show_Diode+0x316>
    3d08:	24 c0       	rjmp	.+72     	; 0x3d52 <Show_Diode+0x386>
   *  - reverse leakage current (for single diodes)
   *  - capacitance (not for anti-parallel diodes)
   */

  /* display Uf */
  LCD_NextLine_EEString_Space(Vf_str);  /* display: Vf */
    3d0a:	8a e9       	ldi	r24, 0x9A	; 154
    3d0c:	91 e0       	ldi	r25, 0x01	; 1
    3d0e:	0e 94 28 10 	call	0x2050	; 0x2050 <LCD_NextLine_EEString_Space>

  /* first diode */
  DisplayValue(D1->V_f, -3, 'V');
    3d12:	f7 01       	movw	r30, r14
    3d14:	62 81       	ldd	r22, Z+2	; 0x02
    3d16:	73 81       	ldd	r23, Z+3	; 0x03
    3d18:	80 e0       	ldi	r24, 0x00	; 0
    3d1a:	90 e0       	ldi	r25, 0x00	; 0
    3d1c:	26 e5       	ldi	r18, 0x56	; 86
    3d1e:	4d ef       	ldi	r20, 0xFD	; 253
    3d20:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>

  LCD_Space();
    3d24:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
    3d28:	77 cf       	rjmp	.-274    	; 0x3c18 <Show_Diode+0x24c>
    else if (A <= 3) LCD_ProbeNumber(D2->C);      /* common anode or in series */
    else LCD_ProbeNumber(D2->A);                  /* common cathode */
  }

  /* check for B-E resistor for possible BJT */
  if (R_Pin1 < 5)                  /* possible BJT */
    3d2a:	f4 e0       	ldi	r31, 0x04	; 4
    3d2c:	fd 15       	cp	r31, r13
    3d2e:	68 f3       	brcs	.-38     	; 0x3d0a <Show_Diode+0x33e>
    3d30:	27 c0       	rjmp	.+78     	; 0x3d80 <Show_Diode+0x3b4>
   *  - reverse leakage current (for single diodes)
   *  - capacitance (not for anti-parallel diodes)
   */

  /* display Uf */
  LCD_NextLine_EEString_Space(Vf_str);  /* display: Vf */
    3d32:	8a e9       	ldi	r24, 0x9A	; 154
    3d34:	91 e0       	ldi	r25, 0x01	; 1
    3d36:	0e 94 28 10 	call	0x2050	; 0x2050 <LCD_NextLine_EEString_Space>

  /* first diode */
  DisplayValue(D1->V_f, -3, 'V');
    3d3a:	f7 01       	movw	r30, r14
    3d3c:	62 81       	ldd	r22, Z+2	; 0x02
    3d3e:	73 81       	ldd	r23, Z+3	; 0x03
    3d40:	80 e0       	ldi	r24, 0x00	; 0
    3d42:	90 e0       	ldi	r25, 0x00	; 0
    3d44:	26 e5       	ldi	r18, 0x56	; 86
    3d46:	4d ef       	ldi	r20, 0xFD	; 253
    3d48:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>

  LCD_Space();
    3d4c:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
    3d50:	90 cf       	rjmp	.-224    	; 0x3c72 <Show_Diode+0x2a6>
  }

  /* check for B-E resistor for possible BJT */
  if (R_Pin1 < 5)                  /* possible BJT */
  {
    if (CheckSingleResistor(R_Pin1, R_Pin2) == 1) /* found B-E resistor */
    3d52:	6b 2d       	mov	r22, r11
    3d54:	8d 2d       	mov	r24, r13
    3d56:	0e 94 a5 29 	call	0x534a	; 0x534a <CheckSingleResistor>
    3d5a:	81 30       	cpi	r24, 0x01	; 1
    3d5c:	51 f7       	brne	.-44     	; 0x3d32 <Show_Diode+0x366>
    3d5e:	32 cf       	rjmp	.-412    	; 0x3bc4 <Show_Diode+0x1f8>
   *  - reverse leakage current (for single diodes)
   *  - capacitance (not for anti-parallel diodes)
   */

  /* display Uf */
  LCD_NextLine_EEString_Space(Vf_str);  /* display: Vf */
    3d60:	8a e9       	ldi	r24, 0x9A	; 154
    3d62:	91 e0       	ldi	r25, 0x01	; 1
    3d64:	0e 94 28 10 	call	0x2050	; 0x2050 <LCD_NextLine_EEString_Space>

  /* first diode */
  DisplayValue(D1->V_f, -3, 'V');
    3d68:	f7 01       	movw	r30, r14
    3d6a:	62 81       	ldd	r22, Z+2	; 0x02
    3d6c:	73 81       	ldd	r23, Z+3	; 0x03
    3d6e:	80 e0       	ldi	r24, 0x00	; 0
    3d70:	90 e0       	ldi	r25, 0x00	; 0
    3d72:	26 e5       	ldi	r18, 0x56	; 86
    3d74:	4d ef       	ldi	r20, 0xFD	; 253
    3d76:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>

  LCD_Space();
    3d7a:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
    3d7e:	4c cf       	rjmp	.-360    	; 0x3c18 <Show_Diode+0x24c>
  }

  /* check for B-E resistor for possible BJT */
  if (R_Pin1 < 5)                  /* possible BJT */
  {
    if (CheckSingleResistor(R_Pin1, R_Pin2) == 1) /* found B-E resistor */
    3d80:	6b 2d       	mov	r22, r11
    3d82:	8d 2d       	mov	r24, r13
    3d84:	0e 94 a5 29 	call	0x534a	; 0x534a <CheckSingleResistor>
    3d88:	81 30       	cpi	r24, 0x01	; 1
    3d8a:	51 f7       	brne	.-44     	; 0x3d60 <Show_Diode+0x394>
    3d8c:	1b cf       	rjmp	.-458    	; 0x3bc4 <Show_Diode+0x1f8>
    LCD_NextLine_EEString_Space(DiodeCap_str);  /* display: C */
    Show_Diode_Cap(D1);                 /* first diode */
    LCD_Space();
    Show_Diode_Cap(D2);                 /* second diode (optional) */
  }
}
    3d8e:	df 91       	pop	r29
    3d90:	cf 91       	pop	r28
    3d92:	1f 91       	pop	r17
    3d94:	0f 91       	pop	r16
    3d96:	ff 90       	pop	r15
    3d98:	ef 90       	pop	r14
    3d9a:	df 90       	pop	r13
    3d9c:	cf 90       	pop	r12
    3d9e:	bf 90       	pop	r11
    3da0:	08 95       	ret

00003da2 <Show_FlybackDiode>:
 *  show intrinsic/freewheeling diode of transistor
 */

void Show_FlybackDiode(void)
{
  LCD_Space();                /* display space */
    3da2:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>

  /* first pin */
  if (Check.Found == COMP_FET)     /* FET */
    3da6:	80 91 09 01 	lds	r24, 0x0109
    3daa:	86 31       	cpi	r24, 0x16	; 22
    3dac:	21 f4       	brne	.+8      	; 0x3db6 <Show_FlybackDiode+0x14>
  {
    LCD_Char('D');                 /* drain */
    3dae:	84 e4       	ldi	r24, 0x44	; 68
    3db0:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    3db4:	03 c0       	rjmp	.+6      	; 0x3dbc <Show_FlybackDiode+0x1a>
  }
  else                             /* BJT/IGBT */
  {
    LCD_Char('C');                 /* collector */
    3db6:	83 e4       	ldi	r24, 0x43	; 67
    3db8:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
  }

  /* diode */
  if (Check.Type & TYPE_N_CHANNEL)      /* n-channel/NPN */
    3dbc:	80 91 0a 01 	lds	r24, 0x010A
    3dc0:	80 ff       	sbrs	r24, 0
    3dc2:	04 c0       	rjmp	.+8      	; 0x3dcc <Show_FlybackDiode+0x2a>
    /*
     *  anode pointing to source/emitter
     *  cathode pointing to drain/collector
     */

    LCD_Char(LCD_CHAR_DIODE_CA);        /* |<| */
    3dc4:	82 e0       	ldi	r24, 0x02	; 2
    3dc6:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    3dca:	03 c0       	rjmp	.+6      	; 0x3dd2 <Show_FlybackDiode+0x30>
    /*
     *  anode pointing to drain/collector
     *  cathode pointing to source/emitter
     */

    LCD_Char(LCD_CHAR_DIODE_AC);        /* |>| */
    3dcc:	81 e0       	ldi	r24, 0x01	; 1
    3dce:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
  }

  /* second pin */
  if (Check.Found == COMP_FET)     /* FET */
    3dd2:	80 91 09 01 	lds	r24, 0x0109
    3dd6:	86 31       	cpi	r24, 0x16	; 22
    3dd8:	21 f4       	brne	.+8      	; 0x3de2 <Show_FlybackDiode+0x40>
  {
    LCD_Char('S');                 /* source */
    3dda:	83 e5       	ldi	r24, 0x53	; 83
    3ddc:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    3de0:	08 95       	ret
  }
  else                             /* BJT/IGBT */
  {
    LCD_Char('E');                 /* emitter */
    3de2:	85 e4       	ldi	r24, 0x45	; 69
    3de4:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    3de8:	08 95       	ret

00003dea <Show_BJT>:
/*
 *  show BJT
 */

void Show_BJT(void)
{
    3dea:	4f 92       	push	r4
    3dec:	5f 92       	push	r5
    3dee:	6f 92       	push	r6
    3df0:	7f 92       	push	r7
    3df2:	9f 92       	push	r9
    3df4:	af 92       	push	r10
    3df6:	bf 92       	push	r11
    3df8:	cf 92       	push	r12
    3dfa:	df 92       	push	r13
    3dfc:	ef 92       	push	r14
    3dfe:	ff 92       	push	r15
    3e00:	0f 93       	push	r16
    3e02:	1f 93       	push	r17
    3e04:	cf 93       	push	r28
    3e06:	df 93       	push	r29
   *  I_1 - I_CE0 (A)
   *  F_1 - hFE
   */

  /* preset stuff based on BJT type */
  if (Check.Type & TYPE_NPN)       /* NPN */
    3e08:	80 91 0a 01 	lds	r24, 0x010A
    3e0c:	80 ff       	sbrs	r24, 0
    3e0e:	07 c0       	rjmp	.+14     	; 0x3e1e <Show_BJT+0x34>
  {
    String = (unsigned char *)NPN_str;       /* "NPN" */

    /* direction of B-E diode: B -> E */
    A_Pin = Semi.A;      /* anode at base */
    3e10:	e1 e8       	ldi	r30, 0x81	; 129
    3e12:	f1 e0       	ldi	r31, 0x01	; 1
    3e14:	10 81       	ld	r17, Z
    C_Pin = Semi.C;      /* cathode at emitter */
    3e16:	02 81       	ldd	r16, Z+2	; 0x02
   */

  /* preset stuff based on BJT type */
  if (Check.Type & TYPE_NPN)       /* NPN */
  {
    String = (unsigned char *)NPN_str;       /* "NPN" */
    3e18:	c6 eb       	ldi	r28, 0xB6	; 182
    3e1a:	d1 e0       	ldi	r29, 0x01	; 1
    3e1c:	06 c0       	rjmp	.+12     	; 0x3e2a <Show_BJT+0x40>
  else                             /* PNP */
  {
    String = (unsigned char *)PNP_str;       /* "PNP" */

    /* direction of B-E diode: E -> B */
    A_Pin = Semi.C;      /* anode at emitter */
    3e1e:	e1 e8       	ldi	r30, 0x81	; 129
    3e20:	f1 e0       	ldi	r31, 0x01	; 1
    3e22:	12 81       	ldd	r17, Z+2	; 0x02
    C_Pin = Semi.A;      /* cathode at base */
    3e24:	00 81       	ld	r16, Z
    A_Pin = Semi.A;      /* anode at base */
    C_Pin = Semi.C;      /* cathode at emitter */
  }
  else                             /* PNP */
  {
    String = (unsigned char *)PNP_str;       /* "PNP" */
    3e26:	c2 eb       	ldi	r28, 0xB2	; 178
    3e28:	d1 e0       	ldi	r29, 0x01	; 1
    A_Pin = Semi.C;      /* anode at emitter */
    C_Pin = Semi.A;      /* cathode at base */
  }

  /* display type */
  LCD_EEString_Space(BJT_str);     /* display: BJT */
    3e2a:	88 e3       	ldi	r24, 0x38	; 56
    3e2c:	92 e0       	ldi	r25, 0x02	; 2
    3e2e:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>
  LCD_EEString(String);            /* display: NPN / PNP */
    3e32:	ce 01       	movw	r24, r28
    3e34:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>

  /* parasitic BJT (freewheeling diode on same substrate) */
  if (Check.Type & TYPE_PARASITIC)
    3e38:	80 91 0a 01 	lds	r24, 0x010A
    3e3c:	82 ff       	sbrs	r24, 2
    3e3e:	03 c0       	rjmp	.+6      	; 0x3e46 <Show_BJT+0x5c>
  {
    LCD_Char('+');
    3e40:	8b e2       	ldi	r24, 0x2B	; 43
    3e42:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
  }

  LCD_NextLine();                  /* move to line #2 */
    3e46:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <LCD_NextLine>

  /* display pinout */
  Show_SemiPinout('B', 'C', 'E');
    3e4a:	45 e4       	ldi	r20, 0x45	; 69
    3e4c:	63 e4       	ldi	r22, 0x43	; 67
    3e4e:	82 e4       	ldi	r24, 0x42	; 66
    3e50:	0e 94 07 1b 	call	0x360e	; 0x360e <Show_SemiPinout>

  /* optional freewheeling diode */
  if (Check.Diodes > 2)       /* transistor is a set of two diodes :-) */
    3e54:	80 91 0c 01 	lds	r24, 0x010C
    3e58:	83 30       	cpi	r24, 0x03	; 3
    3e5a:	10 f0       	brcs	.+4      	; 0x3e60 <Show_BJT+0x76>
  {
    Show_FlybackDiode();           /* show diode */
    3e5c:	0e 94 d1 1e 	call	0x3da2	; 0x3da2 <Show_FlybackDiode>
  }

  LCD_NextLine();                  /* next line */
    3e60:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <LCD_NextLine>

  /* display either optional B-E resistor or hFE & V_BE */
  if (CheckSingleResistor(C_Pin, A_Pin) == 1)     /* found B-E resistor */
    3e64:	61 2f       	mov	r22, r17
    3e66:	80 2f       	mov	r24, r16
    3e68:	0e 94 a5 29 	call	0x534a	; 0x534a <CheckSingleResistor>
    3e6c:	81 30       	cpi	r24, 0x01	; 1
    3e6e:	29 f4       	brne	.+10     	; 0x3e7a <Show_BJT+0x90>
  {
    Show_SingleResistor('B', 'E');
    3e70:	65 e4       	ldi	r22, 0x45	; 69
    3e72:	82 e4       	ldi	r24, 0x42	; 66
    3e74:	0e 94 90 1b 	call	0x3720	; 0x3720 <Show_SingleResistor>
    3e78:	66 c0       	rjmp	.+204    	; 0x3f46 <Show_BJT+0x15c>
  else                                            /* no B-E resistor found */
  {
    /* hFE and V_BE */

    /* display hFE */
    LCD_EEString_Space(hFE_str);        /* display: h_FE */
    3e7a:	8d ea       	ldi	r24, 0xAD	; 173
    3e7c:	91 e0       	ldi	r25, 0x01	; 1
    3e7e:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>
    DisplayValue(Semi.F_1, 0, 0);
    3e82:	60 91 8a 01 	lds	r22, 0x018A
    3e86:	70 91 8b 01 	lds	r23, 0x018B
    3e8a:	80 91 8c 01 	lds	r24, 0x018C
    3e8e:	90 91 8d 01 	lds	r25, 0x018D
    3e92:	20 e0       	ldi	r18, 0x00	; 0
    3e94:	40 e0       	ldi	r20, 0x00	; 0
    3e96:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>

    /* display V_BE (taken from diode forward voltage) */
    Diode = &Diodes[0];                 /* get pointer of first diode */  
    Counter = 0;
    3e9a:	80 e0       	ldi	r24, 0x00	; 0
    /* display hFE */
    LCD_EEString_Space(hFE_str);        /* display: h_FE */
    DisplayValue(Semi.F_1, 0, 0);

    /* display V_BE (taken from diode forward voltage) */
    Diode = &Diodes[0];                 /* get pointer of first diode */  
    3e9c:	cc e5       	ldi	r28, 0x5C	; 92
    3e9e:	d1 e0       	ldi	r29, 0x01	; 1
    Counter = 0;

    while (Counter < Check.Diodes)      /* check all diodes */
    3ea0:	0f 2e       	mov	r0, r31
    3ea2:	f8 e0       	ldi	r31, 0x08	; 8
    3ea4:	ef 2e       	mov	r14, r31
    3ea6:	f1 e0       	ldi	r31, 0x01	; 1
    3ea8:	ff 2e       	mov	r15, r31
    3eaa:	f0 2d       	mov	r31, r0
        /* calculate slope for one decade */
        Slope = Diode->V_f - Diode->V_f2;
        Slope /= 3;

        /* select V_BE based on hFE */
        if (Semi.F_1 < 100)             /* low hFE */
    3eac:	0f 2e       	mov	r0, r31
    3eae:	f1 e8       	ldi	r31, 0x81	; 129
    3eb0:	cf 2e       	mov	r12, r31
    3eb2:	f1 e0       	ldi	r31, 0x01	; 1
    3eb4:	df 2e       	mov	r13, r31
    3eb6:	f0 2d       	mov	r31, r0
          V_BE = Diode->V_f2 + Slope;
        }

        DisplayValue(V_BE, -3, 'V');

        Counter = 10;              /* end loop */
    3eb8:	0f 2e       	mov	r0, r31
    3eba:	fa e0       	ldi	r31, 0x0A	; 10
    3ebc:	9f 2e       	mov	r9, r31
    3ebe:	f0 2d       	mov	r31, r0
         *  3 decades.
         */

        /* calculate slope for one decade */
        Slope = Diode->V_f - Diode->V_f2;
        Slope /= 3;
    3ec0:	0f 2e       	mov	r0, r31
    3ec2:	f3 e0       	ldi	r31, 0x03	; 3
    3ec4:	af 2e       	mov	r10, r31
    3ec6:	b1 2c       	mov	r11, r1
    3ec8:	f0 2d       	mov	r31, r0

    /* display V_BE (taken from diode forward voltage) */
    Diode = &Diodes[0];                 /* get pointer of first diode */  
    Counter = 0;

    while (Counter < Check.Diodes)      /* check all diodes */
    3eca:	38 c0       	rjmp	.+112    	; 0x3f3c <Show_BJT+0x152>
    {
      /* if the diode matches the transistor's B-E diode */
      if ((Diode->A == A_Pin) && (Diode->C == C_Pin))
    3ecc:	98 81       	ld	r25, Y
    3ece:	91 13       	cpse	r25, r17
    3ed0:	33 c0       	rjmp	.+102    	; 0x3f38 <Show_BJT+0x14e>
    3ed2:	99 81       	ldd	r25, Y+1	; 0x01
    3ed4:	90 13       	cpse	r25, r16
    3ed6:	30 c0       	rjmp	.+96     	; 0x3f38 <Show_BJT+0x14e>
      {
        LCD_NextLine_EEString_Space(V_BE_str);   /* display: V_BE */
    3ed8:	88 ea       	ldi	r24, 0xA8	; 168
    3eda:	91 e0       	ldi	r25, 0x01	; 1
    3edc:	0e 94 28 10 	call	0x2050	; 0x2050 <LCD_NextLine_EEString_Space>
         *  and high test current is 7mA. That's a logarithmic scale of
         *  3 decades.
         */

        /* calculate slope for one decade */
        Slope = Diode->V_f - Diode->V_f2;
    3ee0:	2a 81       	ldd	r18, Y+2	; 0x02
    3ee2:	3b 81       	ldd	r19, Y+3	; 0x03
    3ee4:	ec 81       	ldd	r30, Y+4	; 0x04
    3ee6:	fd 81       	ldd	r31, Y+5	; 0x05
        Slope /= 3;

        /* select V_BE based on hFE */
        if (Semi.F_1 < 100)             /* low hFE */
    3ee8:	d6 01       	movw	r26, r12
    3eea:	19 96       	adiw	r26, 0x09	; 9
    3eec:	4d 90       	ld	r4, X+
    3eee:	5d 90       	ld	r5, X+
    3ef0:	6d 90       	ld	r6, X+
    3ef2:	7c 90       	ld	r7, X
    3ef4:	1c 97       	sbiw	r26, 0x0c	; 12
    3ef6:	b4 e6       	ldi	r27, 0x64	; 100
    3ef8:	4b 16       	cp	r4, r27
    3efa:	51 04       	cpc	r5, r1
    3efc:	61 04       	cpc	r6, r1
    3efe:	71 04       	cpc	r7, r1
    3f00:	90 f0       	brcs	.+36     	; 0x3f26 <Show_BJT+0x13c>
         *  and high test current is 7mA. That's a logarithmic scale of
         *  3 decades.
         */

        /* calculate slope for one decade */
        Slope = Diode->V_f - Diode->V_f2;
    3f02:	c9 01       	movw	r24, r18
    3f04:	8e 1b       	sub	r24, r30
    3f06:	9f 0b       	sbc	r25, r31
        Slope /= 3;
    3f08:	b5 01       	movw	r22, r10
    3f0a:	0e 94 72 36 	call	0x6ce4	; 0x6ce4 <__divmodhi4>
           *  measurement (7mA). 
           */

          V_BE = Diode->V_f;
        }
        else if (Semi.F_1 < 250)        /* mid-range hFE */
    3f0e:	8a ef       	ldi	r24, 0xFA	; 250
    3f10:	48 16       	cp	r4, r24
    3f12:	51 04       	cpc	r5, r1
    3f14:	61 04       	cpc	r6, r1
    3f16:	71 04       	cpc	r7, r1
    3f18:	18 f4       	brcc	.+6      	; 0x3f20 <Show_BJT+0x136>
           *  BJTs with a mid-range hFE are signal transistors and need
           *  a small I_b to drive the load. So we interpolate Vf for
           *  a virtual test current of about 1mA.
           */

          V_BE = Diode->V_f - Slope;
    3f1a:	26 1b       	sub	r18, r22
    3f1c:	37 0b       	sbc	r19, r23
    3f1e:	03 c0       	rjmp	.+6      	; 0x3f26 <Show_BJT+0x13c>
           *  BJTs with a high hFE are small signal transistors and need
           *  only a very small I_b to drive the load. So we interpolate Vf
           *  for a virtual test current of about 0.1mA.
           */

          V_BE = Diode->V_f2 + Slope;
    3f20:	9b 01       	movw	r18, r22
    3f22:	2e 0f       	add	r18, r30
    3f24:	3f 1f       	adc	r19, r31
        }

        DisplayValue(V_BE, -3, 'V');
    3f26:	b9 01       	movw	r22, r18
    3f28:	80 e0       	ldi	r24, 0x00	; 0
    3f2a:	90 e0       	ldi	r25, 0x00	; 0
    3f2c:	26 e5       	ldi	r18, 0x56	; 86
    3f2e:	4d ef       	ldi	r20, 0xFD	; 253
    3f30:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>

        Counter = 10;              /* end loop */
    3f34:	89 2d       	mov	r24, r9
    3f36:	02 c0       	rjmp	.+4      	; 0x3f3c <Show_BJT+0x152>
      }
      else                         /* diode doesn't match */
      {
        Counter++;                      /* increase counter */
    3f38:	8f 5f       	subi	r24, 0xFF	; 255
        Diode++;                        /* next one */
    3f3a:	26 96       	adiw	r28, 0x06	; 6

    /* display V_BE (taken from diode forward voltage) */
    Diode = &Diodes[0];                 /* get pointer of first diode */  
    Counter = 0;

    while (Counter < Check.Diodes)      /* check all diodes */
    3f3c:	d7 01       	movw	r26, r14
    3f3e:	14 96       	adiw	r26, 0x04	; 4
    3f40:	9c 91       	ld	r25, X
    3f42:	89 17       	cp	r24, r25
    3f44:	18 f2       	brcs	.-122    	; 0x3ecc <Show_BJT+0xe2>
      }
    }
  }

  /* I_CEO: collector emitter cutoff current (leakage) */
  if (Semi.I_1 > 0)                     /* show if not zero */
    3f46:	80 91 88 01 	lds	r24, 0x0188
    3f4a:	90 91 89 01 	lds	r25, 0x0189
    3f4e:	89 2b       	or	r24, r25
    3f50:	71 f0       	breq	.+28     	; 0x3f6e <Show_BJT+0x184>
  {
    LCD_NextLine_EEString_Space(I_CEO_str);  /* display: I_CE0 */
    3f52:	8d e9       	ldi	r24, 0x9D	; 157
    3f54:	91 e0       	ldi	r25, 0x01	; 1
    3f56:	0e 94 28 10 	call	0x2050	; 0x2050 <LCD_NextLine_EEString_Space>
    DisplayValue(Semi.I_1, -6, 'A');         /* display current */
    3f5a:	60 91 88 01 	lds	r22, 0x0188
    3f5e:	70 91 89 01 	lds	r23, 0x0189
    3f62:	80 e0       	ldi	r24, 0x00	; 0
    3f64:	90 e0       	ldi	r25, 0x00	; 0
    3f66:	21 e4       	ldi	r18, 0x41	; 65
    3f68:	4a ef       	ldi	r20, 0xFA	; 250
    3f6a:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
  }

  #ifdef SW_SYMBOLS
  LCD_FancySemiPinout();           /* display fancy pinout */
    3f6e:	0e 94 31 31 	call	0x6262	; 0x6262 <LCD_FancySemiPinout>
  #endif
}
    3f72:	df 91       	pop	r29
    3f74:	cf 91       	pop	r28
    3f76:	1f 91       	pop	r17
    3f78:	0f 91       	pop	r16
    3f7a:	ff 90       	pop	r15
    3f7c:	ef 90       	pop	r14
    3f7e:	df 90       	pop	r13
    3f80:	cf 90       	pop	r12
    3f82:	bf 90       	pop	r11
    3f84:	af 90       	pop	r10
    3f86:	9f 90       	pop	r9
    3f88:	7f 90       	pop	r7
    3f8a:	6f 90       	pop	r6
    3f8c:	5f 90       	pop	r5
    3f8e:	4f 90       	pop	r4
    3f90:	08 95       	ret

00003f92 <Show_FET_Extras>:
 */

void Show_FET_Extras(void)
{
  /* show instrinsic/freewheeling diode */
  if (Check.Diodes > 0)            /* diode found */
    3f92:	80 91 0c 01 	lds	r24, 0x010C
    3f96:	81 11       	cpse	r24, r1
  {
    Show_FlybackDiode();           /* show diode */
    3f98:	0e 94 d1 1e 	call	0x3da2	; 0x3da2 <Show_FlybackDiode>
  }

  /* skip remaining stuff for depletion-mode FETs/IGBTs */
  if (Check.Type & TYPE_DEPLETION) return;
    3f9c:	80 91 0a 01 	lds	r24, 0x010A
    3fa0:	83 fd       	sbrc	r24, 3
    3fa2:	2b c0       	rjmp	.+86     	; 0x3ffa <Show_FET_Extras+0x68>

  /* gate threshold voltage */
  if (Semi.U_2 != 0)
    3fa4:	80 91 86 01 	lds	r24, 0x0186
    3fa8:	90 91 87 01 	lds	r25, 0x0187
    3fac:	89 2b       	or	r24, r25
    3fae:	81 f0       	breq	.+32     	; 0x3fd0 <Show_FET_Extras+0x3e>
  {
    LCD_NextLine_EEString_Space(Vth_str);    /* display: Vth */
    3fb0:	84 e9       	ldi	r24, 0x94	; 148
    3fb2:	91 e0       	ldi	r25, 0x01	; 1
    3fb4:	0e 94 28 10 	call	0x2050	; 0x2050 <LCD_NextLine_EEString_Space>
    DisplaySignedValue(Semi.U_2, -3, 'V');   /* display V_th in mV */
    3fb8:	60 91 86 01 	lds	r22, 0x0186
    3fbc:	70 91 87 01 	lds	r23, 0x0187
    3fc0:	07 2e       	mov	r0, r23
    3fc2:	00 0c       	add	r0, r0
    3fc4:	88 0b       	sbc	r24, r24
    3fc6:	99 0b       	sbc	r25, r25
    3fc8:	26 e5       	ldi	r18, 0x56	; 86
    3fca:	4d ef       	ldi	r20, 0xFD	; 253
    3fcc:	0e 94 34 33 	call	0x6668	; 0x6668 <DisplaySignedValue>
  }

  /* display gate-source capacitance */
  LCD_NextLine_EEString_Space(GateCap_str);  /* display: Cgs */
    3fd0:	8a eb       	ldi	r24, 0xBA	; 186
    3fd2:	91 e0       	ldi	r25, 0x01	; 1
    3fd4:	0e 94 28 10 	call	0x2050	; 0x2050 <LCD_NextLine_EEString_Space>
  MeasureCap(Semi.A, Semi.C, 0);             /* measure capacitance */
    3fd8:	e1 e8       	ldi	r30, 0x81	; 129
    3fda:	f1 e0       	ldi	r31, 0x01	; 1
    3fdc:	40 e0       	ldi	r20, 0x00	; 0
    3fde:	62 81       	ldd	r22, Z+2	; 0x02
    3fe0:	80 81       	ld	r24, Z
    3fe2:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <MeasureCap>
  /* display value and unit */
  DisplayValue(Caps[0].Value, Caps[0].Scale, 'F');
    3fe6:	eb e3       	ldi	r30, 0x3B	; 59
    3fe8:	f1 e0       	ldi	r31, 0x01	; 1
    3fea:	63 81       	ldd	r22, Z+3	; 0x03
    3fec:	74 81       	ldd	r23, Z+4	; 0x04
    3fee:	85 81       	ldd	r24, Z+5	; 0x05
    3ff0:	96 81       	ldd	r25, Z+6	; 0x06
    3ff2:	26 e4       	ldi	r18, 0x46	; 70
    3ff4:	42 81       	ldd	r20, Z+2	; 0x02
    3ff6:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
    3ffa:	08 95       	ret

00003ffc <Show_FET_Channel>:
 *  show FET/IGBT channel type
 */

void Show_FET_Channel(void)
{
  LCD_Space();                     /* display space */
    3ffc:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>

  /* channel type */
  if (Check.Type & TYPE_N_CHANNEL)   /* n-channel */
    4000:	80 91 0a 01 	lds	r24, 0x010A
    4004:	80 ff       	sbrs	r24, 0
    4006:	04 c0       	rjmp	.+8      	; 0x4010 <Show_FET_Channel+0x14>
  {
    LCD_Char('N');
    4008:	8e e4       	ldi	r24, 0x4E	; 78
    400a:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    400e:	03 c0       	rjmp	.+6      	; 0x4016 <Show_FET_Channel+0x1a>
  }
  else                               /* p-channel */
  {
    LCD_Char('P');
    4010:	80 e5       	ldi	r24, 0x50	; 80
    4012:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
  }

  LCD_EEString(Channel_str);         /* display: -ch */
    4016:	8d ec       	ldi	r24, 0xCD	; 205
    4018:	91 e0       	ldi	r25, 0x01	; 1
    401a:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
    401e:	08 95       	ret

00004020 <Show_FET_Mode>:
 *  show FET/IGBT mode
 */

void Show_FET_Mode(void)
{
  LCD_Space();
    4020:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>

  if (Check.Type & TYPE_ENHANCEMENT)    /* enhancement mode */
    4024:	80 91 0a 01 	lds	r24, 0x010A
    4028:	82 ff       	sbrs	r24, 2
    402a:	05 c0       	rjmp	.+10     	; 0x4036 <Show_FET_Mode+0x16>
  {
    LCD_EEString(Enhancement_str);
    402c:	88 ec       	ldi	r24, 0xC8	; 200
    402e:	91 e0       	ldi	r25, 0x01	; 1
    4030:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
    4034:	08 95       	ret
  }
  else                                  /* depletion mode */
  {
    LCD_EEString(Depletion_str);
    4036:	83 ec       	ldi	r24, 0xC3	; 195
    4038:	91 e0       	ldi	r25, 0x01	; 1
    403a:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
    403e:	08 95       	ret

00004040 <Show_FET>:
   *  C   - Source pin
   *  U_2 - V_th (mV)
   */

  /* display type */
  if (Check.Type & TYPE_MOSFET)    /* MOSFET */
    4040:	80 91 0a 01 	lds	r24, 0x010A
    4044:	84 ff       	sbrs	r24, 4
    4046:	05 c0       	rjmp	.+10     	; 0x4052 <Show_FET+0x12>
  {
    LCD_EEString(MOS_str);           /* display: MOS */
    4048:	85 ed       	ldi	r24, 0xD5	; 213
    404a:	91 e0       	ldi	r25, 0x01	; 1
    404c:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
    4050:	03 c0       	rjmp	.+6      	; 0x4058 <Show_FET+0x18>
  }
  else                             /* JFET */
  {
    LCD_Char('J');                   /* display: J */
    4052:	8a e4       	ldi	r24, 0x4A	; 74
    4054:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
  }
  LCD_EEString(FET_str);           /* display: FET */
    4058:	81 ed       	ldi	r24, 0xD1	; 209
    405a:	91 e0       	ldi	r25, 0x01	; 1
    405c:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>

  /* display channel type */
  Show_FET_Channel();
    4060:	0e 94 fe 1f 	call	0x3ffc	; 0x3ffc <Show_FET_Channel>
      
  /* display mode for MOSFETs*/
  if (Check.Type & TYPE_MOSFET) Show_FET_Mode();
    4064:	80 91 0a 01 	lds	r24, 0x010A
    4068:	84 fd       	sbrc	r24, 4
    406a:	0e 94 10 20 	call	0x4020	; 0x4020 <Show_FET_Mode>

  /* pinout */
  LCD_NextLine();                       /* move to line #2 */
    406e:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <LCD_NextLine>

  if (Check.Type & TYPE_SYMMETRICAL)    /* symmetrical Drain and Source */
    4072:	80 91 0a 01 	lds	r24, 0x010A
    4076:	86 ff       	sbrs	r24, 6
    4078:	06 c0       	rjmp	.+12     	; 0x4086 <Show_FET+0x46>
  {
    /* we can't distinguish D and S */
    Show_SemiPinout('G', 'x', 'x');     /* show pinout */
    407a:	48 e7       	ldi	r20, 0x78	; 120
    407c:	68 e7       	ldi	r22, 0x78	; 120
    407e:	87 e4       	ldi	r24, 0x47	; 71
    4080:	0e 94 07 1b 	call	0x360e	; 0x360e <Show_SemiPinout>
    4084:	05 c0       	rjmp	.+10     	; 0x4090 <Show_FET+0x50>
  }
  else                                  /* unsymmetrical Drain and Source */
  {
    Show_SemiPinout('G', 'D', 'S');     /* show pinout */
    4086:	43 e5       	ldi	r20, 0x53	; 83
    4088:	64 e4       	ldi	r22, 0x44	; 68
    408a:	87 e4       	ldi	r24, 0x47	; 71
    408c:	0e 94 07 1b 	call	0x360e	; 0x360e <Show_SemiPinout>
  }

  /* show diode, V_th and Cgs for MOSFETs */
  if (Check.Type & TYPE_MOSFET) Show_FET_Extras();
    4090:	80 91 0a 01 	lds	r24, 0x010A
    4094:	84 fd       	sbrc	r24, 4
    4096:	0e 94 c9 1f 	call	0x3f92	; 0x3f92 <Show_FET_Extras>

  #ifdef SW_SYMBOLS
  LCD_FancySemiPinout();           /* display fancy pinout */
    409a:	0e 94 31 31 	call	0x6262	; 0x6262 <LCD_FancySemiPinout>
    409e:	08 95       	ret

000040a0 <Show_IGBT>:
   *  B   - Collector pin
   *  C   - Emitter pin
   *  U_2 - V_th (mV)
   */

  LCD_EEString(IGBT_str);          /* display: IGBT */
    40a0:	8e eb       	ldi	r24, 0xBE	; 190
    40a2:	91 e0       	ldi	r25, 0x01	; 1
    40a4:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
  Show_FET_Channel();              /* display channel type */
    40a8:	0e 94 fe 1f 	call	0x3ffc	; 0x3ffc <Show_FET_Channel>
  Show_FET_Mode();                 /* display mode */
    40ac:	0e 94 10 20 	call	0x4020	; 0x4020 <Show_FET_Mode>

  LCD_NextLine();                  /* move to line #2 */
    40b0:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <LCD_NextLine>
  Show_SemiPinout('G', 'C', 'E');  /* show pinout */
    40b4:	45 e4       	ldi	r20, 0x45	; 69
    40b6:	63 e4       	ldi	r22, 0x43	; 67
    40b8:	87 e4       	ldi	r24, 0x47	; 71
    40ba:	0e 94 07 1b 	call	0x360e	; 0x360e <Show_SemiPinout>
  Show_FET_Extras();               /* show diode, V_th and C_GE */
    40be:	0e 94 c9 1f 	call	0x3f92	; 0x3f92 <Show_FET_Extras>

  #ifdef SW_SYMBOLS
  LCD_FancySemiPinout();           /* display fancy pinout */
    40c2:	0e 94 31 31 	call	0x6262	; 0x6262 <LCD_FancySemiPinout>
    40c6:	08 95       	ret

000040c8 <Show_Special>:
   *  C   - Cathode/MT1 pin
   *  U_1 - V_GT (mV)
   */

  /* display component type any pinout */
  if (Check.Found == COMP_THYRISTOR)    /* SCR */
    40c8:	80 91 09 01 	lds	r24, 0x0109
    40cc:	89 31       	cpi	r24, 0x19	; 25
    40ce:	61 f4       	brne	.+24     	; 0x40e8 <Show_Special+0x20>
  {
    LCD_EEString(Thyristor_str);        /* display: thyristor */
    40d0:	84 e3       	ldi	r24, 0x34	; 52
    40d2:	92 e0       	ldi	r25, 0x02	; 2
    40d4:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
    LCD_NextLine();                     /* move to line #2 */
    40d8:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <LCD_NextLine>
    Show_SemiPinout('G', 'A', 'C');     /* display pinout */
    40dc:	43 e4       	ldi	r20, 0x43	; 67
    40de:	61 e4       	ldi	r22, 0x41	; 65
    40e0:	87 e4       	ldi	r24, 0x47	; 71
    40e2:	0e 94 07 1b 	call	0x360e	; 0x360e <Show_SemiPinout>
    40e6:	0b c0       	rjmp	.+22     	; 0x40fe <Show_Special+0x36>
  }
  else                                  /* Triac */
  {
    LCD_EEString(Triac_str);            /* display: triac */
    40e8:	8e e2       	ldi	r24, 0x2E	; 46
    40ea:	92 e0       	ldi	r25, 0x02	; 2
    40ec:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
    LCD_NextLine();                     /* move to line #2 */
    40f0:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <LCD_NextLine>
    Show_SemiPinout('G', '2', '1');     /* display pinout */
    40f4:	41 e3       	ldi	r20, 0x31	; 49
    40f6:	62 e3       	ldi	r22, 0x32	; 50
    40f8:	87 e4       	ldi	r24, 0x47	; 71
    40fa:	0e 94 07 1b 	call	0x360e	; 0x360e <Show_SemiPinout>
  }

  /* show V_GT (gate trigger voltage) */
  if (Semi.U_1 > 0)                /* show if not zero */
    40fe:	80 91 84 01 	lds	r24, 0x0184
    4102:	90 91 85 01 	lds	r25, 0x0185
    4106:	89 2b       	or	r24, r25
    4108:	71 f0       	breq	.+28     	; 0x4126 <Show_Special+0x5e>
  {
    LCD_NextLine_EEString_Space(V_GT_str);   /* display: V_GT */
    410a:	83 ea       	ldi	r24, 0xA3	; 163
    410c:	91 e0       	ldi	r25, 0x01	; 1
    410e:	0e 94 28 10 	call	0x2050	; 0x2050 <LCD_NextLine_EEString_Space>
    DisplayValue(Semi.U_1, -3, 'V');         /* display V_GT in mV */
    4112:	60 91 84 01 	lds	r22, 0x0184
    4116:	70 91 85 01 	lds	r23, 0x0185
    411a:	80 e0       	ldi	r24, 0x00	; 0
    411c:	90 e0       	ldi	r25, 0x00	; 0
    411e:	26 e5       	ldi	r18, 0x56	; 86
    4120:	4d ef       	ldi	r20, 0xFD	; 253
    4122:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
  }

  #ifdef SW_SYMBOLS
  LCD_FancySemiPinout();           /* display fancy pinout */
    4126:	0e 94 31 31 	call	0x6262	; 0x6262 <LCD_FancySemiPinout>
    412a:	08 95       	ret

0000412c <main>:
/*
 *  main function
 */

int main(void)
{
    412c:	8f 92       	push	r8
    412e:	9f 92       	push	r9
    4130:	af 92       	push	r10
    4132:	bf 92       	push	r11
    4134:	cf 92       	push	r12
    4136:	df 92       	push	r13
    4138:	ef 92       	push	r14
    413a:	ff 92       	push	r15
    413c:	0f 93       	push	r16
    413e:	1f 93       	push	r17
    4140:	cf 93       	push	r28
    4142:	df 93       	push	r29
  /*
   *  init
   */

  /* switch on power to keep me alive */
  CONTROL_DDR = (1 << POWER_CTRL);      /* set pin as output */
    4144:	80 e4       	ldi	r24, 0x40	; 64
    4146:	8a b9       	out	0x0a, r24	; 10
  CONTROL_PORT = (1 << POWER_CTRL);     /* set pin to drive power management transistor */
    4148:	8b b9       	out	0x0b, r24	; 11

  /* setup MCU */
  MCUCR = (1 << PUD);                        /* disable pull-up resistors globally */
    414a:	80 e1       	ldi	r24, 0x10	; 16
    414c:	85 bf       	out	0x35, r24	; 53
  ADCSRA = (1 << ADEN) | ADC_CLOCK_DIV;      /* enable ADC and set clock divider */
    414e:	87 e8       	ldi	r24, 0x87	; 135
    4150:	80 93 7a 00 	sts	0x007A, r24
                                      /* ADC_PORT should be 0 */
  ADC_DDR = (1 << TP_REF);            /* short circuit probes */
  #endif

  /* catch watchdog */  
  Test = (MCUSR & (1 << WDRF));         /* save watchdog flag */
    4154:	c4 b7       	in	r28, 0x34	; 52
  MCUSR &= ~(1 << WDRF);                /* reset watchdog flag */
    4156:	84 b7       	in	r24, 0x34	; 52
    4158:	87 7f       	andi	r24, 0xF7	; 247
    415a:	84 bf       	out	0x34, r24	; 52
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    415c:	0f b6       	in	r0, 0x3f	; 63
    415e:	f8 94       	cli
    4160:	a8 95       	wdr
    4162:	80 91 60 00 	lds	r24, 0x0060
    4166:	88 61       	ori	r24, 0x18	; 24
    4168:	80 93 60 00 	sts	0x0060, r24
    416c:	10 92 60 00 	sts	0x0060, r1
    4170:	0f be       	out	0x3f, r0	; 63
  wdt_disable();                        /* disable watchdog */

  /* LCD module */
  LCD_BusSetup();                       /* setup bus */
    4172:	0e 94 ea 2f 	call	0x5fd4	; 0x5fd4 <LCD_BusSetup>
   *  - Does only work if the capacitor at the base of the power management
   *    transistor is large enough to survive a MCU reset. Otherwise the
   *    tester simply loses power.
   */

  if (Test)
    4176:	c3 ff       	sbrs	r28, 3
    4178:	10 c0       	rjmp	.+32     	; 0x419a <main+0x6e>
  {
    LCD_Clear();                        /* display was initialized before */
    417a:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
    LCD_EEString(Timeout_str);          /* display: timeout */
    417e:	88 e8       	ldi	r24, 0x88	; 136
    4180:	91 e0       	ldi	r25, 0x01	; 1
    4182:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
    LCD_NextLine_EEString(Error_str);   /* display: error */
    4186:	81 e4       	ldi	r24, 0x41	; 65
    4188:	92 e0       	ldi	r25, 0x02	; 2
    418a:	0e 94 1d 10 	call	0x203a	; 0x203a <LCD_NextLine_EEString>
    MilliSleep(2000);                   /* give user some time to read */
    418e:	80 ed       	ldi	r24, 0xD0	; 208
    4190:	97 e0       	ldi	r25, 0x07	; 7
    4192:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>
    CONTROL_PORT = 0;                   /* power off myself */
    4196:	1b b8       	out	0x0b, r1	; 11
    return 0;                           /* exit program */
    4198:	9d c1       	rjmp	.+826    	; 0x44d4 <main+0x3a8>

  /*
   *  operation mode selection
   */

  Config.SleepMode = SLEEP_MODE_PWR_SAVE;    /* default: power save */
    419a:	86 e0       	ldi	r24, 0x06	; 6
    419c:	80 93 ab 01 	sts	0x01AB, r24
  UI.TesterMode = MODE_CONTINOUS;            /* set default mode: continous */
    41a0:	10 92 26 01 	sts	0x0126, r1
  Test = 0;                                  /* key press */

  /* catch long key press */
  if (!(CONTROL_PIN & (1 << TEST_BUTTON)))   /* if test button is pressed */
    41a4:	4f 99       	sbic	0x09, 7	; 9
    41a6:	89 c1       	rjmp	.+786    	; 0x44ba <main+0x38e>
  {
    RunsMissed = 0;
    41a8:	10 92 8e 01 	sts	0x018E, r1

    while (Test == 0)
    {
      MilliSleep(20);
    41ac:	84 e1       	ldi	r24, 0x14	; 20
    41ae:	90 e0       	ldi	r25, 0x00	; 0
    41b0:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>
      if (!(CONTROL_PIN & (1 << TEST_BUTTON)))    /* if button is still pressed */
    41b4:	4f 99       	sbic	0x09, 7	; 9
    41b6:	09 c0       	rjmp	.+18     	; 0x41ca <main+0x9e>
      {
        RunsMissed++;
    41b8:	80 91 8e 01 	lds	r24, 0x018E
    41bc:	8f 5f       	subi	r24, 0xFF	; 255
    41be:	80 93 8e 01 	sts	0x018E, r24
        if (RunsMissed > 100) Test = 3;      /* >2000ms */
    41c2:	85 36       	cpi	r24, 0x65	; 101
    41c4:	08 f0       	brcs	.+2      	; 0x41c8 <main+0x9c>
    41c6:	7f c1       	rjmp	.+766    	; 0x44c6 <main+0x39a>
    41c8:	f1 cf       	rjmp	.-30     	; 0x41ac <main+0x80>
      }
      else                                        /* button released */
      {
        Test = 1;                            /* <300ms */
        if (RunsMissed > 15) Test = 2;       /* >300ms */
    41ca:	80 91 8e 01 	lds	r24, 0x018E
    41ce:	80 31       	cpi	r24, 0x10	; 16
    41d0:	08 f0       	brcs	.+2      	; 0x41d4 <main+0xa8>
    41d2:	7b c1       	rjmp	.+758    	; 0x44ca <main+0x39e>
        RunsMissed++;
        if (RunsMissed > 100) Test = 3;      /* >2000ms */
      }
      else                                        /* button released */
      {
        Test = 1;                            /* <300ms */
    41d4:	c1 e0       	ldi	r28, 0x01	; 1

  /* key press >300ms sets autohold mode */
  if (Test > 1) UI.TesterMode = MODE_AUTOHOLD;

  /* init LCD module */
  LCD_Init();                           /* initialize LCD */
    41d6:	0e 94 62 30 	call	0x60c4	; 0x60c4 <LCD_Init>
  LCD_NextLine_Mode(MODE_NONE);         /* reset line mode */
    41da:	80 e0       	ldi	r24, 0x00	; 0
    41dc:	0e 94 1a 10 	call	0x2034	; 0x2034 <LCD_NextLine_Mode>

  /*
   *  load saved offsets and values
   */

  if (Test == 3)              /* key press >2s resets to defaults */
    41e0:	c3 30       	cpi	r28, 0x03	; 3
    41e2:	19 f4       	brne	.+6      	; 0x41ea <main+0xbe>
  {
    SetAdjustDefaults();                /* set default values */
    41e4:	0e 94 15 05 	call	0xa2a	; 0xa2a <SetAdjustDefaults>
    41e8:	04 c0       	rjmp	.+8      	; 0x41f2 <main+0xc6>
  }
  else                        /* normal mode */
  {
    ManageAdjust(MODE_LOAD, 1);    /* load adjustment values: profile #1 */
    41ea:	61 e0       	ldi	r22, 0x01	; 1
    41ec:	81 e0       	ldi	r24, 0x01	; 1
    41ee:	0e 94 38 05 	call	0xa70	; 0xa70 <ManageAdjust>
  }

  /* set extra stuff */
  #ifdef SW_CONTRAST
    LCD_Contrast(NV.Contrast);          /* set LCD contrast */
    41f2:	80 91 a4 01 	lds	r24, 0x01A4
    41f6:	0e 94 54 30 	call	0x60a8	; 0x60a8 <LCD_Contrast>

  /*
   *  welcome user
   */

  LCD_EEString(Tester_str);             /* display: Component Tester */
    41fa:	88 ee       	ldi	r24, 0xE8	; 232
    41fc:	91 e0       	ldi	r25, 0x01	; 1
    41fe:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
  LCD_NextLine_EEString_Space(Edition_str);   /* display firmware edition */
    4202:	81 ee       	ldi	r24, 0xE1	; 225
    4204:	91 e0       	ldi	r25, 0x01	; 1
    4206:	0e 94 28 10 	call	0x2050	; 0x2050 <LCD_NextLine_EEString_Space>
  LCD_EEString(Version_str);            /* display firmware version */
    420a:	8c ec       	ldi	r24, 0xCC	; 204
    420c:	90 e0       	ldi	r25, 0x00	; 0
    420e:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
  #ifdef LCD_COLOR
    UI.PenColor = COLOR_GREEN;          /* set pen color */
  #endif
  MilliSleep(1500);                     /* let the user read the display */
    4212:	8c ed       	ldi	r24, 0xDC	; 220
    4214:	95 e0       	ldi	r25, 0x05	; 5
    4216:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>
  /*
   *  init variables
   */

  /* cycling */
  RunsMissed = 0;
    421a:	10 92 8e 01 	sts	0x018E, r1
  RunsPassed = 0;
    421e:	10 92 80 01 	sts	0x0180, r1

  /* default offsets and values */
  Config.Samples = ADC_SAMPLES;         /* number of ADC samples */
    4222:	eb ea       	ldi	r30, 0xAB	; 171
    4224:	f1 e0       	ldi	r31, 0x01	; 1
    4226:	89 e1       	ldi	r24, 0x19	; 25
    4228:	81 83       	std	Z+1, r24	; 0x01
  Config.AutoScale = 1;                 /* enable ADC auto scaling */
    422a:	81 e0       	ldi	r24, 0x01	; 1
    422c:	82 83       	std	Z+2, r24	; 0x02
  Config.RefFlag = 1;                   /* no ADC reference set yet */
    422e:	83 83       	std	Z+3, r24	; 0x03
  Config.Vcc = UREF_VCC;                /* voltage of Vcc */
    4230:	89 e8       	ldi	r24, 0x89	; 137
    4232:	93 e1       	ldi	r25, 0x13	; 19
    4234:	97 83       	std	Z+7, r25	; 0x07
    4236:	86 83       	std	Z+6, r24	; 0x06
				: "r0"
		);
	}
	else
	{
		__asm__ __volatile__ (
    4238:	9f e0       	ldi	r25, 0x0F	; 15
    423a:	88 e1       	ldi	r24, 0x18	; 24
    423c:	0f b6       	in	r0, 0x3f	; 63
    423e:	f8 94       	cli
    4240:	a8 95       	wdr
    4242:	80 93 60 00 	sts	0x0060, r24
    4246:	0f be       	out	0x3f, r0	; 63
    4248:	90 93 60 00 	sts	0x0060, r25
   */

start:

  /* reset variabels */
  Check.Found = COMP_NONE;
    424c:	c8 e0       	ldi	r28, 0x08	; 8
    424e:	d1 e0       	ldi	r29, 0x01	; 1
  Check.Type = 0;
  Check.Done = 0;
  Check.Diodes = 0;
  Check.Resistors = 0;
  Semi.U_1 = 0;
    4250:	0f 2e       	mov	r0, r31
    4252:	f1 e8       	ldi	r31, 0x81	; 129
    4254:	ef 2e       	mov	r14, r31
    4256:	f1 e0       	ldi	r31, 0x01	; 1
    4258:	ff 2e       	mov	r15, r31
    425a:	f0 2d       	mov	r31, r0
    Config.Vcc = (uint16_t)Temp;
  }
  #endif

  /* internal bandgap reference */
  Config.Bandgap = ReadU(0x0e);         /* dummy read for bandgap stabilization */
    425c:	8f 01       	movw	r16, r30
  Config.Samples = 200;                 /* do a lot of samples for high accuracy */
    425e:	0f 2e       	mov	r0, r31
    4260:	f8 ec       	ldi	r31, 0xC8	; 200
    4262:	8f 2e       	mov	r8, r31
    4264:	f0 2d       	mov	r31, r0
  Config.Bandgap = ReadU(0x0e);         /* get voltage of bandgap reference (mV) */
  Config.Samples = ADC_SAMPLES;         /* set samples back to default */
    4266:	0f 2e       	mov	r0, r31
    4268:	f9 e1       	ldi	r31, 0x19	; 25
    426a:	9f 2e       	mov	r9, r31
    426c:	f0 2d       	mov	r31, r0
  Config.Bandgap += NV.RefOffset;       /* add voltage offset */ 
    426e:	0f 2e       	mov	r0, r31
    4270:	fb e9       	ldi	r31, 0x9B	; 155
    4272:	cf 2e       	mov	r12, r31
    4274:	f1 e0       	ldi	r31, 0x01	; 1
    4276:	df 2e       	mov	r13, r31
    4278:	f0 2d       	mov	r31, r0
   */

start:

  /* reset variabels */
  Check.Found = COMP_NONE;
    427a:	19 82       	std	Y+1, r1	; 0x01
  Check.Type = 0;
    427c:	1a 82       	std	Y+2, r1	; 0x02
  Check.Done = 0;
    427e:	18 82       	st	Y, r1
  Check.Diodes = 0;
    4280:	1c 82       	std	Y+4, r1	; 0x04
  Check.Resistors = 0;
    4282:	1b 82       	std	Y+3, r1	; 0x03
  Semi.U_1 = 0;
    4284:	f7 01       	movw	r30, r14
    4286:	14 82       	std	Z+4, r1	; 0x04
    4288:	13 82       	std	Z+3, r1	; 0x03
  Semi.I_1 = 0;
    428a:	10 86       	std	Z+8, r1	; 0x08
    428c:	17 82       	std	Z+7, r1	; 0x07
  Semi.F_1 = 0;
    428e:	11 86       	std	Z+9, r1	; 0x09
    4290:	12 86       	std	Z+10, r1	; 0x0a
    4292:	13 86       	std	Z+11, r1	; 0x0b
    4294:	14 86       	std	Z+12, r1	; 0x0c

  /* reset hardware */
  ADC_DDR = 0;                     /* set all pins of ADC port as input */
    4296:	17 b8       	out	0x07, r1	; 7
                                   /* also remove short circuit by relay */
  LCD_NextLine_Mode(MODE_KEEP);    /* line mode: keep first line */
    4298:	82 e0       	ldi	r24, 0x02	; 2
    429a:	0e 94 1a 10 	call	0x2034	; 0x2034 <LCD_NextLine_Mode>
  LCD_Clear();                     /* clear LCD */
    429e:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
    Config.Vcc = (uint16_t)Temp;
  }
  #endif

  /* internal bandgap reference */
  Config.Bandgap = ReadU(0x0e);         /* dummy read for bandgap stabilization */
    42a2:	8e e0       	ldi	r24, 0x0E	; 14
    42a4:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    42a8:	f8 01       	movw	r30, r16
    42aa:	95 83       	std	Z+5, r25	; 0x05
    42ac:	84 83       	std	Z+4, r24	; 0x04
  Config.Samples = 200;                 /* do a lot of samples for high accuracy */
    42ae:	81 82       	std	Z+1, r8	; 0x01
  Config.Bandgap = ReadU(0x0e);         /* get voltage of bandgap reference (mV) */
    42b0:	8e e0       	ldi	r24, 0x0E	; 14
    42b2:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
  Config.Samples = ADC_SAMPLES;         /* set samples back to default */
    42b6:	f8 01       	movw	r30, r16
    42b8:	91 82       	std	Z+1, r9	; 0x01
  Config.Bandgap += NV.RefOffset;       /* add voltage offset */ 
    42ba:	f6 01       	movw	r30, r12
    42bc:	27 81       	ldd	r18, Z+7	; 0x07
    42be:	82 0f       	add	r24, r18
    42c0:	91 1d       	adc	r25, r1
    42c2:	27 fd       	sbrc	r18, 7
    42c4:	9a 95       	dec	r25
    42c6:	f8 01       	movw	r30, r16
    42c8:	95 83       	std	Z+5, r25	; 0x05
    42ca:	84 83       	std	Z+4, r24	; 0x04
   *  Ul = (Uin / (Rh + Rl)) * Rl  ->  Uin = (Ul * (Rh + Rl)) / Rl
   *  Uin = (Ul * (10k + 3k3)) / 3k3 = 4 * Ul  
   */

  /* get current voltage */
  U_Bat = ReadU(TP_BAT);                /* read voltage (mV) */
    42cc:	85 e0       	ldi	r24, 0x05	; 5
    42ce:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
  U_Bat *= 4;                           /* calculate U_bat (mV) */
    42d2:	88 0f       	add	r24, r24
    42d4:	99 1f       	adc	r25, r25
    42d6:	88 0f       	add	r24, r24
    42d8:	99 1f       	adc	r25, r25
  U_Bat += BAT_OFFSET;                  /* add offset for voltage drop */
    42da:	5c 01       	movw	r10, r24
    42dc:	fe ed       	ldi	r31, 0xDE	; 222
    42de:	af 1a       	sub	r10, r31
    42e0:	fe ef       	ldi	r31, 0xFE	; 254
    42e2:	bf 0a       	sbc	r11, r31

  /* display battery voltage */
  LCD_EEString_Space(Battery_str);      /* display: Bat. */
    42e4:	8c ed       	ldi	r24, 0xDC	; 220
    42e6:	91 e0       	ldi	r25, 0x01	; 1
    42e8:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>
  DisplayValue(U_Bat / 10, -2, 'V');    /* display battery voltage */
    42ec:	95 01       	movw	r18, r10
    42ee:	ad ec       	ldi	r26, 0xCD	; 205
    42f0:	bc ec       	ldi	r27, 0xCC	; 204
    42f2:	0e 94 cd 36 	call	0x6d9a	; 0x6d9a <__umulhisi3>
    42f6:	96 95       	lsr	r25
    42f8:	87 95       	ror	r24
    42fa:	96 95       	lsr	r25
    42fc:	87 95       	ror	r24
    42fe:	96 95       	lsr	r25
    4300:	87 95       	ror	r24
    4302:	bc 01       	movw	r22, r24
    4304:	80 e0       	ldi	r24, 0x00	; 0
    4306:	90 e0       	ldi	r25, 0x00	; 0
    4308:	26 e5       	ldi	r18, 0x56	; 86
    430a:	4e ef       	ldi	r20, 0xFE	; 254
    430c:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
  LCD_Space();
    4310:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>

  /* check limits */
  if (U_Bat < BAT_POOR)                 /* low level reached */
    4314:	a1 14       	cp	r10, r1
    4316:	29 e1       	ldi	r18, 0x19	; 25
    4318:	b2 06       	cpc	r11, r18
    431a:	48 f4       	brcc	.+18     	; 0x432e <main+0x202>
  {
    LCD_EEString(Low_str);              /* display: low */
    431c:	89 eb       	ldi	r24, 0xB9	; 185
    431e:	92 e0       	ldi	r25, 0x02	; 2
    4320:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
    MilliSleep(2000);                   /* let user read info */
    4324:	80 ed       	ldi	r24, 0xD0	; 208
    4326:	97 e0       	ldi	r25, 0x07	; 7
    4328:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>
    goto power_off;                     /* power off */
    432c:	b3 c0       	rjmp	.+358    	; 0x4494 <main+0x368>
  }
  else if (U_Bat < BAT_POOR + 1000)     /* warning level reached */
    432e:	88 ee       	ldi	r24, 0xE8	; 232
    4330:	a8 16       	cp	r10, r24
    4332:	8c e1       	ldi	r24, 0x1C	; 28
    4334:	b8 06       	cpc	r11, r24
    4336:	28 f4       	brcc	.+10     	; 0x4342 <main+0x216>
  {
    LCD_EEString(Weak_str);             /* display: weak */
    4338:	8d eb       	ldi	r24, 0xBD	; 189
    433a:	92 e0       	ldi	r25, 0x02	; 2
    433c:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
    4340:	04 c0       	rjmp	.+8      	; 0x434a <main+0x21e>
  }
  else                                  /* ok */
  {
    LCD_EEString(OK_str);               /* display: ok */
    4342:	89 ed       	ldi	r24, 0xD9	; 217
    4344:	91 e0       	ldi	r25, 0x01	; 1
    4346:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
  /*
   *  probing
   */

  /* display start of probing */
  LCD_NextLine_EEString(Running_str);   /* display: probing... */
    434a:	82 ec       	ldi	r24, 0xC2	; 194
    434c:	92 e0       	ldi	r25, 0x02	; 2
    434e:	0e 94 1d 10 	call	0x203a	; 0x203a <LCD_NextLine_EEString>

  /* try to discharge any connected component */
  DischargeProbes();
    4352:	0e 94 a3 23 	call	0x4746	; 0x4746 <DischargeProbes>
  if (Check.Found == COMP_ERROR)   /* discharge failed */
    4356:	89 81       	ldd	r24, Y+1	; 0x01
    4358:	81 30       	cpi	r24, 0x01	; 1
    435a:	f1 f1       	breq	.+124    	; 0x43d8 <main+0x2ac>
  {
    goto result;                   /* skip all other checks */
  }

  /* enter main menu if requested by short-circuiting all probes */
  if (AllProbesShorted() == 3)
    435c:	0e 94 91 23 	call	0x4722	; 0x4722 <AllProbesShorted>
    4360:	83 30       	cpi	r24, 0x03	; 3
    4362:	19 f4       	brne	.+6      	; 0x436a <main+0x23e>
  {
    MainMenu();                    /* enter mainmenu */;
    4364:	0e 94 f6 35 	call	0x6bec	; 0x6bec <MainMenu>
    goto end;                      /* new cycle after job is is done */
    4368:	6d c0       	rjmp	.+218    	; 0x4444 <main+0x318>
  }

  /* check all 6 combinations of the 3 probes */ 
  CheckProbes(TP1, TP2, TP3);
    436a:	42 e0       	ldi	r20, 0x02	; 2
    436c:	61 e0       	ldi	r22, 0x01	; 1
    436e:	80 e0       	ldi	r24, 0x00	; 0
    4370:	0e 94 fd 24 	call	0x49fa	; 0x49fa <CheckProbes>
  CheckProbes(TP2, TP1, TP3);
    4374:	42 e0       	ldi	r20, 0x02	; 2
    4376:	60 e0       	ldi	r22, 0x00	; 0
    4378:	81 e0       	ldi	r24, 0x01	; 1
    437a:	0e 94 fd 24 	call	0x49fa	; 0x49fa <CheckProbes>
  CheckProbes(TP1, TP3, TP2);
    437e:	41 e0       	ldi	r20, 0x01	; 1
    4380:	62 e0       	ldi	r22, 0x02	; 2
    4382:	80 e0       	ldi	r24, 0x00	; 0
    4384:	0e 94 fd 24 	call	0x49fa	; 0x49fa <CheckProbes>
  CheckProbes(TP3, TP1, TP2);
    4388:	41 e0       	ldi	r20, 0x01	; 1
    438a:	60 e0       	ldi	r22, 0x00	; 0
    438c:	82 e0       	ldi	r24, 0x02	; 2
    438e:	0e 94 fd 24 	call	0x49fa	; 0x49fa <CheckProbes>
  CheckProbes(TP2, TP3, TP1);
    4392:	40 e0       	ldi	r20, 0x00	; 0
    4394:	62 e0       	ldi	r22, 0x02	; 2
    4396:	81 e0       	ldi	r24, 0x01	; 1
    4398:	0e 94 fd 24 	call	0x49fa	; 0x49fa <CheckProbes>
  CheckProbes(TP3, TP2, TP1);
    439c:	40 e0       	ldi	r20, 0x00	; 0
    439e:	61 e0       	ldi	r22, 0x01	; 1
    43a0:	82 e0       	ldi	r24, 0x02	; 2
    43a2:	0e 94 fd 24 	call	0x49fa	; 0x49fa <CheckProbes>

  /* if component might be a capacitor */
  if ((Check.Found == COMP_NONE) ||
    43a6:	89 81       	ldd	r24, Y+1	; 0x01
    43a8:	88 23       	and	r24, r24
    43aa:	11 f0       	breq	.+4      	; 0x43b0 <main+0x284>
    43ac:	8a 30       	cpi	r24, 0x0A	; 10
    43ae:	a1 f4       	brne	.+40     	; 0x43d8 <main+0x2ac>
      (Check.Found == COMP_RESISTOR))
  {
    /* tell user to be patient with large caps :-) */
    LCD_Space();
    43b0:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
    LCD_Char('C');    
    43b4:	83 e4       	ldi	r24, 0x43	; 67
    43b6:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>

    /* check all possible combinations */
    MeasureCap(TP3, TP1, 0);
    43ba:	40 e0       	ldi	r20, 0x00	; 0
    43bc:	60 e0       	ldi	r22, 0x00	; 0
    43be:	82 e0       	ldi	r24, 0x02	; 2
    43c0:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <MeasureCap>
    MeasureCap(TP3, TP2, 1);
    43c4:	41 e0       	ldi	r20, 0x01	; 1
    43c6:	61 e0       	ldi	r22, 0x01	; 1
    43c8:	82 e0       	ldi	r24, 0x02	; 2
    43ca:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <MeasureCap>
    MeasureCap(TP2, TP1, 2);
    43ce:	42 e0       	ldi	r20, 0x02	; 2
    43d0:	60 e0       	ldi	r22, 0x00	; 0
    43d2:	81 e0       	ldi	r24, 0x01	; 1
    43d4:	0e 94 dd 0e 	call	0x1dba	; 0x1dba <MeasureCap>
   *  output test results
   */

result:

  LCD_Clear();                     /* clear LCD */
    43d8:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
  LCD_NextLine_Mode(MODE_KEEP | MODE_KEY);
    43dc:	83 e0       	ldi	r24, 0x03	; 3
    43de:	0e 94 1a 10 	call	0x2034	; 0x2034 <LCD_NextLine_Mode>

  /* call output function based on component type */
  switch (Check.Found)
    43e2:	e9 81       	ldd	r30, Y+1	; 0x01
    43e4:	8e 2f       	mov	r24, r30
    43e6:	90 e0       	ldi	r25, 0x00	; 0
    43e8:	fc 01       	movw	r30, r24
    43ea:	31 97       	sbiw	r30, 0x01	; 1
    43ec:	e9 31       	cpi	r30, 0x19	; 25
    43ee:	f1 05       	cpc	r31, r1
    43f0:	f8 f4       	brcc	.+62     	; 0x4430 <main+0x304>
    43f2:	ec 5c       	subi	r30, 0xCC	; 204
    43f4:	ff 4f       	sbci	r31, 0xFF	; 255
    43f6:	0c 94 c7 36 	jmp	0x6d8e	; 0x6d8e <__tablejump2__>
  {
    case COMP_ERROR:
      Show_Error();
    43fa:	0e 94 6f 1b 	call	0x36de	; 0x36de <Show_Error>
      goto end;
    43fe:	22 c0       	rjmp	.+68     	; 0x4444 <main+0x318>
      break;

    case COMP_DIODE:
      Show_Diode();
    4400:	0e 94 e6 1c 	call	0x39cc	; 0x39cc <Show_Diode>
      break;
    4404:	18 c0       	rjmp	.+48     	; 0x4436 <main+0x30a>

    case COMP_BJT:
      Show_BJT();
    4406:	0e 94 f5 1e 	call	0x3dea	; 0x3dea <Show_BJT>
      break;
    440a:	15 c0       	rjmp	.+42     	; 0x4436 <main+0x30a>

    case COMP_FET:
      Show_FET();
    440c:	0e 94 20 20 	call	0x4040	; 0x4040 <Show_FET>
      break;
    4410:	12 c0       	rjmp	.+36     	; 0x4436 <main+0x30a>

    case COMP_IGBT:
      Show_IGBT();
    4412:	0e 94 50 20 	call	0x40a0	; 0x40a0 <Show_IGBT>
      break;
    4416:	0f c0       	rjmp	.+30     	; 0x4436 <main+0x30a>

    case COMP_THYRISTOR:
      Show_Special();
    4418:	0e 94 64 20 	call	0x40c8	; 0x40c8 <Show_Special>
      break;
    441c:	0c c0       	rjmp	.+24     	; 0x4436 <main+0x30a>

    case COMP_TRIAC:
      Show_Special();
    441e:	0e 94 64 20 	call	0x40c8	; 0x40c8 <Show_Special>
      break;
    4422:	09 c0       	rjmp	.+18     	; 0x4436 <main+0x30a>

    case COMP_RESISTOR:
      Show_Resistor();
    4424:	0e 94 a9 1b 	call	0x3752	; 0x3752 <Show_Resistor>
      break;
    4428:	06 c0       	rjmp	.+12     	; 0x4436 <main+0x30a>

    case COMP_CAPACITOR:
      Show_Capacitor();
    442a:	0e 94 7e 1c 	call	0x38fc	; 0x38fc <Show_Capacitor>
      break;
    442e:	03 c0       	rjmp	.+6      	; 0x4436 <main+0x30a>

    default:                  /* no component found */
      Show_Fail();
    4430:	0e 94 5f 1b 	call	0x36be	; 0x36be <Show_Fail>
      goto end;
    4434:	07 c0       	rjmp	.+14     	; 0x4444 <main+0x318>
  }

  /* component was found */
  RunsMissed = 0;             /* reset counter */
    4436:	10 92 8e 01 	sts	0x018E, r1
  RunsPassed++;               /* increase counter */
    443a:	80 91 80 01 	lds	r24, 0x0180
    443e:	8f 5f       	subi	r24, 0xFF	; 255
    4440:	80 93 80 01 	sts	0x0180, r24

  #ifdef HW_RELAY
  ADC_DDR = (1<<TP_REF);              /* short circuit probes */
  #endif

  LCD_NextLine_Mode(MODE_NONE);       /* reset next line mode */
    4444:	80 e0       	ldi	r24, 0x00	; 0
    4446:	0e 94 1a 10 	call	0x2034	; 0x2034 <LCD_NextLine_Mode>

  /* get key press or timeout */
  Test = TestKey((uint16_t)CYCLE_DELAY, 12);
    444a:	6c e0       	ldi	r22, 0x0C	; 12
    444c:	88 eb       	ldi	r24, 0xB8	; 184
    444e:	9b e0       	ldi	r25, 0x0B	; 11
    4450:	0e 94 58 33 	call	0x66b0	; 0x66b0 <TestKey>

  if (Test == 0)              /* timeout (no key press) */
    4454:	81 11       	cpse	r24, r1
    4456:	0a c0       	rjmp	.+20     	; 0x446c <main+0x340>
  {
    /* check if we reached the maximum number of rounds (continious mode only) */
    if ((RunsMissed >= CYCLE_MAX) || (RunsPassed >= CYCLE_MAX * 2))
    4458:	80 91 8e 01 	lds	r24, 0x018E
    445c:	85 30       	cpi	r24, 0x05	; 5
    445e:	d0 f4       	brcc	.+52     	; 0x4494 <main+0x368>
    4460:	80 91 80 01 	lds	r24, 0x0180
    4464:	8a 30       	cpi	r24, 0x0A	; 10
    4466:	08 f4       	brcc	.+2      	; 0x446a <main+0x33e>
    4468:	08 cf       	rjmp	.-496    	; 0x427a <main+0x14e>
    446a:	14 c0       	rjmp	.+40     	; 0x4494 <main+0x368>
    {
      goto power_off;              /* -> power off */
    }
  }
  else if (Test == 1)         /* short key press */
    446c:	81 30       	cpi	r24, 0x01	; 1
    446e:	79 f4       	brne	.+30     	; 0x448e <main+0x362>
  {
    /* a second key press triggers extra functions */
    MilliSleep(50);
    4470:	82 e3       	ldi	r24, 0x32	; 50
    4472:	90 e0       	ldi	r25, 0x00	; 0
    4474:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>
    Test = TestKey(300, 0);
    4478:	60 e0       	ldi	r22, 0x00	; 0
    447a:	8c e2       	ldi	r24, 0x2C	; 44
    447c:	91 e0       	ldi	r25, 0x01	; 1
    447e:	0e 94 58 33 	call	0x66b0	; 0x66b0 <TestKey>

    if (Test > 0)           /* short or long key press */
    4482:	88 23       	and	r24, r24
    4484:	09 f4       	brne	.+2      	; 0x4488 <main+0x35c>
    4486:	f9 ce       	rjmp	.-526    	; 0x427a <main+0x14e>
    {
      #ifdef HW_RELAY
      ADC_DDR = 0;               /* remove short circuit */
      #endif

      MainMenu();                /* enter main menu */
    4488:	0e 94 f6 35 	call	0x6bec	; 0x6bec <MainMenu>
      goto end;                  /* re-run cycle control */
    448c:	db cf       	rjmp	.-74     	; 0x4444 <main+0x318>
    }
  }
  else if (Test == 2)         /* long key press */
    448e:	82 30       	cpi	r24, 0x02	; 2
    4490:	09 f0       	breq	.+2      	; 0x4494 <main+0x368>
    4492:	f3 ce       	rjmp	.-538    	; 0x427a <main+0x14e>


power_off:

  /* display feedback (otherwise the user will wait :-) */
  LCD_Clear();
    4494:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
  #ifdef LCD_COLOR
    UI.PenColor = COLOR_BLUE;           /* set pen color */
  #endif
  LCD_EEString(Bye_str);
    4498:	89 e2       	ldi	r24, 0x29	; 41
    449a:	92 e0       	ldi	r25, 0x02	; 2
    449c:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
		);
	}
	else
	{
        uint8_t register temp_reg;
		__asm__ __volatile__ (
    44a0:	0f b6       	in	r0, 0x3f	; 63
    44a2:	f8 94       	cli
    44a4:	a8 95       	wdr
    44a6:	80 91 60 00 	lds	r24, 0x0060
    44aa:	88 61       	ori	r24, 0x18	; 24
    44ac:	80 93 60 00 	sts	0x0060, r24
    44b0:	10 92 60 00 	sts	0x0060, r1
    44b4:	0f be       	out	0x3f, r0	; 63

  wdt_disable();                        /* disable watchdog */
  CONTROL_PORT &= ~(1 << POWER_CTRL);   /* power off myself */
    44b6:	5e 98       	cbi	0x0b, 6	; 11

  return 0;
    44b8:	0d c0       	rjmp	.+26     	; 0x44d4 <main+0x3a8>

  /* key press >300ms sets autohold mode */
  if (Test > 1) UI.TesterMode = MODE_AUTOHOLD;

  /* init LCD module */
  LCD_Init();                           /* initialize LCD */
    44ba:	0e 94 62 30 	call	0x60c4	; 0x60c4 <LCD_Init>
  LCD_NextLine_Mode(MODE_NONE);         /* reset line mode */
    44be:	80 e0       	ldi	r24, 0x00	; 0
    44c0:	0e 94 1a 10 	call	0x2034	; 0x2034 <LCD_NextLine_Mode>
    44c4:	92 ce       	rjmp	.-732    	; 0x41ea <main+0xbe>
    {
      MilliSleep(20);
      if (!(CONTROL_PIN & (1 << TEST_BUTTON)))    /* if button is still pressed */
      {
        RunsMissed++;
        if (RunsMissed > 100) Test = 3;      /* >2000ms */
    44c6:	c3 e0       	ldi	r28, 0x03	; 3
    44c8:	01 c0       	rjmp	.+2      	; 0x44cc <main+0x3a0>
      }
      else                                        /* button released */
      {
        Test = 1;                            /* <300ms */
        if (RunsMissed > 15) Test = 2;       /* >300ms */
    44ca:	c2 e0       	ldi	r28, 0x02	; 2
      }
    }
  }

  /* key press >300ms sets autohold mode */
  if (Test > 1) UI.TesterMode = MODE_AUTOHOLD;
    44cc:	81 e0       	ldi	r24, 0x01	; 1
    44ce:	80 93 26 01 	sts	0x0126, r24
    44d2:	81 ce       	rjmp	.-766    	; 0x41d6 <main+0xaa>

  wdt_disable();                        /* disable watchdog */
  CONTROL_PORT &= ~(1 << POWER_CTRL);   /* power off myself */

  return 0;
}
    44d4:	80 e0       	ldi	r24, 0x00	; 0
    44d6:	90 e0       	ldi	r25, 0x00	; 0
    44d8:	df 91       	pop	r29
    44da:	cf 91       	pop	r28
    44dc:	1f 91       	pop	r17
    44de:	0f 91       	pop	r16
    44e0:	ff 90       	pop	r15
    44e2:	ef 90       	pop	r14
    44e4:	df 90       	pop	r13
    44e6:	cf 90       	pop	r12
    44e8:	bf 90       	pop	r11
    44ea:	af 90       	pop	r10
    44ec:	9f 90       	pop	r9
    44ee:	8f 90       	pop	r8
    44f0:	08 95       	ret

000044f2 <__vector_7>:
/*
 *  ISR for a match of TCNT2 (Timer2) and OCR2A (Output Compare Register A)
 */

ISR(TIMER2_COMPA_vect, ISR_BLOCK)
{
    44f2:	1f 92       	push	r1
    44f4:	0f 92       	push	r0
    44f6:	0f b6       	in	r0, 0x3f	; 63
    44f8:	0f 92       	push	r0
    44fa:	11 24       	eor	r1, r1
  /* this automatically clears the OCF2A flag in the Interrupt Flag Register */

  sei();                      /* allow nested interrupts */
    44fc:	78 94       	sei
  TCCR2B = 0;                 /* disable Timer2 */
    44fe:	10 92 b1 00 	sts	0x00B1, r1
}
    4502:	0f 90       	pop	r0
    4504:	0f be       	out	0x3f, r0	; 63
    4506:	0f 90       	pop	r0
    4508:	1f 90       	pop	r1
    450a:	18 95       	reti

0000450c <MilliSleep>:
 *  - valid time 0 - 65535ms
 *  - don't use this function for time critical stuff!
 */

void MilliSleep(uint16_t Time)
{
    450c:	0f 93       	push	r16
    450e:	1f 93       	push	r17
    4510:	cf 93       	push	r28
    4512:	df 93       	push	r29
      We don't compensate the binary to decimal offset and also not the time
      required for the processing loop, because it would make things much more
      complicated and we don't need exact timing here.
  */

  Mode = Config.SleepMode;              /* get requested sleep mode */
    4514:	30 91 ab 01 	lds	r19, 0x01AB

  /* calculate required timer cycles (prescaler 1024) */
  Cycles = Time;
    4518:	a0 e0       	ldi	r26, 0x00	; 0
    451a:	b0 e0       	ldi	r27, 0x00	; 0
  Cycles *= (CPU_FREQ / 1000000);       /* timer cycles based on MCU frequency */
    451c:	88 0f       	add	r24, r24
    451e:	99 1f       	adc	r25, r25
    4520:	aa 1f       	adc	r26, r26
    4522:	bb 1f       	adc	r27, r27
    4524:	88 0f       	add	r24, r24
    4526:	99 1f       	adc	r25, r25
    4528:	aa 1f       	adc	r26, r26
    452a:	bb 1f       	adc	r27, r27
    452c:	88 0f       	add	r24, r24
    452e:	99 1f       	adc	r25, r25
    4530:	aa 1f       	adc	r26, r26
    4532:	bb 1f       	adc	r27, r27
    4534:	88 0f       	add	r24, r24
    4536:	99 1f       	adc	r25, r25
    4538:	aa 1f       	adc	r26, r26
    453a:	bb 1f       	adc	r27, r27

  if (Mode == SLEEP_MODE_PWR_SAVE)      /* power save mode */
    453c:	36 30       	cpi	r19, 0x06	; 6
    453e:	19 f5       	brne	.+70     	; 0x4586 <MilliSleep+0x7a>
     *  - ceramic resonator:   1k or 256 cycles
     *  - internal RC osc.:    6 cycles
     */

    /* compensate oscillator start-up */
    Value = Cycles / 256;               /* calculate loop runs */
    4540:	49 2f       	mov	r20, r25
    4542:	5a 2f       	mov	r21, r26
    4544:	6b 2f       	mov	r22, r27
    4546:	77 27       	eor	r23, r23
    Value++;                            /* fix offset by division */
    4548:	4f 5f       	subi	r20, 0xFF	; 255
    454a:	5f 4f       	sbci	r21, 0xFF	; 255
    454c:	6f 4f       	sbci	r22, 0xFF	; 255
    454e:	7f 4f       	sbci	r23, 0xFF	; 255
    /* multiply with startup cycles equivalent to timer cycles */
    Value *= (OSC_STARTUP / 1024);      /* overhead cycles */
    4550:	44 0f       	add	r20, r20
    4552:	55 1f       	adc	r21, r21
    4554:	66 1f       	adc	r22, r22
    4556:	77 1f       	adc	r23, r23
    4558:	44 0f       	add	r20, r20
    455a:	55 1f       	adc	r21, r21
    455c:	66 1f       	adc	r22, r22
    455e:	77 1f       	adc	r23, r23
    4560:	44 0f       	add	r20, r20
    4562:	55 1f       	adc	r21, r21
    4564:	66 1f       	adc	r22, r22
    4566:	77 1f       	adc	r23, r23
    4568:	44 0f       	add	r20, r20
    456a:	55 1f       	adc	r21, r21
    456c:	66 1f       	adc	r22, r22
    456e:	77 1f       	adc	r23, r23

    if (Cycles > Value)            /* we are able to compensate */
    4570:	48 17       	cp	r20, r24
    4572:	59 07       	cpc	r21, r25
    4574:	6a 07       	cpc	r22, r26
    4576:	7b 07       	cpc	r23, r27
    4578:	28 f4       	brcc	.+10     	; 0x4584 <MilliSleep+0x78>
    {
      Cycles -= Value;                  /* subtract overhead cycles */
    457a:	84 1b       	sub	r24, r20
    457c:	95 0b       	sbc	r25, r21
    457e:	a6 0b       	sbc	r26, r22
    4580:	b7 0b       	sbc	r27, r23
    4582:	01 c0       	rjmp	.+2      	; 0x4586 <MilliSleep+0x7a>
    }
    else                           /* no way to compensate */
    {
      /* idle mode doesn't require oscillator start-up after wake-up */ 
      Mode = SLEEP_MODE_IDLE;           /* change sleep mode to Idle */
    4584:	30 e0       	ldi	r19, 0x00	; 0

  /*
   *  setup timer
   */

  TCCR2B = 0;                      /* disable timer */
    4586:	10 92 b1 00 	sts	0x00B1, r1
  TCCR2A = (1 << WGM21);           /* set CTC mode */
    458a:	22 e0       	ldi	r18, 0x02	; 2
    458c:	20 93 b0 00 	sts	0x00B0, r18
  TIMSK2 = (1 << OCIE2A);          /* enable interrupt for OCR0A match */
    4590:	20 93 70 00 	sts	0x0070, r18

  set_sleep_mode(Mode);            /* set sleep mode */
    4594:	23 b7       	in	r18, 0x33	; 51
    4596:	21 7f       	andi	r18, 0xF1	; 241
    4598:	23 2b       	or	r18, r19
    459a:	23 bf       	out	0x33, r18	; 51
  if (SREG & SREG_I) Flag = 1;     /* check if interrupts are enabled already */
    459c:	7f b7       	in	r23, 0x3f	; 63
    459e:	77 70       	andi	r23, 0x07	; 7
  sei();                           /* enable interrupts */
    45a0:	78 94       	sei
  /*
   *  processing loop
   *  - sleep for several intervals until requested time is reached
   */

  while (Cycles > 0)
    45a2:	00 97       	sbiw	r24, 0x00	; 0
    45a4:	a1 05       	cpc	r26, r1
    45a6:	b1 05       	cpc	r27, r1
    45a8:	39 f1       	breq	.+78     	; 0x45f8 <MilliSleep+0xec>
  {
    wdt_reset();              /* reset watchdog */

    /* get timeout */
    if (Cycles > 255) Timeout = 255;
    45aa:	6f ef       	ldi	r22, 0xFF	; 255
    Cycles -= Timeout;
    Timeout--;                     /* interrupt is triggered by cycle after match */
    /* todo: what happens if Timeout is 0? */

    /* update timer */
    TCNT2 = 0;                     /* set counter to 0 */
    45ac:	42 eb       	ldi	r20, 0xB2	; 178
    45ae:	50 e0       	ldi	r21, 0x00	; 0
    OCR2A = Timeout;               /* set value to compare with (timeout) */
    45b0:	c3 eb       	ldi	r28, 0xB3	; 179
    45b2:	d0 e0       	ldi	r29, 0x00	; 0

    /* sleep */
    /* enable timer by setting clock prescaler to 1024 */
    TCCR2B = (1 << CS22) | (1 << CS21) | (1 << CS20);
    45b4:	01 eb       	ldi	r16, 0xB1	; 177
    45b6:	10 e0       	ldi	r17, 0x00	; 0
    45b8:	37 e0       	ldi	r19, 0x07	; 7
   *  - sleep for several intervals until requested time is reached
   */

  while (Cycles > 0)
  {
    wdt_reset();              /* reset watchdog */
    45ba:	a8 95       	wdr

    /* get timeout */
    if (Cycles > 255) Timeout = 255;
    45bc:	8f 3f       	cpi	r24, 0xFF	; 255
    45be:	91 05       	cpc	r25, r1
    45c0:	a1 05       	cpc	r26, r1
    45c2:	b1 05       	cpc	r27, r1
    45c4:	09 f0       	breq	.+2      	; 0x45c8 <MilliSleep+0xbc>
    45c6:	10 f4       	brcc	.+4      	; 0x45cc <MilliSleep+0xc0>
    else Timeout = Cycles;
    45c8:	28 2f       	mov	r18, r24
    45ca:	01 c0       	rjmp	.+2      	; 0x45ce <MilliSleep+0xc2>
  while (Cycles > 0)
  {
    wdt_reset();              /* reset watchdog */

    /* get timeout */
    if (Cycles > 255) Timeout = 255;
    45cc:	26 2f       	mov	r18, r22
    else Timeout = Cycles;
    Cycles -= Timeout;
    45ce:	82 1b       	sub	r24, r18
    45d0:	91 09       	sbc	r25, r1
    45d2:	a1 09       	sbc	r26, r1
    45d4:	b1 09       	sbc	r27, r1
    Timeout--;                     /* interrupt is triggered by cycle after match */
    45d6:	21 50       	subi	r18, 0x01	; 1
    /* todo: what happens if Timeout is 0? */

    /* update timer */
    TCNT2 = 0;                     /* set counter to 0 */
    45d8:	fa 01       	movw	r30, r20
    45da:	10 82       	st	Z, r1
    OCR2A = Timeout;               /* set value to compare with (timeout) */
    45dc:	28 83       	st	Y, r18

    /* sleep */
    /* enable timer by setting clock prescaler to 1024 */
    TCCR2B = (1 << CS22) | (1 << CS21) | (1 << CS20);
    45de:	f8 01       	movw	r30, r16
    45e0:	30 83       	st	Z, r19

    sleep_mode();                            /* and sleep */    
    45e2:	23 b7       	in	r18, 0x33	; 51
    45e4:	21 60       	ori	r18, 0x01	; 1
    45e6:	23 bf       	out	0x33, r18	; 51
    45e8:	88 95       	sleep
    45ea:	23 b7       	in	r18, 0x33	; 51
    45ec:	2e 7f       	andi	r18, 0xFE	; 254
    45ee:	23 bf       	out	0x33, r18	; 51
  /*
   *  processing loop
   *  - sleep for several intervals until requested time is reached
   */

  while (Cycles > 0)
    45f0:	00 97       	sbiw	r24, 0x00	; 0
    45f2:	a1 05       	cpc	r26, r1
    45f4:	b1 05       	cpc	r27, r1
    45f6:	09 f7       	brne	.-62     	; 0x45ba <MilliSleep+0xae>
    sleep_mode();                            /* and sleep */    

    /* after wakeup */
  }

  if (Flag == 0) cli();            /* disable interrupts */
    45f8:	71 11       	cpse	r23, r1
    45fa:	01 c0       	rjmp	.+2      	; 0x45fe <MilliSleep+0xf2>
    45fc:	f8 94       	cli
}
    45fe:	df 91       	pop	r29
    4600:	cf 91       	pop	r28
    4602:	1f 91       	pop	r17
    4604:	0f 91       	pop	r16
    4606:	08 95       	ret

00004608 <UpdateProbes>:
 *  - Probe2: pin ID [0-2], mostly low level pin
 *  - Probe3: pin ID [0-2], mostly switch/gate pin
 */

void UpdateProbes(uint8_t Probe1, uint8_t Probe2, uint8_t Probe3)
{
    4608:	cf 92       	push	r12
    460a:	df 92       	push	r13
    460c:	ef 92       	push	r14
    460e:	ff 92       	push	r15
    4610:	0f 93       	push	r16
    4612:	1f 93       	push	r17
    4614:	cf 93       	push	r28
    4616:	df 93       	push	r29
    4618:	e6 2e       	mov	r14, r22
    461a:	04 2f       	mov	r16, r20
  /* set probe IDs */
  Probes.Pin_1 = Probe1;
    461c:	cf e8       	ldi	r28, 0x8F	; 143
    461e:	d1 e0       	ldi	r29, 0x01	; 1
    4620:	88 83       	st	Y, r24
  Probes.Pin_2 = Probe2;
    4622:	69 83       	std	Y+1, r22	; 0x01
  Probes.Pin_3 = Probe3;
    4624:	4a 83       	std	Y+2, r20	; 0x02

  /* setup masks using bitmask tables */
  Probes.Rl_1 = eeprom_read_byte(&Rl_table[Probe1]);
    4626:	c8 2e       	mov	r12, r24
    4628:	d1 2c       	mov	r13, r1
    462a:	c6 01       	movw	r24, r12
    462c:	8a 5f       	subi	r24, 0xFA	; 250
    462e:	9f 4f       	sbci	r25, 0xFF	; 255
    4630:	0e 94 18 37 	call	0x6e30	; 0x6e30 <eeprom_read_byte>
    4634:	8b 83       	std	Y+3, r24	; 0x03
  Probes.Rh_1 = Probes.Rl_1 + Probes.Rl_1;
    4636:	88 0f       	add	r24, r24
    4638:	8c 83       	std	Y+4, r24	; 0x04
  Probes.ADC_1 = eeprom_read_byte(&ADC_table[Probe1]);
    463a:	c6 01       	movw	r24, r12
    463c:	80 50       	subi	r24, 0x00	; 0
    463e:	90 40       	sbci	r25, 0x00	; 0
    4640:	0e 94 18 37 	call	0x6e30	; 0x6e30 <eeprom_read_byte>
    4644:	89 87       	std	Y+9, r24	; 0x09
  Probes.Rl_2 = eeprom_read_byte(&Rl_table[Probe2]);
    4646:	f1 2c       	mov	r15, r1
    4648:	c7 01       	movw	r24, r14
    464a:	8a 5f       	subi	r24, 0xFA	; 250
    464c:	9f 4f       	sbci	r25, 0xFF	; 255
    464e:	0e 94 18 37 	call	0x6e30	; 0x6e30 <eeprom_read_byte>
    4652:	8d 83       	std	Y+5, r24	; 0x05
  Probes.Rh_2 = Probes.Rl_2 + Probes.Rl_2;
    4654:	88 0f       	add	r24, r24
    4656:	8e 83       	std	Y+6, r24	; 0x06
  Probes.ADC_2 = eeprom_read_byte(&ADC_table[Probe2]);
    4658:	c7 01       	movw	r24, r14
    465a:	80 50       	subi	r24, 0x00	; 0
    465c:	90 40       	sbci	r25, 0x00	; 0
    465e:	0e 94 18 37 	call	0x6e30	; 0x6e30 <eeprom_read_byte>
    4662:	8a 87       	std	Y+10, r24	; 0x0a
  Probes.Rl_3 = eeprom_read_byte(&Rl_table[Probe3]);
    4664:	10 e0       	ldi	r17, 0x00	; 0
    4666:	c8 01       	movw	r24, r16
    4668:	8a 5f       	subi	r24, 0xFA	; 250
    466a:	9f 4f       	sbci	r25, 0xFF	; 255
    466c:	0e 94 18 37 	call	0x6e30	; 0x6e30 <eeprom_read_byte>
    4670:	8f 83       	std	Y+7, r24	; 0x07
  Probes.Rh_3 = Probes.Rl_3 + Probes.Rl_3;
    4672:	88 0f       	add	r24, r24
    4674:	88 87       	std	Y+8, r24	; 0x08
  Probes.ADC_3 = eeprom_read_byte(&ADC_table[Probe3]);
    4676:	c8 01       	movw	r24, r16
    4678:	80 50       	subi	r24, 0x00	; 0
    467a:	90 40       	sbci	r25, 0x00	; 0
    467c:	0e 94 18 37 	call	0x6e30	; 0x6e30 <eeprom_read_byte>
    4680:	8b 87       	std	Y+11, r24	; 0x0b
}
    4682:	df 91       	pop	r29
    4684:	cf 91       	pop	r28
    4686:	1f 91       	pop	r17
    4688:	0f 91       	pop	r16
    468a:	ff 90       	pop	r15
    468c:	ef 90       	pop	r14
    468e:	df 90       	pop	r13
    4690:	cf 90       	pop	r12
    4692:	08 95       	ret

00004694 <ShortedProbes>:
 *  - 0 if not shorted
 *  - 1 if shorted
 */

uint8_t ShortedProbes(uint8_t Probe1, uint8_t Probe2)
{
    4694:	0f 93       	push	r16
    4696:	1f 93       	push	r17
    4698:	cf 93       	push	r28
    469a:	df 93       	push	r29
    469c:	08 2f       	mov	r16, r24
    469e:	16 2f       	mov	r17, r22
   *  - Probe1: Rl pull-up
   *  - Probe2: Rl pull-down
   *  - third probe: HiZ
   */

  R_PORT = eeprom_read_byte(&Rl_table[Probe1]);
    46a0:	c8 2f       	mov	r28, r24
    46a2:	d0 e0       	ldi	r29, 0x00	; 0
    46a4:	ca 5f       	subi	r28, 0xFA	; 250
    46a6:	df 4f       	sbci	r29, 0xFF	; 255
    46a8:	ce 01       	movw	r24, r28
    46aa:	0e 94 18 37 	call	0x6e30	; 0x6e30 <eeprom_read_byte>
    46ae:	85 b9       	out	0x05, r24	; 5
  R_DDR = eeprom_read_byte(&Rl_table[Probe1]) | eeprom_read_byte(&Rl_table[Probe2]);
    46b0:	ce 01       	movw	r24, r28
    46b2:	0e 94 18 37 	call	0x6e30	; 0x6e30 <eeprom_read_byte>
    46b6:	c8 2f       	mov	r28, r24
    46b8:	81 2f       	mov	r24, r17
    46ba:	90 e0       	ldi	r25, 0x00	; 0
    46bc:	8a 5f       	subi	r24, 0xFA	; 250
    46be:	9f 4f       	sbci	r25, 0xFF	; 255
    46c0:	0e 94 18 37 	call	0x6e30	; 0x6e30 <eeprom_read_byte>
    46c4:	8c 2b       	or	r24, r28
    46c6:	84 b9       	out	0x04, r24	; 4

  /* read voltages */
  U1 = ReadU(Probe1);
    46c8:	80 2f       	mov	r24, r16
    46ca:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    46ce:	ec 01       	movw	r28, r24
  U2 = ReadU(Probe2);
    46d0:	81 2f       	mov	r24, r17
    46d2:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    46d6:	bc 01       	movw	r22, r24
  /*
   *  We expect both probe voltages to be about the same and
   *  to be half of Vcc (allowed difference +/- 30mV).
   */

  Min = (Config.Vcc / 2) - 30;     /* lower voltage */
    46d8:	20 91 b1 01 	lds	r18, 0x01B1
    46dc:	30 91 b2 01 	lds	r19, 0x01B2
    46e0:	36 95       	lsr	r19
    46e2:	27 95       	ror	r18
    46e4:	a9 01       	movw	r20, r18
    46e6:	4e 51       	subi	r20, 0x1E	; 30
    46e8:	51 09       	sbc	r21, r1
  Max = (Config.Vcc / 2) + 30;     /* upper voltage */

  if ((U1 > Min) && (U1 < Max))
    46ea:	4c 17       	cp	r20, r28
    46ec:	5d 07       	cpc	r21, r29
    46ee:	70 f4       	brcc	.+28     	; 0x470c <ShortedProbes+0x78>
   *  We expect both probe voltages to be about the same and
   *  to be half of Vcc (allowed difference +/- 30mV).
   */

  Min = (Config.Vcc / 2) - 30;     /* lower voltage */
  Max = (Config.Vcc / 2) + 30;     /* upper voltage */
    46f0:	22 5e       	subi	r18, 0xE2	; 226
    46f2:	3f 4f       	sbci	r19, 0xFF	; 255

  if ((U1 > Min) && (U1 < Max))
    46f4:	c2 17       	cp	r28, r18
    46f6:	d3 07       	cpc	r29, r19
    46f8:	58 f4       	brcc	.+22     	; 0x4710 <ShortedProbes+0x7c>
  { 
    if ((U2 > Min) && (U2 < Max))
    46fa:	48 17       	cp	r20, r24
    46fc:	59 07       	cpc	r21, r25
    46fe:	50 f4       	brcc	.+20     	; 0x4714 <ShortedProbes+0x80>
    4700:	81 e0       	ldi	r24, 0x01	; 1
    4702:	62 17       	cp	r22, r18
    4704:	73 07       	cpc	r23, r19
    4706:	38 f0       	brcs	.+14     	; 0x4716 <ShortedProbes+0x82>
    4708:	80 e0       	ldi	r24, 0x00	; 0
    470a:	05 c0       	rjmp	.+10     	; 0x4716 <ShortedProbes+0x82>
 *  - 1 if shorted
 */

uint8_t ShortedProbes(uint8_t Probe1, uint8_t Probe2)
{
  uint8_t           Flag = 0;      /* return value */
    470c:	80 e0       	ldi	r24, 0x00	; 0
    470e:	03 c0       	rjmp	.+6      	; 0x4716 <ShortedProbes+0x82>
    4710:	80 e0       	ldi	r24, 0x00	; 0
    4712:	01 c0       	rjmp	.+2      	; 0x4716 <ShortedProbes+0x82>
    4714:	80 e0       	ldi	r24, 0x00	; 0
      Flag = 1;
    }    
  }

  /* reset port */
  R_DDR = 0;
    4716:	14 b8       	out	0x04, r1	; 4

  return Flag;
}
    4718:	df 91       	pop	r29
    471a:	cf 91       	pop	r28
    471c:	1f 91       	pop	r17
    471e:	0f 91       	pop	r16
    4720:	08 95       	ret

00004722 <AllProbesShorted>:
 *  - 0 if no probes are short-circuited
 *  - number of probe pairs short-circuited (3 = all)
 */

uint8_t AllProbesShorted(void)
{
    4722:	cf 93       	push	r28
  uint8_t           Flag = 0;      /* return value */

  /* check all possible combinations */
  Flag = ShortedProbes(TP1, TP2);
    4724:	61 e0       	ldi	r22, 0x01	; 1
    4726:	80 e0       	ldi	r24, 0x00	; 0
    4728:	0e 94 4a 23 	call	0x4694	; 0x4694 <ShortedProbes>
    472c:	c8 2f       	mov	r28, r24
  Flag += ShortedProbes(TP1, TP3);
    472e:	62 e0       	ldi	r22, 0x02	; 2
    4730:	80 e0       	ldi	r24, 0x00	; 0
    4732:	0e 94 4a 23 	call	0x4694	; 0x4694 <ShortedProbes>
    4736:	c8 0f       	add	r28, r24
  Flag += ShortedProbes(TP2, TP3);
    4738:	62 e0       	ldi	r22, 0x02	; 2
    473a:	81 e0       	ldi	r24, 0x01	; 1
    473c:	0e 94 4a 23 	call	0x4694	; 0x4694 <ShortedProbes>

  return Flag;  
}
    4740:	8c 0f       	add	r24, r28
    4742:	cf 91       	pop	r28
    4744:	08 95       	ret

00004746 <DischargeProbes>:
 *  - detect batteries
 *  - sometimes large caps are detected as a battery
 */

void DischargeProbes(void)
{
    4746:	5f 92       	push	r5
    4748:	6f 92       	push	r6
    474a:	7f 92       	push	r7
    474c:	8f 92       	push	r8
    474e:	9f 92       	push	r9
    4750:	af 92       	push	r10
    4752:	bf 92       	push	r11
    4754:	cf 92       	push	r12
    4756:	df 92       	push	r13
    4758:	ef 92       	push	r14
    475a:	ff 92       	push	r15
    475c:	0f 93       	push	r16
    475e:	1f 93       	push	r17
    4760:	cf 93       	push	r28
    4762:	df 93       	push	r29
    4764:	00 d0       	rcall	.+0      	; 0x4766 <DischargeProbes+0x20>
    4766:	00 d0       	rcall	.+0      	; 0x4768 <DischargeProbes+0x22>
    4768:	00 d0       	rcall	.+0      	; 0x476a <DischargeProbes+0x24>
    476a:	cd b7       	in	r28, 0x3d	; 61
    476c:	de b7       	in	r29, 0x3e	; 62
  /*
   *  set probes to a save discharge mode (pull-down via Rh) 
   */

  /* set ADC port to HiZ input */
  ADC_DDR = 0;
    476e:	17 b8       	out	0x07, r1	; 7
  ADC_PORT = 0;
    4770:	18 b8       	out	0x08, r1	; 8

  /* all probe pins: Rh and Rl pull-down */
  R_PORT = 0;
    4772:	15 b8       	out	0x05, r1	; 5
  R_DDR = (2 << (TP1 * 2)) | (2 << (TP2 * 2)) | (2 << (TP3 * 2));
    4774:	8a e2       	ldi	r24, 0x2A	; 42
    4776:	84 b9       	out	0x04, r24	; 4
  R_DDR |= (1 << (TP1 * 2)) | (1 << (TP2 * 2)) | (1 << (TP3 * 2));
    4778:	84 b1       	in	r24, 0x04	; 4
    477a:	85 61       	ori	r24, 0x15	; 21
    477c:	84 b9       	out	0x04, r24	; 4

  /* get current voltages */
  U_old[0] = ReadU(TP1);
    477e:	80 e0       	ldi	r24, 0x00	; 0
    4780:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    4784:	9a 83       	std	Y+2, r25	; 0x02
    4786:	89 83       	std	Y+1, r24	; 0x01
  U_old[1] = ReadU(TP2);
    4788:	81 e0       	ldi	r24, 0x01	; 1
    478a:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    478e:	9c 83       	std	Y+4, r25	; 0x04
    4790:	8b 83       	std	Y+3, r24	; 0x03
  U_old[2] = ReadU(TP3);
    4792:	82 e0       	ldi	r24, 0x02	; 2
    4794:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    4798:	9e 83       	std	Y+6, r25	; 0x06
    479a:	8d 83       	std	Y+5, r24	; 0x05
   *    maybe never :-)
   */

  Counter = 1;
  ID = 2;
  DischargeMask = 0;
    479c:	00 e0       	ldi	r16, 0x00	; 0
   *  - A very large cap will discharge too slowly and an external voltage
   *    maybe never :-)
   */

  Counter = 1;
  ID = 2;
    479e:	12 e0       	ldi	r17, 0x02	; 2
 */

void DischargeProbes(void)
{
  uint8_t           Counter;            /* loop control */
  uint8_t           Limit = 40;         /* sliding timeout (2s) */
    47a0:	0f 2e       	mov	r0, r31
    47a2:	f8 e2       	ldi	r31, 0x28	; 40
    47a4:	af 2e       	mov	r10, r31
    47a6:	f0 2d       	mov	r31, r0
   *    large caps.
   *  - A very large cap will discharge too slowly and an external voltage
   *    maybe never :-)
   */

  Counter = 1;
    47a8:	bb 24       	eor	r11, r11
    47aa:	b3 94       	inc	r11
  DischargeMask = 0;

  while (Counter > 0)
  {
    ID++;                               /* next probe */
    if (ID > 2) ID = 0;                 /* start with probe #1 again */
    47ac:	71 2c       	mov	r7, r1
      Counter++;              /* increase no-changes counter */
    }

    if (U_c <= CAP_DISCHARGED)          /* seems to be discharged */
    {
      DischargeMask |= (1 << ID);       /* set flag */
    47ae:	cc 24       	eor	r12, r12
    47b0:	c3 94       	inc	r12
    47b2:	d1 2c       	mov	r13, r1
      {
        /* increase timeout while preventing overflow */
        if (Limit < (255 - 20)) Limit += 20;
      }

      Counter = 1;                      /* reset no-changes counter */
    47b4:	66 24       	eor	r6, r6
    47b6:	63 94       	inc	r6
  ID = 2;
  DischargeMask = 0;

  while (Counter > 0)
  {
    ID++;                               /* next probe */
    47b8:	1f 5f       	subi	r17, 0xFF	; 255
    if (ID > 2) ID = 0;                 /* start with probe #1 again */
    47ba:	13 30       	cpi	r17, 0x03	; 3
    47bc:	08 f0       	brcs	.+2      	; 0x47c0 <DischargeProbes+0x7a>
    47be:	17 2d       	mov	r17, r7

    if (DischargeMask & (1 << ID))      /* skip discharged probe */
    47c0:	e1 2e       	mov	r14, r17
    47c2:	f1 2c       	mov	r15, r1
    47c4:	20 2f       	mov	r18, r16
    47c6:	30 e0       	ldi	r19, 0x00	; 0
    47c8:	01 2e       	mov	r0, r17
    47ca:	02 c0       	rjmp	.+4      	; 0x47d0 <DischargeProbes+0x8a>
    47cc:	35 95       	asr	r19
    47ce:	27 95       	ror	r18
    47d0:	0a 94       	dec	r0
    47d2:	e2 f7       	brpl	.-8      	; 0x47cc <DischargeProbes+0x86>
    47d4:	20 fd       	sbrc	r18, 0
    47d6:	65 c0       	rjmp	.+202    	; 0x48a2 <DischargeProbes+0x15c>
      continue;

    U_c = ReadU(ID);                    /* get voltage of probe */
    47d8:	81 2f       	mov	r24, r17
    47da:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    47de:	4c 01       	movw	r8, r24

    if (U_c < U_old[ID])                /* voltage decreased */
    47e0:	f7 01       	movw	r30, r14
    47e2:	ee 0f       	add	r30, r30
    47e4:	ff 1f       	adc	r31, r31
    47e6:	81 e0       	ldi	r24, 0x01	; 1
    47e8:	90 e0       	ldi	r25, 0x00	; 0
    47ea:	8c 0f       	add	r24, r28
    47ec:	9d 1f       	adc	r25, r29
    47ee:	e8 0f       	add	r30, r24
    47f0:	f9 1f       	adc	r31, r25
    47f2:	80 81       	ld	r24, Z
    47f4:	91 81       	ldd	r25, Z+1	; 0x01
    47f6:	88 16       	cp	r8, r24
    47f8:	99 06       	cpc	r9, r25
    47fa:	c0 f4       	brcc	.+48     	; 0x482c <DischargeProbes+0xe6>
    {
      U_old[ID] = U_c;                  /* update old value */
    47fc:	f7 01       	movw	r30, r14
    47fe:	ee 0f       	add	r30, r30
    4800:	ff 1f       	adc	r31, r31
    4802:	81 e0       	ldi	r24, 0x01	; 1
    4804:	90 e0       	ldi	r25, 0x00	; 0
    4806:	8c 0f       	add	r24, r28
    4808:	9d 1f       	adc	r25, r29
    480a:	e8 0f       	add	r30, r24
    480c:	f9 1f       	adc	r31, r25
    480e:	91 82       	std	Z+1, r9	; 0x01
    4810:	80 82       	st	Z, r8

      /* adapt timeout based on discharge rate */
      if ((Limit - Counter) < 20)
    4812:	8a 2d       	mov	r24, r10
    4814:	90 e0       	ldi	r25, 0x00	; 0
    4816:	8b 19       	sub	r24, r11
    4818:	91 09       	sbc	r25, r1
    481a:	44 97       	sbiw	r24, 0x14	; 20
    481c:	a4 f4       	brge	.+40     	; 0x4846 <DischargeProbes+0x100>
      {
        /* increase timeout while preventing overflow */
        if (Limit < (255 - 20)) Limit += 20;
    481e:	9a ee       	ldi	r25, 0xEA	; 234
    4820:	9a 15       	cp	r25, r10
    4822:	98 f0       	brcs	.+38     	; 0x484a <DischargeProbes+0x104>
    4824:	84 e1       	ldi	r24, 0x14	; 20
    4826:	a8 0e       	add	r10, r24
      }

      Counter = 1;                      /* reset no-changes counter */
    4828:	b6 2c       	mov	r11, r6
    482a:	10 c0       	rjmp	.+32     	; 0x484c <DischargeProbes+0x106>
    }
    else                                /* voltage not decreased */
    {
      /* increase limit if we start at a low voltage */
      if ((U_c < 10) && (Limit <= 40)) Limit = 80;
    482c:	9a e0       	ldi	r25, 0x0A	; 10
    482e:	89 16       	cp	r8, r25
    4830:	91 04       	cpc	r9, r1
    4832:	38 f4       	brcc	.+14     	; 0x4842 <DischargeProbes+0xfc>
    4834:	88 e2       	ldi	r24, 0x28	; 40
    4836:	8a 15       	cp	r24, r10
    4838:	20 f0       	brcs	.+8      	; 0x4842 <DischargeProbes+0xfc>
    483a:	0f 2e       	mov	r0, r31
    483c:	f0 e5       	ldi	r31, 0x50	; 80
    483e:	af 2e       	mov	r10, r31
    4840:	f0 2d       	mov	r31, r0

      Counter++;              /* increase no-changes counter */
    4842:	b3 94       	inc	r11
    4844:	03 c0       	rjmp	.+6      	; 0x484c <DischargeProbes+0x106>
      {
        /* increase timeout while preventing overflow */
        if (Limit < (255 - 20)) Limit += 20;
      }

      Counter = 1;                      /* reset no-changes counter */
    4846:	b6 2c       	mov	r11, r6
    4848:	01 c0       	rjmp	.+2      	; 0x484c <DischargeProbes+0x106>
    484a:	b6 2c       	mov	r11, r6
      if ((U_c < 10) && (Limit <= 40)) Limit = 80;

      Counter++;              /* increase no-changes counter */
    }

    if (U_c <= CAP_DISCHARGED)          /* seems to be discharged */
    484c:	93 e0       	ldi	r25, 0x03	; 3
    484e:	89 16       	cp	r8, r25
    4850:	91 04       	cpc	r9, r1
    4852:	40 f4       	brcc	.+16     	; 0x4864 <DischargeProbes+0x11e>
    {
      DischargeMask |= (1 << ID);       /* set flag */
    4854:	c6 01       	movw	r24, r12
    4856:	02 c0       	rjmp	.+4      	; 0x485c <DischargeProbes+0x116>
    4858:	88 0f       	add	r24, r24
    485a:	99 1f       	adc	r25, r25
    485c:	ea 94       	dec	r14
    485e:	e2 f7       	brpl	.-8      	; 0x4858 <DischargeProbes+0x112>
    4860:	08 2b       	or	r16, r24
    4862:	0d c0       	rjmp	.+26     	; 0x487e <DischargeProbes+0x138>
    }
    else if (U_c < 800)                 /* extra pull-down */
    4864:	80 e2       	ldi	r24, 0x20	; 32
    4866:	88 16       	cp	r8, r24
    4868:	83 e0       	ldi	r24, 0x03	; 3
    486a:	98 06       	cpc	r9, r24
    486c:	40 f4       	brcc	.+16     	; 0x487e <DischargeProbes+0x138>
    {
      /* it's save now to pull-down probe pin directly */
      ADC_DDR |= eeprom_read_byte(&ADC_table[ID]);
    486e:	57 b0       	in	r5, 0x07	; 7
    4870:	c7 01       	movw	r24, r14
    4872:	80 50       	subi	r24, 0x00	; 0
    4874:	90 40       	sbci	r25, 0x00	; 0
    4876:	0e 94 18 37 	call	0x6e30	; 0x6e30 <eeprom_read_byte>
    487a:	85 29       	or	r24, r5
    487c:	87 b9       	out	0x07, r24	; 7
    }

    if (DischargeMask == 0b00000111)    /* all probes discharged */
    487e:	07 30       	cpi	r16, 0x07	; 7
    4880:	91 f0       	breq	.+36     	; 0x48a6 <DischargeProbes+0x160>
    {
      Counter = 0;                        /* end loop */
    }
    else if (Counter > Limit)             /* no decrease for some time */
    4882:	ab 14       	cp	r10, r11
    4884:	48 f4       	brcc	.+18     	; 0x4898 <DischargeProbes+0x152>
    {
      /* might be a battery or a super cap */
      Check.Found = COMP_ERROR;           /* report error */
    4886:	e8 e0       	ldi	r30, 0x08	; 8
    4888:	f1 e0       	ldi	r31, 0x01	; 1
    488a:	81 e0       	ldi	r24, 0x01	; 1
    488c:	81 83       	std	Z+1, r24	; 0x01
      Check.Type = TYPE_DISCHARGE;        /* discharge problem */
    488e:	82 83       	std	Z+2, r24	; 0x02
      Check.Probe = ID;                   /* save probe */
    4890:	15 83       	std	Z+5, r17	; 0x05
      Check.U = U_c;                      /* save voltage */
    4892:	97 82       	std	Z+7, r9	; 0x07
    4894:	86 82       	std	Z+6, r8	; 0x06
    4896:	07 c0       	rjmp	.+14     	; 0x48a6 <DischargeProbes+0x160>
      Counter = 0;                        /* end loop */
    }
    else                                /* go for another round */
    {
      wdt_reset();                        /* reset watchdog */
    4898:	a8 95       	wdr
      MilliSleep(50);                     /* wait for 50ms */
    489a:	82 e3       	ldi	r24, 0x32	; 50
    489c:	90 e0       	ldi	r25, 0x00	; 0
    489e:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>

  Counter = 1;
  ID = 2;
  DischargeMask = 0;

  while (Counter > 0)
    48a2:	b1 10       	cpse	r11, r1
    48a4:	89 cf       	rjmp	.-238    	; 0x47b8 <DischargeProbes+0x72>
      MilliSleep(50);                     /* wait for 50ms */
    }
  }

  /* reset probes */
  R_DDR = 0;                       /* set resistor port to input mode */
    48a6:	14 b8       	out	0x04, r1	; 4
  ADC_DDR = 0;                     /* set ADC port to input mode */
    48a8:	17 b8       	out	0x07, r1	; 7
}
    48aa:	26 96       	adiw	r28, 0x06	; 6
    48ac:	0f b6       	in	r0, 0x3f	; 63
    48ae:	f8 94       	cli
    48b0:	de bf       	out	0x3e, r29	; 62
    48b2:	0f be       	out	0x3f, r0	; 63
    48b4:	cd bf       	out	0x3d, r28	; 61
    48b6:	df 91       	pop	r29
    48b8:	cf 91       	pop	r28
    48ba:	1f 91       	pop	r17
    48bc:	0f 91       	pop	r16
    48be:	ff 90       	pop	r15
    48c0:	ef 90       	pop	r14
    48c2:	df 90       	pop	r13
    48c4:	cf 90       	pop	r12
    48c6:	bf 90       	pop	r11
    48c8:	af 90       	pop	r10
    48ca:	9f 90       	pop	r9
    48cc:	8f 90       	pop	r8
    48ce:	7f 90       	pop	r7
    48d0:	6f 90       	pop	r6
    48d2:	5f 90       	pop	r5
    48d4:	08 95       	ret

000048d6 <PullProbe>:
 */

void PullProbe(uint8_t Mask, uint8_t Mode)
{
  /* set pull mode */
  if (Mode & FLAG_PULLUP) R_PORT |= Mask;    /* pull-up */
    48d6:	60 ff       	sbrs	r22, 0
    48d8:	04 c0       	rjmp	.+8      	; 0x48e2 <PullProbe+0xc>
    48da:	95 b1       	in	r25, 0x05	; 5
    48dc:	98 2b       	or	r25, r24
    48de:	95 b9       	out	0x05, r25	; 5
    48e0:	05 c0       	rjmp	.+10     	; 0x48ec <PullProbe+0x16>
  else R_PORT &= ~Mask;                      /* pull-down */
    48e2:	95 b1       	in	r25, 0x05	; 5
    48e4:	28 2f       	mov	r18, r24
    48e6:	20 95       	com	r18
    48e8:	92 23       	and	r25, r18
    48ea:	95 b9       	out	0x05, r25	; 5
  R_DDR |= Mask;                             /* enable pulling */
    48ec:	94 b1       	in	r25, 0x04	; 4
    48ee:	98 2b       	or	r25, r24
    48f0:	94 b9       	out	0x04, r25	; 4

  if (Mode & FLAG_1MS) _delay_ms(1);            /* wait 1ms */
    48f2:	63 ff       	sbrs	r22, 3
    48f4:	07 c0       	rjmp	.+14     	; 0x4904 <PullProbe+0x2e>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    48f6:	ef e9       	ldi	r30, 0x9F	; 159
    48f8:	ff e0       	ldi	r31, 0x0F	; 15
    48fa:	31 97       	sbiw	r30, 0x01	; 1
    48fc:	f1 f7       	brne	.-4      	; 0x48fa <PullProbe+0x24>
    48fe:	00 c0       	rjmp	.+0      	; 0x4900 <PullProbe+0x2a>
    4900:	00 00       	nop
    4902:	06 c0       	rjmp	.+12     	; 0x4910 <PullProbe+0x3a>
    4904:	ef e3       	ldi	r30, 0x3F	; 63
    4906:	fc e9       	ldi	r31, 0x9C	; 156
    4908:	31 97       	sbiw	r30, 0x01	; 1
    490a:	f1 f7       	brne	.-4      	; 0x4908 <PullProbe+0x32>
    490c:	00 c0       	rjmp	.+0      	; 0x490e <PullProbe+0x38>
    490e:	00 00       	nop
  else _delay_ms(10);                         /* wait 10ms */

  /* reset pulling */
  R_DDR &= ~Mask;                       /* set to HiZ mode */
    4910:	94 b1       	in	r25, 0x04	; 4
    4912:	80 95       	com	r24
    4914:	98 23       	and	r25, r24
    4916:	94 b9       	out	0x04, r25	; 4
  R_PORT &= ~Mask;                      /* set 0 */
    4918:	95 b1       	in	r25, 0x05	; 5
    491a:	89 23       	and	r24, r25
    491c:	85 b9       	out	0x05, r24	; 5
    491e:	08 95       	ret

00004920 <GetFactor>:
 *  returns:
 *  - multiplicator/factor
 */

uint16_t GetFactor(uint16_t U_in, uint8_t ID)
{
    4920:	df 92       	push	r13
    4922:	ef 92       	push	r14
    4924:	ff 92       	push	r15
    4926:	0f 93       	push	r16
    4928:	1f 93       	push	r17
    492a:	cf 93       	push	r28
    492c:	df 93       	push	r29

  /*
   *  setup table specific stuff
   */

  if (ID == TABLE_SMALL_CAP)
    492e:	61 30       	cpi	r22, 0x01	; 1
    4930:	e9 f1       	breq	.+122    	; 0x49ac <GetFactor+0x8c>
    TabStart = 1000;               /* table starts at 1000mV */
    TabStep = 50;                  /* 50mV steps between entries */
    TabIndex = 7;                  /* entries in table - 2 */
    Table = (uint16_t *)&SmallCap_table[0];    /* pointer to table start */
  }
  else if (ID == TABLE_LARGE_CAP)
    4932:	62 30       	cpi	r22, 0x02	; 2
    4934:	09 f4       	brne	.+2      	; 0x4938 <GetFactor+0x18>
    4936:	43 c0       	rjmp	.+134    	; 0x49be <GetFactor+0x9e>
    TabStep = 25;                  /* 25mV steps between entries */
    TabIndex = 42;                 /* entries in table - 2 */
    Table = (uint16_t *)&LargeCap_table[0];    /* pointer to table start */
  }
  #ifdef SW_INDUCTOR
  else if (ID == TABLE_INDUCTOR)
    4938:	63 30       	cpi	r22, 0x03	; 3
    493a:	09 f4       	brne	.+2      	; 0x493e <GetFactor+0x1e>
    493c:	49 c0       	rjmp	.+146    	; 0x49d0 <GetFactor+0xb0>
    Table = (uint16_t *)&Inductor_table[0];    /* pointer to table start */
  }
  #endif
  else
  {
    return 0;
    493e:	80 e0       	ldi	r24, 0x00	; 0
    4940:	90 e0       	ldi	r25, 0x00	; 0
    4942:	53 c0       	rjmp	.+166    	; 0x49ea <GetFactor+0xca>
  /*
   *  We interpolate the table values corresponding to the given voltage/ratio.
   */

  /* difference to start of table */
  if (U_in >= TabStart) U_Diff = U_in - TabStart;  
    4944:	84 1b       	sub	r24, r20
    4946:	95 0b       	sbc	r25, r21
  else U_Diff = 0;

  /* calculate table index */
  Index = U_Diff / TabStep;             /* index (position in table) */
    4948:	b8 01       	movw	r22, r16
    494a:	0e 94 5e 36 	call	0x6cbc	; 0x6cbc <__udivmodhi4>
  Diff = U_Diff % TabStep;              /* difference to index */
  Diff = TabStep - Diff;                /* difference to next entry */
    494e:	d0 2e       	mov	r13, r16
    4950:	d8 1a       	sub	r13, r24

  /* prevent index overflow */
  if (Index > TabIndex) Index = TabIndex;
    4952:	cb 01       	movw	r24, r22
    4954:	99 27       	eor	r25, r25
    4956:	c8 17       	cp	r28, r24
    4958:	d9 07       	cpc	r29, r25
    495a:	10 f0       	brcs	.+4      	; 0x4960 <GetFactor+0x40>
  /* difference to start of table */
  if (U_in >= TabStart) U_Diff = U_in - TabStart;  
  else U_Diff = 0;

  /* calculate table index */
  Index = U_Diff / TabStep;             /* index (position in table) */
    495c:	26 2f       	mov	r18, r22
    495e:	01 c0       	rjmp	.+2      	; 0x4962 <GetFactor+0x42>
  Diff = U_Diff % TabStep;              /* difference to index */
  Diff = TabStep - Diff;                /* difference to next entry */

  /* prevent index overflow */
  if (Index > TabIndex) Index = TabIndex;
    4960:	2c 2f       	mov	r18, r28

  /* get values for index and next entry */
  Table += Index;                       /* advance to index */
    4962:	c2 2f       	mov	r28, r18
    4964:	d0 e0       	ldi	r29, 0x00	; 0
    4966:	cc 0f       	add	r28, r28
    4968:	dd 1f       	adc	r29, r29
    496a:	ce 0f       	add	r28, r30
    496c:	df 1f       	adc	r29, r31
  Fact1 = eeprom_read_word(Table);
    496e:	ce 01       	movw	r24, r28
    4970:	0e 94 20 37 	call	0x6e40	; 0x6e40 <eeprom_read_word>
    4974:	7c 01       	movw	r14, r24
  Table++;                              /* next entry */
  Fact2 = eeprom_read_word(Table);
    4976:	ce 01       	movw	r24, r28
    4978:	02 96       	adiw	r24, 0x02	; 2
    497a:	0e 94 20 37 	call	0x6e40	; 0x6e40 <eeprom_read_word>
    497e:	9c 01       	movw	r18, r24

  /* interpolate values based on the difference */
  Factor = Fact1 - Fact2;
    4980:	e8 1a       	sub	r14, r24
    4982:	f9 0a       	sbc	r15, r25
  Factor *= Diff;
    4984:	de 9c       	mul	r13, r14
    4986:	a0 01       	movw	r20, r0
    4988:	df 9c       	mul	r13, r15
    498a:	50 0d       	add	r21, r0
    498c:	11 24       	eor	r1, r1
  Factor += TabStep / 2;
    498e:	c8 01       	movw	r24, r16
    4990:	96 95       	lsr	r25
    4992:	87 95       	ror	r24
    4994:	84 0f       	add	r24, r20
    4996:	95 1f       	adc	r25, r21
  Factor /= TabStep;
    4998:	b8 01       	movw	r22, r16
    499a:	0e 94 5e 36 	call	0x6cbc	; 0x6cbc <__udivmodhi4>
  Factor += Fact2;
    499e:	cb 01       	movw	r24, r22
    49a0:	82 0f       	add	r24, r18
    49a2:	93 1f       	adc	r25, r19

  return Factor;
    49a4:	22 c0       	rjmp	.+68     	; 0x49ea <GetFactor+0xca>
  /* difference to start of table */
  if (U_in >= TabStart) U_Diff = U_in - TabStart;  
  else U_Diff = 0;

  /* calculate table index */
  Index = U_Diff / TabStep;             /* index (position in table) */
    49a6:	20 e0       	ldi	r18, 0x00	; 0
  Diff = U_Diff % TabStep;              /* difference to index */
  Diff = TabStep - Diff;                /* difference to next entry */
    49a8:	d0 2e       	mov	r13, r16
    49aa:	db cf       	rjmp	.-74     	; 0x4962 <GetFactor+0x42>
  if (ID == TABLE_SMALL_CAP)
  {
    TabStart = 1000;               /* table starts at 1000mV */
    TabStep = 50;                  /* 50mV steps between entries */
    TabIndex = 7;                  /* entries in table - 2 */
    Table = (uint16_t *)&SmallCap_table[0];    /* pointer to table start */
    49ac:	e9 e5       	ldi	r30, 0x59	; 89
    49ae:	f0 e0       	ldi	r31, 0x00	; 0

  if (ID == TABLE_SMALL_CAP)
  {
    TabStart = 1000;               /* table starts at 1000mV */
    TabStep = 50;                  /* 50mV steps between entries */
    TabIndex = 7;                  /* entries in table - 2 */
    49b0:	c7 e0       	ldi	r28, 0x07	; 7
    49b2:	d0 e0       	ldi	r29, 0x00	; 0
   */

  if (ID == TABLE_SMALL_CAP)
  {
    TabStart = 1000;               /* table starts at 1000mV */
    TabStep = 50;                  /* 50mV steps between entries */
    49b4:	02 e3       	ldi	r16, 0x32	; 50
    49b6:	10 e0       	ldi	r17, 0x00	; 0
   *  setup table specific stuff
   */

  if (ID == TABLE_SMALL_CAP)
  {
    TabStart = 1000;               /* table starts at 1000mV */
    49b8:	48 ee       	ldi	r20, 0xE8	; 232
    49ba:	53 e0       	ldi	r21, 0x03	; 3
    49bc:	11 c0       	rjmp	.+34     	; 0x49e0 <GetFactor+0xc0>
  else if (ID == TABLE_LARGE_CAP)
  {
    TabStart = 300;                /* table starts at 1000mV */
    TabStep = 25;                  /* 25mV steps between entries */
    TabIndex = 42;                 /* entries in table - 2 */
    Table = (uint16_t *)&LargeCap_table[0];    /* pointer to table start */
    49be:	eb e6       	ldi	r30, 0x6B	; 107
    49c0:	f0 e0       	ldi	r31, 0x00	; 0
  }
  else if (ID == TABLE_LARGE_CAP)
  {
    TabStart = 300;                /* table starts at 1000mV */
    TabStep = 25;                  /* 25mV steps between entries */
    TabIndex = 42;                 /* entries in table - 2 */
    49c2:	ca e2       	ldi	r28, 0x2A	; 42
    49c4:	d0 e0       	ldi	r29, 0x00	; 0
    Table = (uint16_t *)&SmallCap_table[0];    /* pointer to table start */
  }
  else if (ID == TABLE_LARGE_CAP)
  {
    TabStart = 300;                /* table starts at 1000mV */
    TabStep = 25;                  /* 25mV steps between entries */
    49c6:	09 e1       	ldi	r16, 0x19	; 25
    49c8:	10 e0       	ldi	r17, 0x00	; 0
    TabIndex = 7;                  /* entries in table - 2 */
    Table = (uint16_t *)&SmallCap_table[0];    /* pointer to table start */
  }
  else if (ID == TABLE_LARGE_CAP)
  {
    TabStart = 300;                /* table starts at 1000mV */
    49ca:	4c e2       	ldi	r20, 0x2C	; 44
    49cc:	51 e0       	ldi	r21, 0x01	; 1
    49ce:	08 c0       	rjmp	.+16     	; 0x49e0 <GetFactor+0xc0>
  else if (ID == TABLE_INDUCTOR)
  {
    TabStart = 200;                /* table starts at 200 */
    TabStep = 25;                  /* steps between entries */
    TabIndex = 30;                 /* entries in table - 2 */
    Table = (uint16_t *)&Inductor_table[0];    /* pointer to table start */
    49d0:	e9 e0       	ldi	r30, 0x09	; 9
    49d2:	f0 e0       	ldi	r31, 0x00	; 0
  #ifdef SW_INDUCTOR
  else if (ID == TABLE_INDUCTOR)
  {
    TabStart = 200;                /* table starts at 200 */
    TabStep = 25;                  /* steps between entries */
    TabIndex = 30;                 /* entries in table - 2 */
    49d4:	ce e1       	ldi	r28, 0x1E	; 30
    49d6:	d0 e0       	ldi	r29, 0x00	; 0
  }
  #ifdef SW_INDUCTOR
  else if (ID == TABLE_INDUCTOR)
  {
    TabStart = 200;                /* table starts at 200 */
    TabStep = 25;                  /* steps between entries */
    49d8:	09 e1       	ldi	r16, 0x19	; 25
    49da:	10 e0       	ldi	r17, 0x00	; 0
    Table = (uint16_t *)&LargeCap_table[0];    /* pointer to table start */
  }
  #ifdef SW_INDUCTOR
  else if (ID == TABLE_INDUCTOR)
  {
    TabStart = 200;                /* table starts at 200 */
    49dc:	48 ec       	ldi	r20, 0xC8	; 200
    49de:	50 e0       	ldi	r21, 0x00	; 0
  /*
   *  We interpolate the table values corresponding to the given voltage/ratio.
   */

  /* difference to start of table */
  if (U_in >= TabStart) U_Diff = U_in - TabStart;  
    49e0:	84 17       	cp	r24, r20
    49e2:	95 07       	cpc	r25, r21
    49e4:	08 f0       	brcs	.+2      	; 0x49e8 <GetFactor+0xc8>
    49e6:	ae cf       	rjmp	.-164    	; 0x4944 <GetFactor+0x24>
    49e8:	de cf       	rjmp	.-68     	; 0x49a6 <GetFactor+0x86>
  Factor += TabStep / 2;
  Factor /= TabStep;
  Factor += Fact2;

  return Factor;
}
    49ea:	df 91       	pop	r29
    49ec:	cf 91       	pop	r28
    49ee:	1f 91       	pop	r17
    49f0:	0f 91       	pop	r16
    49f2:	ff 90       	pop	r15
    49f4:	ef 90       	pop	r14
    49f6:	df 90       	pop	r13
    49f8:	08 95       	ret

000049fa <CheckProbes>:
 *  - Probe2: ID of probe to be pulled down [0-2]
 *  - Probe3: ID of probe to be in HiZ mode [0-2]
 */

void CheckProbes(uint8_t Probe1, uint8_t Probe2, uint8_t Probe3)
{
    49fa:	0f 93       	push	r16
    49fc:	1f 93       	push	r17
    49fe:	cf 93       	push	r28
    4a00:	df 93       	push	r29
  uint8_t           Flag;          /* temporary value */
  uint16_t          U_Rl;          /* voltage across Rl (load) */
  uint16_t          U_1;           /* voltage #1 */

  /* init */
  if (Check.Found == COMP_ERROR) return;   /* skip check on any error */
    4a02:	90 91 09 01 	lds	r25, 0x0109
    4a06:	91 30       	cpi	r25, 0x01	; 1
    4a08:	09 f4       	brne	.+2      	; 0x4a0c <CheckProbes+0x12>
    4a0a:	87 c0       	rjmp	.+270    	; 0x4b1a <CheckProbes+0x120>
    4a0c:	06 2f       	mov	r16, r22
    4a0e:	18 2f       	mov	r17, r24
  wdt_reset();                             /* reset watchdog */
    4a10:	a8 95       	wdr
  UpdateProbes(Probe1, Probe2, Probe3);    /* update bitmasks */
    4a12:	0e 94 04 23 	call	0x4608	; 0x4608 <UpdateProbes>
   *  In case of a FET we have to take care about the gate charge based on
   *  the channel type.
   */

  /* set probes: Gnd -- Rl -- probe-2 / probe-1 -- Vcc */
  R_PORT = 0;                      /* set resistor port to Gnd */
    4a16:	15 b8       	out	0x05, r1	; 5
  R_DDR = Probes.Rl_2;             /* pull down probe-2 via Rl */
    4a18:	cf e8       	ldi	r28, 0x8F	; 143
    4a1a:	d1 e0       	ldi	r29, 0x01	; 1
    4a1c:	8d 81       	ldd	r24, Y+5	; 0x05
    4a1e:	84 b9       	out	0x04, r24	; 4
  ADC_DDR = Probes.ADC_1;          /* set probe-1 to output */
    4a20:	99 85       	ldd	r25, Y+9	; 0x09
    4a22:	97 b9       	out	0x07, r25	; 7
  ADC_PORT = Probes.ADC_1;         /* pull-up probe-1 directly */
    4a24:	98 b9       	out	0x08, r25	; 8
  /*
   *  For a possible n channel FET we pull down the gate for a few ms,
   *  assuming: probe-1 = D / probe-2 = S / probe-3 = G
   */

  PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLDOWN);   /* discharge gate via Rl */
    4a26:	60 e1       	ldi	r22, 0x10	; 16
    4a28:	8f 81       	ldd	r24, Y+7	; 0x07
    4a2a:	0e 94 6b 24 	call	0x48d6	; 0x48d6 <PullProbe>
  U_Rl = ReadU_5ms(Probes.Pin_2);                    /* get voltage at Rl */
    4a2e:	89 81       	ldd	r24, Y+1	; 0x01
    4a30:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
    4a34:	ec 01       	movw	r28, r24
  /*
   *  If we got conduction we could have a p channel FET. For any
   *  other part U_Rl will be the same.
   */
 
  if (U_Rl >= 977)               /* > 1.4mA */
    4a36:	81 3d       	cpi	r24, 0xD1	; 209
    4a38:	93 40       	sbci	r25, 0x03	; 3
    4a3a:	08 f4       	brcc	.+2      	; 0x4a3e <CheckProbes+0x44>
    4a3c:	68 c0       	rjmp	.+208    	; 0x4b0e <CheckProbes+0x114>
    /*
     *  For a possible p channel FET we pull up the gate for a few ms,
     *  assuming: probe-1 = S / probe-2 = D / probe-3 = G
     */

    PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLUP);   /* discharge gate via Rl */
    4a3e:	cf e8       	ldi	r28, 0x8F	; 143
    4a40:	d1 e0       	ldi	r29, 0x01	; 1
    4a42:	61 e1       	ldi	r22, 0x11	; 17
    4a44:	8f 81       	ldd	r24, Y+7	; 0x07
    4a46:	0e 94 6b 24 	call	0x48d6	; 0x48d6 <PullProbe>
    U_Rl = ReadU_5ms(Probes.Pin_2);                    /* get voltage at Rl */
    4a4a:	89 81       	ldd	r24, Y+1	; 0x01
    4a4c:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
    4a50:	ec 01       	movw	r28, r24
   *
   *  Other possibilities:
   *  - diode or resistor
   */

  if (U_Rl > 490)         /* > 700A (was 92mV/130A) */
    4a52:	cb 3e       	cpi	r28, 0xEB	; 235
    4a54:	81 e0       	ldi	r24, 0x01	; 1
    4a56:	d8 07       	cpc	r29, r24
    4a58:	10 f0       	brcs	.+4      	; 0x4a5e <CheckProbes+0x64>
  {
    CheckDepletionModeFET();
    4a5a:	0e 94 57 2e 	call	0x5cae	; 0x5cae <CheckDepletionModeFET>
   *  - enhancement mode FET
   *  - Thyristor or Triac
   *  or a large resistor
   */

  if (U_Rl < 977)         /* load current < 1.4mA (resistance > 3k) */
    4a5e:	c1 3d       	cpi	r28, 0xD1	; 209
    4a60:	93 e0       	ldi	r25, 0x03	; 3
    4a62:	d9 07       	cpc	r29, r25
    4a64:	e8 f5       	brcc	.+122    	; 0x4ae0 <CheckProbes+0xe6>
     *  check for:
     *  - PNP BJT (common emitter circuit)
     *  - p-channel MOSFET (low side switching circuit)
     */

    if (Check.Done == 0)           /* not sure yet */
    4a66:	80 91 08 01 	lds	r24, 0x0108
    4a6a:	81 11       	cpse	r24, r1
    4a6c:	3b c0       	rjmp	.+118    	; 0x4ae4 <CheckProbes+0xea>
    {
      /* we assume: probe-1 = E / probe-2 = C / probe-3 = B */
      /* set probes: Gnd -- Rl - probe-2 / probe-1 -- Vcc */
      R_DDR = Probes.Rl_2;                /* enable Rl for probe-2 */
    4a6e:	ef e8       	ldi	r30, 0x8F	; 143
    4a70:	f1 e0       	ldi	r31, 0x01	; 1
    4a72:	85 81       	ldd	r24, Z+5	; 0x05
    4a74:	84 b9       	out	0x04, r24	; 4
      R_PORT = 0;                         /* pull down collector via Rl */
    4a76:	15 b8       	out	0x05, r1	; 5
      ADC_DDR = Probes.ADC_1;             /* set probe 1 to output */
    4a78:	81 85       	ldd	r24, Z+9	; 0x09
    4a7a:	87 b9       	out	0x07, r24	; 7
      ADC_PORT = Probes.ADC_1;            /* pull up emitter directly */
    4a7c:	88 b9       	out	0x08, r24	; 8
    4a7e:	8f e1       	ldi	r24, 0x1F	; 31
    4a80:	9e e4       	ldi	r25, 0x4E	; 78
    4a82:	01 97       	sbiw	r24, 0x01	; 1
    4a84:	f1 f7       	brne	.-4      	; 0x4a82 <CheckProbes+0x88>
    4a86:	00 c0       	rjmp	.+0      	; 0x4a88 <CheckProbes+0x8e>
    4a88:	00 00       	nop
      _delay_ms(5);
      R_DDR = Probes.Rl_2 | Probes.Rl_3;  /* pull down base via Rl */
    4a8a:	97 81       	ldd	r25, Z+7	; 0x07
    4a8c:	85 81       	ldd	r24, Z+5	; 0x05
    4a8e:	89 2b       	or	r24, r25
    4a90:	84 b9       	out	0x04, r24	; 4
      U_1 = ReadU_5ms(Probe2);            /* get voltage at collector */ 
    4a92:	80 2f       	mov	r24, r16
    4a94:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
 
      /*
       *  If DUT is conducting we might have a PNP BJT or p-channel FET.
       */

      if (U_1 > 3422)                   /* detected current > 4.8mA */
    4a98:	8f 35       	cpi	r24, 0x5F	; 95
    4a9a:	9d 40       	sbci	r25, 0x0D	; 13
    4a9c:	20 f0       	brcs	.+8      	; 0x4aa6 <CheckProbes+0xac>
      {
        /* distinguish PNP BJT from p-channel MOSFET */
        CheckBJTorEnhModeMOSFET(TYPE_PNP, U_Rl);
    4a9e:	be 01       	movw	r22, r28
    4aa0:	82 e0       	ldi	r24, 0x02	; 2
    4aa2:	0e 94 f5 2c 	call	0x59ea	; 0x59ea <CheckBJTorEnhModeMOSFET>
     *  - NPN BJT (common emitter circuit)
     *  - Thyristor and Triac
     *  - n-channel MOSFET (high side switching circuit)
     */

    if (Check.Done == 0)           /* not sure yet */
    4aa6:	80 91 08 01 	lds	r24, 0x0108
    4aaa:	81 11       	cpse	r24, r1
    4aac:	1b c0       	rjmp	.+54     	; 0x4ae4 <CheckProbes+0xea>
    {
      /* we assume: probe-1 = C / probe-2 = E / probe-3 = B */
      /* set probes: Gnd -- probe-2 / probe-1 -- Rl -- Vcc */
      ADC_DDR = Probes.ADC_2;                /* set probe-2 to output mode */
    4aae:	ef e8       	ldi	r30, 0x8F	; 143
    4ab0:	f1 e0       	ldi	r31, 0x01	; 1
    4ab2:	82 85       	ldd	r24, Z+10	; 0x0a
    4ab4:	87 b9       	out	0x07, r24	; 7
      ADC_PORT = 0;                          /* pull down probe-2 directly */
    4ab6:	18 b8       	out	0x08, r1	; 8
      R_DDR = Probes.Rl_1 | Probes.Rl_3;     /* select Rl for probe-1 & Rl for probe-3 */
    4ab8:	97 81       	ldd	r25, Z+7	; 0x07
    4aba:	83 81       	ldd	r24, Z+3	; 0x03
    4abc:	89 2b       	or	r24, r25
    4abe:	84 b9       	out	0x04, r24	; 4
      R_PORT = Probes.Rl_1 | Probes.Rl_3;    /* pull up collector & base via Rl */
    4ac0:	85 b9       	out	0x05, r24	; 5
      U_1 = ReadU_5ms(Probe1);               /* get voltage at collector */
    4ac2:	81 2f       	mov	r24, r17
    4ac4:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
      /*
       *  If DUT is conducting we might have a NPN BJT, something similar or
       *  a n-channel MOSFET.
       */

      if (U_1 < 1600)                   /* detected current > 4.8mA */
    4ac8:	80 34       	cpi	r24, 0x40	; 64
    4aca:	96 40       	sbci	r25, 0x06	; 6
    4acc:	58 f4       	brcc	.+22     	; 0x4ae4 <CheckProbes+0xea>
      {
        /* first check for thyristor and triac */
        Flag = CheckThyristorTriac();
    4ace:	0e 94 45 2f 	call	0x5e8a	; 0x5e8a <CheckThyristorTriac>

        if (Flag == 0)                 /* no thyristor or triac */
    4ad2:	81 11       	cpse	r24, r1
    4ad4:	07 c0       	rjmp	.+14     	; 0x4ae4 <CheckProbes+0xea>
        {
          /* we might got a NPN BJT or a n-channel MOSFET. */
          CheckBJTorEnhModeMOSFET(TYPE_NPN, U_Rl);
    4ad6:	be 01       	movw	r22, r28
    4ad8:	81 e0       	ldi	r24, 0x01	; 1
    4ada:	0e 94 f5 2c 	call	0x59ea	; 0x59ea <CheckBJTorEnhModeMOSFET>
    4ade:	02 c0       	rjmp	.+4      	; 0x4ae4 <CheckProbes+0xea>
    /*
     *  We check for a diode even if we already found a component to get Vf, 
     *  since there could be a body/protection diode of a transistor.
     */

    CheckDiode();
    4ae0:	0e 94 58 2b 	call	0x56b0	; 0x56b0 <CheckDiode>

  /*
   *  Check for a resistor.
   */

  if ((Check.Found == COMP_NONE) ||
    4ae4:	80 91 09 01 	lds	r24, 0x0109
    4ae8:	88 23       	and	r24, r24
    4aea:	11 f0       	breq	.+4      	; 0x4af0 <CheckProbes+0xf6>
    4aec:	8a 30       	cpi	r24, 0x0A	; 10
    4aee:	19 f4       	brne	.+6      	; 0x4af6 <CheckProbes+0xfc>
      (Check.Found == COMP_RESISTOR))
  {
    CheckResistor();
    4af0:	0e 94 bc 26 	call	0x4d78	; 0x4d78 <CheckResistor>
    4af4:	07 c0       	rjmp	.+14     	; 0x4b04 <CheckProbes+0x10a>
   */

  else
  {
    /* verify a MOSFET */
    if ((Check.Found == COMP_FET) && (Check.Type & TYPE_MOSFET))
    4af6:	86 31       	cpi	r24, 0x16	; 22
    4af8:	29 f4       	brne	.+10     	; 0x4b04 <CheckProbes+0x10a>
    4afa:	80 91 0a 01 	lds	r24, 0x010A
    4afe:	84 fd       	sbrc	r24, 4
      VerifyMOSFET();
    4b00:	0e 94 c8 2c 	call	0x5990	; 0x5990 <VerifyMOSFET>
  }


  /* clean up */
  ADC_DDR = 0;           /* set ADC port to HiZ mode */
    4b04:	17 b8       	out	0x07, r1	; 7
  ADC_PORT = 0;          /* set ADC port low */
    4b06:	18 b8       	out	0x08, r1	; 8
  R_DDR = 0;             /* set resistor port to HiZ mode */
    4b08:	14 b8       	out	0x04, r1	; 4
  R_PORT = 0;            /* set resistor port low */
    4b0a:	15 b8       	out	0x05, r1	; 5
    4b0c:	06 c0       	rjmp	.+12     	; 0x4b1a <CheckProbes+0x120>
   *
   *  Other possibilities:
   *  - diode or resistor
   */

  if (U_Rl > 490)         /* > 700A (was 92mV/130A) */
    4b0e:	cb 3e       	cpi	r28, 0xEB	; 235
    4b10:	81 e0       	ldi	r24, 0x01	; 1
    4b12:	d8 07       	cpc	r29, r24
    4b14:	08 f4       	brcc	.+2      	; 0x4b18 <CheckProbes+0x11e>
    4b16:	a7 cf       	rjmp	.-178    	; 0x4a66 <CheckProbes+0x6c>
    4b18:	a0 cf       	rjmp	.-192    	; 0x4a5a <CheckProbes+0x60>
  /* clean up */
  ADC_DDR = 0;           /* set ADC port to HiZ mode */
  ADC_PORT = 0;          /* set ADC port low */
  R_DDR = 0;             /* set resistor port to HiZ mode */
  R_PORT = 0;            /* set resistor port low */
}
    4b1a:	df 91       	pop	r29
    4b1c:	cf 91       	pop	r28
    4b1e:	1f 91       	pop	r17
    4b20:	0f 91       	pop	r16
    4b22:	08 95       	ret

00004b24 <SmallResistor>:
 *  returns:
 *  - resistance in 0.01 Ohm
 */

uint16_t SmallResistor(uint8_t ZeroFlag)
{
    4b24:	2f 92       	push	r2
    4b26:	3f 92       	push	r3
    4b28:	4f 92       	push	r4
    4b2a:	5f 92       	push	r5
    4b2c:	6f 92       	push	r6
    4b2e:	7f 92       	push	r7
    4b30:	8f 92       	push	r8
    4b32:	9f 92       	push	r9
    4b34:	af 92       	push	r10
    4b36:	bf 92       	push	r11
    4b38:	cf 92       	push	r12
    4b3a:	df 92       	push	r13
    4b3c:	ef 92       	push	r14
    4b3e:	ff 92       	push	r15
    4b40:	0f 93       	push	r16
    4b42:	1f 93       	push	r17
    4b44:	cf 93       	push	r28
    4b46:	df 93       	push	r29
    4b48:	1f 92       	push	r1
    4b4a:	cd b7       	in	r28, 0x3d	; 61
    4b4c:	de b7       	in	r29, 0x3e	; 62
    4b4e:	89 83       	std	Y+1, r24	; 0x01
  uint8_t           Counter;       /* sample counter */
  uint32_t          Value;         /* ADC sample value */
  uint32_t          Value1 = 0;    /* U_Rl temp. value */
  uint32_t          Value2 = 0;    /* U_R_i_L temp. value */

  DischargeProbes();                    /* try to discharge probes */
    4b50:	0e 94 a3 23 	call	0x4746	; 0x4746 <DischargeProbes>
  if (Check.Found == COMP_ERROR) return R;   /* skip on error */
    4b54:	80 91 09 01 	lds	r24, 0x0109
    4b58:	81 30       	cpi	r24, 0x01	; 1
    4b5a:	09 f4       	brne	.+2      	; 0x4b5e <SmallResistor+0x3a>
    4b5c:	eb c0       	rjmp	.+470    	; 0x4d34 <SmallResistor+0x210>
   *  - repeat that for the low side of the DUT
   */

  /* pulse on: GND -- probe 2 / probe 1 -- Rl -- 5V */
  /* pulse off: GND -- probe 2 / probe 1 -- Rl -- GND */
  ADC_PORT = 0;                         /* set ADC port to low */
    4b5e:	18 b8       	out	0x08, r1	; 8
  ADC_DDR = Probes.ADC_2;               /* pull-down probe 2 directly */
    4b60:	ef e8       	ldi	r30, 0x8F	; 143
    4b62:	f1 e0       	ldi	r31, 0x01	; 1
    4b64:	82 85       	ldd	r24, Z+10	; 0x0a
    4b66:	87 b9       	out	0x07, r24	; 7
  R_PORT = 0;                           /* low by default */
    4b68:	15 b8       	out	0x05, r1	; 5
  R_DDR = Probes.Rl_1;                  /* enable resistor */
    4b6a:	83 81       	ldd	r24, Z+3	; 0x03
    4b6c:	84 b9       	out	0x04, r24	; 4
  uint16_t          R = 0;         /* return value */
  uint8_t           Probe;         /* probe ID */
  uint8_t           Mode;          /* measurement mode */
  uint8_t           Counter;       /* sample counter */
  uint32_t          Value;         /* ADC sample value */
  uint32_t          Value1 = 0;    /* U_Rl temp. value */
    4b6e:	81 2c       	mov	r8, r1
    4b70:	91 2c       	mov	r9, r1
    4b72:	54 01       	movw	r10, r8

  /*
   *   measurement loop
   */

  Mode = MODE_HIGH;
    4b74:	81 e0       	ldi	r24, 0x01	; 1

  while (Mode > 0)
  {
    /* setup measurement */
    if (Mode & MODE_HIGH) Probe = Probes.Pin_1;
    else Probe = Probes.Pin_2;
    4b76:	8f 01       	movw	r16, r30
    Counter = 0;              /* reset loop counter */
    Value = 0;                /* reset sample value */

    /* set ADC to use bandgap reference and run a dummy conversion */
    Probe |= (1 << REFS0) | (1 << REFS1);
    ADMUX = Probe;                   /* set input channel and U reference */
    4b78:	0f 2e       	mov	r0, r31
    4b7a:	fc e7       	ldi	r31, 0x7C	; 124
    4b7c:	4f 2e       	mov	r4, r31
    4b7e:	51 2c       	mov	r5, r1
    4b80:	f0 2d       	mov	r31, r0
    4b82:	d1 2c       	mov	r13, r1
    4b84:	c1 2c       	mov	r12, r1
      R_PORT = 0;
      ADC_DDR = Probes.ADC_2 | Probes.ADC_1;

      /* get ADC reading (about 100s) */
      while (ADCSRA & (1 << ADSC));     /* wait until conversion is done */
      Value += ADCW;                    /* add ADC reading */
    4b86:	0f 2e       	mov	r0, r31
    4b88:	f8 e7       	ldi	r31, 0x78	; 120
    4b8a:	ef 2e       	mov	r14, r31
    4b8c:	f1 2c       	mov	r15, r1
    4b8e:	f0 2d       	mov	r31, r0

      Counter++;                        /* next round */
    }

    /* convert ADC reading to voltage */
    Value *= Config.Bandgap;
    4b90:	0f 2e       	mov	r0, r31
    4b92:	fb ea       	ldi	r31, 0xAB	; 171
    4b94:	2f 2e       	mov	r2, r31
    4b96:	f1 e0       	ldi	r31, 0x01	; 1
    4b98:	3f 2e       	mov	r3, r31
    4b9a:	f0 2d       	mov	r31, r0
    Value /= 10;                   /* de-sample to 0.1mV */

    /* loop control */
    if (Mode & MODE_HIGH)          /* probe #1 / Rl */
    {
      Mode = MODE_LOW;             /* switch to low side */
    4b9c:	68 94       	set
    4b9e:	66 24       	eor	r6, r6
    4ba0:	61 f8       	bld	r6, 1
    4ba2:	68 2f       	mov	r22, r24
    4ba4:	04 c0       	rjmp	.+8      	; 0x4bae <SmallResistor+0x8a>
    }

    /* convert ADC reading to voltage */
    Value *= Config.Bandgap;
    Value /= 1024;                 /* / 1024 for 10bit ADC */
    Value /= 10;                   /* de-sample to 0.1mV */
    4ba6:	82 2e       	mov	r8, r18
    4ba8:	93 2e       	mov	r9, r19
    4baa:	a4 2e       	mov	r10, r20
    4bac:	b5 2e       	mov	r11, r21
  Mode = MODE_HIGH;

  while (Mode > 0)
  {
    /* setup measurement */
    if (Mode & MODE_HIGH) Probe = Probes.Pin_1;
    4bae:	86 2f       	mov	r24, r22
    4bb0:	81 70       	andi	r24, 0x01	; 1
    4bb2:	78 2e       	mov	r7, r24
    4bb4:	60 ff       	sbrs	r22, 0
    4bb6:	03 c0       	rjmp	.+6      	; 0x4bbe <SmallResistor+0x9a>
    4bb8:	f8 01       	movw	r30, r16
    4bba:	80 81       	ld	r24, Z
    4bbc:	02 c0       	rjmp	.+4      	; 0x4bc2 <SmallResistor+0x9e>
    else Probe = Probes.Pin_2;
    4bbe:	f8 01       	movw	r30, r16
    4bc0:	81 81       	ldd	r24, Z+1	; 0x01

    wdt_reset();              /* reset watchdog */
    4bc2:	a8 95       	wdr
    Counter = 0;              /* reset loop counter */
    Value = 0;                /* reset sample value */

    /* set ADC to use bandgap reference and run a dummy conversion */
    Probe |= (1 << REFS0) | (1 << REFS1);
    4bc4:	80 6c       	ori	r24, 0xC0	; 192
    ADMUX = Probe;                   /* set input channel and U reference */
    4bc6:	f2 01       	movw	r30, r4
    4bc8:	80 83       	st	Z, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    4bca:	8f e8       	ldi	r24, 0x8F	; 143
    4bcc:	91 e0       	ldi	r25, 0x01	; 1
    4bce:	01 97       	sbiw	r24, 0x01	; 1
    4bd0:	f1 f7       	brne	.-4      	; 0x4bce <SmallResistor+0xaa>
    4bd2:	00 c0       	rjmp	.+0      	; 0x4bd4 <SmallResistor+0xb0>
    4bd4:	00 00       	nop
    _delay_us(100);                     /* time for voltage stabilization */
    ADCSRA |= (1 << ADSC);           /* start conversion */
    4bd6:	ea e7       	ldi	r30, 0x7A	; 122
    4bd8:	f0 e0       	ldi	r31, 0x00	; 0
    4bda:	80 81       	ld	r24, Z
    4bdc:	80 64       	ori	r24, 0x40	; 64
    4bde:	80 83       	st	Z, r24
    while (ADCSRA & (1 << ADSC));    /* wait until conversion is done */
    4be0:	ea e7       	ldi	r30, 0x7A	; 122
    4be2:	f0 e0       	ldi	r31, 0x00	; 0
    4be4:	80 81       	ld	r24, Z
    4be6:	86 fd       	sbrc	r24, 6
    4be8:	fb cf       	rjmp	.-10     	; 0x4be0 <SmallResistor+0xbc>
    4bea:	34 e6       	ldi	r19, 0x64	; 100
    4bec:	40 e0       	ldi	r20, 0x00	; 0
    4bee:	50 e0       	ldi	r21, 0x00	; 0
    4bf0:	6d 2d       	mov	r22, r13
    4bf2:	7c 2d       	mov	r23, r12
     */

    while (Counter < 100)
    {
      /* create short pulse */
      ADC_DDR = Probes.ADC_2;           /* pull-down probe-2 directly */
    4bf4:	f8 01       	movw	r30, r16
    4bf6:	82 85       	ldd	r24, Z+10	; 0x0a
    4bf8:	87 b9       	out	0x07, r24	; 7
      R_PORT = Probes.Rl_1;
    4bfa:	83 81       	ldd	r24, Z+3	; 0x03
    4bfc:	85 b9       	out	0x05, r24	; 5

      /* start ADC conversion */
      /* ADC performs S&H after 1.5 ADC cycles (12s) */
      ADCSRA |= (1 << ADSC);            /* start conversion */
    4bfe:	ea e7       	ldi	r30, 0x7A	; 122
    4c00:	f0 e0       	ldi	r31, 0x00	; 0
    4c02:	80 81       	ld	r24, Z
    4c04:	80 64       	ori	r24, 0x40	; 64
    4c06:	80 83       	st	Z, r24
    4c08:	fa e6       	ldi	r31, 0x6A	; 106
    4c0a:	fa 95       	dec	r31
    4c0c:	f1 f7       	brne	.-4      	; 0x4c0a <SmallResistor+0xe6>
    4c0e:	00 c0       	rjmp	.+0      	; 0x4c10 <SmallResistor+0xec>

      /* wait 20s to allow the ADC to do it's job (S&H) */
      _delay_us(20);

      /* stop pulse */
      R_PORT = 0;
    4c10:	15 b8       	out	0x05, r1	; 5
      ADC_DDR = Probes.ADC_2 | Probes.ADC_1;
    4c12:	f8 01       	movw	r30, r16
    4c14:	91 85       	ldd	r25, Z+9	; 0x09
    4c16:	82 85       	ldd	r24, Z+10	; 0x0a
    4c18:	89 2b       	or	r24, r25
    4c1a:	87 b9       	out	0x07, r24	; 7

      /* get ADC reading (about 100s) */
      while (ADCSRA & (1 << ADSC));     /* wait until conversion is done */
    4c1c:	ea e7       	ldi	r30, 0x7A	; 122
    4c1e:	f0 e0       	ldi	r31, 0x00	; 0
    4c20:	80 81       	ld	r24, Z
    4c22:	86 fd       	sbrc	r24, 6
    4c24:	fb cf       	rjmp	.-10     	; 0x4c1c <SmallResistor+0xf8>
      Value += ADCW;                    /* add ADC reading */
    4c26:	f7 01       	movw	r30, r14
    4c28:	80 81       	ld	r24, Z
    4c2a:	91 81       	ldd	r25, Z+1	; 0x01
    4c2c:	48 0f       	add	r20, r24
    4c2e:	59 1f       	adc	r21, r25
    4c30:	61 1d       	adc	r22, r1
    4c32:	71 1d       	adc	r23, r1
    4c34:	8f e3       	ldi	r24, 0x3F	; 63
    4c36:	96 e0       	ldi	r25, 0x06	; 6
    4c38:	01 97       	sbiw	r24, 0x01	; 1
    4c3a:	f1 f7       	brne	.-4      	; 0x4c38 <SmallResistor+0x114>
    4c3c:	00 c0       	rjmp	.+0      	; 0x4c3e <SmallResistor+0x11a>
    4c3e:	00 00       	nop
    4c40:	ef ec       	ldi	r30, 0xCF	; 207
    4c42:	f7 e0       	ldi	r31, 0x07	; 7
    4c44:	31 97       	sbiw	r30, 0x01	; 1
    4c46:	f1 f7       	brne	.-4      	; 0x4c44 <SmallResistor+0x120>
    4c48:	00 c0       	rjmp	.+0      	; 0x4c4a <SmallResistor+0x126>
    4c4a:	00 00       	nop
    4c4c:	31 50       	subi	r19, 0x01	; 1

    /*
     *  measurement loop (about 1ms per cycle)
     */

    while (Counter < 100)
    4c4e:	91 f6       	brne	.-92     	; 0x4bf4 <SmallResistor+0xd0>

      Counter++;                        /* next round */
    }

    /* convert ADC reading to voltage */
    Value *= Config.Bandgap;
    4c50:	f1 01       	movw	r30, r2
    4c52:	a4 81       	ldd	r26, Z+4	; 0x04
    4c54:	b5 81       	ldd	r27, Z+5	; 0x05
    4c56:	9a 01       	movw	r18, r20
    4c58:	ab 01       	movw	r20, r22
    4c5a:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
    Value /= 1024;                 /* / 1024 for 10bit ADC */
    4c5e:	05 2e       	mov	r0, r21
    4c60:	5a e0       	ldi	r21, 0x0A	; 10
    4c62:	96 95       	lsr	r25
    4c64:	87 95       	ror	r24
    4c66:	77 95       	ror	r23
    4c68:	67 95       	ror	r22
    4c6a:	5a 95       	dec	r21
    4c6c:	d1 f7       	brne	.-12     	; 0x4c62 <SmallResistor+0x13e>
    4c6e:	50 2d       	mov	r21, r0
    Value /= 10;                   /* de-sample to 0.1mV */
    4c70:	2a e0       	ldi	r18, 0x0A	; 10
    4c72:	30 e0       	ldi	r19, 0x00	; 0
    4c74:	40 e0       	ldi	r20, 0x00	; 0
    4c76:	50 e0       	ldi	r21, 0x00	; 0
    4c78:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    4c7c:	82 2f       	mov	r24, r18
    4c7e:	93 2f       	mov	r25, r19
    4c80:	a4 2f       	mov	r26, r20
    4c82:	b5 2f       	mov	r27, r21

    /* loop control */
    if (Mode & MODE_HIGH)          /* probe #1 / Rl */
    {
      Mode = MODE_LOW;             /* switch to low side */
    4c84:	66 2d       	mov	r22, r6
    Value *= Config.Bandgap;
    Value /= 1024;                 /* / 1024 for 10bit ADC */
    Value /= 10;                   /* de-sample to 0.1mV */

    /* loop control */
    if (Mode & MODE_HIGH)          /* probe #1 / Rl */
    4c86:	71 10       	cpse	r7, r1
    4c88:	8e cf       	rjmp	.-228    	; 0x4ba6 <SmallResistor+0x82>
    4c8a:	57 c0       	rjmp	.+174    	; 0x4d3a <SmallResistor+0x216>
   */

  if (Value1 > Value2)             /* sanity check */
  {
    /* I = U/R = (5V - U_Rl)/(Rl + R_i_H) */
    Value = 10UL * Config.Vcc;               /* in 0.1 mV */
    4c8c:	80 91 b1 01 	lds	r24, 0x01B1
    4c90:	90 91 b2 01 	lds	r25, 0x01B2
    4c94:	a0 e0       	ldi	r26, 0x00	; 0
    4c96:	b0 e0       	ldi	r27, 0x00	; 0
    4c98:	88 0f       	add	r24, r24
    4c9a:	99 1f       	adc	r25, r25
    4c9c:	aa 1f       	adc	r26, r26
    4c9e:	bb 1f       	adc	r27, r27
    4ca0:	ac 01       	movw	r20, r24
    4ca2:	bd 01       	movw	r22, r26
    4ca4:	44 0f       	add	r20, r20
    4ca6:	55 1f       	adc	r21, r21
    4ca8:	66 1f       	adc	r22, r22
    4caa:	77 1f       	adc	r23, r23
    4cac:	44 0f       	add	r20, r20
    4cae:	55 1f       	adc	r21, r21
    4cb0:	66 1f       	adc	r22, r22
    4cb2:	77 1f       	adc	r23, r23
    4cb4:	84 0f       	add	r24, r20
    4cb6:	95 1f       	adc	r25, r21
    4cb8:	a6 1f       	adc	r26, r22
    4cba:	b7 1f       	adc	r27, r23
    Value -= Value1;
    4cbc:	9c 01       	movw	r18, r24
    4cbe:	ad 01       	movw	r20, r26
    4cc0:	28 19       	sub	r18, r8
    4cc2:	39 09       	sbc	r19, r9
    4cc4:	4a 09       	sbc	r20, r10
    4cc6:	5b 09       	sbc	r21, r11
    Value *= 1000;                           /* scale to A */
    4cc8:	a8 ee       	ldi	r26, 0xE8	; 232
    4cca:	b3 e0       	ldi	r27, 0x03	; 3
    4ccc:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
    4cd0:	6b 01       	movw	r12, r22
    4cd2:	7c 01       	movw	r14, r24
    Value /= ((R_LOW * 10) + NV.RiH);        /* in 0.1 Ohms */

    /* U = U_Rl - U_R_i_L = U_Rl - (R_i_L * I) */
    /* U = U_probe1 - U_probe2 */
    Value1 -= Value2;                        /* in 0.1 mV */
    4cd4:	a5 01       	movw	r20, r10
    4cd6:	94 01       	movw	r18, r8
    4cd8:	24 19       	sub	r18, r4
    4cda:	35 09       	sbc	r19, r5
    4cdc:	46 09       	sbc	r20, r6
    4cde:	57 09       	sbc	r21, r7
    Value1 *= 10000;                         /* scale to 0.01 V */
    4ce0:	a0 e1       	ldi	r26, 0x10	; 16
    4ce2:	b7 e2       	ldi	r27, 0x27	; 39
    4ce4:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
    4ce8:	4b 01       	movw	r8, r22
    4cea:	5c 01       	movw	r10, r24
  {
    /* I = U/R = (5V - U_Rl)/(Rl + R_i_H) */
    Value = 10UL * Config.Vcc;               /* in 0.1 mV */
    Value -= Value1;
    Value *= 1000;                           /* scale to A */
    Value /= ((R_LOW * 10) + NV.RiH);        /* in 0.1 Ohms */
    4cec:	20 91 9d 01 	lds	r18, 0x019D
    4cf0:	30 91 9e 01 	lds	r19, 0x019E
    4cf4:	20 57       	subi	r18, 0x70	; 112
    4cf6:	35 4e       	sbci	r19, 0xE5	; 229
    4cf8:	40 e0       	ldi	r20, 0x00	; 0
    4cfa:	50 e0       	ldi	r21, 0x00	; 0
    4cfc:	c7 01       	movw	r24, r14
    4cfe:	b6 01       	movw	r22, r12
    4d00:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    /* U = U_probe1 - U_probe2 */
    Value1 -= Value2;                        /* in 0.1 mV */
    Value1 *= 10000;                         /* scale to 0.01 V */

    /* R = U/I (including R of probe leads) */
    Value1 /= Value;                         /* in 0.01 Ohms */
    4d04:	c5 01       	movw	r24, r10
    4d06:	b4 01       	movw	r22, r8
    4d08:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    R = (uint16_t)Value1;                    /* copy result */
    4d0c:	c9 01       	movw	r24, r18

    if (ZeroFlag == 1)        /* auto-zero */
    4d0e:	f9 81       	ldd	r31, Y+1	; 0x01
    4d10:	f1 30       	cpi	r31, 0x01	; 1
    4d12:	61 f4       	brne	.+24     	; 0x4d2c <SmallResistor+0x208>
    {
      if (R > NV.RZero) R -= NV.RZero;
    4d14:	60 91 9f 01 	lds	r22, 0x019F
    4d18:	70 91 a0 01 	lds	r23, 0x01A0
    4d1c:	62 17       	cp	r22, r18
    4d1e:	73 07       	cpc	r23, r19
    4d20:	18 f4       	brcc	.+6      	; 0x4d28 <SmallResistor+0x204>
    4d22:	86 1b       	sub	r24, r22
    4d24:	97 0b       	sbc	r25, r23
    4d26:	02 c0       	rjmp	.+4      	; 0x4d2c <SmallResistor+0x208>
      else R = 0;
    4d28:	80 e0       	ldi	r24, 0x00	; 0
    4d2a:	90 e0       	ldi	r25, 0x00	; 0

#undef MODE_LOW
#undef MODE_HIGH

  /* update Uref flag for next ADC run */
  Config.RefFlag = (1 << REFS1);        /* set REFS1 bit flag */
    4d2c:	20 e8       	ldi	r18, 0x80	; 128
    4d2e:	20 93 ae 01 	sts	0x01AE, r18

  return R;
    4d32:	0e c0       	rjmp	.+28     	; 0x4d50 <SmallResistor+0x22c>
  uint32_t          Value;         /* ADC sample value */
  uint32_t          Value1 = 0;    /* U_Rl temp. value */
  uint32_t          Value2 = 0;    /* U_R_i_L temp. value */

  DischargeProbes();                    /* try to discharge probes */
  if (Check.Found == COMP_ERROR) return R;   /* skip on error */
    4d34:	80 e0       	ldi	r24, 0x00	; 0
    4d36:	90 e0       	ldi	r25, 0x00	; 0
    4d38:	0b c0       	rjmp	.+22     	; 0x4d50 <SmallResistor+0x22c>
    4d3a:	2c 01       	movw	r4, r24
    4d3c:	3d 01       	movw	r6, r26

  /*
   *  process measurement
   */

  if (Value1 > Value2)             /* sanity check */
    4d3e:	48 14       	cp	r4, r8
    4d40:	59 04       	cpc	r5, r9
    4d42:	6a 04       	cpc	r6, r10
    4d44:	7b 04       	cpc	r7, r11
    4d46:	08 f4       	brcc	.+2      	; 0x4d4a <SmallResistor+0x226>
    4d48:	a1 cf       	rjmp	.-190    	; 0x4c8c <SmallResistor+0x168>
 *  - resistance in 0.01 Ohm
 */

uint16_t SmallResistor(uint8_t ZeroFlag)
{
  uint16_t          R = 0;         /* return value */
    4d4a:	80 e0       	ldi	r24, 0x00	; 0
    4d4c:	90 e0       	ldi	r25, 0x00	; 0
    4d4e:	ee cf       	rjmp	.-36     	; 0x4d2c <SmallResistor+0x208>

  /* update Uref flag for next ADC run */
  Config.RefFlag = (1 << REFS1);        /* set REFS1 bit flag */

  return R;
}
    4d50:	0f 90       	pop	r0
    4d52:	df 91       	pop	r29
    4d54:	cf 91       	pop	r28
    4d56:	1f 91       	pop	r17
    4d58:	0f 91       	pop	r16
    4d5a:	ff 90       	pop	r15
    4d5c:	ef 90       	pop	r14
    4d5e:	df 90       	pop	r13
    4d60:	cf 90       	pop	r12
    4d62:	bf 90       	pop	r11
    4d64:	af 90       	pop	r10
    4d66:	9f 90       	pop	r9
    4d68:	8f 90       	pop	r8
    4d6a:	7f 90       	pop	r7
    4d6c:	6f 90       	pop	r6
    4d6e:	5f 90       	pop	r5
    4d70:	4f 90       	pop	r4
    4d72:	3f 90       	pop	r3
    4d74:	2f 90       	pop	r2
    4d76:	08 95       	ret

00004d78 <CheckResistor>:
/*
 *  check for resistor
 */

void CheckResistor(void)
{
    4d78:	2f 92       	push	r2
    4d7a:	3f 92       	push	r3
    4d7c:	4f 92       	push	r4
    4d7e:	5f 92       	push	r5
    4d80:	6f 92       	push	r6
    4d82:	7f 92       	push	r7
    4d84:	8f 92       	push	r8
    4d86:	9f 92       	push	r9
    4d88:	af 92       	push	r10
    4d8a:	bf 92       	push	r11
    4d8c:	cf 92       	push	r12
    4d8e:	df 92       	push	r13
    4d90:	ef 92       	push	r14
    4d92:	ff 92       	push	r15
    4d94:	0f 93       	push	r16
    4d96:	1f 93       	push	r17
    4d98:	cf 93       	push	r28
    4d9a:	df 93       	push	r29
    4d9c:	cd b7       	in	r28, 0x3d	; 61
    4d9e:	de b7       	in	r29, 0x3e	; 62
    4da0:	62 97       	sbiw	r28, 0x12	; 18
    4da2:	0f b6       	in	r0, 0x3f	; 63
    4da4:	f8 94       	cli
    4da6:	de bf       	out	0x3e, r29	; 62
    4da8:	0f be       	out	0x3f, r0	; 63
    4daa:	cd bf       	out	0x3d, r28	; 61
  uint16_t          U_Ri_H;        /* voltage at Ri oulled up */
  uint16_t          U_Ri_L;        /* voltage at Ri pulled down */
  uint16_t          U_Rh_H;        /* voltage at Rh pulled up */
  uint16_t          U_Rh_L;        /* voltage ar Rh pulled down */

  wdt_reset();                     /* reset watchdog */
    4dac:	a8 95       	wdr
  /* 
   *  Charge possible capacitor and get voltages for Rl pulled up.
   */

  /*  set probes: Gnd -- probe-2 / probe-1 -- Rl -- Vcc */
  ADC_PORT = 0;                         /* set ADC port to low */
    4dae:	18 b8       	out	0x08, r1	; 8
  ADC_DDR = Probes.ADC_2;               /* pull down probe-2 directly */
    4db0:	0f e8       	ldi	r16, 0x8F	; 143
    4db2:	11 e0       	ldi	r17, 0x01	; 1
    4db4:	d8 01       	movw	r26, r16
    4db6:	1a 96       	adiw	r26, 0x0a	; 10
    4db8:	8c 91       	ld	r24, X
    4dba:	1a 97       	sbiw	r26, 0x0a	; 10
    4dbc:	87 b9       	out	0x07, r24	; 7
  R_DDR = Probes.Rl_1;                  /* enable Rl for probe-1 */
    4dbe:	13 96       	adiw	r26, 0x03	; 3
    4dc0:	8c 91       	ld	r24, X
    4dc2:	13 97       	sbiw	r26, 0x03	; 3
    4dc4:	84 b9       	out	0x04, r24	; 4
  R_PORT = Probes.Rl_1;                 /* pull up probe-1 via Rl */
    4dc6:	85 b9       	out	0x05, r24	; 5
  U_Ri_L = ReadU_5ms(Probes.Pin_2);     /* get voltage at internal R of MCU */
    4dc8:	11 96       	adiw	r26, 0x01	; 1
    4dca:	8c 91       	ld	r24, X
    4dcc:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
    4dd0:	5c 01       	movw	r10, r24
  U_Rl_H = ReadU(Probes.Pin_1);         /* get voltage at Rl pulled up */
    4dd2:	f8 01       	movw	r30, r16
    4dd4:	80 81       	ld	r24, Z
    4dd6:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    4dda:	6c 01       	movw	r12, r24
  /*
   *  discharge possible capacitor
   */

  /* set probes: Gnd -- probe-2 / Gnd -- Rh -- probe-1 */
  R_PORT = 0;                           /* set resistor port low */
    4ddc:	15 b8       	out	0x05, r1	; 5
  R_DDR = Probes.Rh_1;                  /* pull down probe-1 via Rh */
    4dde:	d8 01       	movw	r26, r16
    4de0:	14 96       	adiw	r26, 0x04	; 4
    4de2:	9c 91       	ld	r25, X
    4de4:	14 97       	sbiw	r26, 0x04	; 4
    4de6:	94 b9       	out	0x04, r25	; 4
  U_Rh_L = ReadU_5ms(Probes.Pin_1);     /* get voltage at probe 1 */
    4de8:	8c 91       	ld	r24, X
    4dea:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>

  /* we got a resistor if the voltage is near Gnd */
  if (U_Rh_L <= 20)
    4dee:	45 97       	sbiw	r24, 0x15	; 21
    4df0:	08 f0       	brcs	.+2      	; 0x4df4 <CheckResistor+0x7c>
    4df2:	92 c2       	rjmp	.+1316   	; 0x5318 <CheckResistor+0x5a0>
    /*
     *  get voltage at Rh pulled up
     */

    /* set probes: Gnd -- probe-2 / probe-1 -- Rh -- Vcc */
    R_PORT = Probes.Rh_1;                    /* pull up probe-1 via Rh */
    4df4:	f8 01       	movw	r30, r16
    4df6:	84 81       	ldd	r24, Z+4	; 0x04
    4df8:	85 b9       	out	0x05, r24	; 5
    U_Rh_H = ReadU_5ms(Probes.Pin_1);        /* get voltage at Rh pulled up */
    4dfa:	80 81       	ld	r24, Z
    4dfc:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
    4e00:	3c 01       	movw	r6, r24
    /*
     *  get voltage at Rl pulled down and Rh pulled down
     */

    /* set probes: Gnd -- Rl -- probe-2 / probe-1 -- Vcc */
    ADC_DDR = Probes.ADC_1;                  /* set probe-1 to output */
    4e02:	d8 01       	movw	r26, r16
    4e04:	19 96       	adiw	r26, 0x09	; 9
    4e06:	9c 91       	ld	r25, X
    4e08:	19 97       	sbiw	r26, 0x09	; 9
    4e0a:	97 b9       	out	0x07, r25	; 7
    ADC_PORT = Probes.ADC_1;                 /* pull up probe-1 directly */
    4e0c:	98 b9       	out	0x08, r25	; 8
    R_PORT = 0;                              /* set resistor port to low */ 
    4e0e:	15 b8       	out	0x05, r1	; 5
    R_DDR = Probes.Rl_2;                     /* pull down probe-2 via Rl */
    4e10:	15 96       	adiw	r26, 0x05	; 5
    4e12:	8c 91       	ld	r24, X
    4e14:	15 97       	sbiw	r26, 0x05	; 5
    4e16:	84 b9       	out	0x04, r24	; 4
    U_Ri_H = ReadU_5ms(Probes.Pin_1);        /* get voltage at internal R of MCU */
    4e18:	8c 91       	ld	r24, X
    4e1a:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
    4e1e:	1c 01       	movw	r2, r24
    U_Rl_L = ReadU(Probes.Pin_2);            /* get voltage at Rl pulled down */
    4e20:	f8 01       	movw	r30, r16
    4e22:	81 81       	ldd	r24, Z+1	; 0x01
    4e24:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    4e28:	2c 01       	movw	r4, r24

    /* set probes: Gnd -- Rh -- probe-2 / probe-1 -- Vcc */
    R_DDR = Probes.Rh_2;                /* pull down probe-2 via Rh */
    4e2a:	d8 01       	movw	r26, r16
    4e2c:	16 96       	adiw	r26, 0x06	; 6
    4e2e:	8c 91       	ld	r24, X
    4e30:	16 97       	sbiw	r26, 0x06	; 6
    4e32:	84 b9       	out	0x04, r24	; 4
    U_Rh_L = ReadU_5ms(Probes.Pin_2);   /* get voltage at Rh pulled down */
    4e34:	11 96       	adiw	r26, 0x01	; 1
    4e36:	8c 91       	ld	r24, X
    4e38:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
    4e3c:	7c 01       	movw	r14, r24

    /* if voltage breakdown is sufficient */
    if ((U_Rl_H >= 4400) || (U_Rh_H <= 97))   /* R >= 5.1k or R < 9.3k */
    4e3e:	b0 e3       	ldi	r27, 0x30	; 48
    4e40:	cb 16       	cp	r12, r27
    4e42:	b1 e1       	ldi	r27, 0x11	; 17
    4e44:	db 06       	cpc	r13, r27
    4e46:	28 f4       	brcc	.+10     	; 0x4e52 <CheckResistor+0xda>
    4e48:	e2 e6       	ldi	r30, 0x62	; 98
    4e4a:	6e 16       	cp	r6, r30
    4e4c:	71 04       	cpc	r7, r1
    4e4e:	08 f0       	brcs	.+2      	; 0x4e52 <CheckResistor+0xda>
    4e50:	63 c2       	rjmp	.+1222   	; 0x5318 <CheckResistor+0x5a0>
    {
      if (U_Rh_H < 4972)            /* R < 83.4M & prevent division by zero */
    4e52:	fc e6       	ldi	r31, 0x6C	; 108
    4e54:	6f 16       	cp	r6, r31
    4e56:	f3 e1       	ldi	r31, 0x13	; 19
    4e58:	7f 06       	cpc	r7, r31
    4e5a:	08 f0       	brcs	.+2      	; 0x4e5e <CheckResistor+0xe6>
    4e5c:	5d c2       	rjmp	.+1210   	; 0x5318 <CheckResistor+0x5a0>
        /* voltage breaks down with low test current and it is not nearly 
           shorted => resistor */

        Value = 0;                      /* reset value of resistor */

        if (U_Rl_L < 169)               /* R > 19.5k */
    4e5e:	29 ea       	ldi	r18, 0xA9	; 169
    4e60:	42 16       	cp	r4, r18
    4e62:	51 04       	cpc	r5, r1
    4e64:	08 f0       	brcs	.+2      	; 0x4e68 <CheckResistor+0xf0>
    4e66:	84 c0       	rjmp	.+264    	; 0x4f70 <CheckResistor+0x1f8>
          /*
           *  use measurements done with Rh
           */

          /* resistor is less than 60MOhm */
          if (U_Rh_L >= 38)        /* R < 61.4M & prevent division by zero */
    4e68:	36 e2       	ldi	r19, 0x26	; 38
    4e6a:	e3 16       	cp	r14, r19
    4e6c:	f1 04       	cpc	r15, r1
    4e6e:	08 f4       	brcc	.+2      	; 0x4e72 <CheckResistor+0xfa>
    4e70:	53 c2       	rjmp	.+1190   	; 0x5318 <CheckResistor+0x5a0>
             *  Or via voltage divider:
             *  R = Rh * (U_dut / U_Rh)
             *    = Rh * (U_Rh_H / (Vcc - U_Rh_H))
             */

            Value1 = R_HIGH * U_Rh_H;
    4e72:	d3 01       	movw	r26, r6
    4e74:	20 ef       	ldi	r18, 0xF0	; 240
    4e76:	3b e2       	ldi	r19, 0x2B	; 43
    4e78:	47 e0       	ldi	r20, 0x07	; 7
    4e7a:	50 e0       	ldi	r21, 0x00	; 0
    4e7c:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
            Value1 /= (Config.Vcc - U_Rh_H);
    4e80:	c0 90 b1 01 	lds	r12, 0x01B1
    4e84:	d0 90 b2 01 	lds	r13, 0x01B2
    4e88:	96 01       	movw	r18, r12
    4e8a:	26 19       	sub	r18, r6
    4e8c:	37 09       	sbc	r19, r7
    4e8e:	40 e0       	ldi	r20, 0x00	; 0
    4e90:	50 e0       	ldi	r21, 0x00	; 0
    4e92:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    4e96:	49 01       	movw	r8, r18
    4e98:	5a 01       	movw	r10, r20
             *  Or via voltage divider:
             *  R = Rh * (U_R / U_Rh)
             *    = Rh * ((Vcc - U_Rh_L) / U_Rh_L)
             */

            Value2 = R_HIGH * (Config.Vcc - U_Rh_L);
    4e9a:	d6 01       	movw	r26, r12
    4e9c:	ae 19       	sub	r26, r14
    4e9e:	bf 09       	sbc	r27, r15
    4ea0:	20 ef       	ldi	r18, 0xF0	; 240
    4ea2:	3b e2       	ldi	r19, 0x2B	; 43
    4ea4:	47 e0       	ldi	r20, 0x07	; 7
    4ea6:	50 e0       	ldi	r21, 0x00	; 0
    4ea8:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
            Value2 /= U_Rh_L;
    4eac:	87 01       	movw	r16, r14
    4eae:	20 e0       	ldi	r18, 0x00	; 0
    4eb0:	30 e0       	ldi	r19, 0x00	; 0
    4eb2:	a9 01       	movw	r20, r18
    4eb4:	98 01       	movw	r18, r16
    4eb6:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
             *  calculate weighted average of both measurements
             *  - Voltages below the bandgap reference got a higher resolution
             *    (1.1mV instead of 4.9mV).
             */

            if (U_Rh_H < 990)           /* below bandgap reference */
    4eba:	8e ed       	ldi	r24, 0xDE	; 222
    4ebc:	68 16       	cp	r6, r24
    4ebe:	83 e0       	ldi	r24, 0x03	; 3
    4ec0:	78 06       	cpc	r7, r24
    4ec2:	a8 f4       	brcc	.+42     	; 0x4eee <CheckResistor+0x176>
            {
              /* weighted average for U_Rh_H */
              Value = (Value1 * 4);
    4ec4:	88 0c       	add	r8, r8
    4ec6:	99 1c       	adc	r9, r9
    4ec8:	aa 1c       	adc	r10, r10
    4eca:	bb 1c       	adc	r11, r11
    4ecc:	88 0c       	add	r8, r8
    4ece:	99 1c       	adc	r9, r9
    4ed0:	aa 1c       	adc	r10, r10
    4ed2:	bb 1c       	adc	r11, r11
              Value += Value2;
    4ed4:	c5 01       	movw	r24, r10
    4ed6:	b4 01       	movw	r22, r8
    4ed8:	62 0f       	add	r22, r18
    4eda:	73 1f       	adc	r23, r19
    4edc:	84 1f       	adc	r24, r20
    4ede:	95 1f       	adc	r25, r21
              Value /= 5;
    4ee0:	25 e0       	ldi	r18, 0x05	; 5
    4ee2:	30 e0       	ldi	r19, 0x00	; 0
    4ee4:	40 e0       	ldi	r20, 0x00	; 0
    4ee6:	50 e0       	ldi	r21, 0x00	; 0
    4ee8:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    4eec:	28 c0       	rjmp	.+80     	; 0x4f3e <CheckResistor+0x1c6>
            }
            else if (U_Rh_L < 990)      /* below bandgap reference */
    4eee:	9e ed       	ldi	r25, 0xDE	; 222
    4ef0:	e9 16       	cp	r14, r25
    4ef2:	93 e0       	ldi	r25, 0x03	; 3
    4ef4:	f9 06       	cpc	r15, r25
    4ef6:	b8 f4       	brcc	.+46     	; 0x4f26 <CheckResistor+0x1ae>
            {
              /* weighted average for U_Rh_L */
              Value = (Value2 * 4);
    4ef8:	da 01       	movw	r26, r20
    4efa:	c9 01       	movw	r24, r18
    4efc:	88 0f       	add	r24, r24
    4efe:	99 1f       	adc	r25, r25
    4f00:	aa 1f       	adc	r26, r26
    4f02:	bb 1f       	adc	r27, r27
    4f04:	88 0f       	add	r24, r24
    4f06:	99 1f       	adc	r25, r25
    4f08:	aa 1f       	adc	r26, r26
    4f0a:	bb 1f       	adc	r27, r27
              Value += Value1;
    4f0c:	bc 01       	movw	r22, r24
    4f0e:	cd 01       	movw	r24, r26
    4f10:	68 0d       	add	r22, r8
    4f12:	79 1d       	adc	r23, r9
    4f14:	8a 1d       	adc	r24, r10
    4f16:	9b 1d       	adc	r25, r11
              Value /= 5;
    4f18:	25 e0       	ldi	r18, 0x05	; 5
    4f1a:	30 e0       	ldi	r19, 0x00	; 0
    4f1c:	40 e0       	ldi	r20, 0x00	; 0
    4f1e:	50 e0       	ldi	r21, 0x00	; 0
    4f20:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    4f24:	0c c0       	rjmp	.+24     	; 0x4f3e <CheckResistor+0x1c6>
            }
            else                        /* higher than bandgap reference */
            {
              /* classic average */
              Value = (Value1 + Value2) / 2;
    4f26:	da 01       	movw	r26, r20
    4f28:	c9 01       	movw	r24, r18
    4f2a:	88 0d       	add	r24, r8
    4f2c:	99 1d       	adc	r25, r9
    4f2e:	aa 1d       	adc	r26, r10
    4f30:	bb 1d       	adc	r27, r11
    4f32:	9c 01       	movw	r18, r24
    4f34:	ad 01       	movw	r20, r26
    4f36:	56 95       	lsr	r21
    4f38:	47 95       	ror	r20
    4f3a:	37 95       	ror	r19
    4f3c:	27 95       	ror	r18
            }

            Value += RH_OFFSET;         /* add offset value for Rh */
    4f3e:	da 01       	movw	r26, r20
    4f40:	c9 01       	movw	r24, r18
    4f42:	84 54       	subi	r24, 0x44	; 68
    4f44:	9d 4f       	sbci	r25, 0xFD	; 253
    4f46:	af 4f       	sbci	r26, 0xFF	; 255
    4f48:	bf 4f       	sbci	r27, 0xFF	; 255
            Value *= 10;                /* upscale to 0.1 Ohms */
    4f4a:	88 0f       	add	r24, r24
    4f4c:	99 1f       	adc	r25, r25
    4f4e:	aa 1f       	adc	r26, r26
    4f50:	bb 1f       	adc	r27, r27
    4f52:	4c 01       	movw	r8, r24
    4f54:	5d 01       	movw	r10, r26
    4f56:	88 0c       	add	r8, r8
    4f58:	99 1c       	adc	r9, r9
    4f5a:	aa 1c       	adc	r10, r10
    4f5c:	bb 1c       	adc	r11, r11
    4f5e:	88 0c       	add	r8, r8
    4f60:	99 1c       	adc	r9, r9
    4f62:	aa 1c       	adc	r10, r10
    4f64:	bb 1c       	adc	r11, r11
    4f66:	88 0e       	add	r8, r24
    4f68:	99 1e       	adc	r9, r25
    4f6a:	aa 1e       	adc	r10, r26
    4f6c:	bb 1e       	adc	r11, r27
    4f6e:	8a c0       	rjmp	.+276    	; 0x5084 <CheckResistor+0x30c>
           *  use measurements done with Rl
           */

          /* voltages below and above DUT match voltage divider */
          /* voltage below DUT can't be higher than above DUT */
          if ((U_Rl_H >= U_Ri_L) && (U_Ri_H >= U_Rl_L))
    4f70:	ca 14       	cp	r12, r10
    4f72:	db 04       	cpc	r13, r11
    4f74:	08 f4       	brcc	.+2      	; 0x4f78 <CheckResistor+0x200>
    4f76:	78 c0       	rjmp	.+240    	; 0x5068 <CheckResistor+0x2f0>
    4f78:	24 14       	cp	r2, r4
    4f7a:	35 04       	cpc	r3, r5
    4f7c:	08 f4       	brcc	.+2      	; 0x4f80 <CheckResistor+0x208>
    4f7e:	74 c0       	rjmp	.+232    	; 0x5068 <CheckResistor+0x2f0>
             *  Or via voltage divider:
             *  R = (Rl + RiH) * (U_R_RiL / U_Rl_RiH) - RiL
             *    = (Rl + RiH) * (U_R_RiL / (Vcc - U_dut_RiL)) - RiL
             */

            if (U_Rl_H == Config.Vcc) U_Rl_H = Config.Vcc - 1;   /* prevent division by zero */
    4f80:	40 91 b1 01 	lds	r20, 0x01B1
    4f84:	50 91 b2 01 	lds	r21, 0x01B2
    4f88:	4c 15       	cp	r20, r12
    4f8a:	5d 05       	cpc	r21, r13
    4f8c:	21 f4       	brne	.+8      	; 0x4f96 <CheckResistor+0x21e>
    4f8e:	6a 01       	movw	r12, r20
    4f90:	a1 e0       	ldi	r26, 0x01	; 1
    4f92:	ca 1a       	sub	r12, r26
    4f94:	d1 08       	sbc	r13, r1
            Value1 = (R_LOW * 10) + NV.RiH;       /* Rl + RiH in 0.1 Ohm */
    4f96:	0b e9       	ldi	r16, 0x9B	; 155
    4f98:	11 e0       	ldi	r17, 0x01	; 1
    4f9a:	f8 01       	movw	r30, r16
    4f9c:	22 81       	ldd	r18, Z+2	; 0x02
    4f9e:	33 81       	ldd	r19, Z+3	; 0x03
    4fa0:	20 57       	subi	r18, 0x70	; 112
    4fa2:	35 4e       	sbci	r19, 0xE5	; 229
            Value1 *= (U_Rl_H - U_Ri_L);
    4fa4:	d6 01       	movw	r26, r12
    4fa6:	aa 19       	sub	r26, r10
    4fa8:	bb 09       	sbc	r27, r11
    4faa:	0e 94 cd 36 	call	0x6d9a	; 0x6d9a <__umulhisi3>
            Value1 /= (Config.Vcc - U_Rl_H);
    4fae:	9a 01       	movw	r18, r20
    4fb0:	2c 19       	sub	r18, r12
    4fb2:	3d 09       	sbc	r19, r13
    4fb4:	40 e0       	ldi	r20, 0x00	; 0
    4fb6:	50 e0       	ldi	r21, 0x00	; 0
    4fb8:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    4fbc:	49 01       	movw	r8, r18
    4fbe:	5a 01       	movw	r10, r20
             *  Or via voltage divider:
             *  R = (Rl + RiL) * (U_R_RiH / U_Rl_RiL) - RiH
             *    = (Rl + RiL) * ((Vcc - U_Rl_RiL) / U_Rl_RiL) - RiH
             */

            Value2 = (R_LOW * 10) + NV.RiL;       /* Rl + RiL in 0.1 Ohms */
    4fc0:	d8 01       	movw	r26, r16
    4fc2:	2d 91       	ld	r18, X+
    4fc4:	3c 91       	ld	r19, X
    4fc6:	20 57       	subi	r18, 0x70	; 112
    4fc8:	35 4e       	sbci	r19, 0xE5	; 229
            Value2 *= (U_Ri_H - U_Rl_L);
    4fca:	d1 01       	movw	r26, r2
    4fcc:	a4 19       	sub	r26, r4
    4fce:	b5 09       	sbc	r27, r5
    4fd0:	0e 94 cd 36 	call	0x6d9a	; 0x6d9a <__umulhisi3>
            Value2 /= U_Rl_L;
    4fd4:	82 01       	movw	r16, r4
    4fd6:	20 e0       	ldi	r18, 0x00	; 0
    4fd8:	30 e0       	ldi	r19, 0x00	; 0
    4fda:	a9 01       	movw	r20, r18
    4fdc:	98 01       	movw	r18, r16
    4fde:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
             *  calculate weighted average of both measurements
             *  - Voltages below the bandgap reference got a higher resolution
             *    (1.1mV instead of 4.9mV).
             */

            if (U_Rl_H < 990)           /* below bandgap reference */
    4fe2:	be ed       	ldi	r27, 0xDE	; 222
    4fe4:	cb 16       	cp	r12, r27
    4fe6:	b3 e0       	ldi	r27, 0x03	; 3
    4fe8:	db 06       	cpc	r13, r27
    4fea:	b8 f4       	brcc	.+46     	; 0x501a <CheckResistor+0x2a2>
            {
              /* weighted average for U_Rh_H */
              Value = (Value1 * 4);
    4fec:	88 0c       	add	r8, r8
    4fee:	99 1c       	adc	r9, r9
    4ff0:	aa 1c       	adc	r10, r10
    4ff2:	bb 1c       	adc	r11, r11
    4ff4:	88 0c       	add	r8, r8
    4ff6:	99 1c       	adc	r9, r9
    4ff8:	aa 1c       	adc	r10, r10
    4ffa:	bb 1c       	adc	r11, r11
              Value += Value2;
    4ffc:	c5 01       	movw	r24, r10
    4ffe:	b4 01       	movw	r22, r8
    5000:	62 0f       	add	r22, r18
    5002:	73 1f       	adc	r23, r19
    5004:	84 1f       	adc	r24, r20
    5006:	95 1f       	adc	r25, r21
              Value /= 5;
    5008:	25 e0       	ldi	r18, 0x05	; 5
    500a:	30 e0       	ldi	r19, 0x00	; 0
    500c:	40 e0       	ldi	r20, 0x00	; 0
    500e:	50 e0       	ldi	r21, 0x00	; 0
    5010:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    5014:	49 01       	movw	r8, r18
    5016:	5a 01       	movw	r10, r20
    5018:	35 c0       	rjmp	.+106    	; 0x5084 <CheckResistor+0x30c>
            }
            else if (U_Rl_L < 990)      /* below bandgap reference */
    501a:	ee ed       	ldi	r30, 0xDE	; 222
    501c:	4e 16       	cp	r4, r30
    501e:	e3 e0       	ldi	r30, 0x03	; 3
    5020:	5e 06       	cpc	r5, r30
    5022:	c8 f4       	brcc	.+50     	; 0x5056 <CheckResistor+0x2de>
            {
              /* weighted average for U_Rh_L */
              Value = (Value2 * 4);
    5024:	da 01       	movw	r26, r20
    5026:	c9 01       	movw	r24, r18
    5028:	88 0f       	add	r24, r24
    502a:	99 1f       	adc	r25, r25
    502c:	aa 1f       	adc	r26, r26
    502e:	bb 1f       	adc	r27, r27
    5030:	88 0f       	add	r24, r24
    5032:	99 1f       	adc	r25, r25
    5034:	aa 1f       	adc	r26, r26
    5036:	bb 1f       	adc	r27, r27
              Value += Value1;
    5038:	bc 01       	movw	r22, r24
    503a:	cd 01       	movw	r24, r26
    503c:	68 0d       	add	r22, r8
    503e:	79 1d       	adc	r23, r9
    5040:	8a 1d       	adc	r24, r10
    5042:	9b 1d       	adc	r25, r11
              Value /= 5;
    5044:	25 e0       	ldi	r18, 0x05	; 5
    5046:	30 e0       	ldi	r19, 0x00	; 0
    5048:	40 e0       	ldi	r20, 0x00	; 0
    504a:	50 e0       	ldi	r21, 0x00	; 0
    504c:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    5050:	49 01       	movw	r8, r18
    5052:	5a 01       	movw	r10, r20
    5054:	17 c0       	rjmp	.+46     	; 0x5084 <CheckResistor+0x30c>
            }
            else                        /* higher than bandgap reference */
            {
              /* classic average */
              Value = (Value1 + Value2) / 2;
    5056:	82 0e       	add	r8, r18
    5058:	93 1e       	adc	r9, r19
    505a:	a4 1e       	adc	r10, r20
    505c:	b5 1e       	adc	r11, r21
    505e:	b6 94       	lsr	r11
    5060:	a7 94       	ror	r10
    5062:	97 94       	ror	r9
    5064:	87 94       	ror	r8
    5066:	0e c0       	rjmp	.+28     	; 0x5084 <CheckResistor+0x30c>
            }
          }
          else      /* may happen for very low resistances */
          {
            if (U_Rl_L > 4750) Value = 1;    /* U_Rl_L: R < 15 Ohms */
    5068:	31 e0       	ldi	r19, 0x01	; 1
    506a:	20 e0       	ldi	r18, 0x00	; 0
    506c:	90 e0       	ldi	r25, 0x00	; 0
    506e:	80 e0       	ldi	r24, 0x00	; 0
    5070:	ff e8       	ldi	r31, 0x8F	; 143
    5072:	4f 16       	cp	r4, r31
    5074:	f2 e1       	ldi	r31, 0x12	; 18
    5076:	5f 06       	cpc	r5, r31
    5078:	08 f4       	brcc	.+2      	; 0x507c <CheckResistor+0x304>
    507a:	30 e0       	ldi	r19, 0x00	; 0
              /* classic average */
              Value = (Value1 + Value2) / 2;
            }

            Value += RH_OFFSET;         /* add offset value for Rh */
            Value *= 10;                /* upscale to 0.1 Ohms */
    507c:	83 2e       	mov	r8, r19
    507e:	92 2e       	mov	r9, r18
    5080:	a9 2e       	mov	r10, r25
    5082:	b8 2e       	mov	r11, r24

        /*
         *  process results of the resistance measurement
         */

        if (Value > 0)             /* valid resistor */
    5084:	81 14       	cp	r8, r1
    5086:	91 04       	cpc	r9, r1
    5088:	a1 04       	cpc	r10, r1
    508a:	b1 04       	cpc	r11, r1
    508c:	09 f4       	brne	.+2      	; 0x5090 <CheckResistor+0x318>
    508e:	44 c1       	rjmp	.+648    	; 0x5318 <CheckResistor+0x5a0>

          /*
           *  meassure small resistor <10 Ohm with special method
           */

          if (Value < 100UL)
    5090:	24 e6       	ldi	r18, 0x64	; 100
    5092:	82 16       	cp	r8, r18
    5094:	91 04       	cpc	r9, r1
    5096:	a1 04       	cpc	r10, r1
    5098:	b1 04       	cpc	r11, r1
    509a:	48 f5       	brcc	.+82     	; 0x50ee <CheckResistor+0x376>
          {
            /* run low resistance measurement (in 0.01 Ohms) */
            Value2 = (uint32_t)SmallResistor(1);
    509c:	81 e0       	ldi	r24, 0x01	; 1
    509e:	0e 94 92 25 	call	0x4b24	; 0x4b24 <SmallResistor>
    50a2:	a0 e0       	ldi	r26, 0x00	; 0
    50a4:	b0 e0       	ldi	r27, 0x00	; 0

            /* check for valid result */
            Value1 = Value * 2;         /* allow 100% tolerance */       
            Value1 *= 10;               /* re-scale to 0.01 Ohms */     
    50a6:	95 01       	movw	r18, r10
    50a8:	84 01       	movw	r16, r8
    50aa:	00 0f       	add	r16, r16
    50ac:	11 1f       	adc	r17, r17
    50ae:	22 1f       	adc	r18, r18
    50b0:	33 1f       	adc	r19, r19
    50b2:	00 0f       	add	r16, r16
    50b4:	11 1f       	adc	r17, r17
    50b6:	22 1f       	adc	r18, r18
    50b8:	33 1f       	adc	r19, r19
    50ba:	b9 01       	movw	r22, r18
    50bc:	a8 01       	movw	r20, r16
    50be:	44 0f       	add	r20, r20
    50c0:	55 1f       	adc	r21, r21
    50c2:	66 1f       	adc	r22, r22
    50c4:	77 1f       	adc	r23, r23
    50c6:	44 0f       	add	r20, r20
    50c8:	55 1f       	adc	r21, r21
    50ca:	66 1f       	adc	r22, r22
    50cc:	77 1f       	adc	r23, r23
    50ce:	40 0f       	add	r20, r16
    50d0:	51 1f       	adc	r21, r17
    50d2:	62 1f       	adc	r22, r18
    50d4:	73 1f       	adc	r23, r19

            if (Value1 > Value2)        /* got expected value */
    50d6:	84 17       	cp	r24, r20
    50d8:	95 07       	cpc	r25, r21
    50da:	a6 07       	cpc	r26, r22
    50dc:	b7 07       	cpc	r27, r23
    50de:	50 f4       	brcc	.+20     	; 0x50f4 <CheckResistor+0x37c>
            {
              Value = Value2;           /* update data */
    50e0:	4c 01       	movw	r8, r24
    50e2:	5d 01       	movw	r10, r26
              Scale = -2;               /* 0.01 Ohm */
    50e4:	0f 2e       	mov	r0, r31
    50e6:	fe ef       	ldi	r31, 0xFE	; 254
    50e8:	ff 2e       	mov	r15, r31
    50ea:	f0 2d       	mov	r31, r0
    50ec:	05 c0       	rjmp	.+10     	; 0x50f8 <CheckResistor+0x380>
         *  process results of the resistance measurement
         */

        if (Value > 0)             /* valid resistor */
        {
          Scale = -1;              /* 0.1 Ohm by default */
    50ee:	ff 24       	eor	r15, r15
    50f0:	fa 94       	dec	r15
    50f2:	02 c0       	rjmp	.+4      	; 0x50f8 <CheckResistor+0x380>
    50f4:	ff 24       	eor	r15, r15
    50f6:	fa 94       	dec	r15
              {
                Temp = Value / 2;            /* 50% */
              }
              else                                     /* >= 2 Ohm */
              {
                Temp = Value / 20;           /* 5% */
    50f8:	c5 01       	movw	r24, r10
    50fa:	b4 01       	movw	r22, r8
    50fc:	24 e1       	ldi	r18, 0x14	; 20
    50fe:	30 e0       	ldi	r19, 0x00	; 0
    5100:	40 e0       	ldi	r20, 0x00	; 0
    5102:	50 e0       	ldi	r21, 0x00	; 0
    5104:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>

              /* special case for very low resistance */
              if (CmpValue(Value, Scale, 1, -1) == -1)   /* < 0.1 Ohm */
              {
                Value1 = 0;                  /* 0 */
                Value2 = Value * 5;          /* 500% */
    5108:	d5 01       	movw	r26, r10
    510a:	c4 01       	movw	r24, r8
    510c:	88 0f       	add	r24, r24
    510e:	99 1f       	adc	r25, r25
    5110:	aa 1f       	adc	r26, r26
    5112:	bb 1f       	adc	r27, r27
    5114:	88 0f       	add	r24, r24
    5116:	99 1f       	adc	r25, r25
    5118:	aa 1f       	adc	r26, r26
    511a:	bb 1f       	adc	r27, r27
    511c:	2c 01       	movw	r4, r24
    511e:	3d 01       	movw	r6, r26
    5120:	48 0c       	add	r4, r8
    5122:	59 1c       	adc	r5, r9
    5124:	6a 1c       	adc	r6, r10
    5126:	7b 1c       	adc	r7, r11

          /*
           *  check for measurement in reversed direction
           */

          n = 0;
    5128:	80 e0       	ldi	r24, 0x00	; 0
          while (n < Check.Resistors)           /* loop through resistors */
    512a:	0f 2e       	mov	r0, r31
    512c:	f8 e0       	ldi	r31, 0x08	; 8
    512e:	2f 2e       	mov	r2, r31
    5130:	f1 e0       	ldi	r31, 0x01	; 1
    5132:	3f 2e       	mov	r3, r31
    5134:	f0 2d       	mov	r31, r0
          {
            Resistor = &Resistors[n];           /* pointer to element */

            if ((Resistor->A == Probes.Pin_1) && (Resistor->B == Probes.Pin_2))
    5136:	0f 2e       	mov	r0, r31
    5138:	ff e8       	ldi	r31, 0x8F	; 143
    513a:	cf 2e       	mov	r12, r31
    513c:	f1 e0       	ldi	r31, 0x01	; 1
    513e:	df 2e       	mov	r13, r31
    5140:	f0 2d       	mov	r31, r0

              /* special case for very low resistance */
              if (CmpValue(Value, Scale, 1, -1) == -1)   /* < 0.1 Ohm */
              {
                Value1 = 0;                  /* 0 */
                Value2 = Value * 5;          /* 500% */
    5142:	4d 86       	std	Y+13, r4	; 0x0d
    5144:	5e 86       	std	Y+14, r5	; 0x0e
    5146:	6f 86       	std	Y+15, r6	; 0x0f
    5148:	78 8a       	std	Y+16, r7	; 0x10
              {
                Temp = Value / 2;            /* 50% */
              }
              else                                     /* >= 2 Ohm */
              {
                Temp = Value / 20;           /* 5% */
    514a:	2d 83       	std	Y+5, r18	; 0x05
    514c:	3e 83       	std	Y+6, r19	; 0x06
    514e:	4f 83       	std	Y+7, r20	; 0x07
    5150:	58 87       	std	Y+8, r21	; 0x08
               */

              /* set lower and upper tolerance limits */
              if (CmpValue(Value, Scale, 2, 0) == -1)  /* < 2 Ohm */
              {
                Temp = Value / 2;            /* 50% */
    5152:	a5 01       	movw	r20, r10
    5154:	94 01       	movw	r18, r8
    5156:	56 95       	lsr	r21
    5158:	47 95       	ror	r20
    515a:	37 95       	ror	r19
    515c:	27 95       	ror	r18
    515e:	29 87       	std	Y+9, r18	; 0x09
    5160:	3a 87       	std	Y+10, r19	; 0x0a
    5162:	4b 87       	std	Y+11, r20	; 0x0b
    5164:	5c 87       	std	Y+12, r21	; 0x0c
          /*
           *  check for measurement in reversed direction
           */

          n = 0;
          while (n < Check.Resistors)           /* loop through resistors */
    5166:	b8 c0       	rjmp	.+368    	; 0x52d8 <CheckResistor+0x560>
          {
            Resistor = &Resistors[n];           /* pointer to element */

            if ((Resistor->A == Probes.Pin_1) && (Resistor->B == Probes.Pin_2))
    5168:	48 2f       	mov	r20, r24
    516a:	50 e0       	ldi	r21, 0x00	; 0
    516c:	5a 8b       	std	Y+18, r21	; 0x12
    516e:	49 8b       	std	Y+17, r20	; 0x11
    5170:	57 e0       	ldi	r21, 0x07	; 7
    5172:	85 9f       	mul	r24, r21
    5174:	f0 01       	movw	r30, r0
    5176:	11 24       	eor	r1, r1
    5178:	ef 5e       	subi	r30, 0xEF	; 239
    517a:	fe 4f       	sbci	r31, 0xFE	; 254
    517c:	20 81       	ld	r18, Z
    517e:	d6 01       	movw	r26, r12
    5180:	9c 91       	ld	r25, X
    5182:	29 13       	cpse	r18, r25
    5184:	a4 c0       	rjmp	.+328    	; 0x52ce <CheckResistor+0x556>
    5186:	e9 89       	ldd	r30, Y+17	; 0x11
    5188:	fa 89       	ldd	r31, Y+18	; 0x12
    518a:	ee 0f       	add	r30, r30
    518c:	ff 1f       	adc	r31, r31
    518e:	ee 0f       	add	r30, r30
    5190:	ff 1f       	adc	r31, r31
    5192:	ee 0f       	add	r30, r30
    5194:	ff 1f       	adc	r31, r31
    5196:	29 89       	ldd	r18, Y+17	; 0x11
    5198:	3a 89       	ldd	r19, Y+18	; 0x12
    519a:	e2 1b       	sub	r30, r18
    519c:	f3 0b       	sbc	r31, r19
    519e:	ef 5e       	subi	r30, 0xEF	; 239
    51a0:	fe 4f       	sbci	r31, 0xFE	; 254
    51a2:	21 81       	ldd	r18, Z+1	; 0x01
    51a4:	11 96       	adiw	r26, 0x01	; 1
    51a6:	9c 91       	ld	r25, X
    51a8:	29 13       	cpse	r18, r25
    51aa:	91 c0       	rjmp	.+290    	; 0x52ce <CheckResistor+0x556>
              /*
               *  check if the reversed measurement is within a specific tolerance
               */

              /* set lower and upper tolerance limits */
              if (CmpValue(Value, Scale, 2, 0) == -1)  /* < 2 Ohm */
    51ac:	e1 2c       	mov	r14, r1
    51ae:	02 e0       	ldi	r16, 0x02	; 2
    51b0:	10 e0       	ldi	r17, 0x00	; 0
    51b2:	20 e0       	ldi	r18, 0x00	; 0
    51b4:	30 e0       	ldi	r19, 0x00	; 0
    51b6:	4f 2d       	mov	r20, r15
    51b8:	c5 01       	movw	r24, r10
    51ba:	b4 01       	movw	r22, r8
    51bc:	0e 94 ac 31 	call	0x6358	; 0x6358 <CmpValue>
    51c0:	8f 3f       	cpi	r24, 0xFF	; 255
    51c2:	49 f4       	brne	.+18     	; 0x51d6 <CheckResistor+0x45e>
              {
                Temp = Value / 2;            /* 50% */
    51c4:	89 85       	ldd	r24, Y+9	; 0x09
    51c6:	9a 85       	ldd	r25, Y+10	; 0x0a
    51c8:	ab 85       	ldd	r26, Y+11	; 0x0b
    51ca:	bc 85       	ldd	r27, Y+12	; 0x0c
    51cc:	89 83       	std	Y+1, r24	; 0x01
    51ce:	9a 83       	std	Y+2, r25	; 0x02
    51d0:	ab 83       	std	Y+3, r26	; 0x03
    51d2:	bc 83       	std	Y+4, r27	; 0x04
    51d4:	08 c0       	rjmp	.+16     	; 0x51e6 <CheckResistor+0x46e>
              }
              else                                     /* >= 2 Ohm */
              {
                Temp = Value / 20;           /* 5% */
    51d6:	9d 81       	ldd	r25, Y+5	; 0x05
    51d8:	99 83       	std	Y+1, r25	; 0x01
    51da:	ae 81       	ldd	r26, Y+6	; 0x06
    51dc:	aa 83       	std	Y+2, r26	; 0x02
    51de:	bf 81       	ldd	r27, Y+7	; 0x07
    51e0:	bb 83       	std	Y+3, r27	; 0x03
    51e2:	e8 85       	ldd	r30, Y+8	; 0x08
    51e4:	ec 83       	std	Y+4, r30	; 0x04

              Value1 = Value - Temp;         /* 95% or 50% */
              Value2 = Value + Temp;         /* 105% or 150% */

              /* special case for very low resistance */
              if (CmpValue(Value, Scale, 1, -1) == -1)   /* < 0.1 Ohm */
    51e6:	ee 24       	eor	r14, r14
    51e8:	ea 94       	dec	r14
    51ea:	01 e0       	ldi	r16, 0x01	; 1
    51ec:	10 e0       	ldi	r17, 0x00	; 0
    51ee:	20 e0       	ldi	r18, 0x00	; 0
    51f0:	30 e0       	ldi	r19, 0x00	; 0
    51f2:	4f 2d       	mov	r20, r15
    51f4:	c5 01       	movw	r24, r10
    51f6:	b4 01       	movw	r22, r8
    51f8:	0e 94 ac 31 	call	0x6358	; 0x6358 <CmpValue>
    51fc:	8f 3f       	cpi	r24, 0xFF	; 255
    51fe:	99 f0       	breq	.+38     	; 0x5226 <CheckResistor+0x4ae>
              else                                     /* >= 2 Ohm */
              {
                Temp = Value / 20;           /* 5% */
              }

              Value1 = Value - Temp;         /* 95% or 50% */
    5200:	95 01       	movw	r18, r10
    5202:	84 01       	movw	r16, r8
    5204:	89 81       	ldd	r24, Y+1	; 0x01
    5206:	9a 81       	ldd	r25, Y+2	; 0x02
    5208:	ab 81       	ldd	r26, Y+3	; 0x03
    520a:	bc 81       	ldd	r27, Y+4	; 0x04
    520c:	08 1b       	sub	r16, r24
    520e:	19 0b       	sbc	r17, r25
    5210:	2a 0b       	sbc	r18, r26
    5212:	3b 0b       	sbc	r19, r27
              Value2 = Value + Temp;         /* 105% or 150% */
    5214:	88 0d       	add	r24, r8
    5216:	99 1d       	adc	r25, r9
    5218:	aa 1d       	adc	r26, r10
    521a:	bb 1d       	adc	r27, r11
    521c:	89 83       	std	Y+1, r24	; 0x01
    521e:	9a 83       	std	Y+2, r25	; 0x02
    5220:	ab 83       	std	Y+3, r26	; 0x03
    5222:	bc 83       	std	Y+4, r27	; 0x04
    5224:	1b c0       	rjmp	.+54     	; 0x525c <CheckResistor+0x4e4>
              /* special case for very low resistance */
              if (CmpValue(Value, Scale, 1, -1) == -1)   /* < 0.1 Ohm */
              {
                Value1 = 0;                  /* 0 */
                Value2 = Value * 5;          /* 500% */
                if (Value2 == 0) Value2 = 5;   /* special case */
    5226:	41 14       	cp	r4, r1
    5228:	51 04       	cpc	r5, r1
    522a:	61 04       	cpc	r6, r1
    522c:	71 04       	cpc	r7, r1
    522e:	51 f4       	brne	.+20     	; 0x5244 <CheckResistor+0x4cc>
    5230:	95 e0       	ldi	r25, 0x05	; 5
    5232:	99 83       	std	Y+1, r25	; 0x01
    5234:	1a 82       	std	Y+2, r1	; 0x02
    5236:	1b 82       	std	Y+3, r1	; 0x03
    5238:	1c 82       	std	Y+4, r1	; 0x04
              Value2 = Value + Temp;         /* 105% or 150% */

              /* special case for very low resistance */
              if (CmpValue(Value, Scale, 1, -1) == -1)   /* < 0.1 Ohm */
              {
                Value1 = 0;                  /* 0 */
    523a:	00 e0       	ldi	r16, 0x00	; 0
    523c:	10 e0       	ldi	r17, 0x00	; 0
    523e:	20 e0       	ldi	r18, 0x00	; 0
    5240:	30 e0       	ldi	r19, 0x00	; 0
    5242:	0c c0       	rjmp	.+24     	; 0x525c <CheckResistor+0x4e4>
                Value2 = Value * 5;          /* 500% */
    5244:	ad 85       	ldd	r26, Y+13	; 0x0d
    5246:	a9 83       	std	Y+1, r26	; 0x01
    5248:	be 85       	ldd	r27, Y+14	; 0x0e
    524a:	ba 83       	std	Y+2, r27	; 0x02
    524c:	ef 85       	ldd	r30, Y+15	; 0x0f
    524e:	eb 83       	std	Y+3, r30	; 0x03
    5250:	f8 89       	ldd	r31, Y+16	; 0x10
    5252:	fc 83       	std	Y+4, r31	; 0x04
              Value2 = Value + Temp;         /* 105% or 150% */

              /* special case for very low resistance */
              if (CmpValue(Value, Scale, 1, -1) == -1)   /* < 0.1 Ohm */
              {
                Value1 = 0;                  /* 0 */
    5254:	00 e0       	ldi	r16, 0x00	; 0
    5256:	10 e0       	ldi	r17, 0x00	; 0
    5258:	20 e0       	ldi	r18, 0x00	; 0
    525a:	30 e0       	ldi	r19, 0x00	; 0
                Value2 = Value * 5;          /* 500% */
                if (Value2 == 0) Value2 = 5;   /* special case */
              }

              /* check if value matches given tolerance */
              if ((CmpValue(Resistor->Value, Resistor->Scale, Value1, Scale) >= 0) &&
    525c:	e9 89       	ldd	r30, Y+17	; 0x11
    525e:	fa 89       	ldd	r31, Y+18	; 0x12
    5260:	ee 0f       	add	r30, r30
    5262:	ff 1f       	adc	r31, r31
    5264:	ee 0f       	add	r30, r30
    5266:	ff 1f       	adc	r31, r31
    5268:	ee 0f       	add	r30, r30
    526a:	ff 1f       	adc	r31, r31
    526c:	49 89       	ldd	r20, Y+17	; 0x11
    526e:	5a 89       	ldd	r21, Y+18	; 0x12
    5270:	e4 1b       	sub	r30, r20
    5272:	f5 0b       	sbc	r31, r21
    5274:	ef 5e       	subi	r30, 0xEF	; 239
    5276:	fe 4f       	sbci	r31, 0xFE	; 254
    5278:	63 81       	ldd	r22, Z+3	; 0x03
    527a:	74 81       	ldd	r23, Z+4	; 0x04
    527c:	85 81       	ldd	r24, Z+5	; 0x05
    527e:	96 81       	ldd	r25, Z+6	; 0x06
    5280:	ef 2c       	mov	r14, r15
    5282:	42 81       	ldd	r20, Z+2	; 0x02
    5284:	0e 94 ac 31 	call	0x6358	; 0x6358 <CmpValue>
    5288:	88 23       	and	r24, r24
    528a:	1c f1       	brlt	.+70     	; 0x52d2 <CheckResistor+0x55a>
                  (CmpValue(Resistor->Value, Resistor->Scale, Value2, Scale) <= 0))
    528c:	e9 89       	ldd	r30, Y+17	; 0x11
    528e:	fa 89       	ldd	r31, Y+18	; 0x12
    5290:	ee 0f       	add	r30, r30
    5292:	ff 1f       	adc	r31, r31
    5294:	ee 0f       	add	r30, r30
    5296:	ff 1f       	adc	r31, r31
    5298:	ee 0f       	add	r30, r30
    529a:	ff 1f       	adc	r31, r31
    529c:	89 89       	ldd	r24, Y+17	; 0x11
    529e:	9a 89       	ldd	r25, Y+18	; 0x12
    52a0:	e8 1b       	sub	r30, r24
    52a2:	f9 0b       	sbc	r31, r25
    52a4:	ef 5e       	subi	r30, 0xEF	; 239
    52a6:	fe 4f       	sbci	r31, 0xFE	; 254
    52a8:	63 81       	ldd	r22, Z+3	; 0x03
    52aa:	74 81       	ldd	r23, Z+4	; 0x04
    52ac:	85 81       	ldd	r24, Z+5	; 0x05
    52ae:	96 81       	ldd	r25, Z+6	; 0x06
    52b0:	09 81       	ldd	r16, Y+1	; 0x01
    52b2:	1a 81       	ldd	r17, Y+2	; 0x02
    52b4:	2b 81       	ldd	r18, Y+3	; 0x03
    52b6:	3c 81       	ldd	r19, Y+4	; 0x04
    52b8:	42 81       	ldd	r20, Z+2	; 0x02
    52ba:	0e 94 ac 31 	call	0x6358	; 0x6358 <CmpValue>
                Value2 = Value * 5;          /* 500% */
                if (Value2 == 0) Value2 = 5;   /* special case */
              }

              /* check if value matches given tolerance */
              if ((CmpValue(Resistor->Value, Resistor->Scale, Value1, Scale) >= 0) &&
    52be:	18 16       	cp	r1, r24
    52c0:	54 f0       	brlt	.+20     	; 0x52d6 <CheckResistor+0x55e>
                  (CmpValue(Resistor->Value, Resistor->Scale, Value2, Scale) <= 0))
              {
                n = 100;                     /* end loop and signal match */
                Check.Found = COMP_RESISTOR;
    52c2:	ea e0       	ldi	r30, 0x0A	; 10
    52c4:	d1 01       	movw	r26, r2
    52c6:	11 96       	adiw	r26, 0x01	; 1
    52c8:	ec 93       	st	X, r30

              /* check if value matches given tolerance */
              if ((CmpValue(Resistor->Value, Resistor->Scale, Value1, Scale) >= 0) &&
                  (CmpValue(Resistor->Value, Resistor->Scale, Value2, Scale) <= 0))
              {
                n = 100;                     /* end loop and signal match */
    52ca:	84 e6       	ldi	r24, 0x64	; 100
                Check.Found = COMP_RESISTOR;
    52cc:	05 c0       	rjmp	.+10     	; 0x52d8 <CheckResistor+0x560>
                n = 200;                     /* end loop and signal mis-match */
              }
            }
            else                           /* no match */
            {
              n++;                          /* next one */
    52ce:	8f 5f       	subi	r24, 0xFF	; 255
    52d0:	03 c0       	rjmp	.+6      	; 0x52d8 <CheckResistor+0x560>
                n = 100;                     /* end loop and signal match */
                Check.Found = COMP_RESISTOR;
              }
              else                 /* no match */
              {
                n = 200;                     /* end loop and signal mis-match */
    52d2:	88 ec       	ldi	r24, 0xC8	; 200
    52d4:	01 c0       	rjmp	.+2      	; 0x52d8 <CheckResistor+0x560>
    52d6:	88 ec       	ldi	r24, 0xC8	; 200
          /*
           *  check for measurement in reversed direction
           */

          n = 0;
          while (n < Check.Resistors)           /* loop through resistors */
    52d8:	d1 01       	movw	r26, r2
    52da:	13 96       	adiw	r26, 0x03	; 3
    52dc:	9c 91       	ld	r25, X
    52de:	89 17       	cp	r24, r25
    52e0:	08 f4       	brcc	.+2      	; 0x52e4 <CheckResistor+0x56c>
    52e2:	42 cf       	rjmp	.-380    	; 0x5168 <CheckResistor+0x3f0>

          /*
           *  we got a new resistor
           */

          if (n != 100)            /* not a known resistor */
    52e4:	84 36       	cpi	r24, 0x64	; 100
    52e6:	c1 f0       	breq	.+48     	; 0x5318 <CheckResistor+0x5a0>
          {
            if (Check.Resistors < 3)              /* prevent array overflow */
    52e8:	93 30       	cpi	r25, 0x03	; 3
    52ea:	b0 f4       	brcc	.+44     	; 0x5318 <CheckResistor+0x5a0>
            {
              /* save data */
              Resistor = &Resistors[Check.Resistors];  /* unused dataset */
              Resistor->A = Probes.Pin_2;              /* pin facing Gnd */
    52ec:	b7 e0       	ldi	r27, 0x07	; 7
    52ee:	9b 9f       	mul	r25, r27
    52f0:	f0 01       	movw	r30, r0
    52f2:	11 24       	eor	r1, r1
    52f4:	ef 5e       	subi	r30, 0xEF	; 239
    52f6:	fe 4f       	sbci	r31, 0xFE	; 254
    52f8:	af e8       	ldi	r26, 0x8F	; 143
    52fa:	b1 e0       	ldi	r27, 0x01	; 1
    52fc:	11 96       	adiw	r26, 0x01	; 1
    52fe:	8c 91       	ld	r24, X
    5300:	11 97       	sbiw	r26, 0x01	; 1
    5302:	80 83       	st	Z, r24
              Resistor->B = Probes.Pin_1;              /* pin facing Vcc */
    5304:	8c 91       	ld	r24, X
    5306:	81 83       	std	Z+1, r24	; 0x01
              Resistor->Value = Value;
    5308:	83 82       	std	Z+3, r8	; 0x03
    530a:	94 82       	std	Z+4, r9	; 0x04
    530c:	a5 82       	std	Z+5, r10	; 0x05
    530e:	b6 82       	std	Z+6, r11	; 0x06
              Resistor->Scale = Scale;
    5310:	f2 82       	std	Z+2, r15	; 0x02
              Check.Resistors++;                       /* another one found */
    5312:	9f 5f       	subi	r25, 0xFF	; 255
    5314:	90 93 0b 01 	sts	0x010B, r25
          }
        }
      }
    }
  }
}
    5318:	62 96       	adiw	r28, 0x12	; 18
    531a:	0f b6       	in	r0, 0x3f	; 63
    531c:	f8 94       	cli
    531e:	de bf       	out	0x3e, r29	; 62
    5320:	0f be       	out	0x3f, r0	; 63
    5322:	cd bf       	out	0x3d, r28	; 61
    5324:	df 91       	pop	r29
    5326:	cf 91       	pop	r28
    5328:	1f 91       	pop	r17
    532a:	0f 91       	pop	r16
    532c:	ff 90       	pop	r15
    532e:	ef 90       	pop	r14
    5330:	df 90       	pop	r13
    5332:	cf 90       	pop	r12
    5334:	bf 90       	pop	r11
    5336:	af 90       	pop	r10
    5338:	9f 90       	pop	r9
    533a:	8f 90       	pop	r8
    533c:	7f 90       	pop	r7
    533e:	6f 90       	pop	r6
    5340:	5f 90       	pop	r5
    5342:	4f 90       	pop	r4
    5344:	3f 90       	pop	r3
    5346:	2f 90       	pop	r2
    5348:	08 95       	ret

0000534a <CheckSingleResistor>:
 *  - HighPin = pin facing Vcc
 *  - LowPin = pin facing Gnd
 */

uint8_t CheckSingleResistor(uint8_t HighPin, uint8_t LowPin)
{
    534a:	cf 93       	push	r28
    534c:	df 93       	push	r29
  uint8_t                Flag = 0;      /* return value */

  /* check for a specific resistor */
  Check.Resistors = 0;                  /* reset counter */
    534e:	c8 e0       	ldi	r28, 0x08	; 8
    5350:	d1 e0       	ldi	r29, 0x01	; 1
    5352:	1b 82       	std	Y+3, r1	; 0x03
  UpdateProbes(HighPin, LowPin, 0);     /* set probes */
    5354:	40 e0       	ldi	r20, 0x00	; 0
    5356:	0e 94 04 23 	call	0x4608	; 0x4608 <UpdateProbes>
  CheckResistor();                      /* check for resistor */
    535a:	0e 94 bc 26 	call	0x4d78	; 0x4d78 <CheckResistor>

  if (Check.Resistors == 1)             /* found resistor */
    535e:	81 e0       	ldi	r24, 0x01	; 1
    5360:	9b 81       	ldd	r25, Y+3	; 0x03
    5362:	91 30       	cpi	r25, 0x01	; 1
    5364:	09 f0       	breq	.+2      	; 0x5368 <CheckSingleResistor+0x1e>
    5366:	80 e0       	ldi	r24, 0x00	; 0
  {
    Flag = 1;            /* signal detected resistor */
  }

  return Flag;
}
    5368:	df 91       	pop	r29
    536a:	cf 91       	pop	r28
    536c:	08 95       	ret

0000536e <Get_hFE_C>:
 *  returns:
 *  - hFE
 */

uint32_t Get_hFE_C(uint8_t Type)
{
    536e:	ef 92       	push	r14
    5370:	ff 92       	push	r15
    5372:	0f 93       	push	r16
    5374:	1f 93       	push	r17
    5376:	cf 93       	push	r28
    5378:	df 93       	push	r29

  /*
   *  setup probes and get voltages
   */

  if (Type == TYPE_NPN)            /* NPN */
    537a:	81 30       	cpi	r24, 0x01	; 1
    537c:	e1 f4       	brne	.+56     	; 0x53b6 <Get_hFE_C+0x48>
  {
    /* we assume: probe-1 = C / probe-2 = E / probe-3 = B */
    /* set probes: Gnd -- Rl -- probe-2 / probe-1 -- Vcc */
    ADC_DDR = Probes.ADC_1;             /* set probe 1 to output */
    537e:	cf e8       	ldi	r28, 0x8F	; 143
    5380:	d1 e0       	ldi	r29, 0x01	; 1
    5382:	89 85       	ldd	r24, Y+9	; 0x09
    5384:	87 b9       	out	0x07, r24	; 7
    ADC_PORT = Probes.ADC_1;            /* pull up collector directly */
    5386:	88 b9       	out	0x08, r24	; 8
    R_DDR = Probes.Rl_2 | Probes.Rl_3;  /* select Rl for probe-2 & Rl for probe-3 */
    5388:	9f 81       	ldd	r25, Y+7	; 0x07
    538a:	8d 81       	ldd	r24, Y+5	; 0x05
    538c:	89 2b       	or	r24, r25
    538e:	84 b9       	out	0x04, r24	; 4
    R_PORT = Probes.Rl_3;               /* pull up base via Rl */
    5390:	95 b9       	out	0x05, r25	; 5

    U_R_e = ReadU_5ms(Probes.Pin_2);              /* U_R_e = U_e */
    5392:	89 81       	ldd	r24, Y+1	; 0x01
    5394:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
    5398:	8c 01       	movw	r16, r24
    U_R_b = Config.Vcc - ReadU(Probes.Pin_3);     /* U_R_b = Vcc - U_b */
    539a:	e0 90 b1 01 	lds	r14, 0x01B1
    539e:	f0 90 b2 01 	lds	r15, 0x01B2
    53a2:	8a 81       	ldd	r24, Y+2	; 0x02
    53a4:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    53a8:	b7 01       	movw	r22, r14
    53aa:	68 1b       	sub	r22, r24
    53ac:	79 0b       	sbc	r23, r25

    U_R_e = Config.Vcc - ReadU_5ms(Probes.Pin_1); /* U_R_e = Vcc - U_e */
    U_R_b = ReadU(Probes.Pin_3);                  /* U_R_b = U_b */
  }

  if (U_R_b < 10)             /* I_b < 14A -> Darlington */
    53ae:	6a 30       	cpi	r22, 0x0A	; 10
    53b0:	71 05       	cpc	r23, r1
    53b2:	e0 f0       	brcs	.+56     	; 0x53ec <Get_hFE_C+0x7e>
    53b4:	7e c0       	rjmp	.+252    	; 0x54b2 <Get_hFE_C+0x144>
  }
  else                             /* PNP */
  {
    /* we assume: probe-1 = E / probe-2 = C / probe-3 = B */
    /* set probes: Gnd -- probe-2 / probe-1 -- Rl -- Vcc */
    ADC_PORT = 0;                       /* set ADC port low */
    53b6:	18 b8       	out	0x08, r1	; 8
    ADC_DDR = Probes.ADC_2;             /* pull down collector directly */
    53b8:	cf e8       	ldi	r28, 0x8F	; 143
    53ba:	d1 e0       	ldi	r29, 0x01	; 1
    53bc:	8a 85       	ldd	r24, Y+10	; 0x0a
    53be:	87 b9       	out	0x07, r24	; 7
    R_PORT = Probes.Rl_1;               /* pull up emitter via Rl */
    53c0:	8b 81       	ldd	r24, Y+3	; 0x03
    53c2:	85 b9       	out	0x05, r24	; 5
    R_DDR = Probes.Rl_1 | Probes.Rl_3;  /* pull down base via Rl */
    53c4:	9f 81       	ldd	r25, Y+7	; 0x07
    53c6:	89 2b       	or	r24, r25
    53c8:	84 b9       	out	0x04, r24	; 4

    U_R_e = Config.Vcc - ReadU_5ms(Probes.Pin_1); /* U_R_e = Vcc - U_e */
    53ca:	00 91 b1 01 	lds	r16, 0x01B1
    53ce:	10 91 b2 01 	lds	r17, 0x01B2
    53d2:	88 81       	ld	r24, Y
    53d4:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
    53d8:	7c 01       	movw	r14, r24
    U_R_b = ReadU(Probes.Pin_3);                  /* U_R_b = U_b */
    53da:	8a 81       	ldd	r24, Y+2	; 0x02
    53dc:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    53e0:	bc 01       	movw	r22, r24
  }

  if (U_R_b < 10)             /* I_b < 14A -> Darlington */
    53e2:	0a 97       	sbiw	r24, 0x0a	; 10
    53e4:	e8 f0       	brcs	.+58     	; 0x5420 <Get_hFE_C+0xb2>
    ADC_PORT = 0;                       /* set ADC port low */
    ADC_DDR = Probes.ADC_2;             /* pull down collector directly */
    R_PORT = Probes.Rl_1;               /* pull up emitter via Rl */
    R_DDR = Probes.Rl_1 | Probes.Rl_3;  /* pull down base via Rl */

    U_R_e = Config.Vcc - ReadU_5ms(Probes.Pin_1); /* U_R_e = Vcc - U_e */
    53e6:	0e 19       	sub	r16, r14
    53e8:	1f 09       	sbc	r17, r15
    53ea:	63 c0       	rjmp	.+198    	; 0x54b2 <Get_hFE_C+0x144>
  if (U_R_b < 10)             /* I_b < 14A -> Darlington */
  {
    /* change base resistor from Rl to Rh and measure again */
    if (Type == TYPE_NPN)            /* NPN */
    {    
      R_DDR = Probes.Rl_2 | Probes.Rh_3;     /* select Rl for probe-2 & Rh for probe-3 */
    53ec:	cf e8       	ldi	r28, 0x8F	; 143
    53ee:	d1 e0       	ldi	r29, 0x01	; 1
    53f0:	98 85       	ldd	r25, Y+8	; 0x08
    53f2:	8d 81       	ldd	r24, Y+5	; 0x05
    53f4:	89 2b       	or	r24, r25
    53f6:	84 b9       	out	0x04, r24	; 4
      R_PORT = Probes.Rh_3;                  /* pull up base via Rh */
    53f8:	95 b9       	out	0x05, r25	; 5

      U_R_e = ReadU_5ms(Probes.Pin_2);            /* U_R_e = U_e */
    53fa:	89 81       	ldd	r24, Y+1	; 0x01
    53fc:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
    5400:	8c 01       	movw	r16, r24
      U_R_b = Config.Vcc - ReadU(Probes.Pin_3);   /* U_R_b = Vcc - U_b */
    5402:	e0 90 b1 01 	lds	r14, 0x01B1
    5406:	f0 90 b2 01 	lds	r15, 0x01B2
    540a:	8a 81       	ldd	r24, Y+2	; 0x02
    540c:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    5410:	f7 01       	movw	r30, r14
    5412:	e8 1b       	sub	r30, r24
    5414:	f9 0b       	sbc	r31, r25

      Ri = NV.RiL;                           /* get internal resistor */
    5416:	c0 91 9b 01 	lds	r28, 0x019B
    541a:	d0 91 9c 01 	lds	r29, 0x019C
    541e:	17 c0       	rjmp	.+46     	; 0x544e <Get_hFE_C+0xe0>
    }
    else                             /* PNP */
    {
      R_DDR = Probes.Rl_1 | Probes.Rh_3;     /* pull down base via Rh */
    5420:	cf e8       	ldi	r28, 0x8F	; 143
    5422:	d1 e0       	ldi	r29, 0x01	; 1
    5424:	98 85       	ldd	r25, Y+8	; 0x08
    5426:	8b 81       	ldd	r24, Y+3	; 0x03
    5428:	89 2b       	or	r24, r25
    542a:	84 b9       	out	0x04, r24	; 4

      U_R_e = Config.Vcc - ReadU_5ms(Probes.Pin_1);    /* U_R_e = Vcc - U_e */
    542c:	00 91 b1 01 	lds	r16, 0x01B1
    5430:	10 91 b2 01 	lds	r17, 0x01B2
    5434:	88 81       	ld	r24, Y
    5436:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
    543a:	08 1b       	sub	r16, r24
    543c:	19 0b       	sbc	r17, r25
      U_R_b = ReadU(Probes.Pin_3);                     /* U_R_b = U_b */
    543e:	8a 81       	ldd	r24, Y+2	; 0x02
    5440:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    5444:	fc 01       	movw	r30, r24

      Ri = NV.RiH;                           /* get internal resistor */
    5446:	c0 91 9d 01 	lds	r28, 0x019D
    544a:	d0 91 9e 01 	lds	r29, 0x019E
     *  hFE = I_e / I_b
     *      = (U_R_e / R_e) / (U_R_b / R_b)
     *      = (U_R_e * R_b) / (U_R_b * R_e)
     */

    if (U_R_b < 1) U_R_b = 1;                /* prevent division by zero */
    544e:	30 97       	sbiw	r30, 0x00	; 0
    5450:	11 f4       	brne	.+4      	; 0x5456 <Get_hFE_C+0xe8>
    5452:	e1 e0       	ldi	r30, 0x01	; 1
    5454:	f0 e0       	ldi	r31, 0x00	; 0
    hFE =  U_R_e * R_HIGH;                   /* U_R_e * R_b */
    5456:	d8 01       	movw	r26, r16
    5458:	20 ef       	ldi	r18, 0xF0	; 240
    545a:	3b e2       	ldi	r19, 0x2B	; 43
    545c:	47 e0       	ldi	r20, 0x07	; 7
    545e:	50 e0       	ldi	r21, 0x00	; 0
    5460:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
    hFE /= U_R_b;                            /* / U_R_b */
    5464:	9f 01       	movw	r18, r30
    5466:	40 e0       	ldi	r20, 0x00	; 0
    5468:	50 e0       	ldi	r21, 0x00	; 0
    546a:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    hFE *= 10;                               /* upscale to 0.1 */
    546e:	ba 01       	movw	r22, r20
    5470:	a9 01       	movw	r20, r18
    5472:	44 0f       	add	r20, r20
    5474:	55 1f       	adc	r21, r21
    5476:	66 1f       	adc	r22, r22
    5478:	77 1f       	adc	r23, r23
    547a:	db 01       	movw	r26, r22
    547c:	ca 01       	movw	r24, r20
    547e:	88 0f       	add	r24, r24
    5480:	99 1f       	adc	r25, r25
    5482:	aa 1f       	adc	r26, r26
    5484:	bb 1f       	adc	r27, r27
    5486:	88 0f       	add	r24, r24
    5488:	99 1f       	adc	r25, r25
    548a:	aa 1f       	adc	r26, r26
    548c:	bb 1f       	adc	r27, r27
    548e:	8a 01       	movw	r16, r20
    5490:	9b 01       	movw	r18, r22
    5492:	08 0f       	add	r16, r24
    5494:	19 1f       	adc	r17, r25
    5496:	2a 1f       	adc	r18, r26
    5498:	3b 1f       	adc	r19, r27
    549a:	c9 01       	movw	r24, r18
    549c:	b8 01       	movw	r22, r16
    hFE /= (R_LOW * 10) + Ri;                /* / R_e in 0.1 Ohm */
    549e:	9e 01       	movw	r18, r28
    54a0:	20 57       	subi	r18, 0x70	; 112
    54a2:	35 4e       	sbci	r19, 0xE5	; 229
    54a4:	40 e0       	ldi	r20, 0x00	; 0
    54a6:	50 e0       	ldi	r21, 0x00	; 0
    54a8:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    54ac:	ca 01       	movw	r24, r20
    54ae:	b9 01       	movw	r22, r18
    54b0:	07 c0       	rjmp	.+14     	; 0x54c0 <Get_hFE_C+0x152>
     *  Both resistors are the same (R_e = R_b): 
     *  - hFE = ((U_R_e / R_e) - (U_R_b / R_b)) / (U_R_b / R_b)
     *  -     = (U_R_e - U_R_b) / U_R_b 
     */

    hFE = (uint32_t)((U_R_e - U_R_b) / U_R_b);
    54b2:	c8 01       	movw	r24, r16
    54b4:	86 1b       	sub	r24, r22
    54b6:	97 0b       	sbc	r25, r23
    54b8:	0e 94 5e 36 	call	0x6cbc	; 0x6cbc <__udivmodhi4>
    54bc:	80 e0       	ldi	r24, 0x00	; 0
    54be:	90 e0       	ldi	r25, 0x00	; 0
  }

  return hFE;
}
    54c0:	df 91       	pop	r29
    54c2:	cf 91       	pop	r28
    54c4:	1f 91       	pop	r17
    54c6:	0f 91       	pop	r16
    54c8:	ff 90       	pop	r15
    54ca:	ef 90       	pop	r14
    54cc:	08 95       	ret

000054ce <GetGateThreshold>:
 *  requires:
 *  - Type: n-channel or p-channel
 */

void GetGateThreshold(uint8_t Type)
{
    54ce:	3f 92       	push	r3
    54d0:	4f 92       	push	r4
    54d2:	5f 92       	push	r5
    54d4:	6f 92       	push	r6
    54d6:	7f 92       	push	r7
    54d8:	8f 92       	push	r8
    54da:	9f 92       	push	r9
    54dc:	af 92       	push	r10
    54de:	bf 92       	push	r11
    54e0:	cf 92       	push	r12
    54e2:	df 92       	push	r13
    54e4:	ef 92       	push	r14
    54e6:	ff 92       	push	r15
    54e8:	0f 93       	push	r16
    54ea:	1f 93       	push	r17
    54ec:	cf 93       	push	r28
    54ee:	df 93       	push	r29

  /*
   *  init variables
   */

  if (Type & TYPE_N_CHANNEL)       /* n-channel */
    54f0:	28 2f       	mov	r18, r24
    54f2:	21 70       	andi	r18, 0x01	; 1
    54f4:	52 2e       	mov	r5, r18
    54f6:	80 ff       	sbrs	r24, 0
    54f8:	08 c0       	rjmp	.+16     	; 0x550a <GetGateThreshold+0x3c>
  {
    /* we assume: probe-1 = D / probe-2 = S / probe-3 = G */
    /* probe-2 is still pulled down directly */
    /* probe-1 is still pulled up via Rl */

    Drain_Rl =  Probes.Rl_1;
    54fa:	ef e8       	ldi	r30, 0x8F	; 143
    54fc:	f1 e0       	ldi	r31, 0x01	; 1
    54fe:	43 80       	ldd	r4, Z+3	; 0x03
    Drain_ADC = Probes.ADC_1;
    5500:	81 85       	ldd	r24, Z+9	; 0x09
    PullMode = FLAG_10MS | FLAG_PULLDOWN;
    5502:	68 94       	set
    5504:	33 24       	eor	r3, r3
    5506:	34 f8       	bld	r3, 4
    5508:	08 c0       	rjmp	.+16     	; 0x551a <GetGateThreshold+0x4c>
  {
    /* we assume: probe-1 = S / probe-2 = D / probe-3 = G */
    /* probe-2 is still pulled down via Rl */
    /* probe-1 is still pulled up directly */

    Drain_Rl =  Probes.Rl_2;
    550a:	ef e8       	ldi	r30, 0x8F	; 143
    550c:	f1 e0       	ldi	r31, 0x01	; 1
    550e:	45 80       	ldd	r4, Z+5	; 0x05
    Drain_ADC = Probes.ADC_2;
    5510:	82 85       	ldd	r24, Z+10	; 0x0a
    PullMode = FLAG_10MS | FLAG_PULLUP;
    5512:	0f 2e       	mov	r0, r31
    5514:	f1 e1       	ldi	r31, 0x11	; 17
    5516:	3f 2e       	mov	r3, r31
    5518:	f0 2d       	mov	r31, r0
  /*
   *  For low reaction times we use the ADC directly.
   */

  /* sanitize bit mask for drain to prevent a never-ending loop */ 
  Drain_ADC &= 0b00000111;              /* drain */
    551a:	87 70       	andi	r24, 0x07	; 7
    551c:	78 2e       	mov	r7, r24
  ADMUX = Probes.Pin_3 | (1 << REFS0);  /* select probe-3 for ADC input */
    551e:	80 91 91 01 	lds	r24, 0x0191
    5522:	80 64       	ori	r24, 0x40	; 64
    5524:	80 93 7c 00 	sts	0x007C, r24
    5528:	0f 2e       	mov	r0, r31
    552a:	fa e0       	ldi	r31, 0x0A	; 10
    552c:	6f 2e       	mov	r6, r31
    552e:	f0 2d       	mov	r31, r0
 *  - Type: n-channel or p-channel
 */

void GetGateThreshold(uint8_t Type)
{
  int32_t           Ugs = 0;       /* gate threshold voltage / Vth */
    5530:	81 2c       	mov	r8, r1
    5532:	91 2c       	mov	r9, r1
    5534:	54 01       	movw	r10, r8
  for (Counter = 0; Counter < 10; Counter++) 
  {
    wdt_reset();                         /* reset watchdog */

    /* discharge gate via Rl for 10 ms */
    PullProbe(Probes.Rl_3, PullMode);
    5536:	0f e8       	ldi	r16, 0x8F	; 143
    5538:	11 e0       	ldi	r17, 0x01	; 1
    }

    R_DDR = Drain_Rl;                   /* set probe-3 to HiZ mode */

    /* get voltage of gate */
    ADCSRA |= (1 << ADSC);              /* start ADC conversion */
    553a:	ca e7       	ldi	r28, 0x7A	; 122
    553c:	d0 e0       	ldi	r29, 0x00	; 0
    {
      Ugs += ADCW;                        /* Ugs = U_g */
    }
    else                                /* p-channel */
    {
      Ugs -= (1023 - ADCW);               /* Ugs = - (Vcc - U_g) */
    553e:	0f 2e       	mov	r0, r31
    5540:	f8 e7       	ldi	r31, 0x78	; 120
    5542:	ef 2e       	mov	r14, r31
    5544:	f1 2c       	mov	r15, r1
    5546:	f0 2d       	mov	r31, r0
    5548:	0f 2e       	mov	r0, r31
    554a:	cc 24       	eor	r12, r12
    554c:	ca 94       	dec	r12
    554e:	f3 e0       	ldi	r31, 0x03	; 3
    5550:	df 2e       	mov	r13, r31
    5552:	f0 2d       	mov	r31, r0
  ADMUX = Probes.Pin_3 | (1 << REFS0);  /* select probe-3 for ADC input */

  /* sample 10 times */
  for (Counter = 0; Counter < 10; Counter++) 
  {
    wdt_reset();                         /* reset watchdog */
    5554:	a8 95       	wdr

    /* discharge gate via Rl for 10 ms */
    PullProbe(Probes.Rl_3, PullMode);
    5556:	63 2d       	mov	r22, r3
    5558:	f8 01       	movw	r30, r16
    555a:	87 81       	ldd	r24, Z+7	; 0x07
    555c:	0e 94 6b 24 	call	0x48d6	; 0x48d6 <PullProbe>

    /* pull up/down gate via Rh to slowly charge gate */
    R_DDR = Drain_Rl | Probes.Rh_3;
    5560:	f8 01       	movw	r30, r16
    5562:	80 85       	ldd	r24, Z+8	; 0x08
    5564:	84 29       	or	r24, r4
    5566:	84 b9       	out	0x04, r24	; 4

    /* wait until FET conducts */
    if (Type & TYPE_N_CHANNEL)          /* n-channel */
    5568:	55 20       	and	r5, r5
    556a:	21 f0       	breq	.+8      	; 0x5574 <GetGateThreshold+0xa6>
    {
      /* FET conducts when the voltage at drain reaches low level */
      while (ADC_PIN & Drain_ADC);
    556c:	86 b1       	in	r24, 0x06	; 6
    556e:	87 21       	and	r24, r7
    5570:	e9 f7       	brne	.-6      	; 0x556c <GetGateThreshold+0x9e>
    5572:	03 c0       	rjmp	.+6      	; 0x557a <GetGateThreshold+0xac>
    }
    else                                /* p-channel */
    {
      /* FET conducts when the voltage at drain reaches high level */
      while (!(ADC_PIN & Drain_ADC));             
    5574:	86 b1       	in	r24, 0x06	; 6
    5576:	87 21       	and	r24, r7
    5578:	e9 f3       	breq	.-6      	; 0x5574 <GetGateThreshold+0xa6>
    }

    R_DDR = Drain_Rl;                   /* set probe-3 to HiZ mode */
    557a:	44 b8       	out	0x04, r4	; 4

    /* get voltage of gate */
    ADCSRA |= (1 << ADSC);              /* start ADC conversion */
    557c:	88 81       	ld	r24, Y
    557e:	80 64       	ori	r24, 0x40	; 64
    5580:	88 83       	st	Y, r24
    while (ADCSRA & (1 << ADSC));       /* wait until conversion is done */
    5582:	88 81       	ld	r24, Y
    5584:	86 fd       	sbrc	r24, 6
    5586:	fd cf       	rjmp	.-6      	; 0x5582 <GetGateThreshold+0xb4>

    /* add ADC reading */
    if (Type & TYPE_N_CHANNEL)          /* n-channel */
    5588:	55 20       	and	r5, r5
    558a:	41 f0       	breq	.+16     	; 0x559c <GetGateThreshold+0xce>
    {
      Ugs += ADCW;                        /* Ugs = U_g */
    558c:	f7 01       	movw	r30, r14
    558e:	80 81       	ld	r24, Z
    5590:	91 81       	ldd	r25, Z+1	; 0x01
    5592:	88 0e       	add	r8, r24
    5594:	99 1e       	adc	r9, r25
    5596:	a1 1c       	adc	r10, r1
    5598:	b1 1c       	adc	r11, r1
    559a:	0a c0       	rjmp	.+20     	; 0x55b0 <GetGateThreshold+0xe2>
    }
    else                                /* p-channel */
    {
      Ugs -= (1023 - ADCW);               /* Ugs = - (Vcc - U_g) */
    559c:	f7 01       	movw	r30, r14
    559e:	80 81       	ld	r24, Z
    55a0:	91 81       	ldd	r25, Z+1	; 0x01
    55a2:	96 01       	movw	r18, r12
    55a4:	28 1b       	sub	r18, r24
    55a6:	39 0b       	sbc	r19, r25
    55a8:	82 1a       	sub	r8, r18
    55aa:	93 0a       	sbc	r9, r19
    55ac:	a1 08       	sbc	r10, r1
    55ae:	b1 08       	sbc	r11, r1
    55b0:	6a 94       	dec	r6
  /* sanitize bit mask for drain to prevent a never-ending loop */ 
  Drain_ADC &= 0b00000111;              /* drain */
  ADMUX = Probes.Pin_3 | (1 << REFS0);  /* select probe-3 for ADC input */

  /* sample 10 times */
  for (Counter = 0; Counter < 10; Counter++) 
    55b2:	61 10       	cpse	r6, r1
    55b4:	cf cf       	rjmp	.-98     	; 0x5554 <GetGateThreshold+0x86>
      Ugs -= (1023 - ADCW);               /* Ugs = - (Vcc - U_g) */
    }
  }

  /* calculate V_th */
  Ugs /= 10;                     /* average of 10 samples */
    55b6:	c5 01       	movw	r24, r10
    55b8:	b4 01       	movw	r22, r8
    55ba:	2a e0       	ldi	r18, 0x0A	; 10
    55bc:	30 e0       	ldi	r19, 0x00	; 0
    55be:	40 e0       	ldi	r20, 0x00	; 0
    55c0:	50 e0       	ldi	r21, 0x00	; 0
    55c2:	0e 94 a8 36 	call	0x6d50	; 0x6d50 <__divmodsi4>
  Ugs *= Config.Vcc;             /* convert to voltage */
    55c6:	a0 91 b1 01 	lds	r26, 0x01B1
    55ca:	b0 91 b2 01 	lds	r27, 0x01B2
    55ce:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
  Ugs /= 1024;                   /* using 10 bit resolution */
    55d2:	8b 01       	movw	r16, r22
    55d4:	9c 01       	movw	r18, r24
    55d6:	99 23       	and	r25, r25
    55d8:	24 f4       	brge	.+8      	; 0x55e2 <GetGateThreshold+0x114>
    55da:	01 50       	subi	r16, 0x01	; 1
    55dc:	1c 4f       	sbci	r17, 0xFC	; 252
    55de:	2f 4f       	sbci	r18, 0xFF	; 255
    55e0:	3f 4f       	sbci	r19, 0xFF	; 255
    55e2:	d9 01       	movw	r26, r18
    55e4:	c8 01       	movw	r24, r16
    55e6:	07 2e       	mov	r0, r23
    55e8:	7a e0       	ldi	r23, 0x0A	; 10
    55ea:	b5 95       	asr	r27
    55ec:	a7 95       	ror	r26
    55ee:	97 95       	ror	r25
    55f0:	87 95       	ror	r24
    55f2:	7a 95       	dec	r23
    55f4:	d1 f7       	brne	.-12     	; 0x55ea <GetGateThreshold+0x11c>
    55f6:	70 2d       	mov	r23, r0

  /* save data */
  Semi.U_2 = (int16_t)Ugs;       /* gate threshold voltage (in mV) */
    55f8:	90 93 87 01 	sts	0x0187, r25
    55fc:	80 93 86 01 	sts	0x0186, r24
}
    5600:	df 91       	pop	r29
    5602:	cf 91       	pop	r28
    5604:	1f 91       	pop	r17
    5606:	0f 91       	pop	r16
    5608:	ff 90       	pop	r15
    560a:	ef 90       	pop	r14
    560c:	df 90       	pop	r13
    560e:	cf 90       	pop	r12
    5610:	bf 90       	pop	r11
    5612:	af 90       	pop	r10
    5614:	9f 90       	pop	r9
    5616:	8f 90       	pop	r8
    5618:	7f 90       	pop	r7
    561a:	6f 90       	pop	r6
    561c:	5f 90       	pop	r5
    561e:	4f 90       	pop	r4
    5620:	3f 90       	pop	r3
    5622:	08 95       	ret

00005624 <GetLeakageCurrent>:
 *  returns:
 *  - leakage current in A
 */

uint16_t GetLeakageCurrent(void)
{
    5624:	cf 92       	push	r12
    5626:	df 92       	push	r13
    5628:	ef 92       	push	r14
    562a:	ff 92       	push	r15
   *    Diode:    probe-1 = cathode /  probe-2 = anode
   *    NPN BJT:  probe-1 = collector / probe-2 = emitter
   *    PNP BJT:  probe-1 = emitter / probe-2 = collector
   */

  R_PORT = 0;                      /* set resistor port to Gnd */
    562c:	15 b8       	out	0x05, r1	; 5
  R_DDR = Probes.Rl_2;             /* pull down probe-2 via Rl */
    562e:	ef e8       	ldi	r30, 0x8F	; 143
    5630:	f1 e0       	ldi	r31, 0x01	; 1
    5632:	85 81       	ldd	r24, Z+5	; 0x05
    5634:	84 b9       	out	0x04, r24	; 4
  ADC_DDR = Probes.ADC_1;          /* set probe-1 to output */
    5636:	81 85       	ldd	r24, Z+9	; 0x09
    5638:	87 b9       	out	0x07, r24	; 7
  ADC_PORT = Probes.ADC_1;         /* pull-up probe-1 directly */
    563a:	88 b9       	out	0x08, r24	; 8

  U_Rl = ReadU_5ms(Probes.Pin_2);  /* get voltage at Rl */
    563c:	81 81       	ldd	r24, Z+1	; 0x01
    563e:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>

  /* calculate current */
  R_Shunt = NV.RiL + (R_LOW * 10); /* consider internal resistance of MCU (0.1 Ohms) */ 
  R_Shunt += 5;                    /* for rounding */
    5642:	e0 91 9b 01 	lds	r30, 0x019B
    5646:	f0 91 9c 01 	lds	r31, 0x019C
    564a:	eb 56       	subi	r30, 0x6B	; 107
    564c:	f5 4e       	sbci	r31, 0xE5	; 229
  R_Shunt /= 10;                   /* scale to Ohms */
  Value = U_Rl * 100000;           /* scale to 10nV */
    564e:	dc 01       	movw	r26, r24
    5650:	20 ea       	ldi	r18, 0xA0	; 160
    5652:	36 e8       	ldi	r19, 0x86	; 134
    5654:	41 e0       	ldi	r20, 0x01	; 1
    5656:	50 e0       	ldi	r21, 0x00	; 0
    5658:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
    565c:	6b 01       	movw	r12, r22
    565e:	7c 01       	movw	r14, r24
  U_Rl = ReadU_5ms(Probes.Pin_2);  /* get voltage at Rl */

  /* calculate current */
  R_Shunt = NV.RiL + (R_LOW * 10); /* consider internal resistance of MCU (0.1 Ohms) */ 
  R_Shunt += 5;                    /* for rounding */
  R_Shunt /= 10;                   /* scale to Ohms */
    5660:	9f 01       	movw	r18, r30
    5662:	ad ec       	ldi	r26, 0xCD	; 205
    5664:	bc ec       	ldi	r27, 0xCC	; 204
    5666:	0e 94 cd 36 	call	0x6d9a	; 0x6d9a <__umulhisi3>
    566a:	96 95       	lsr	r25
    566c:	87 95       	ror	r24
    566e:	96 95       	lsr	r25
    5670:	87 95       	ror	r24
    5672:	96 95       	lsr	r25
    5674:	87 95       	ror	r24
  Value = U_Rl * 100000;           /* scale to 10nV */
  Value /= R_Shunt;                /* in 10nA */
    5676:	9c 01       	movw	r18, r24
    5678:	40 e0       	ldi	r20, 0x00	; 0
    567a:	50 e0       	ldi	r21, 0x00	; 0
    567c:	c7 01       	movw	r24, r14
    567e:	b6 01       	movw	r22, r12
    5680:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
  Value += 55;                     /* for rounding */
    5684:	ca 01       	movw	r24, r20
    5686:	b9 01       	movw	r22, r18
    5688:	69 5c       	subi	r22, 0xC9	; 201
    568a:	7f 4f       	sbci	r23, 0xFF	; 255
    568c:	8f 4f       	sbci	r24, 0xFF	; 255
    568e:	9f 4f       	sbci	r25, 0xFF	; 255
  Value /= 100;                    /* scale to A */
  I_leak = Value;

  /* clean up */
  ADC_DDR = 0;           /* set ADC port to HiZ mode */
    5690:	17 b8       	out	0x07, r1	; 7
  ADC_PORT = 0;          /* set ADC port low */
    5692:	18 b8       	out	0x08, r1	; 8
  R_DDR = 0;             /* set resistor port to HiZ mode */
    5694:	14 b8       	out	0x04, r1	; 4
  R_PORT = 0;            /* set resistor port low */
    5696:	15 b8       	out	0x05, r1	; 5
  R_Shunt += 5;                    /* for rounding */
  R_Shunt /= 10;                   /* scale to Ohms */
  Value = U_Rl * 100000;           /* scale to 10nV */
  Value /= R_Shunt;                /* in 10nA */
  Value += 55;                     /* for rounding */
  Value /= 100;                    /* scale to A */
    5698:	24 e6       	ldi	r18, 0x64	; 100
    569a:	30 e0       	ldi	r19, 0x00	; 0
    569c:	40 e0       	ldi	r20, 0x00	; 0
    569e:	50 e0       	ldi	r21, 0x00	; 0
    56a0:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
  ADC_PORT = 0;          /* set ADC port low */
  R_DDR = 0;             /* set resistor port to HiZ mode */
  R_PORT = 0;            /* set resistor port low */

  return I_leak;
}
    56a4:	c9 01       	movw	r24, r18
    56a6:	ff 90       	pop	r15
    56a8:	ef 90       	pop	r14
    56aa:	df 90       	pop	r13
    56ac:	cf 90       	pop	r12
    56ae:	08 95       	ret

000056b0 <CheckDiode>:
/*
 *  check for diode
 */

void CheckDiode(void)
{
    56b0:	2f 92       	push	r2
    56b2:	3f 92       	push	r3
    56b4:	4f 92       	push	r4
    56b6:	5f 92       	push	r5
    56b8:	6f 92       	push	r6
    56ba:	7f 92       	push	r7
    56bc:	8f 92       	push	r8
    56be:	9f 92       	push	r9
    56c0:	af 92       	push	r10
    56c2:	bf 92       	push	r11
    56c4:	cf 92       	push	r12
    56c6:	df 92       	push	r13
    56c8:	ef 92       	push	r14
    56ca:	ff 92       	push	r15
    56cc:	0f 93       	push	r16
    56ce:	1f 93       	push	r17
    56d0:	cf 93       	push	r28
    56d2:	df 93       	push	r29
    56d4:	00 d0       	rcall	.+0      	; 0x56d6 <CheckDiode+0x26>
    56d6:	00 d0       	rcall	.+0      	; 0x56d8 <CheckDiode+0x28>
    56d8:	cd b7       	in	r28, 0x3d	; 61
    56da:	de b7       	in	r29, 0x3e	; 62
  uint16_t          U2_Rl;         /* Vf #2 with Rl pull-down */
  uint16_t          U2_Rh;         /* Vf #2 with Rh pull-down */
  uint16_t          U2_Zero;       /* Vf #2 zero */
  uint16_t          U_Diff;        /* Vf difference */

  wdt_reset();                          /* reset watchdog */
    56dc:	a8 95       	wdr

  DischargeProbes();                    /* try to discharge probes */
    56de:	0e 94 a3 23 	call	0x4746	; 0x4746 <DischargeProbes>
  if (Check.Found == COMP_ERROR) return;     /* skip on error */
    56e2:	80 91 09 01 	lds	r24, 0x0109
    56e6:	81 30       	cpi	r24, 0x01	; 1
    56e8:	09 f4       	brne	.+2      	; 0x56ec <CheckDiode+0x3c>
    56ea:	3b c1       	rjmp	.+630    	; 0x5962 <CheckDiode+0x2b2>
   *  Vf #1, supporting a possible p-channel MOSFET
   */

  /* we assume: probe-1 = A / probe2 = C */
  /* set probes: Gnd -- probe-2 / probe-1 -- HiZ */
  ADC_PORT = 0;
    56ec:	18 b8       	out	0x08, r1	; 8
  ADC_DDR = Probes.ADC_2;               /* pull down cathode directly */
    56ee:	0f 2e       	mov	r0, r31
    56f0:	ff e8       	ldi	r31, 0x8F	; 143
    56f2:	ef 2e       	mov	r14, r31
    56f4:	f1 e0       	ldi	r31, 0x01	; 1
    56f6:	ff 2e       	mov	r15, r31
    56f8:	f0 2d       	mov	r31, r0
    56fa:	f7 01       	movw	r30, r14
    56fc:	82 85       	ldd	r24, Z+10	; 0x0a
    56fe:	87 b9       	out	0x07, r24	; 7
  /* R_DDR is set to HiZ by DischargeProbes() */
  U1_Zero = ReadU(Probes.Pin_1);        /* get voltage at anode */
    5700:	80 81       	ld	r24, Z
    5702:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    5706:	6c 01       	movw	r12, r24

  /* measure voltage across DUT (Vf) with Rh */
  /* set probes: Gnd -- probe-2 / probe-1 -- Rh -- Vcc */
  R_DDR = Probes.Rh_1;                  /* enable Rh for probe-1 */
    5708:	f7 01       	movw	r30, r14
    570a:	84 81       	ldd	r24, Z+4	; 0x04
    570c:	84 b9       	out	0x04, r24	; 4
  R_PORT = Probes.Rh_1;                 /* pull up anode via Rh */
    570e:	85 b9       	out	0x05, r24	; 5
  PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLUP);     /* discharge gate */
    5710:	61 e1       	ldi	r22, 0x11	; 17
    5712:	87 81       	ldd	r24, Z+7	; 0x07
    5714:	0e 94 6b 24 	call	0x48d6	; 0x48d6 <PullProbe>
  U1_Rh = ReadU_5ms(Probes.Pin_1);      /* get voltage at anode */
    5718:	f7 01       	movw	r30, r14
    571a:	80 81       	ld	r24, Z
    571c:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
    5720:	4c 01       	movw	r8, r24
                                        /* neglect voltage at cathode */

  /* measure voltage across DUT (Vf) with Rl */
  /* set probes: Gnd -- probe-2 / probe-1 -- Rl -- Vcc */
  R_DDR = Probes.Rl_1;                  /* enable Rl for probe-1 */
    5722:	f7 01       	movw	r30, r14
    5724:	83 81       	ldd	r24, Z+3	; 0x03
    5726:	84 b9       	out	0x04, r24	; 4
  R_PORT = Probes.Rl_1;                 /* pull up anode via Rl */
    5728:	85 b9       	out	0x05, r24	; 5
  PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLUP);     /* discharge gate */
    572a:	61 e1       	ldi	r22, 0x11	; 17
    572c:	87 81       	ldd	r24, Z+7	; 0x07
    572e:	0e 94 6b 24 	call	0x48d6	; 0x48d6 <PullProbe>
  U1_Rl = ReadU_5ms(Probes.Pin_1);      /* get voltage at anode */
    5732:	f7 01       	movw	r30, r14
    5734:	80 81       	ld	r24, Z
    5736:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
    573a:	8c 01       	movw	r16, r24
  U1_Rl -= ReadU(Probes.Pin_2);         /* substract voltage at cathode */
    573c:	f7 01       	movw	r30, r14
    573e:	81 81       	ldd	r24, Z+1	; 0x01
    5740:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    5744:	7c 01       	movw	r14, r24


  DischargeProbes();                    /* try to discharge probes */
    5746:	0e 94 a3 23 	call	0x4746	; 0x4746 <DischargeProbes>
  if (Check.Found == COMP_ERROR) return;     /* skip on error */  
    574a:	90 91 09 01 	lds	r25, 0x0109
    574e:	91 30       	cpi	r25, 0x01	; 1
    5750:	09 f4       	brne	.+2      	; 0x5754 <CheckDiode+0xa4>
    5752:	07 c1       	rjmp	.+526    	; 0x5962 <CheckDiode+0x2b2>
  /* set probes: Gnd -- probe-2 / probe-1 -- Rl -- Vcc */
  R_DDR = Probes.Rl_1;                  /* enable Rl for probe-1 */
  R_PORT = Probes.Rl_1;                 /* pull up anode via Rl */
  PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLUP);     /* discharge gate */
  U1_Rl = ReadU_5ms(Probes.Pin_1);      /* get voltage at anode */
  U1_Rl -= ReadU(Probes.Pin_2);         /* substract voltage at cathode */
    5754:	0e 19       	sub	r16, r14
    5756:	1f 09       	sbc	r17, r15
   *  Vf #2, supporting a possible n-channel MOSFET
   */

  /* we assume: probe-1 = A / probe2 = C */
  /* set probes: Gnd -- probe-2 / probe-1 -- HiZ */
  ADC_PORT = 0;
    5758:	18 b8       	out	0x08, r1	; 8
  ADC_DDR = Probes.ADC_2;               /* pull down cathode directly */
    575a:	0f 2e       	mov	r0, r31
    575c:	ff e8       	ldi	r31, 0x8F	; 143
    575e:	2f 2e       	mov	r2, r31
    5760:	f1 e0       	ldi	r31, 0x01	; 1
    5762:	3f 2e       	mov	r3, r31
    5764:	f0 2d       	mov	r31, r0
    5766:	f1 01       	movw	r30, r2
    5768:	82 85       	ldd	r24, Z+10	; 0x0a
    576a:	87 b9       	out	0x07, r24	; 7
  /* R_DDR is set to HiZ by DischargeProbes() */
  U2_Zero = ReadU(Probes.Pin_1);        /* get voltage at anode */
    576c:	80 81       	ld	r24, Z
    576e:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    5772:	48 2e       	mov	r4, r24
    5774:	59 2e       	mov	r5, r25

  /* set probes: Gnd -- Rh -- probe-2 / probe-1 -- Vcc */
  ADC_DDR = 0;                          /* set to HiZ to prepare change */
    5776:	17 b8       	out	0x07, r1	; 7
  ADC_PORT = Probes.ADC_1;              /* pull up anode directly */
    5778:	f1 01       	movw	r30, r2
    577a:	81 85       	ldd	r24, Z+9	; 0x09
    577c:	88 b9       	out	0x08, r24	; 8
  ADC_DDR = Probes.ADC_1;               /* enable output */
    577e:	87 b9       	out	0x07, r24	; 7
  R_PORT = 0;                           /* pull down cathode via Rh */
    5780:	15 b8       	out	0x05, r1	; 5
  R_DDR = Probes.Rh_2;                  /* enable Rh for probe-2 */
    5782:	86 81       	ldd	r24, Z+6	; 0x06
    5784:	84 b9       	out	0x04, r24	; 4
  PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLDOWN);   /* discharge gate */
    5786:	60 e1       	ldi	r22, 0x10	; 16
    5788:	87 81       	ldd	r24, Z+7	; 0x07
    578a:	0e 94 6b 24 	call	0x48d6	; 0x48d6 <PullProbe>
  U2_Rh = ReadU_5ms(Probes.Pin_1);      /* get voltage at anode */
    578e:	f1 01       	movw	r30, r2
    5790:	80 81       	ld	r24, Z
    5792:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
    5796:	5c 01       	movw	r10, r24
  U2_Rh -= ReadU(Probes.Pin_2);         /* substract voltage at cathode */
    5798:	f1 01       	movw	r30, r2
    579a:	81 81       	ldd	r24, Z+1	; 0x01
    579c:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    57a0:	3c 01       	movw	r6, r24

  /* set probes: Gnd -- Rl -- probe-2 / probe-1 -- Vcc */
  R_DDR = Probes.Rl_2;                  /* pull down cathode via Rl */
    57a2:	f1 01       	movw	r30, r2
    57a4:	85 81       	ldd	r24, Z+5	; 0x05
    57a6:	84 b9       	out	0x04, r24	; 4
  PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLDOWN);   /* discharge gate */
    57a8:	60 e1       	ldi	r22, 0x10	; 16
    57aa:	87 81       	ldd	r24, Z+7	; 0x07
    57ac:	0e 94 6b 24 	call	0x48d6	; 0x48d6 <PullProbe>
  U2_Rl = ReadU_5ms(Probes.Pin_1);      /* get voltage at anode */
    57b0:	f1 01       	movw	r30, r2
    57b2:	80 81       	ld	r24, Z
    57b4:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
    57b8:	7c 01       	movw	r14, r24
  U2_Rl -= ReadU(Probes.Pin_2);         /* substract voltage at cathode */
    57ba:	f1 01       	movw	r30, r2
    57bc:	81 81       	ldd	r24, Z+1	; 0x01
    57be:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    57c2:	e8 1a       	sub	r14, r24
    57c4:	f9 0a       	sbc	r15, r25

  ADC_DDR = 0;                     /* stop pulling up */
    57c6:	17 b8       	out	0x07, r1	; 7
  /*
   *  process results
   */

  /* choose between both measurements */
  if (U1_Rl > U2_Rl)          /* the higher voltage wins */
    57c8:	e0 16       	cp	r14, r16
    57ca:	f1 06       	cpc	r15, r17
    57cc:	20 f4       	brcc	.+8      	; 0x57d6 <CheckDiode+0x126>
  {
    U_Diff = U1_Rl - U2_Rl;   /* difference of U_Rls */
    57ce:	c8 01       	movw	r24, r16
    57d0:	8e 19       	sub	r24, r14
    57d2:	9f 09       	sbc	r25, r15
    57d4:	09 c0       	rjmp	.+18     	; 0x57e8 <CheckDiode+0x138>
  ADC_DDR = Probes.ADC_1;               /* enable output */
  R_PORT = 0;                           /* pull down cathode via Rh */
  R_DDR = Probes.Rh_2;                  /* enable Rh for probe-2 */
  PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLDOWN);   /* discharge gate */
  U2_Rh = ReadU_5ms(Probes.Pin_1);      /* get voltage at anode */
  U2_Rh -= ReadU(Probes.Pin_2);         /* substract voltage at cathode */
    57d6:	45 01       	movw	r8, r10
    57d8:	86 18       	sub	r8, r6
    57da:	97 08       	sbc	r9, r7
    U2_Rh = U1_Rh;
    U2_Zero = U1_Zero;
  }
  else
  {
    U_Diff = U2_Rl - U1_Rl;   /* difference of U_Rls */
    57dc:	c7 01       	movw	r24, r14
    57de:	80 1b       	sub	r24, r16
    57e0:	91 0b       	sbc	r25, r17
  /* we assume: probe-1 = A / probe2 = C */
  /* set probes: Gnd -- probe-2 / probe-1 -- HiZ */
  ADC_PORT = 0;
  ADC_DDR = Probes.ADC_2;               /* pull down cathode directly */
  /* R_DDR is set to HiZ by DischargeProbes() */
  U2_Zero = ReadU(Probes.Pin_1);        /* get voltage at anode */
    57e2:	c4 2c       	mov	r12, r4
    57e4:	d5 2c       	mov	r13, r5

  /* set probes: Gnd -- Rl -- probe-2 / probe-1 -- Vcc */
  R_DDR = Probes.Rl_2;                  /* pull down cathode via Rl */
  PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLDOWN);   /* discharge gate */
  U2_Rl = ReadU_5ms(Probes.Pin_1);      /* get voltage at anode */
  U2_Rl -= ReadU(Probes.Pin_2);         /* substract voltage at cathode */
    57e6:	87 01       	movw	r16, r14
   *  - nearly zero for diodes, BJTs etc.
   *  - about a diode drop for enh-mode MOSFETs
   *  - >1000mV for dep-mode FETs partly conducting 
   */

  if (U_Diff > 1000) return;       /* dep-mode FET not fully turned off */
    57e8:	89 3e       	cpi	r24, 0xE9	; 233
    57ea:	93 40       	sbci	r25, 0x03	; 3
    57ec:	08 f0       	brcs	.+2      	; 0x57f0 <CheckDiode+0x140>
    57ee:	b9 c0       	rjmp	.+370    	; 0x5962 <CheckDiode+0x2b2>
    #define RESISTOR_LIMIT    16
  #else
    #define RESISTOR_LIMIT    10
  #endif

  if (U2_Rh <= RESISTOR_LIMIT) return;  /* small resistor or very large cap */
    57f0:	2b e0       	ldi	r18, 0x0B	; 11
    57f2:	82 16       	cp	r8, r18
    57f4:	91 04       	cpc	r9, r1
    57f6:	08 f4       	brcc	.+2      	; 0x57fa <CheckDiode+0x14a>
    57f8:	b4 c0       	rjmp	.+360    	; 0x5962 <CheckDiode+0x2b2>
   *  Hints:
   *  If U_Zero > 10 and U_Rh is about U_Zero it's a large cap.
   *  As larger the cap as lower U_Rl (charging time 15ms).
   */

  if (U2_Rh > U2_Zero)             /* prevent underrun */
    57fa:	c8 14       	cp	r12, r8
    57fc:	d9 04       	cpc	r13, r9
    57fe:	20 f4       	brcc	.+8      	; 0x5808 <CheckDiode+0x158>
  {
    U_Diff = U2_Rh - U2_Zero;      /* calculate difference */
    5800:	c4 01       	movw	r24, r8
    5802:	8c 19       	sub	r24, r12
    5804:	9d 09       	sbc	r25, r13
    5806:	03 c0       	rjmp	.+6      	; 0x580e <CheckDiode+0x15e>
  }
  else
  {
    U_Diff = U2_Zero - U2_Rh;
    5808:	c6 01       	movw	r24, r12
    580a:	88 19       	sub	r24, r8
    580c:	99 09       	sbc	r25, r9
  }

  if ((U2_Zero > 2) && (U_Diff < 100)) return;    /* capacitor */
    580e:	33 e0       	ldi	r19, 0x03	; 3
    5810:	c3 16       	cp	r12, r19
    5812:	d1 04       	cpc	r13, r1
    5814:	20 f0       	brcs	.+8      	; 0x581e <CheckDiode+0x16e>
    5816:	84 36       	cpi	r24, 0x64	; 100
    5818:	91 05       	cpc	r25, r1
    581a:	08 f4       	brcc	.+2      	; 0x581e <CheckDiode+0x16e>
    581c:	a2 c0       	rjmp	.+324    	; 0x5962 <CheckDiode+0x2b2>
   *  Hint: Actually we could change the threshold above from 10 to 40mV and
   *  remove this test completely. The lowest U_Rh measured for a diode was
   *  56mV for an AA118 (Germanium).
   */

  if (U2_Rh < 40)             /* resistor (< 3k) */
    581e:	88 e2       	ldi	r24, 0x28	; 40
    5820:	88 16       	cp	r8, r24
    5822:	91 04       	cpc	r9, r1
    5824:	08 f0       	brcs	.+2      	; 0x5828 <CheckDiode+0x178>
    5826:	6b c0       	rjmp	.+214    	; 0x58fe <CheckDiode+0x24e>
  {
    uint32_t      a, b;

    /* calculate expected U_Rl based on measured U_Rh in mV */
    b = (R_HIGH * 10) / ((R_LOW * 10) + NV.RiH + NV.RiL);  /* k factor */
    5828:	eb e9       	ldi	r30, 0x9B	; 155
    582a:	f1 e0       	ldi	r31, 0x01	; 1
    582c:	22 81       	ldd	r18, Z+2	; 0x02
    582e:	33 81       	ldd	r19, Z+3	; 0x03
    5830:	80 81       	ld	r24, Z
    5832:	91 81       	ldd	r25, Z+1	; 0x01
    5834:	28 0f       	add	r18, r24
    5836:	39 1f       	adc	r19, r25
    5838:	20 57       	subi	r18, 0x70	; 112
    583a:	35 4e       	sbci	r19, 0xE5	; 229
    583c:	40 e0       	ldi	r20, 0x00	; 0
    583e:	50 e0       	ldi	r21, 0x00	; 0
    5840:	60 e6       	ldi	r22, 0x60	; 96
    5842:	77 eb       	ldi	r23, 0xB7	; 183
    5844:	87 e4       	ldi	r24, 0x47	; 71
    5846:	90 e0       	ldi	r25, 0x00	; 0
    5848:	0e 94 a8 36 	call	0x6d50	; 0x6d50 <__divmodsi4>
    584c:	29 01       	movw	r4, r18
    584e:	3a 01       	movw	r6, r20
    a = b - 1;                          /* k-1 */
    5850:	21 50       	subi	r18, 0x01	; 1
    5852:	31 09       	sbc	r19, r1
    5854:	41 09       	sbc	r20, r1
    5856:	51 09       	sbc	r21, r1
    a *= 1000;                          /* scale for mV */
    5858:	a8 ee       	ldi	r26, 0xE8	; 232
    585a:	b3 e0       	ldi	r27, 0x03	; 3
    585c:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
    a /= Config.Vcc;                    /* /Vcc (in mV) */
    5860:	c0 90 b1 01 	lds	r12, 0x01B1
    5864:	d0 90 b2 01 	lds	r13, 0x01B2
    5868:	96 01       	movw	r18, r12
    586a:	40 e0       	ldi	r20, 0x00	; 0
    586c:	50 e0       	ldi	r21, 0x00	; 0
    586e:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    5872:	ca 01       	movw	r24, r20
    5874:	b9 01       	movw	r22, r18
    a *= U2_Rh;                         /* *U_Rh (in mV) */
    5876:	64 01       	movw	r12, r8
    5878:	e1 2c       	mov	r14, r1
    587a:	f1 2c       	mov	r15, r1
    587c:	a7 01       	movw	r20, r14
    587e:	96 01       	movw	r18, r12
    5880:	0e 94 4e 36 	call	0x6c9c	; 0x6c9c <__mulsi3>
    5884:	69 83       	std	Y+1, r22	; 0x01
    5886:	7a 83       	std	Y+2, r23	; 0x02
    5888:	8b 83       	std	Y+3, r24	; 0x03
    588a:	9c 83       	std	Y+4, r25	; 0x04
    a += 1000;                          /* +1 (1000 for mV) */
    b *= 1000;                          /* for mV */
    588c:	a8 ee       	ldi	r26, 0xE8	; 232
    588e:	b3 e0       	ldi	r27, 0x03	; 3
    5890:	a3 01       	movw	r20, r6
    5892:	92 01       	movw	r18, r4
    5894:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
    5898:	9b 01       	movw	r18, r22
    589a:	ac 01       	movw	r20, r24
    b *= U2_Rh;                         /* *U_Rh (in mV) */
    589c:	c7 01       	movw	r24, r14
    589e:	b6 01       	movw	r22, r12
    58a0:	0e 94 4e 36 	call	0x6c9c	; 0x6c9c <__mulsi3>
    b = (R_HIGH * 10) / ((R_LOW * 10) + NV.RiH + NV.RiL);  /* k factor */
    a = b - 1;                          /* k-1 */
    a *= 1000;                          /* scale for mV */
    a /= Config.Vcc;                    /* /Vcc (in mV) */
    a *= U2_Rh;                         /* *U_Rh (in mV) */
    a += 1000;                          /* +1 (1000 for mV) */
    58a4:	29 81       	ldd	r18, Y+1	; 0x01
    58a6:	3a 81       	ldd	r19, Y+2	; 0x02
    58a8:	4b 81       	ldd	r20, Y+3	; 0x03
    58aa:	5c 81       	ldd	r21, Y+4	; 0x04
    58ac:	28 51       	subi	r18, 0x18	; 24
    58ae:	3c 4f       	sbci	r19, 0xFC	; 252
    58b0:	4f 4f       	sbci	r20, 0xFF	; 255
    58b2:	5f 4f       	sbci	r21, 0xFF	; 255
    b *= 1000;                          /* for mV */
    b *= U2_Rh;                         /* *U_Rh (in mV) */
    b /= a;                             /* U_Rl in mV */
    58b4:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    58b8:	69 01       	movw	r12, r18
    58ba:	7a 01       	movw	r14, r20
    U1_Rl = U1_Zero;
    U1_Rh = U1_Zero;
    U1_Zero /= 10;            /* 10% */
    U1_Rh += U1_Zero;         /* 110% */
    U1_Zero = (uint16_t)b;
    U1_Zero /= 33;            /* 3% */
    58bc:	af e3       	ldi	r26, 0x3F	; 63
    58be:	b8 ef       	ldi	r27, 0xF8	; 248
    58c0:	0e 94 cd 36 	call	0x6d9a	; 0x6d9a <__umulhisi3>
    58c4:	96 95       	lsr	r25
    58c6:	87 95       	ror	r24
    58c8:	92 95       	swap	r25
    58ca:	82 95       	swap	r24
    58cc:	8f 70       	andi	r24, 0x0F	; 15
    58ce:	89 27       	eor	r24, r25
    58d0:	9f 70       	andi	r25, 0x0F	; 15
    58d2:	89 27       	eor	r24, r25
    U1_Rl -= U1_Zero;         /* 97% (for resistors near 1k) */
    58d4:	f6 01       	movw	r30, r12
    58d6:	e8 1b       	sub	r30, r24
    58d8:	f9 0b       	sbc	r31, r25

    if ((U2_Rl >= U1_Rl) && (U2_Rl <= U1_Rh)) return;     /* resistor */
    58da:	0e 17       	cp	r16, r30
    58dc:	1f 07       	cpc	r17, r31
    58de:	78 f0       	brcs	.+30     	; 0x58fe <CheckDiode+0x24e>

    /* check if calculated U_Rl is within some % of measured value */
    U1_Zero = (uint16_t)b;
    U1_Rl = U1_Zero;
    U1_Rh = U1_Zero;
    U1_Zero /= 10;            /* 10% */
    58e0:	ad ec       	ldi	r26, 0xCD	; 205
    58e2:	bc ec       	ldi	r27, 0xCC	; 204
    58e4:	0e 94 cd 36 	call	0x6d9a	; 0x6d9a <__umulhisi3>
    58e8:	96 95       	lsr	r25
    58ea:	87 95       	ror	r24
    58ec:	96 95       	lsr	r25
    58ee:	87 95       	ror	r24
    58f0:	96 95       	lsr	r25
    58f2:	87 95       	ror	r24
    U1_Rh += U1_Zero;         /* 110% */
    58f4:	c8 0e       	add	r12, r24
    58f6:	d9 1e       	adc	r13, r25
    U1_Zero = (uint16_t)b;
    U1_Zero /= 33;            /* 3% */
    U1_Rl -= U1_Zero;         /* 97% (for resistors near 1k) */

    if ((U2_Rl >= U1_Rl) && (U2_Rl <= U1_Rh)) return;     /* resistor */
    58f8:	c0 16       	cp	r12, r16
    58fa:	d1 06       	cpc	r13, r17
    58fc:	90 f5       	brcc	.+100    	; 0x5962 <CheckDiode+0x2b2>

  /*
   *  if U_Rl (Vf) is between 0.15V and 4.64V it's a diode
   */

  if ((U2_Rl > 150) && (U2_Rl < 4640))
    58fe:	c8 01       	movw	r24, r16
    5900:	87 59       	subi	r24, 0x97	; 151
    5902:	91 09       	sbc	r25, r1
    5904:	89 38       	cpi	r24, 0x89	; 137
    5906:	91 41       	sbci	r25, 0x11	; 17
    5908:	60 f5       	brcc	.+88     	; 0x5962 <CheckDiode+0x2b2>
  {
    /* if we haven't found any other component yet */
    if ((Check.Found == COMP_NONE) ||
    590a:	80 91 09 01 	lds	r24, 0x0109
    590e:	88 23       	and	r24, r24
    5910:	11 f0       	breq	.+4      	; 0x5916 <CheckDiode+0x266>
    5912:	8a 30       	cpi	r24, 0x0A	; 10
    5914:	19 f4       	brne	.+6      	; 0x591c <CheckDiode+0x26c>
        (Check.Found == COMP_RESISTOR))
    {
      Check.Found = COMP_DIODE;
    5916:	84 e1       	ldi	r24, 0x14	; 20
    5918:	80 93 09 01 	sts	0x0109, r24
    }

    /* save data */
    Diode = &Diodes[Check.Diodes];
    591c:	68 e0       	ldi	r22, 0x08	; 8
    591e:	71 e0       	ldi	r23, 0x01	; 1
    5920:	fb 01       	movw	r30, r22
    5922:	24 81       	ldd	r18, Z+4	; 0x04
    5924:	82 2f       	mov	r24, r18
    5926:	90 e0       	ldi	r25, 0x00	; 0
    Diode->A = Probes.Pin_1;
    5928:	7c 01       	movw	r14, r24
    592a:	ee 0c       	add	r14, r14
    592c:	ff 1c       	adc	r15, r15
    592e:	d7 01       	movw	r26, r14
    5930:	a8 0f       	add	r26, r24
    5932:	b9 1f       	adc	r27, r25
    5934:	aa 0f       	add	r26, r26
    5936:	bb 1f       	adc	r27, r27
    5938:	a4 5a       	subi	r26, 0xA4	; 164
    593a:	be 4f       	sbci	r27, 0xFE	; 254
    593c:	4f e8       	ldi	r20, 0x8F	; 143
    593e:	51 e0       	ldi	r21, 0x01	; 1
    5940:	fa 01       	movw	r30, r20
    5942:	30 81       	ld	r19, Z
    5944:	3c 93       	st	X, r19
    Diode->C = Probes.Pin_2;
    5946:	31 81       	ldd	r19, Z+1	; 0x01
    5948:	11 96       	adiw	r26, 0x01	; 1
    594a:	3c 93       	st	X, r19
    594c:	11 97       	sbiw	r26, 0x01	; 1
    Diode->V_f = U2_Rl;       /* Vf for high measurement current */
    594e:	13 96       	adiw	r26, 0x03	; 3
    5950:	1c 93       	st	X, r17
    5952:	0e 93       	st	-X, r16
    5954:	12 97       	sbiw	r26, 0x02	; 2
    Diode->V_f2 = U2_Rh;      /* Vf for low measurement current */
    5956:	fd 01       	movw	r30, r26
    5958:	95 82       	std	Z+5, r9	; 0x05
    595a:	84 82       	std	Z+4, r8	; 0x04
    Check.Diodes++;
    595c:	2f 5f       	subi	r18, 0xFF	; 255
    595e:	fb 01       	movw	r30, r22
    5960:	24 83       	std	Z+4, r18	; 0x04
  }

  #undef RESISTOR_LIMIT
}
    5962:	0f 90       	pop	r0
    5964:	0f 90       	pop	r0
    5966:	0f 90       	pop	r0
    5968:	0f 90       	pop	r0
    596a:	df 91       	pop	r29
    596c:	cf 91       	pop	r28
    596e:	1f 91       	pop	r17
    5970:	0f 91       	pop	r16
    5972:	ff 90       	pop	r15
    5974:	ef 90       	pop	r14
    5976:	df 90       	pop	r13
    5978:	cf 90       	pop	r12
    597a:	bf 90       	pop	r11
    597c:	af 90       	pop	r10
    597e:	9f 90       	pop	r9
    5980:	8f 90       	pop	r8
    5982:	7f 90       	pop	r7
    5984:	6f 90       	pop	r6
    5986:	5f 90       	pop	r5
    5988:	4f 90       	pop	r4
    598a:	3f 90       	pop	r3
    598c:	2f 90       	pop	r2
    598e:	08 95       	ret

00005990 <VerifyMOSFET>:
  uint8_t           Anode;
  uint8_t           Cathode;
  Diode_Type        *Diode;             /* pointer to diode */

  /* set expected body diode */
  if (Check.Type & TYPE_N_CHANNEL)      /* n-channel */
    5990:	80 91 0a 01 	lds	r24, 0x010A
    5994:	80 ff       	sbrs	r24, 0
    5996:	05 c0       	rjmp	.+10     	; 0x59a2 <VerifyMOSFET+0x12>
  {
    Anode = Semi.C;      /* anode at source */
    5998:	e1 e8       	ldi	r30, 0x81	; 129
    599a:	f1 e0       	ldi	r31, 0x01	; 1
    599c:	42 81       	ldd	r20, Z+2	; 0x02
    Cathode = Semi.B;    /* cathode at drain */
    599e:	31 81       	ldd	r19, Z+1	; 0x01
    59a0:	04 c0       	rjmp	.+8      	; 0x59aa <VerifyMOSFET+0x1a>
  }
  else                                  /* p-channel */
  {
    Anode = Semi.B;      /* anode at drain */
    59a2:	e1 e8       	ldi	r30, 0x81	; 129
    59a4:	f1 e0       	ldi	r31, 0x01	; 1
    59a6:	41 81       	ldd	r20, Z+1	; 0x01
    Cathode = Semi.C;    /* cathode at source */
    59a8:	32 81       	ldd	r19, Z+2	; 0x02
  }

  Diode = &Diodes[0];              /* first diode */

  /* check all known diodes for reversed one */
  while (n < Check.Diodes)
    59aa:	20 91 0c 01 	lds	r18, 0x010C
    59ae:	22 23       	and	r18, r18
    59b0:	d9 f0       	breq	.+54     	; 0x59e8 <VerifyMOSFET+0x58>
    59b2:	ed e5       	ldi	r30, 0x5D	; 93
    59b4:	f1 e0       	ldi	r31, 0x01	; 1
    59b6:	80 e0       	ldi	r24, 0x00	; 0
    59b8:	50 e0       	ldi	r21, 0x00	; 0
  {
    if ((Diode->A == Cathode) && (Diode->C == Anode))
    {
      Flag = 1;          /* signal match */
      n = 10;            /* end loop */
    59ba:	7a e0       	ldi	r23, 0x0A	; 10
  /* check all known diodes for reversed one */
  while (n < Check.Diodes)
  {
    if ((Diode->A == Cathode) && (Diode->C == Anode))
    {
      Flag = 1;          /* signal match */
    59bc:	61 e0       	ldi	r22, 0x01	; 1
    59be:	df 01       	movw	r26, r30
    59c0:	11 97       	sbiw	r26, 0x01	; 1
  Diode = &Diodes[0];              /* first diode */

  /* check all known diodes for reversed one */
  while (n < Check.Diodes)
  {
    if ((Diode->A == Cathode) && (Diode->C == Anode))
    59c2:	9c 91       	ld	r25, X
    59c4:	93 13       	cpse	r25, r19
    59c6:	05 c0       	rjmp	.+10     	; 0x59d2 <VerifyMOSFET+0x42>
    59c8:	90 81       	ld	r25, Z
    59ca:	94 13       	cpse	r25, r20
    59cc:	02 c0       	rjmp	.+4      	; 0x59d2 <VerifyMOSFET+0x42>
    {
      Flag = 1;          /* signal match */
      n = 10;            /* end loop */
    59ce:	87 2f       	mov	r24, r23
  /* check all known diodes for reversed one */
  while (n < Check.Diodes)
  {
    if ((Diode->A == Cathode) && (Diode->C == Anode))
    {
      Flag = 1;          /* signal match */
    59d0:	56 2f       	mov	r21, r22
      n = 10;            /* end loop */
    }

    n++;                 /* next diode */
    59d2:	8f 5f       	subi	r24, 0xFF	; 255
    59d4:	36 96       	adiw	r30, 0x06	; 6
  }

  Diode = &Diodes[0];              /* first diode */

  /* check all known diodes for reversed one */
  while (n < Check.Diodes)
    59d6:	82 17       	cp	r24, r18
    59d8:	90 f3       	brcs	.-28     	; 0x59be <VerifyMOSFET+0x2e>

    n++;                 /* next diode */
    Diode++;
  }

  if (Flag == 1)         /* found reversed diode */
    59da:	51 30       	cpi	r21, 0x01	; 1
    59dc:	29 f4       	brne	.+10     	; 0x59e8 <VerifyMOSFET+0x58>
  {
    /* this can't be a MOSFET, so let's reset */
    Check.Found = COMP_NONE;
    59de:	e8 e0       	ldi	r30, 0x08	; 8
    59e0:	f1 e0       	ldi	r31, 0x01	; 1
    59e2:	11 82       	std	Z+1, r1	; 0x01
    Check.Type = 0;
    59e4:	12 82       	std	Z+2, r1	; 0x02
    Check.Done = 0;
    59e6:	10 82       	st	Z, r1
    59e8:	08 95       	ret

000059ea <CheckBJTorEnhModeMOSFET>:
 *  - BJT_Type: NPN or PNP (also used for FET channel type)
 *  - U_Rl: voltage across Rl pulled down
 */

void CheckBJTorEnhModeMOSFET(uint8_t BJT_Type, uint16_t U_Rl)
{
    59ea:	8f 92       	push	r8
    59ec:	9f 92       	push	r9
    59ee:	af 92       	push	r10
    59f0:	bf 92       	push	r11
    59f2:	cf 92       	push	r12
    59f4:	df 92       	push	r13
    59f6:	ef 92       	push	r14
    59f8:	ff 92       	push	r15
    59fa:	0f 93       	push	r16
    59fc:	1f 93       	push	r17
    59fe:	cf 93       	push	r28
    5a00:	df 93       	push	r29
    5a02:	18 2f       	mov	r17, r24
    5a04:	5b 01       	movw	r10, r22

  /*
   *  init, set probes and measure
   */

  if (BJT_Type == TYPE_NPN)   /* NPN / n-channel */
    5a06:	81 30       	cpi	r24, 0x01	; 1
    5a08:	69 f5       	brne	.+90     	; 0x5a64 <CheckBJTorEnhModeMOSFET+0x7a>
     *  - FET: probe-1 = D / probe-2 = S / probe-3 = G
     *  probes already set to: Gnd -- probe-2 / probe-1 -- Rl -- Vcc
     *  drive base/gate via Rh instead of Rl
     */

    R_DDR = Probes.Rl_1 | Probes.Rh_3;  /* enable Rl for probe-1 & Rh for probe-3 */
    5a0a:	cf e8       	ldi	r28, 0x8F	; 143
    5a0c:	d1 e0       	ldi	r29, 0x01	; 1
    5a0e:	98 85       	ldd	r25, Y+8	; 0x08
    5a10:	8b 81       	ldd	r24, Y+3	; 0x03
    5a12:	89 2b       	or	r24, r25
    5a14:	84 b9       	out	0x04, r24	; 4
    R_PORT = Probes.Rl_1 | Probes.Rh_3; /* pull up collector via Rl and base via Rh */
    5a16:	85 b9       	out	0x05, r24	; 5
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5a18:	2f ef       	ldi	r18, 0xFF	; 255
    5a1a:	80 e7       	ldi	r24, 0x70	; 112
    5a1c:	92 e0       	ldi	r25, 0x02	; 2
    5a1e:	21 50       	subi	r18, 0x01	; 1
    5a20:	80 40       	sbci	r24, 0x00	; 0
    5a22:	90 40       	sbci	r25, 0x00	; 0
    5a24:	e1 f7       	brne	.-8      	; 0x5a1e <CheckBJTorEnhModeMOSFET+0x34>
    5a26:	00 c0       	rjmp	.+0      	; 0x5a28 <CheckBJTorEnhModeMOSFET+0x3e>
    5a28:	00 00       	nop
    _delay_ms(50);                         /* wait to skip gate charging of a FET */
    U_R_c = Config.Vcc - ReadU(Probes.Pin_1);     /* U_R_c = Vcc - U_c */ 
    5a2a:	0f 2e       	mov	r0, r31
    5a2c:	fb ea       	ldi	r31, 0xAB	; 171
    5a2e:	cf 2e       	mov	r12, r31
    5a30:	f1 e0       	ldi	r31, 0x01	; 1
    5a32:	df 2e       	mov	r13, r31
    5a34:	f0 2d       	mov	r31, r0
    5a36:	f6 01       	movw	r30, r12
    5a38:	e6 80       	ldd	r14, Z+6	; 0x06
    5a3a:	f7 80       	ldd	r15, Z+7	; 0x07
    5a3c:	88 81       	ld	r24, Y
    5a3e:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    5a42:	e8 1a       	sub	r14, r24
    5a44:	f9 0a       	sbc	r15, r25
    U_R_b = Config.Vcc - ReadU(Probes.Pin_3);     /* U_R_b = Vcc - U_b */
    5a46:	f6 01       	movw	r30, r12
    5a48:	c6 80       	ldd	r12, Z+6	; 0x06
    5a4a:	d7 80       	ldd	r13, Z+7	; 0x07
    5a4c:	8a 81       	ldd	r24, Y+2	; 0x02
    5a4e:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    5a52:	e6 01       	movw	r28, r12
    5a54:	c8 1b       	sub	r28, r24
    5a56:	d9 0b       	sbc	r29, r25
   */

  if (BJT_Type == TYPE_NPN)   /* NPN / n-channel */
  {
    BJT_Level = 2557;         /* voltage across base resistor (5.44A) */
    FET_Level = 3400;         /* voltage across drain resistor (4.8mA) */
    5a58:	88 e4       	ldi	r24, 0x48	; 72
    5a5a:	9d e0       	ldi	r25, 0x0D	; 13
   *  init, set probes and measure
   */

  if (BJT_Type == TYPE_NPN)   /* NPN / n-channel */
  {
    BJT_Level = 2557;         /* voltage across base resistor (5.44A) */
    5a5c:	2d ef       	ldi	r18, 0xFD	; 253
    5a5e:	39 e0       	ldi	r19, 0x09	; 9
    FET_Level = 3400;         /* voltage across drain resistor (4.8mA) */
    FET_Type = TYPE_N_CHANNEL;
    5a60:	01 e0       	ldi	r16, 0x01	; 1
    5a62:	13 c0       	rjmp	.+38     	; 0x5a8a <CheckBJTorEnhModeMOSFET+0xa0>
     *  - FET: probe-1 = S / probe-2 = D / probe-3 = G
     *  probes already set to: Gnd -- Rl - probe-2 / probe-1 -- Vcc
     *  drive base/gate via Rh instead of Rl
     */

    R_DDR = Probes.Rl_2 | Probes.Rh_3;  /* pull down base via Rh */
    5a64:	cf e8       	ldi	r28, 0x8F	; 143
    5a66:	d1 e0       	ldi	r29, 0x01	; 1
    5a68:	98 85       	ldd	r25, Y+8	; 0x08
    5a6a:	8d 81       	ldd	r24, Y+5	; 0x05
    5a6c:	89 2b       	or	r24, r25
    5a6e:	84 b9       	out	0x04, r24	; 4
    U_R_c = ReadU_5ms(Probes.Pin_2);    /* U_R_c = U_c */
    5a70:	89 81       	ldd	r24, Y+1	; 0x01
    5a72:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
    5a76:	7c 01       	movw	r14, r24
    U_R_b = ReadU(Probes.Pin_3);        /* U_R_b = U_b */
    5a78:	8a 81       	ldd	r24, Y+2	; 0x02
    5a7a:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    5a7e:	ec 01       	movw	r28, r24
    U_R_b = Config.Vcc - ReadU(Probes.Pin_3);     /* U_R_b = Vcc - U_b */
  }
  else                        /* PNP / p-channel */
  {
    BJT_Level = 977;          /* voltage across base resistor (2.1A) */
    FET_Level = 2000;         /* voltage across drain resistor (2.8mA) */
    5a80:	80 ed       	ldi	r24, 0xD0	; 208
    5a82:	97 e0       	ldi	r25, 0x07	; 7
    U_R_c = Config.Vcc - ReadU(Probes.Pin_1);     /* U_R_c = Vcc - U_c */ 
    U_R_b = Config.Vcc - ReadU(Probes.Pin_3);     /* U_R_b = Vcc - U_b */
  }
  else                        /* PNP / p-channel */
  {
    BJT_Level = 977;          /* voltage across base resistor (2.1A) */
    5a84:	21 ed       	ldi	r18, 0xD1	; 209
    5a86:	33 e0       	ldi	r19, 0x03	; 3
    FET_Level = 2000;         /* voltage across drain resistor (2.8mA) */
    FET_Type = TYPE_P_CHANNEL;
    5a88:	02 e0       	ldi	r16, 0x02	; 2

  /*
   *  distinguish BJT from enhancement-mode MOSFET
   */

  if (U_R_b > BJT_Level)      /* U_R_b exceeds minimum level of BJT */
    5a8a:	2c 17       	cp	r18, r28
    5a8c:	3d 07       	cpc	r19, r29
    5a8e:	08 f0       	brcs	.+2      	; 0x5a92 <CheckBJTorEnhModeMOSFET+0xa8>
    5a90:	9f c0       	rjmp	.+318    	; 0x5bd0 <CheckBJTorEnhModeMOSFET+0x1e6>
     *  A reversed collector and emitter also passes the tests, but with a
     *  lower hFE. So we need to run the BJT test twice to be sure and select
     *  the results with the higher hFE.
     */

    if (Check.Found == COMP_BJT)        /* second test run */
    5a92:	80 91 09 01 	lds	r24, 0x0109
    5a96:	85 31       	cpi	r24, 0x15	; 21
    5a98:	61 f4       	brne	.+24     	; 0x5ab2 <CheckBJTorEnhModeMOSFET+0xc8>
    {
      Check.Done = 1;                   /* no more tests needed */
    5a9a:	e8 e0       	ldi	r30, 0x08	; 8
    5a9c:	f1 e0       	ldi	r31, 0x01	; 1
    5a9e:	81 e0       	ldi	r24, 0x01	; 1
    5aa0:	80 83       	st	Z, r24
      /*
       *  If the type is different from the one in the first run, we have
       *  a parasitic BJT (caused by a freewheeling diode on the same substrate).
       */

      if (!(Check.Type & BJT_Type)) Check.Type |= TYPE_PARASITIC;
    5aa2:	82 81       	ldd	r24, Z+2	; 0x02
    5aa4:	91 2f       	mov	r25, r17
    5aa6:	98 23       	and	r25, r24
    5aa8:	49 f4       	brne	.+18     	; 0x5abc <CheckBJTorEnhModeMOSFET+0xd2>
    5aaa:	84 60       	ori	r24, 0x04	; 4
    5aac:	80 93 0a 01 	sts	0x010A, r24
    5ab0:	05 c0       	rjmp	.+10     	; 0x5abc <CheckBJTorEnhModeMOSFET+0xd2>
    }
    else                                /* first test run */
    {
      Check.Found = COMP_BJT;
    5ab2:	e8 e0       	ldi	r30, 0x08	; 8
    5ab4:	f1 e0       	ldi	r31, 0x01	; 1
    5ab6:	85 e1       	ldi	r24, 0x15	; 21
    5ab8:	81 83       	std	Z+1, r24	; 0x01
      Check.Type = BJT_Type;
    5aba:	12 83       	std	Z+2, r17	; 0x02
    }

    /* leakage current */
    I_CE0 = GetLeakageCurrent();        /* get leakage current (in A) */
    5abc:	0e 94 12 2b 	call	0x5624	; 0x5624 <GetLeakageCurrent>
    5ac0:	6c 01       	movw	r12, r24
     *        = (U_R_c_conducting - U_R_c_leak) / R_c
     *    -> U_R_c = U_R_c_conducting - U_R_c_leak
     *             = U_R_c_conducting - U_Rl
     */

    if (U_R_c > U_Rl) U_R_c -= U_Rl;       /* - U_Rl (leakage) */
    5ac2:	ae 14       	cp	r10, r14
    5ac4:	bf 04       	cpc	r11, r15
    5ac6:	10 f4       	brcc	.+4      	; 0x5acc <CheckBJTorEnhModeMOSFET+0xe2>
    5ac8:	ea 18       	sub	r14, r10
    5aca:	fb 08       	sbc	r15, r11
    hFE_E = U_R_c * R_HIGH;                /* U_R_c * R_b */
    5acc:	d7 01       	movw	r26, r14
    5ace:	20 ef       	ldi	r18, 0xF0	; 240
    5ad0:	3b e2       	ldi	r19, 0x2B	; 43
    5ad2:	47 e0       	ldi	r20, 0x07	; 7
    5ad4:	50 e0       	ldi	r21, 0x00	; 0
    5ad6:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
    hFE_E /= U_R_b;                        /* / U_R_b */
    5ada:	9e 01       	movw	r18, r28
    5adc:	40 e0       	ldi	r20, 0x00	; 0
    5ade:	50 e0       	ldi	r21, 0x00	; 0
    5ae0:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    hFE_E *= 10;                           /* upscale to 0.1 */
    5ae4:	da 01       	movw	r26, r20
    5ae6:	c9 01       	movw	r24, r18
    5ae8:	88 0f       	add	r24, r24
    5aea:	99 1f       	adc	r25, r25
    5aec:	aa 1f       	adc	r26, r26
    5aee:	bb 1f       	adc	r27, r27
    5af0:	4c 01       	movw	r8, r24
    5af2:	5d 01       	movw	r10, r26
    5af4:	88 0c       	add	r8, r8
    5af6:	99 1c       	adc	r9, r9
    5af8:	aa 1c       	adc	r10, r10
    5afa:	bb 1c       	adc	r11, r11
    5afc:	88 0c       	add	r8, r8
    5afe:	99 1c       	adc	r9, r9
    5b00:	aa 1c       	adc	r10, r10
    5b02:	bb 1c       	adc	r11, r11
    5b04:	bc 01       	movw	r22, r24
    5b06:	cd 01       	movw	r24, r26
    5b08:	68 0d       	add	r22, r8
    5b0a:	79 1d       	adc	r23, r9
    5b0c:	8a 1d       	adc	r24, r10
    5b0e:	9b 1d       	adc	r25, r11

    if (BJT_Type == TYPE_NPN)      /* NPN */
    5b10:	11 30       	cpi	r17, 0x01	; 1
    5b12:	69 f4       	brne	.+26     	; 0x5b2e <CheckBJTorEnhModeMOSFET+0x144>
      hFE_E /= (R_LOW * 10) + NV.RiH;    /* / R_c in 0.1 Ohm */
    5b14:	20 91 9d 01 	lds	r18, 0x019D
    5b18:	30 91 9e 01 	lds	r19, 0x019E
    5b1c:	20 57       	subi	r18, 0x70	; 112
    5b1e:	35 4e       	sbci	r19, 0xE5	; 229
    5b20:	40 e0       	ldi	r20, 0x00	; 0
    5b22:	50 e0       	ldi	r21, 0x00	; 0
    5b24:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    5b28:	49 01       	movw	r8, r18
    5b2a:	5a 01       	movw	r10, r20
    5b2c:	0c c0       	rjmp	.+24     	; 0x5b46 <CheckBJTorEnhModeMOSFET+0x15c>
    else                           /* PNP */
      hFE_E /= (R_LOW * 10) + NV.RiL;    /* / R_c in 0.1 Ohm */
    5b2e:	20 91 9b 01 	lds	r18, 0x019B
    5b32:	30 91 9c 01 	lds	r19, 0x019C
    5b36:	20 57       	subi	r18, 0x70	; 112
    5b38:	35 4e       	sbci	r19, 0xE5	; 229
    5b3a:	40 e0       	ldi	r20, 0x00	; 0
    5b3c:	50 e0       	ldi	r21, 0x00	; 0
    5b3e:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    5b42:	49 01       	movw	r8, r18
    5b44:	5a 01       	movw	r10, r20

    /* get hFE for common collector circuit */
    hFE_C = Get_hFE_C(BJT_Type);
    5b46:	81 2f       	mov	r24, r17
    5b48:	0e 94 b7 29 	call	0x536e	; 0x536e <Get_hFE_C>

    /* keep higher hFE */
    if (hFE_C > hFE_E) hFE_E = hFE_C;

    /* parasitic BJT */
    if (Check.Type & TYPE_PARASITIC)
    5b4c:	30 91 0a 01 	lds	r19, 0x010A
    5b50:	32 fd       	sbrc	r19, 2
    5b52:	a0 c0       	rjmp	.+320    	; 0x5c94 <CheckBJTorEnhModeMOSFET+0x2aa>
    5b54:	46 2f       	mov	r20, r22
    5b56:	57 2f       	mov	r21, r23
    5b58:	68 2f       	mov	r22, r24
    5b5a:	79 2f       	mov	r23, r25
    5b5c:	48 15       	cp	r20, r8
    5b5e:	59 05       	cpc	r21, r9
    5b60:	6a 05       	cpc	r22, r10
    5b62:	7b 05       	cpc	r23, r11
    5b64:	10 f4       	brcc	.+4      	; 0x5b6a <CheckBJTorEnhModeMOSFET+0x180>
    5b66:	b5 01       	movw	r22, r10
    5b68:	a4 01       	movw	r20, r8

      hFE_E = 0;    /* we keep the first type found at the moment */
    }

    /* only update data if hFE is higher than old one or not set yet */
    if (hFE_E > Semi.F_1)
    5b6a:	80 91 8a 01 	lds	r24, 0x018A
    5b6e:	90 91 8b 01 	lds	r25, 0x018B
    5b72:	a0 91 8c 01 	lds	r26, 0x018C
    5b76:	b0 91 8d 01 	lds	r27, 0x018D
    5b7a:	84 17       	cp	r24, r20
    5b7c:	95 07       	cpc	r25, r21
    5b7e:	a6 07       	cpc	r26, r22
    5b80:	b7 07       	cpc	r27, r23
    5b82:	08 f0       	brcs	.+2      	; 0x5b86 <CheckBJTorEnhModeMOSFET+0x19c>
    5b84:	87 c0       	rjmp	.+270    	; 0x5c94 <CheckBJTorEnhModeMOSFET+0x2aa>
    {
      /* save data */
      Semi.F_1 = hFE_E;            /* hFE */
    5b86:	e1 e8       	ldi	r30, 0x81	; 129
    5b88:	f1 e0       	ldi	r31, 0x01	; 1
    5b8a:	41 87       	std	Z+9, r20	; 0x09
    5b8c:	52 87       	std	Z+10, r21	; 0x0a
    5b8e:	63 87       	std	Z+11, r22	; 0x0b
    5b90:	74 87       	std	Z+12, r23	; 0x0c
      Semi.I_1 = I_CE0;            /* leakage current */
    5b92:	d0 86       	std	Z+8, r13	; 0x08
    5b94:	c7 82       	std	Z+7, r12	; 0x07
      Semi.A = Probes.Pin_3;       /* base pin */
    5b96:	80 91 91 01 	lds	r24, 0x0191
    5b9a:	80 83       	st	Z, r24

      /* update Collector and Emitter pins */
      if (BJT_Type == TYPE_NPN)    /* NPN */
    5b9c:	11 30       	cpi	r17, 0x01	; 1
    5b9e:	51 f4       	brne	.+20     	; 0x5bb4 <CheckBJTorEnhModeMOSFET+0x1ca>
      {
        Semi.B = Probes.Pin_1;     /* collector pin */
    5ba0:	af e8       	ldi	r26, 0x8F	; 143
    5ba2:	b1 e0       	ldi	r27, 0x01	; 1
    5ba4:	8c 91       	ld	r24, X
    5ba6:	81 83       	std	Z+1, r24	; 0x01
        Semi.C = Probes.Pin_2;     /* emitter pin */
    5ba8:	11 96       	adiw	r26, 0x01	; 1
    5baa:	8c 91       	ld	r24, X
    5bac:	82 83       	std	Z+2, r24	; 0x02

        #ifdef SW_SYMBOLS
        Check.Symbol = SYMBOL_BJT_NPN;  /* set symbol ID */
    5bae:	10 92 10 01 	sts	0x0110, r1
    5bb2:	70 c0       	rjmp	.+224    	; 0x5c94 <CheckBJTorEnhModeMOSFET+0x2aa>
        #endif
      }
      else                         /* PNP */
      {
        Semi.B = Probes.Pin_2;     /* collector pin */
    5bb4:	e1 e8       	ldi	r30, 0x81	; 129
    5bb6:	f1 e0       	ldi	r31, 0x01	; 1
    5bb8:	af e8       	ldi	r26, 0x8F	; 143
    5bba:	b1 e0       	ldi	r27, 0x01	; 1
    5bbc:	11 96       	adiw	r26, 0x01	; 1
    5bbe:	8c 91       	ld	r24, X
    5bc0:	11 97       	sbiw	r26, 0x01	; 1
    5bc2:	81 83       	std	Z+1, r24	; 0x01
        Semi.C = Probes.Pin_1;     /* emitter pin */
    5bc4:	8c 91       	ld	r24, X
    5bc6:	82 83       	std	Z+2, r24	; 0x02

        #ifdef SW_SYMBOLS
        Check.Symbol = SYMBOL_BJT_PNP;  /* set symbol ID */
    5bc8:	81 e0       	ldi	r24, 0x01	; 1
    5bca:	80 93 10 01 	sts	0x0110, r24
    5bce:	62 c0       	rjmp	.+196    	; 0x5c94 <CheckBJTorEnhModeMOSFET+0x2aa>
        #endif
      }
    }
  }
  else if ((U_Rl < 97) && (U_R_c > FET_Level))    /* no BJT */
    5bd0:	f1 e6       	ldi	r31, 0x61	; 97
    5bd2:	af 16       	cp	r10, r31
    5bd4:	b1 04       	cpc	r11, r1
    5bd6:	08 f0       	brcs	.+2      	; 0x5bda <CheckBJTorEnhModeMOSFET+0x1f0>
    5bd8:	5d c0       	rjmp	.+186    	; 0x5c94 <CheckBJTorEnhModeMOSFET+0x2aa>
    5bda:	8e 15       	cp	r24, r14
    5bdc:	9f 05       	cpc	r25, r15
    5bde:	08 f0       	brcs	.+2      	; 0x5be2 <CheckBJTorEnhModeMOSFET+0x1f8>
    5be0:	59 c0       	rjmp	.+178    	; 0x5c94 <CheckBJTorEnhModeMOSFET+0x2aa>
     *  while an IGBT acts more like a diode. So we measure the voltage drop
     *  across the conducting path. A MOSFET got a low voltage drop based on
     *  it's R_DS_on and the current. An IGBT got a much higher voltage drop.
     */

    I_CE0= ReadU(Probes.Pin_1) - ReadU(Probes.Pin_2);
    5be2:	cf e8       	ldi	r28, 0x8F	; 143
    5be4:	d1 e0       	ldi	r29, 0x01	; 1
    5be6:	88 81       	ld	r24, Y
    5be8:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    5bec:	7c 01       	movw	r14, r24
    5bee:	89 81       	ldd	r24, Y+1	; 0x01
    5bf0:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    5bf4:	e7 01       	movw	r28, r14
    5bf6:	c8 1b       	sub	r28, r24
    5bf8:	d9 0b       	sbc	r29, r25

    if (I_CE0 < 250)          /* MOSFET */
    5bfa:	ca 3f       	cpi	r28, 0xFA	; 250
    5bfc:	d1 05       	cpc	r29, r1
    5bfe:	88 f4       	brcc	.+34     	; 0x5c22 <CheckBJTorEnhModeMOSFET+0x238>
    {
      Check.Found = COMP_FET;
    5c00:	e8 e0       	ldi	r30, 0x08	; 8
    5c02:	f1 e0       	ldi	r31, 0x01	; 1
    5c04:	86 e1       	ldi	r24, 0x16	; 22
    5c06:	81 83       	std	Z+1, r24	; 0x01
      Check.Type = FET_Type | TYPE_ENHANCEMENT | TYPE_MOSFET;
    5c08:	80 2f       	mov	r24, r16
    5c0a:	84 61       	ori	r24, 0x14	; 20
    5c0c:	82 83       	std	Z+2, r24	; 0x02

      #ifdef SW_SYMBOLS
      if (FET_Type == TYPE_N_CHANNEL)        /* n-channel */
    5c0e:	01 30       	cpi	r16, 0x01	; 1
    5c10:	21 f4       	brne	.+8      	; 0x5c1a <CheckBJTorEnhModeMOSFET+0x230>
      {
        Check.Symbol = SYMBOL_MOSFET_ENH_N;  /* set symbol ID */
    5c12:	82 e0       	ldi	r24, 0x02	; 2
    5c14:	80 93 10 01 	sts	0x0110, r24
    5c18:	15 c0       	rjmp	.+42     	; 0x5c44 <CheckBJTorEnhModeMOSFET+0x25a>
      }
      else                                   /* p-channel */
      {
        Check.Symbol = SYMBOL_MOSFET_ENH_P;  /* set symbol ID */
    5c1a:	83 e0       	ldi	r24, 0x03	; 3
    5c1c:	80 93 10 01 	sts	0x0110, r24
    5c20:	25 c0       	rjmp	.+74     	; 0x5c6c <CheckBJTorEnhModeMOSFET+0x282>
      }
      #endif
    }
    else                      /* IGBT */
    {
      Check.Found = COMP_IGBT;
    5c22:	e8 e0       	ldi	r30, 0x08	; 8
    5c24:	f1 e0       	ldi	r31, 0x01	; 1
    5c26:	87 e1       	ldi	r24, 0x17	; 23
    5c28:	81 83       	std	Z+1, r24	; 0x01
      Check.Type = FET_Type | TYPE_ENHANCEMENT;
    5c2a:	80 2f       	mov	r24, r16
    5c2c:	84 60       	ori	r24, 0x04	; 4
    5c2e:	82 83       	std	Z+2, r24	; 0x02

      #ifdef SW_SYMBOLS
      if (FET_Type == TYPE_N_CHANNEL)        /* n-channel */
    5c30:	01 30       	cpi	r16, 0x01	; 1
    5c32:	21 f4       	brne	.+8      	; 0x5c3c <CheckBJTorEnhModeMOSFET+0x252>
      {
        Check.Symbol = SYMBOL_IGBT_ENH_N;    /* set symbol ID */
    5c34:	88 e0       	ldi	r24, 0x08	; 8
    5c36:	80 93 10 01 	sts	0x0110, r24
    5c3a:	04 c0       	rjmp	.+8      	; 0x5c44 <CheckBJTorEnhModeMOSFET+0x25a>
      }
      else                                   /* p-channel */
      {
        Check.Symbol = SYMBOL_IGBT_ENH_P;    /* set symbol ID */
    5c3c:	89 e0       	ldi	r24, 0x09	; 9
    5c3e:	80 93 10 01 	sts	0x0110, r24
    5c42:	14 c0       	rjmp	.+40     	; 0x5c6c <CheckBJTorEnhModeMOSFET+0x282>
      }
      #endif
    }

    Check.Done = 1;           /* transistor found */
    5c44:	81 e0       	ldi	r24, 0x01	; 1
    5c46:	80 93 08 01 	sts	0x0108, r24

    /* measure gate threshold voltage */
    GetGateThreshold(FET_Type);
    5c4a:	80 2f       	mov	r24, r16
    5c4c:	0e 94 67 2a 	call	0x54ce	; 0x54ce <GetGateThreshold>

    /* save data */
    Semi.A = Probes.Pin_3;          /* gate pin */
    5c50:	e1 e8       	ldi	r30, 0x81	; 129
    5c52:	f1 e0       	ldi	r31, 0x01	; 1
    5c54:	af e8       	ldi	r26, 0x8F	; 143
    5c56:	b1 e0       	ldi	r27, 0x01	; 1
    5c58:	12 96       	adiw	r26, 0x02	; 2
    5c5a:	8c 91       	ld	r24, X
    5c5c:	12 97       	sbiw	r26, 0x02	; 2
    5c5e:	80 83       	st	Z, r24

    if (FET_Type == TYPE_N_CHANNEL)     /* n-channel */
    {
      Semi.B = Probes.Pin_1;       /* drain pin */
    5c60:	8c 91       	ld	r24, X
    5c62:	81 83       	std	Z+1, r24	; 0x01
      Semi.C = Probes.Pin_2;       /* source pin */
    5c64:	11 96       	adiw	r26, 0x01	; 1
    5c66:	8c 91       	ld	r24, X
    5c68:	82 83       	std	Z+2, r24	; 0x02
    5c6a:	14 c0       	rjmp	.+40     	; 0x5c94 <CheckBJTorEnhModeMOSFET+0x2aa>
        Check.Symbol = SYMBOL_IGBT_ENH_P;    /* set symbol ID */
      }
      #endif
    }

    Check.Done = 1;           /* transistor found */
    5c6c:	81 e0       	ldi	r24, 0x01	; 1
    5c6e:	80 93 08 01 	sts	0x0108, r24

    /* measure gate threshold voltage */
    GetGateThreshold(FET_Type);
    5c72:	80 2f       	mov	r24, r16
    5c74:	0e 94 67 2a 	call	0x54ce	; 0x54ce <GetGateThreshold>

    /* save data */
    Semi.A = Probes.Pin_3;          /* gate pin */
    5c78:	e1 e8       	ldi	r30, 0x81	; 129
    5c7a:	f1 e0       	ldi	r31, 0x01	; 1
    5c7c:	af e8       	ldi	r26, 0x8F	; 143
    5c7e:	b1 e0       	ldi	r27, 0x01	; 1
    5c80:	12 96       	adiw	r26, 0x02	; 2
    5c82:	8c 91       	ld	r24, X
    5c84:	12 97       	sbiw	r26, 0x02	; 2
    5c86:	80 83       	st	Z, r24
      Semi.B = Probes.Pin_1;       /* drain pin */
      Semi.C = Probes.Pin_2;       /* source pin */
    }
    else                                /* p-channel */
    {
      Semi.B = Probes.Pin_2;       /* drain pin */
    5c88:	11 96       	adiw	r26, 0x01	; 1
    5c8a:	8c 91       	ld	r24, X
    5c8c:	11 97       	sbiw	r26, 0x01	; 1
    5c8e:	81 83       	std	Z+1, r24	; 0x01
      Semi.C = Probes.Pin_1;       /* source pin */
    5c90:	8c 91       	ld	r24, X
    5c92:	82 83       	std	Z+2, r24	; 0x02
    }
  }
}
    5c94:	df 91       	pop	r29
    5c96:	cf 91       	pop	r28
    5c98:	1f 91       	pop	r17
    5c9a:	0f 91       	pop	r16
    5c9c:	ff 90       	pop	r15
    5c9e:	ef 90       	pop	r14
    5ca0:	df 90       	pop	r13
    5ca2:	cf 90       	pop	r12
    5ca4:	bf 90       	pop	r11
    5ca6:	af 90       	pop	r10
    5ca8:	9f 90       	pop	r9
    5caa:	8f 90       	pop	r8
    5cac:	08 95       	ret

00005cae <CheckDepletionModeFET>:
 *  requires:
 *  - voltage across Rl in pull-down mode
 */

void CheckDepletionModeFET(void)
{
    5cae:	cf 92       	push	r12
    5cb0:	df 92       	push	r13
    5cb2:	ef 92       	push	r14
    5cb4:	ff 92       	push	r15
    5cb6:	0f 93       	push	r16
    5cb8:	1f 93       	push	r17
    5cba:	cf 93       	push	r28
    5cbc:	df 93       	push	r29
  /*
   *  check if we got a n-channel JFET or depletion-mode MOSFET
   *  - JFETs are depletion-mode only
   */

  if (Check.Done == 0)        /* no transistor found yet */
    5cbe:	80 91 08 01 	lds	r24, 0x0108
    5cc2:	81 11       	cpse	r24, r1
    5cc4:	d9 c0       	rjmp	.+434    	; 0x5e78 <CheckDepletionModeFET+0x1ca>
  {
    /* we assume: probe-1 = D / probe-2 = S / probe-3 = G */
    /* probes already set to: Gnd -- Rl -- probe-2 / probe-1 -- Vcc */
    R_DDR = Probes.Rl_2 | Probes.Rh_3;  /* pull down gate via Rh */
    5cc6:	cf e8       	ldi	r28, 0x8F	; 143
    5cc8:	d1 e0       	ldi	r29, 0x01	; 1
    5cca:	98 85       	ldd	r25, Y+8	; 0x08
    5ccc:	8d 81       	ldd	r24, Y+5	; 0x05
    5cce:	89 2b       	or	r24, r25
    5cd0:	84 b9       	out	0x04, r24	; 4
    U_1 = ReadU_20ms(Probes.Pin_2);     /* voltage at source */
    5cd2:	89 81       	ldd	r24, Y+1	; 0x01
    5cd4:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>
    5cd8:	8c 01       	movw	r16, r24

    R_PORT = Probes.Rh_3;               /* pull up gate via Rh */
    5cda:	88 85       	ldd	r24, Y+8	; 0x08
    5cdc:	85 b9       	out	0x05, r24	; 5
    U_2 = ReadU_20ms(Probes.Pin_2);     /* voltage at source */
    5cde:	89 81       	ldd	r24, Y+1	; 0x01
    5ce0:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>
    Diff_1 = U_2 - U_1;                 /* source voltage difference */
    5ce4:	ec 01       	movw	r28, r24
    5ce6:	c0 1b       	sub	r28, r16
    5ce8:	d1 0b       	sbc	r29, r17
     *  voltage vs. connected to ground we got a depletion-mode n-channel FET.
     *  The source resistor creates a voltage offset based on the current
     *  causing V_GS to become negative with the gate pulled down.
     */

    if (U_2 > (U_1 + 488))
    5cea:	08 51       	subi	r16, 0x18	; 24
    5cec:	1e 4f       	sbci	r17, 0xFE	; 254
    5cee:	08 17       	cp	r16, r24
    5cf0:	19 07       	cpc	r17, r25
    5cf2:	08 f0       	brcs	.+2      	; 0x5cf6 <CheckDepletionModeFET+0x48>
    5cf4:	b7 c0       	rjmp	.+366    	; 0x5e64 <CheckDepletionModeFET+0x1b6>
       *  - to detect drain and source of MOSFET
       */

      /* we simulate: probe-1 = S / probe-2 = D / probe-3 = G */
      /* set probes: Gnd -- Rl -- probe-1 / probe-2 -- Vcc */
      ADC_PORT = Probes.ADC_2;               /* set ADC port to high */
    5cf6:	0f 2e       	mov	r0, r31
    5cf8:	ff e8       	ldi	r31, 0x8F	; 143
    5cfa:	ef 2e       	mov	r14, r31
    5cfc:	f1 e0       	ldi	r31, 0x01	; 1
    5cfe:	ff 2e       	mov	r15, r31
    5d00:	f0 2d       	mov	r31, r0
    5d02:	f7 01       	movw	r30, r14
    5d04:	82 85       	ldd	r24, Z+10	; 0x0a
    5d06:	88 b9       	out	0x08, r24	; 8
      ADC_DDR = Probes.ADC_2;                /* pull up drain directly */
    5d08:	87 b9       	out	0x07, r24	; 7
      R_DDR = Probes.Rl_1 | Probes.Rh_3;     /* enable Rl for source and Rh for gate */
    5d0a:	90 85       	ldd	r25, Z+8	; 0x08
    5d0c:	83 81       	ldd	r24, Z+3	; 0x03
    5d0e:	89 2b       	or	r24, r25
    5d10:	84 b9       	out	0x04, r24	; 4
      R_PORT = 0;                            /* pull down source via Rl / pull down gate via Rh */
    5d12:	15 b8       	out	0x05, r1	; 5
      U_1 = ReadU_20ms(Probes.Pin_1);        /* voltage at source */
    5d14:	80 81       	ld	r24, Z
    5d16:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>
    5d1a:	8c 01       	movw	r16, r24

      R_PORT = Probes.Rh_3;                  /* pull up gate via Rh */
    5d1c:	f7 01       	movw	r30, r14
    5d1e:	80 85       	ldd	r24, Z+8	; 0x08
    5d20:	85 b9       	out	0x05, r24	; 5
      U_2 = ReadU_20ms(Probes.Pin_1);        /* voltage at source */
    5d22:	80 81       	ld	r24, Z
    5d24:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>
      Diff_2 = U_2 - U_1;                    /* source voltage difference */
    5d28:	80 1b       	sub	r24, r16
    5d2a:	91 0b       	sbc	r25, r17
    5d2c:	8c 01       	movw	r16, r24
      /*
       *  Compare gate voltages to distinguish JFET from MOSFET
       */

      /* set probes: Gnd -- probe-2 / probe-1 -- Rl -- Vcc */
      ADC_PORT = 0;                          /* set ADC port to low */
    5d2e:	18 b8       	out	0x08, r1	; 8
      ADC_DDR = Probes.ADC_2;                /* pull down source directly */
    5d30:	f7 01       	movw	r30, r14
    5d32:	82 85       	ldd	r24, Z+10	; 0x0a
    5d34:	87 b9       	out	0x07, r24	; 7
      R_DDR = Probes.Rl_1 | Probes.Rh_3;     /* enable Rl for probe-1 & Rh for probe-3 */
    5d36:	90 85       	ldd	r25, Z+8	; 0x08
    5d38:	83 81       	ldd	r24, Z+3	; 0x03
    5d3a:	89 2b       	or	r24, r25
    5d3c:	84 b9       	out	0x04, r24	; 4
      R_PORT = Probes.Rl_1 | Probes.Rh_3;    /* pull up drain via Rl / pull up gate via Rh */
    5d3e:	85 b9       	out	0x05, r24	; 5

      U_1 = ReadU_20ms(Probes.Pin_3);        /* get voltage at gate */
    5d40:	82 81       	ldd	r24, Z+2	; 0x02
    5d42:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>

      if (U_1 > 3911)              /* MOSFET */
    5d46:	88 34       	cpi	r24, 0x48	; 72
    5d48:	9f 40       	sbci	r25, 0x0F	; 15
    5d4a:	38 f0       	brcs	.+14     	; 0x5d5a <CheckDepletionModeFET+0xac>
      {
        /* n channel depletion-mode MOSFET */ 
        Check.Type = TYPE_N_CHANNEL | TYPE_DEPLETION | TYPE_MOSFET;
    5d4c:	e8 e0       	ldi	r30, 0x08	; 8
    5d4e:	f1 e0       	ldi	r31, 0x01	; 1
    5d50:	89 e1       	ldi	r24, 0x19	; 25
    5d52:	82 83       	std	Z+2, r24	; 0x02
        #ifdef SW_SYMBOLS
        Check.Symbol = SYMBOL_MOSFET_DEP_N;  /* set symbol ID */
    5d54:	84 e0       	ldi	r24, 0x04	; 4
    5d56:	80 87       	std	Z+8, r24	; 0x08
    5d58:	4a c0       	rjmp	.+148    	; 0x5dee <CheckDepletionModeFET+0x140>
        #endif
      }
      else                         /* JFET */
      {
        /* n channel JFET (depletion-mode only) */
        Check.Type = TYPE_N_CHANNEL | TYPE_DEPLETION | TYPE_JFET;
    5d5a:	e8 e0       	ldi	r30, 0x08	; 8
    5d5c:	f1 e0       	ldi	r31, 0x01	; 1
    5d5e:	89 e2       	ldi	r24, 0x29	; 41
    5d60:	82 83       	std	Z+2, r24	; 0x02
        #ifdef SW_SYMBOLS
        Check.Symbol = SYMBOL_JFET_N;        /* set symbol ID */
    5d62:	86 e0       	ldi	r24, 0x06	; 6
    5d64:	80 87       	std	Z+8, r24	; 0x08
    5d66:	43 c0       	rjmp	.+134    	; 0x5dee <CheckDepletionModeFET+0x140>

  if ((Check.Done == 0) && (Flag == 0))      /* no transistor found yet */
  {
    /* we assume: probe-1 = S / probe-2 = D / probe-3 = G */
    /* set probes: Gnd -- probe-2 / probe-1 -- Rl -- Vcc */
    ADC_PORT = 0;                       /* set ADC port to Gnd */
    5d68:	18 b8       	out	0x08, r1	; 8
    ADC_DDR = Probes.ADC_2;             /* pull down drain directly */
    5d6a:	cf e8       	ldi	r28, 0x8F	; 143
    5d6c:	d1 e0       	ldi	r29, 0x01	; 1
    5d6e:	8a 85       	ldd	r24, Y+10	; 0x0a
    5d70:	87 b9       	out	0x07, r24	; 7
    R_DDR = Probes.Rl_1 | Probes.Rh_3;  /* enable Rl for probe-1 & Rh for probe-3 */
    5d72:	98 85       	ldd	r25, Y+8	; 0x08
    5d74:	8b 81       	ldd	r24, Y+3	; 0x03
    5d76:	89 2b       	or	r24, r25
    5d78:	84 b9       	out	0x04, r24	; 4
    R_PORT = Probes.Rl_1 | Probes.Rh_3; /* pull up source via Rl / pull up gate via Rh */
    5d7a:	85 b9       	out	0x05, r24	; 5
    U_1 = ReadU_20ms(Probes.Pin_1);     /* get voltage at source */
    5d7c:	88 81       	ld	r24, Y
    5d7e:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>
    5d82:	6c 01       	movw	r12, r24

    R_PORT = Probes.Rl_1;               /* pull down gate via Rh */
    5d84:	8b 81       	ldd	r24, Y+3	; 0x03
    5d86:	85 b9       	out	0x05, r24	; 5
    U_2 = ReadU_20ms(Probes.Pin_1);     /* get voltage at source */
    5d88:	88 81       	ld	r24, Y
    5d8a:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>
    5d8e:	7c 01       	movw	r14, r24
     *  voltage vs. connected to ground we got a depletion-mode p-channel FET.
     *  The source resistor creates a voltage offset based on the current
     *  causing V_GS to become positive with the gate pulled up.
     */

    if (U_1 > (U_2 + 488))
    5d90:	88 51       	subi	r24, 0x18	; 24
    5d92:	9e 4f       	sbci	r25, 0xFE	; 254
    5d94:	8c 15       	cp	r24, r12
    5d96:	9d 05       	cpc	r25, r13
    5d98:	08 f0       	brcs	.+2      	; 0x5d9c <CheckDepletionModeFET+0xee>
    5d9a:	6e c0       	rjmp	.+220    	; 0x5e78 <CheckDepletionModeFET+0x1ca>
       *  - to detect drain and source of MOSFET
       */

      /* we simulate: probe-1 = D / probe-2 = S / probe-3 = G */
      /* set probes: Gnd -- probe-1 / probe-2 -- Rl -- Vcc */
      ADC_DDR = Probes.ADC_1;             /* pull down drain directly */
    5d9c:	89 85       	ldd	r24, Y+9	; 0x09
    5d9e:	87 b9       	out	0x07, r24	; 7
      R_DDR = Probes.Rl_2 | Probes.Rh_3;  /* enable Rl for probe-2 & Rh for probe-3 */
    5da0:	98 85       	ldd	r25, Y+8	; 0x08
    5da2:	8d 81       	ldd	r24, Y+5	; 0x05
    5da4:	89 2b       	or	r24, r25
    5da6:	84 b9       	out	0x04, r24	; 4
      R_PORT = Probes.Rl_2 | Probes.Rh_3; /* pull up source via Rl / pull up gate via Rh */
    5da8:	85 b9       	out	0x05, r24	; 5
      U_1 = ReadU_20ms(Probes.Pin_2);     /* get voltage at source */
    5daa:	89 81       	ldd	r24, Y+1	; 0x01
    5dac:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>
    5db0:	8c 01       	movw	r16, r24

      R_PORT = Probes.Rl_2;               /* pull down gate via Rh */
    5db2:	8d 81       	ldd	r24, Y+5	; 0x05
    5db4:	85 b9       	out	0x05, r24	; 5
      U_2 = ReadU_20ms(Probes.Pin_2);     /* get voltage at source */
    5db6:	89 81       	ldd	r24, Y+1	; 0x01
    5db8:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>
      Diff_2 = U_1 - U_2;                 /* source voltage difference */
    5dbc:	08 1b       	sub	r16, r24
    5dbe:	19 0b       	sbc	r17, r25
      /*
       *  Compare gate voltages to distinguish JFET from MOSFET
       */

      /* set probes: probe-2 = HiZ / probe-1 -- Vcc */
      ADC_PORT = Probes.ADC_1;          /* pull up source directly */
    5dc0:	89 85       	ldd	r24, Y+9	; 0x09
    5dc2:	88 b9       	out	0x08, r24	; 8
      ADC_DDR = Probes.ADC_1;           /* enable pull up for source */
    5dc4:	87 b9       	out	0x07, r24	; 7
      /* gate is still pulled down via Rh */
      U_1 = ReadU_20ms(Probes.Pin_3);   /* get voltage at gate */
    5dc6:	8a 81       	ldd	r24, Y+2	; 0x02
    5dc8:	0e 94 09 05 	call	0xa12	; 0xa12 <ReadU_20ms>

      if (U_1 < 977)               /* MOSFET */
    5dcc:	81 3d       	cpi	r24, 0xD1	; 209
    5dce:	93 40       	sbci	r25, 0x03	; 3
    5dd0:	38 f4       	brcc	.+14     	; 0x5de0 <CheckDepletionModeFET+0x132>
      {
        /* p-channel depletion-mode MOSFET */ 
        Check.Type =  TYPE_P_CHANNEL | TYPE_DEPLETION | TYPE_MOSFET;
    5dd2:	e8 e0       	ldi	r30, 0x08	; 8
    5dd4:	f1 e0       	ldi	r31, 0x01	; 1
    5dd6:	8a e1       	ldi	r24, 0x1A	; 26
    5dd8:	82 83       	std	Z+2, r24	; 0x02
        #ifdef SW_SYMBOLS
        Check.Symbol = SYMBOL_MOSFET_DEP_P;  /* set symbol ID */
    5dda:	85 e0       	ldi	r24, 0x05	; 5
    5ddc:	80 87       	std	Z+8, r24	; 0x08
    5dde:	48 c0       	rjmp	.+144    	; 0x5e70 <CheckDepletionModeFET+0x1c2>
        #endif
      }
      else                         /* JFET */
      {
        /* p-channel JFET (depletion-mode only) */
        Check.Type = TYPE_P_CHANNEL | TYPE_DEPLETION | TYPE_JFET;
    5de0:	e8 e0       	ldi	r30, 0x08	; 8
    5de2:	f1 e0       	ldi	r31, 0x01	; 1
    5de4:	8a e2       	ldi	r24, 0x2A	; 42
    5de6:	82 83       	std	Z+2, r24	; 0x02
        #ifdef SW_SYMBOLS
        Check.Symbol = SYMBOL_JFET_P;        /* set symbol ID */
    5de8:	87 e0       	ldi	r24, 0x07	; 7
    5dea:	80 87       	std	Z+8, r24	; 0x08
    5dec:	41 c0       	rjmp	.+130    	; 0x5e70 <CheckDepletionModeFET+0x1c2>
   */

  if (Flag == 1)         /* found depletion-mode FET */
  {
    /* common stuff */
    Check.Found = COMP_FET;
    5dee:	e8 e0       	ldi	r30, 0x08	; 8
    5df0:	f1 e0       	ldi	r31, 0x01	; 1
    5df2:	86 e1       	ldi	r24, 0x16	; 22
    5df4:	81 83       	std	Z+1, r24	; 0x01
    Check.Done = 1;
    5df6:	81 e0       	ldi	r24, 0x01	; 1
    5df8:	80 83       	st	Z, r24
    Semi.A = Probes.Pin_3;         /* gate pin */
    5dfa:	80 91 91 01 	lds	r24, 0x0191
    5dfe:	80 93 81 01 	sts	0x0181, r24
    /*
     *  drain & source pinout
     *  - larger voltage difference wins
     */

    if (Diff_1 > Diff_2)      /* drain and source as assumed */
    5e02:	0c 17       	cp	r16, r28
    5e04:	1d 07       	cpc	r17, r29
    5e06:	50 f4       	brcc	.+20     	; 0x5e1c <CheckDepletionModeFET+0x16e>
    {
      Semi.B = Probes.Pin_1;       /* drain pin */
    5e08:	e1 e8       	ldi	r30, 0x81	; 129
    5e0a:	f1 e0       	ldi	r31, 0x01	; 1
    5e0c:	af e8       	ldi	r26, 0x8F	; 143
    5e0e:	b1 e0       	ldi	r27, 0x01	; 1
    5e10:	8c 91       	ld	r24, X
    5e12:	81 83       	std	Z+1, r24	; 0x01
      Semi.C = Probes.Pin_2;       /* source pin */
    5e14:	11 96       	adiw	r26, 0x01	; 1
    5e16:	8c 91       	ld	r24, X
    5e18:	82 83       	std	Z+2, r24	; 0x02
    5e1a:	0a c0       	rjmp	.+20     	; 0x5e30 <CheckDepletionModeFET+0x182>
    }
    else                      /* drain and source reversed */
    {
      Semi.B = Probes.Pin_2;       /* drain pin */
    5e1c:	e1 e8       	ldi	r30, 0x81	; 129
    5e1e:	f1 e0       	ldi	r31, 0x01	; 1
    5e20:	af e8       	ldi	r26, 0x8F	; 143
    5e22:	b1 e0       	ldi	r27, 0x01	; 1
    5e24:	11 96       	adiw	r26, 0x01	; 1
    5e26:	8c 91       	ld	r24, X
    5e28:	11 97       	sbiw	r26, 0x01	; 1
    5e2a:	81 83       	std	Z+1, r24	; 0x01
      Semi.C = Probes.Pin_1;       /* source pin */
    5e2c:	8c 91       	ld	r24, X
    5e2e:	82 83       	std	Z+2, r24	; 0x02
     *  drain & source symmetry
     *  - if both voltage differences are about the same we got a
     *    symmetrical FET
     */

    U_2 = Diff_1 / 50;             /* 2% of Diff_1 */
    5e30:	9e 01       	movw	r18, r28
    5e32:	36 95       	lsr	r19
    5e34:	27 95       	ror	r18
    5e36:	ab e7       	ldi	r26, 0x7B	; 123
    5e38:	b4 e1       	ldi	r27, 0x14	; 20
    5e3a:	0e 94 cd 36 	call	0x6d9a	; 0x6d9a <__umulhisi3>
    5e3e:	96 95       	lsr	r25
    5e40:	87 95       	ror	r24
    U_1 = Diff_1 - U_2;            /* 98% */
    5e42:	9e 01       	movw	r18, r28
    5e44:	28 1b       	sub	r18, r24
    5e46:	39 0b       	sbc	r19, r25
    U_2 += Diff_1;                 /* 102% */
    if ((Diff_2 >= U_1) && (Diff_2 <= U_2))
    5e48:	02 17       	cp	r16, r18
    5e4a:	13 07       	cpc	r17, r19
    5e4c:	a8 f0       	brcs	.+42     	; 0x5e78 <CheckDepletionModeFET+0x1ca>
     *    symmetrical FET
     */

    U_2 = Diff_1 / 50;             /* 2% of Diff_1 */
    U_1 = Diff_1 - U_2;            /* 98% */
    U_2 += Diff_1;                 /* 102% */
    5e4e:	c8 0f       	add	r28, r24
    5e50:	d9 1f       	adc	r29, r25
    if ((Diff_2 >= U_1) && (Diff_2 <= U_2))
    5e52:	c0 17       	cp	r28, r16
    5e54:	d1 07       	cpc	r29, r17
    5e56:	80 f0       	brcs	.+32     	; 0x5e78 <CheckDepletionModeFET+0x1ca>
    {
      Check.Type |= TYPE_SYMMETRICAL; 
    5e58:	e8 e0       	ldi	r30, 0x08	; 8
    5e5a:	f1 e0       	ldi	r31, 0x01	; 1
    5e5c:	82 81       	ldd	r24, Z+2	; 0x02
    5e5e:	80 64       	ori	r24, 0x40	; 64
    5e60:	82 83       	std	Z+2, r24	; 0x02
    5e62:	0a c0       	rjmp	.+20     	; 0x5e78 <CheckDepletionModeFET+0x1ca>
  /*
   *  check if we got a p-channel JFET or depletion-mode MOSFET
   *  - JFETs are depletion-mode only
   */

  if ((Check.Done == 0) && (Flag == 0))      /* no transistor found yet */
    5e64:	80 91 08 01 	lds	r24, 0x0108
    5e68:	88 23       	and	r24, r24
    5e6a:	09 f4       	brne	.+2      	; 0x5e6e <CheckDepletionModeFET+0x1c0>
    5e6c:	7d cf       	rjmp	.-262    	; 0x5d68 <CheckDepletionModeFET+0xba>
    5e6e:	04 c0       	rjmp	.+8      	; 0x5e78 <CheckDepletionModeFET+0x1ca>
    R_PORT = Probes.Rl_1 | Probes.Rh_3; /* pull up source via Rl / pull up gate via Rh */
    U_1 = ReadU_20ms(Probes.Pin_1);     /* get voltage at source */

    R_PORT = Probes.Rl_1;               /* pull down gate via Rh */
    U_2 = ReadU_20ms(Probes.Pin_1);     /* get voltage at source */
    Diff_1 = U_1 - U_2;                 /* source voltage difference */
    5e70:	e6 01       	movw	r28, r12
    5e72:	ce 19       	sub	r28, r14
    5e74:	df 09       	sbc	r29, r15
    5e76:	bb cf       	rjmp	.-138    	; 0x5dee <CheckDepletionModeFET+0x140>
    if ((Diff_2 >= U_1) && (Diff_2 <= U_2))
    {
      Check.Type |= TYPE_SYMMETRICAL; 
    }
  }
}
    5e78:	df 91       	pop	r29
    5e7a:	cf 91       	pop	r28
    5e7c:	1f 91       	pop	r17
    5e7e:	0f 91       	pop	r16
    5e80:	ff 90       	pop	r15
    5e82:	ef 90       	pop	r14
    5e84:	df 90       	pop	r13
    5e86:	cf 90       	pop	r12
    5e88:	08 95       	ret

00005e8a <CheckThyristorTriac>:
 *  - 1 if component was found
 *  - 0 if component wasn't found
 */

uint8_t CheckThyristorTriac(void)
{
    5e8a:	cf 92       	push	r12
    5e8c:	df 92       	push	r13
    5e8e:	ef 92       	push	r14
    5e90:	ff 92       	push	r15
    5e92:	0f 93       	push	r16
    5e94:	1f 93       	push	r17
    5e96:	cf 93       	push	r28
    5e98:	df 93       	push	r29

  /* we assume: probe-1 = A / probe-2 = C / probe-3 = G for a SCR */
  /*            probe-1 = MT2 / probe-2 = MT1 / probe-3 = G for a triac */  

  /* V_GT (gate trigger voltage) */
  U_1 = ReadU(Probes.Pin_3);            /* voltage at gate */
    5e9a:	cf e8       	ldi	r28, 0x8F	; 143
    5e9c:	d1 e0       	ldi	r29, 0x01	; 1
    5e9e:	8a 81       	ldd	r24, Y+2	; 0x02
    5ea0:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    5ea4:	7c 01       	movw	r14, r24
  U_2 = ReadU(Probes.Pin_2);            /* voltage at cathode */
    5ea6:	89 81       	ldd	r24, Y+1	; 0x01
    5ea8:	0e 94 6c 04 	call	0x8d8	; 0x8d8 <ReadU>
    5eac:	6c 01       	movw	r12, r24
  V_GT = U_1 - U_2;                     /* = Ug - Uc */

  /* discharge gate and check load current */
  PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLDOWN);    /* discharge gate */
    5eae:	60 e1       	ldi	r22, 0x10	; 16
    5eb0:	8f 81       	ldd	r24, Y+7	; 0x07
    5eb2:	0e 94 6b 24 	call	0x48d6	; 0x48d6 <PullProbe>
  U_1 = ReadU_5ms(Probes.Pin_1);        /* get voltage at anode */
    5eb6:	88 81       	ld	r24, Y
    5eb8:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
    5ebc:	8c 01       	movw	r16, r24

  /* simulate short loss of current and check load current again */ 
  R_PORT = 0;                           /* pull down anode */
    5ebe:	15 b8       	out	0x05, r1	; 5
    5ec0:	8f e1       	ldi	r24, 0x1F	; 31
    5ec2:	9e e4       	ldi	r25, 0x4E	; 78
    5ec4:	01 97       	sbiw	r24, 0x01	; 1
    5ec6:	f1 f7       	brne	.-4      	; 0x5ec4 <CheckThyristorTriac+0x3a>
    5ec8:	00 c0       	rjmp	.+0      	; 0x5eca <CheckThyristorTriac+0x40>
    5eca:	00 00       	nop
  _delay_ms(5);
  R_PORT = Probes.Rl_1;                 /* and pull up anode again */
    5ecc:	9b 81       	ldd	r25, Y+3	; 0x03
    5ece:	95 b9       	out	0x05, r25	; 5
  U_2 = ReadU_5ms(Probes.Pin_1);        /* get voltage at anode (below Rl) */
    5ed0:	88 81       	ld	r24, Y
    5ed2:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>

  /* voltages at anode match behaviour of thyristor or triac */
  if ((U_1 < 1600) && (U_2 > 4400))
    5ed6:	00 34       	cpi	r16, 0x40	; 64
    5ed8:	16 40       	sbci	r17, 0x06	; 6
    5eda:	08 f0       	brcs	.+2      	; 0x5ede <CheckThyristorTriac+0x54>
    5edc:	56 c0       	rjmp	.+172    	; 0x5f8a <CheckThyristorTriac+0x100>
    5ede:	81 33       	cpi	r24, 0x31	; 49
    5ee0:	91 41       	sbci	r25, 0x11	; 17
    5ee2:	08 f4       	brcc	.+2      	; 0x5ee6 <CheckThyristorTriac+0x5c>
    5ee4:	54 c0       	rjmp	.+168    	; 0x5f8e <CheckThyristorTriac+0x104>
     *  A thyrister shouldn't conduct but a triac should (Q3 operation mode).
     */

    /* reverse Anode and Cathode (MT2 and MT1) */
    /* set probes: Gnd -- probe-1 / probe-2 -- Rl -- Vcc  */
    R_DDR = 0;                          /* disable all probe resistors */
    5ee6:	14 b8       	out	0x04, r1	; 4
    R_PORT = 0;
    5ee8:	15 b8       	out	0x05, r1	; 5
    ADC_PORT = Probes.ADC_2;            /* pull up Cathode directly */
    5eea:	8a 85       	ldd	r24, Y+10	; 0x0a
    5eec:	88 b9       	out	0x08, r24	; 8
    5eee:	8f e1       	ldi	r24, 0x1F	; 31
    5ef0:	9e e4       	ldi	r25, 0x4E	; 78
    5ef2:	01 97       	sbiw	r24, 0x01	; 1
    5ef4:	f1 f7       	brne	.-4      	; 0x5ef2 <CheckThyristorTriac+0x68>
    5ef6:	00 c0       	rjmp	.+0      	; 0x5ef8 <CheckThyristorTriac+0x6e>
    5ef8:	00 00       	nop
    _delay_ms(5);
    R_DDR = Probes.Rl_1;                /* pull down Anode via Rl */ 
    5efa:	8b 81       	ldd	r24, Y+3	; 0x03
    5efc:	84 b9       	out	0x04, r24	; 4
    /* probe-3 = gate is in HiZ mode */

    /* check if DUT doesn't conduct */
    U_1 = ReadU_5ms(Probes.Pin_1);      /* get voltage at Anode */
    5efe:	88 81       	ld	r24, Y
    5f00:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>

    if (U_1 <= 244)      /* voltage at Anode is low (no current) */
    5f04:	85 3f       	cpi	r24, 0xF5	; 245
    5f06:	91 05       	cpc	r25, r1
    5f08:	08 f0       	brcs	.+2      	; 0x5f0c <CheckThyristorTriac+0x82>
    5f0a:	43 c0       	rjmp	.+134    	; 0x5f92 <CheckThyristorTriac+0x108>
    {
      /* trigger the gate with a negative current (Triac: Q3) */
      PullProbe(Probes.Rl_3, FLAG_10MS | FLAG_PULLDOWN);
    5f0c:	60 e1       	ldi	r22, 0x10	; 16
    5f0e:	8f 81       	ldd	r24, Y+7	; 0x07
    5f10:	0e 94 6b 24 	call	0x48d6	; 0x48d6 <PullProbe>

      /* check for conduction */
      U_1 = ReadU_5ms(Probes.Pin_1);    /* get voltage at Anode */
    5f14:	88 81       	ld	r24, Y
    5f16:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>
    5f1a:	ec 01       	movw	r28, r24

      if (U_1 < 733)         /* no current -> Thyristor */
    5f1c:	cd 3d       	cpi	r28, 0xDD	; 221
    5f1e:	92 e0       	ldi	r25, 0x02	; 2
    5f20:	d9 07       	cpc	r29, r25
    5f22:	48 f4       	brcc	.+18     	; 0x5f36 <CheckThyristorTriac+0xac>
      {
        Check.Found = COMP_THYRISTOR;   /* we found a Thyristor */
    5f24:	e8 e0       	ldi	r30, 0x08	; 8
    5f26:	f1 e0       	ldi	r31, 0x01	; 1
    5f28:	89 e1       	ldi	r24, 0x19	; 25
    5f2a:	81 83       	std	Z+1, r24	; 0x01
        Check.Done = 1;                 /* detected component */
    5f2c:	81 e0       	ldi	r24, 0x01	; 1
    5f2e:	80 83       	st	Z, r24
        #ifdef SW_SYMBOLS
        Check.Symbol = SYMBOL_SCR;      /* set symbol ID */
    5f30:	8a e0       	ldi	r24, 0x0A	; 10
    5f32:	80 87       	std	Z+8, r24	; 0x08
    5f34:	34 c0       	rjmp	.+104    	; 0x5f9e <CheckThyristorTriac+0x114>
         *  To verify the Triac we stop the current flow for a moment and check
         *  the voltage at MT2 again. The Triac shouldn't conduct anymore,
         */

        /* drop load current for a moment */
        R_PORT = Probes.Rl_1;           /* pull up MT2 via Rl */
    5f36:	ef e8       	ldi	r30, 0x8F	; 143
    5f38:	f1 e0       	ldi	r31, 0x01	; 1
    5f3a:	83 81       	ldd	r24, Z+3	; 0x03
    5f3c:	85 b9       	out	0x05, r24	; 5
    5f3e:	8f e1       	ldi	r24, 0x1F	; 31
    5f40:	9e e4       	ldi	r25, 0x4E	; 78
    5f42:	01 97       	sbiw	r24, 0x01	; 1
    5f44:	f1 f7       	brne	.-4      	; 0x5f42 <CheckThyristorTriac+0xb8>
    5f46:	00 c0       	rjmp	.+0      	; 0x5f48 <CheckThyristorTriac+0xbe>
    5f48:	00 00       	nop
        _delay_ms(5);
        R_PORT = 0;                     /* and pull down MT2 via Rl */
    5f4a:	15 b8       	out	0x05, r1	; 5

        /* and check load current again */
        U_2 = ReadU_5ms(Probes.Pin_1);  /* get voltage at MT2 */
    5f4c:	80 81       	ld	r24, Z
    5f4e:	0e 94 00 05 	call	0xa00	; 0xa00 <ReadU_5ms>

        if (U_2 <= 244)       /* no current */
    5f52:	85 3f       	cpi	r24, 0xF5	; 245
    5f54:	91 05       	cpc	r25, r1
    5f56:	f8 f4       	brcc	.+62     	; 0x5f96 <CheckThyristorTriac+0x10c>
        {
          if (Check.Found == COMP_TRIAC)     /* second test run */
    5f58:	80 91 09 01 	lds	r24, 0x0109
    5f5c:	88 31       	cpi	r24, 0x18	; 24
    5f5e:	19 f4       	brne	.+6      	; 0x5f66 <CheckThyristorTriac+0xdc>
          {
            Check.Done = 1;             /* no more tests needed */
    5f60:	81 e0       	ldi	r24, 0x01	; 1
    5f62:	80 93 08 01 	sts	0x0108, r24
          }

          Check.Found = COMP_TRIAC;     /* found Triac */
    5f66:	e8 e0       	ldi	r30, 0x08	; 8
    5f68:	f1 e0       	ldi	r31, 0x01	; 1
    5f6a:	88 e1       	ldi	r24, 0x18	; 24
    5f6c:	81 83       	std	Z+1, r24	; 0x01
          #ifdef SW_SYMBOLS
          Check.Symbol = SYMBOL_TRIAC;  /* set symbol ID */
    5f6e:	8b e0       	ldi	r24, 0x0B	; 11
    5f70:	80 87       	std	Z+8, r24	; 0x08
           *  through MT2 would be a little bit lower. Another issue is that some
           *  Triacs don't support Q4. So we support up to two test runs and prefer
           *  the one with the higher voltage at MT2.
           */

          if (U_1 > Semi.I_1)      /* first run or higher current */
    5f72:	80 91 88 01 	lds	r24, 0x0188
    5f76:	90 91 89 01 	lds	r25, 0x0189
    5f7a:	8c 17       	cp	r24, r28
    5f7c:	9d 07       	cpc	r25, r29
    5f7e:	68 f4       	brcc	.+26     	; 0x5f9a <CheckThyristorTriac+0x110>
          {
            Semi.I_1 = U_1;        /* update reference value */
    5f80:	d0 93 89 01 	sts	0x0189, r29
    5f84:	c0 93 88 01 	sts	0x0188, r28
    5f88:	0a c0       	rjmp	.+20     	; 0x5f9e <CheckThyristorTriac+0x114>
 *  - 0 if component wasn't found
 */

uint8_t CheckThyristorTriac(void)
{
  uint8_t           Flag = 0;      /* return value */
    5f8a:	80 e0       	ldi	r24, 0x00	; 0
    5f8c:	1a c0       	rjmp	.+52     	; 0x5fc2 <CheckThyristorTriac+0x138>
    5f8e:	80 e0       	ldi	r24, 0x00	; 0
    5f90:	18 c0       	rjmp	.+48     	; 0x5fc2 <CheckThyristorTriac+0x138>
    5f92:	80 e0       	ldi	r24, 0x00	; 0
    5f94:	16 c0       	rjmp	.+44     	; 0x5fc2 <CheckThyristorTriac+0x138>
    5f96:	80 e0       	ldi	r24, 0x00	; 0
    5f98:	14 c0       	rjmp	.+40     	; 0x5fc2 <CheckThyristorTriac+0x138>
            Semi.I_1 = U_1;        /* update reference value */
            Flag = 2;              /* save data and signal success */
          }
          else                     /* wrong pinout */
          {
            Flag = 1;              /* signal success, but don't save data */
    5f9a:	81 e0       	ldi	r24, 0x01	; 1
    5f9c:	12 c0       	rjmp	.+36     	; 0x5fc2 <CheckThyristorTriac+0x138>
  }

  if (Flag == 2)         /* save data and signal success */
  {
    /* save data */
    Semi.A = Probes.Pin_3;    /* Gate pin */
    5f9e:	e1 e8       	ldi	r30, 0x81	; 129
    5fa0:	f1 e0       	ldi	r31, 0x01	; 1
    5fa2:	af e8       	ldi	r26, 0x8F	; 143
    5fa4:	b1 e0       	ldi	r27, 0x01	; 1
    5fa6:	12 96       	adiw	r26, 0x02	; 2
    5fa8:	8c 91       	ld	r24, X
    5faa:	12 97       	sbiw	r26, 0x02	; 2
    5fac:	80 83       	st	Z, r24
    Semi.B = Probes.Pin_1;    /* Anode/MT2 pin */
    5fae:	8c 91       	ld	r24, X
    5fb0:	81 83       	std	Z+1, r24	; 0x01
    Semi.C = Probes.Pin_2;    /* Cathode/MT1 pin */
    5fb2:	11 96       	adiw	r26, 0x01	; 1
    5fb4:	8c 91       	ld	r24, X
    5fb6:	82 83       	std	Z+2, r24	; 0x02
  /*            probe-1 = MT2 / probe-2 = MT1 / probe-3 = G for a triac */  

  /* V_GT (gate trigger voltage) */
  U_1 = ReadU(Probes.Pin_3);            /* voltage at gate */
  U_2 = ReadU(Probes.Pin_2);            /* voltage at cathode */
  V_GT = U_1 - U_2;                     /* = Ug - Uc */
    5fb8:	ec 18       	sub	r14, r12
    5fba:	fd 08       	sbc	r15, r13
  {
    /* save data */
    Semi.A = Probes.Pin_3;    /* Gate pin */
    Semi.B = Probes.Pin_1;    /* Anode/MT2 pin */
    Semi.C = Probes.Pin_2;    /* Cathode/MT1 pin */
    Semi.U_1 = V_GT;          /* gate trigger voltage (in mV) */
    5fbc:	f4 82       	std	Z+4, r15	; 0x04
    5fbe:	e3 82       	std	Z+3, r14	; 0x03

    Flag = 1;                 /* signal success */
    5fc0:	81 e0       	ldi	r24, 0x01	; 1
  }

  return Flag;
}
    5fc2:	df 91       	pop	r29
    5fc4:	cf 91       	pop	r28
    5fc6:	1f 91       	pop	r17
    5fc8:	0f 91       	pop	r16
    5fca:	ff 90       	pop	r15
    5fcc:	ef 90       	pop	r14
    5fce:	df 90       	pop	r13
    5fd0:	cf 90       	pop	r12
    5fd2:	08 95       	ret

00005fd4 <LCD_BusSetup>:
void LCD_BusSetup(void)
{
  /* set port pins to output mode */
  #ifdef LCD_CS
    /* including /CS1 */
    LCD_DDR = LCD_DDR | (1 << LCD_RESET) | (1 << LCD_A0) | (1 << LCD_SCL) | (1 << LCD_SI) | (1 << LCD_CS);
    5fd4:	8a b1       	in	r24, 0x0a	; 10
    5fd6:	8f 62       	ori	r24, 0x2F	; 47
    5fd8:	8a b9       	out	0x0a, r24	; 10
   *  - SCL high
   */

  #ifdef LCD_CS
    /* including /CS1 */
    LCD_PORT = LCD_PORT | (1 << LCD_CS) | (1 << LCD_SCL);
    5fda:	8b b1       	in	r24, 0x0b	; 11
    5fdc:	84 62       	ori	r24, 0x24	; 36
    5fde:	8b b9       	out	0x0b, r24	; 11
    /* excluding /CS1 */
    LCD_PORT = LCD_PORT | (1 << LCD_SCL);
  #endif

  /* disable reset */
  LCD_PORT = LCD_PORT | (1 << LCD_RESET);    /* set /RES high */
    5fe0:	58 9a       	sbi	0x0b, 0	; 11
    5fe2:	08 95       	ret

00005fe4 <LCD_Send>:
{
  uint8_t           n = 8;         /* counter */

  /* select chip, if pin available */
  #ifdef LCD_CS
    LCD_PORT = LCD_PORT & ~(1 << LCD_CS);    /* set /CS1 low */
    5fe4:	5d 98       	cbi	0x0b, 5	; 11
    5fe6:	98 e0       	ldi	r25, 0x08	; 8

  /* bit-bang 8 bits */
  while (n > 0)               /* 8 bits */
  {
    /* get current MSB and set SI */
    if (Byte & 0b10000000)    /* 1 */
    5fe8:	88 23       	and	r24, r24
    5fea:	14 f4       	brge	.+4      	; 0x5ff0 <LCD_Send+0xc>
    {
      /* set SI high */
      LCD_PORT = LCD_PORT | (1 << LCD_SI);
    5fec:	5b 9a       	sbi	0x0b, 3	; 11
    5fee:	01 c0       	rjmp	.+2      	; 0x5ff2 <LCD_Send+0xe>
    }
    else                      /* 0 */
    {
      /* set SI low */
      LCD_PORT = LCD_PORT & ~(1 << LCD_SI);
    5ff0:	5b 98       	cbi	0x0b, 3	; 11
    }

    /* start clock cycle (falling edge) */
    LCD_PORT = LCD_PORT & ~(1 << LCD_SCL);
    5ff2:	5a 98       	cbi	0x0b, 2	; 11

    /* end clock cycle (rising edge takes bit) */
    LCD_PORT = LCD_PORT |(1 << LCD_SCL); 
    5ff4:	5a 9a       	sbi	0x0b, 2	; 11

    Byte <<= 1;               /* shift bits one step left */
    5ff6:	88 0f       	add	r24, r24
    5ff8:	91 50       	subi	r25, 0x01	; 1
  #ifdef LCD_CS
    LCD_PORT = LCD_PORT & ~(1 << LCD_CS);    /* set /CS1 low */
  #endif

  /* bit-bang 8 bits */
  while (n > 0)               /* 8 bits */
    5ffa:	b1 f7       	brne	.-20     	; 0x5fe8 <LCD_Send+0x4>
    n--;                      /* next bit */
  }

  /* deselect chip, if pin available */
  #ifdef LCD_CS
    LCD_PORT = LCD_PORT | (1 << LCD_CS);     /* set /CS1 high */
    5ffc:	5d 9a       	sbi	0x0b, 5	; 11
    5ffe:	08 95       	ret

00006000 <LCD_Cmd>:
 */
 
void LCD_Cmd(uint8_t Cmd)
{
  /* indicate command mode */
  LCD_PORT = LCD_PORT & ~(1 << LCD_A0);      /* set A0 low */
    6000:	59 98       	cbi	0x0b, 1	; 11

  LCD_Send(Cmd);              /* send command */
    6002:	0e 94 f2 2f 	call	0x5fe4	; 0x5fe4 <LCD_Send>
    6006:	08 95       	ret

00006008 <LCD_Data>:
 */

void LCD_Data(uint8_t Data)
{
  /* indicate data mode */
  LCD_PORT = LCD_PORT | (1 << LCD_A0);       /* set A0 high */
    6008:	59 9a       	sbi	0x0b, 1	; 11

  LCD_Send(Data);             /* send data */
    600a:	0e 94 f2 2f 	call	0x5fe4	; 0x5fe4 <LCD_Send>
    600e:	08 95       	ret

00006010 <LCD_Pos>:
 *  - x:  horizontal position (1-)
 *  - y:  vertical position (1-)
 */

void LCD_Pos(uint8_t x, uint8_t y)
{
    6010:	cf 93       	push	r28
    6012:	c8 2f       	mov	r28, r24
  uint8_t           Temp;     /* temp. value */

  /* update UI */
  UI.CharPos_X = x;
    6014:	e6 e2       	ldi	r30, 0x26	; 38
    6016:	f1 e0       	ldi	r31, 0x01	; 1
    6018:	82 83       	std	Z+2, r24	; 0x02
  UI.CharPos_Y = y;
    601a:	63 83       	std	Z+3, r22	; 0x03

  /* vertical position */
  y--;                               /* pages start at 0 */
    601c:	8f ef       	ldi	r24, 0xFF	; 255
    601e:	86 0f       	add	r24, r22
  y *= CHAR_PAGES;                   /* offset for character */
  LCD_Cmd(CMD_PAGE | y);             /* set page */
    6020:	80 6b       	ori	r24, 0xB0	; 176
    6022:	0e 94 00 30 	call	0x6000	; 0x6000 <LCD_Cmd>

  /* horizontal position */
  x--;                               /* columns starts at 0 */
  x *= FONT_SIZE_X;                  /* offset for character */
    6026:	cc 0f       	add	r28, r28
    6028:	cc 0f       	add	r28, r28
    602a:	cc 0f       	add	r28, r28
  #ifdef LCD_OFFSET_X
  x += 4;                            /* offset of 4 dots */
    602c:	c4 50       	subi	r28, 0x04	; 4
  #endif
  X_Start = x;                       /* update start position */
    602e:	c0 93 b5 01 	sts	0x01B5, r28
  Temp = x;
  Temp &= 0b00001111;                /* filter lower nibble */
  LCD_Cmd(CMD_COLUMN_L | Temp);      /* set lower nibble */
    6032:	8c 2f       	mov	r24, r28
    6034:	8c 70       	andi	r24, 0x0C	; 12
    6036:	0e 94 00 30 	call	0x6000	; 0x6000 <LCD_Cmd>
  Temp = x;
  Temp >>= 4;                        /* shift upper nibble to lower */
    603a:	8c 2f       	mov	r24, r28
    603c:	82 95       	swap	r24
    603e:	8f 70       	andi	r24, 0x0F	; 15
  Temp &= 0b00001111;                /* filter nibble */
  LCD_Cmd(CMD_COLUMN_H | Temp);      /* set upper nibble */
    6040:	80 61       	ori	r24, 0x10	; 16
    6042:	0e 94 00 30 	call	0x6000	; 0x6000 <LCD_Cmd>
}
    6046:	cf 91       	pop	r28
    6048:	08 95       	ret

0000604a <LCD_ClearLine>:
 *  - Line: line number (1-)
 *    special case line 0: clear remaining space in current line
 */ 

void LCD_ClearLine(uint8_t Line)
{
    604a:	cf 93       	push	r28
    604c:	98 2f       	mov	r25, r24
  uint8_t           MaxPage;            /* page limit */
  uint8_t           Pos = 1;            /* character position */
  uint8_t           n;                  /* counter */

  if (Line == 0)         /* special case: rest of current line */
    604e:	81 11       	cpse	r24, r1
    6050:	05 c0       	rjmp	.+10     	; 0x605c <LCD_ClearLine+0x12>
  {
    Line = UI.CharPos_Y;                /* current line */
    6052:	e6 e2       	ldi	r30, 0x26	; 38
    6054:	f1 e0       	ldi	r31, 0x01	; 1
    6056:	93 81       	ldd	r25, Z+3	; 0x03
    Pos = UI.CharPos_X;                 /* current character position */
    6058:	82 81       	ldd	r24, Z+2	; 0x02
    605a:	01 c0       	rjmp	.+2      	; 0x605e <LCD_ClearLine+0x14>
 */ 

void LCD_ClearLine(uint8_t Line)
{
  uint8_t           MaxPage;            /* page limit */
  uint8_t           Pos = 1;            /* character position */
    605c:	81 e0       	ldi	r24, 0x01	; 1
    Line = UI.CharPos_Y;                /* current line */
    Pos = UI.CharPos_X;                 /* current character position */
  }

  /* convert line to page */
  Line--;                               /* pages start at 0 */
    605e:	cf ef       	ldi	r28, 0xFF	; 255
    6060:	c9 0f       	add	r28, r25
  Line *= CHAR_PAGES;                   /* offset for char */
  MaxPage = Line + CHAR_PAGES;          /* end page + 1 */

  /* clear line */
  while (Line < MaxPage)           /* loop through pages */
    6062:	c9 17       	cp	r28, r25
    6064:	88 f4       	brcc	.+34     	; 0x6088 <LCD_ClearLine+0x3e>
  {
    LCD_Pos(Pos, 1);               /* set start position */
    6066:	61 e0       	ldi	r22, 0x01	; 1
    6068:	0e 94 08 30 	call	0x6010	; 0x6010 <LCD_Pos>
                                   /* updates also X_Start */
    LCD_Cmd(CMD_PAGE | Line);      /* set page directly */
    606c:	8c 2f       	mov	r24, r28
    606e:	80 6b       	ori	r24, 0xB0	; 176
    6070:	0e 94 00 30 	call	0x6000	; 0x6000 <LCD_Cmd>

    /* clear page */
    n = X_Start;              /* reset counter */
    6074:	c0 91 b5 01 	lds	r28, 0x01B5
    while (n < 132)           /* up to internal RAM size */
    6078:	c4 38       	cpi	r28, 0x84	; 132
    607a:	30 f4       	brcc	.+12     	; 0x6088 <LCD_ClearLine+0x3e>
    {
      LCD_Data(0);            /* send empty byte */
    607c:	80 e0       	ldi	r24, 0x00	; 0
    607e:	0e 94 04 30 	call	0x6008	; 0x6008 <LCD_Data>
      n++;                    /* next byte */
    6082:	cf 5f       	subi	r28, 0xFF	; 255
                                   /* updates also X_Start */
    LCD_Cmd(CMD_PAGE | Line);      /* set page directly */

    /* clear page */
    n = X_Start;              /* reset counter */
    while (n < 132)           /* up to internal RAM size */
    6084:	c4 38       	cpi	r28, 0x84	; 132
    6086:	d1 f7       	brne	.-12     	; 0x607c <LCD_ClearLine+0x32>
      n++;                    /* next byte */
    }

    Line++;                   /* next page */
  }
}
    6088:	cf 91       	pop	r28
    608a:	08 95       	ret

0000608c <LCD_Clear>:
/*
 *  clear the display 
 */ 

void LCD_Clear(void)
{
    608c:	cf 93       	push	r28
  uint8_t           n = 1;         /* counter */
    608e:	c1 e0       	ldi	r28, 0x01	; 1

  /* we have to clear all dots manually :-( */
  while (n <= LCD_CHAR_Y)          /* for all lines */
  {
    LCD_ClearLine(n);              /* clear line */
    6090:	8c 2f       	mov	r24, r28
    6092:	0e 94 25 30 	call	0x604a	; 0x604a <LCD_ClearLine>
    n++;                           /* next line */
    6096:	cf 5f       	subi	r28, 0xFF	; 255
void LCD_Clear(void)
{
  uint8_t           n = 1;         /* counter */

  /* we have to clear all dots manually :-( */
  while (n <= LCD_CHAR_Y)          /* for all lines */
    6098:	c9 30       	cpi	r28, 0x09	; 9
    609a:	d1 f7       	brne	.-12     	; 0x6090 <LCD_Clear+0x4>
  {
    LCD_ClearLine(n);              /* clear line */
    n++;                           /* next line */
  }

  LCD_Pos(1, 1);         /* reset character position */
    609c:	61 e0       	ldi	r22, 0x01	; 1
    609e:	81 e0       	ldi	r24, 0x01	; 1
    60a0:	0e 94 08 30 	call	0x6010	; 0x6010 <LCD_Pos>
}
    60a4:	cf 91       	pop	r28
    60a6:	08 95       	ret

000060a8 <LCD_Contrast>:
 *  required:
 *  - value: 0-63
 */

void LCD_Contrast(uint8_t Contrast)
{
    60a8:	cf 93       	push	r28

  if (Contrast <= 63)              /* limit value */
    60aa:	80 34       	cpi	r24, 0x40	; 64
    60ac:	48 f4       	brcc	.+18     	; 0x60c0 <LCD_Contrast+0x18>
    60ae:	c8 2f       	mov	r28, r24
  {
    /* set contrast */
    LCD_Cmd(CMD_V0_MODE);
    60b0:	81 e8       	ldi	r24, 0x81	; 129
    60b2:	0e 94 00 30 	call	0x6000	; 0x6000 <LCD_Cmd>
    LCD_Cmd(CMD_V0_REG | Contrast);
    60b6:	8c 2f       	mov	r24, r28
    60b8:	0e 94 00 30 	call	0x6000	; 0x6000 <LCD_Cmd>

    NV.Contrast = Contrast;        /* update value */
    60bc:	c0 93 a4 01 	sts	0x01A4, r28
  }
}
    60c0:	cf 91       	pop	r28
    60c2:	08 95       	ret

000060c4 <LCD_Init>:
 */
 
void LCD_Init(void)
{
  /* reset display */
  LCD_PORT = LCD_PORT & ~(1 << LCD_RESET);   /* set /RES low */
    60c4:	58 98       	cbi	0x0b, 0	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    60c6:	85 e0       	ldi	r24, 0x05	; 5
    60c8:	8a 95       	dec	r24
    60ca:	f1 f7       	brne	.-4      	; 0x60c8 <LCD_Init+0x4>
    60cc:	00 00       	nop
  _delay_us(1);                                 /* wait 1s */
  LCD_PORT = LCD_PORT | (1 << LCD_RESET);    /* set /RES high */
    60ce:	58 9a       	sbi	0x0b, 0	; 11
    60d0:	85 e0       	ldi	r24, 0x05	; 5
    60d2:	8a 95       	dec	r24
    60d4:	f1 f7       	brne	.-4      	; 0x60d2 <LCD_Init+0xe>
    60d6:	00 00       	nop
  _delay_us(1);                                /* wait 1s */

  /* set start line: user defined value (default 0) */
  LCD_Cmd(CMD_START_LINE | LCD_START_Y);
    60d8:	80 e4       	ldi	r24, 0x40	; 64
    60da:	0e 94 00 30 	call	0x6000	; 0x6000 <LCD_Cmd>

  /* set segment driver direction (ADC) */
  LCD_Cmd(CMD_SEGMENT_DIR | ADC_MODE);
    60de:	80 ea       	ldi	r24, 0xA0	; 160
    60e0:	0e 94 00 30 	call	0x6000	; 0x6000 <LCD_Cmd>

  /* set common driver direction */
  LCD_Cmd(CMD_COMMON_DIR | COMMON_MODE);
    60e4:	88 ec       	ldi	r24, 0xC8	; 200
    60e6:	0e 94 00 30 	call	0x6000	; 0x6000 <LCD_Cmd>

  /* set LCD bias to 1/9 (duty 1/65) */
  LCD_Cmd(CMD_LCD_BIAS | FLAG_BIAS_19);
    60ea:	82 ea       	ldi	r24, 0xA2	; 162
    60ec:	0e 94 00 30 	call	0x6000	; 0x6000 <LCD_Cmd>

  /* set power mode: all on */
  LCD_Cmd(CMD_POWER_MODE | FLAG_FOLOWER_ON | FLAG_REGULATOR_ON | FLAG_BOOSTER_ON);
    60f0:	8f e2       	ldi	r24, 0x2F	; 47
    60f2:	0e 94 00 30 	call	0x6000	; 0x6000 <LCD_Cmd>

  /* set booster ratio to 4x */
  LCD_Cmd(CMD_BOOSTER_MODE);
    60f6:	88 ef       	ldi	r24, 0xF8	; 248
    60f8:	0e 94 00 30 	call	0x6000	; 0x6000 <LCD_Cmd>
  LCD_Cmd(CMD_BOOSTER_REG | FLAG_BOOSTER_234);
    60fc:	80 e0       	ldi	r24, 0x00	; 0
    60fe:	0e 94 00 30 	call	0x6000	; 0x6000 <LCD_Cmd>

  /* set contrast: resistor ratio 6.5 */
  LCD_Cmd(CMD_V0_RATIO | FLAG_RATIO_65);
    6102:	87 e2       	ldi	r24, 0x27	; 39
    6104:	0e 94 00 30 	call	0x6000	; 0x6000 <LCD_Cmd>

  /* set contrast: user defined value (default 22) */
  LCD_Contrast(LCD_CONTRAST);
    6108:	86 e1       	ldi	r24, 0x16	; 22
    610a:	0e 94 54 30 	call	0x60a8	; 0x60a8 <LCD_Contrast>

  /* no indicator */
  LCD_Cmd(CMD_INDICATOR_MODE);
    610e:	8c ea       	ldi	r24, 0xAC	; 172
    6110:	0e 94 00 30 	call	0x6000	; 0x6000 <LCD_Cmd>
  LCD_Cmd(CMD_INDICATOR_REG | FLAG_INDICATOR_OFF);
    6114:	80 e0       	ldi	r24, 0x00	; 0
    6116:	0e 94 00 30 	call	0x6000	; 0x6000 <LCD_Cmd>

  /* switch display on */
  LCD_Cmd(CMD_DISPLAY | FLAG_DISPLAY_ON);
    611a:	8f ea       	ldi	r24, 0xAF	; 175
    611c:	0e 94 00 30 	call	0x6000	; 0x6000 <LCD_Cmd>

  /* update maximums */
  UI.CharMax_X = LCD_CHAR_X;       /* characters per line */
    6120:	e6 e2       	ldi	r30, 0x26	; 38
    6122:	f1 e0       	ldi	r31, 0x01	; 1
    6124:	80 e1       	ldi	r24, 0x10	; 16
    6126:	84 83       	std	Z+4, r24	; 0x04
  UI.CharMax_Y = LCD_CHAR_Y;       /* lines */
    6128:	88 e0       	ldi	r24, 0x08	; 8
    612a:	85 83       	std	Z+5, r24	; 0x05
  UI.MaxContrast = 63;             /* LCD contrast */
    612c:	8f e3       	ldi	r24, 0x3F	; 63
    612e:	86 83       	std	Z+6, r24	; 0x06

  LCD_Clear();                /* clear display */
    6130:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
    6134:	08 95       	ret

00006136 <LCD_Char>:
 *  requires:
 *  - Char: character to display
 */

void LCD_Char(unsigned char Char)
{
    6136:	0f 93       	push	r16
    6138:	1f 93       	push	r17
    613a:	cf 93       	push	r28
    613c:	df 93       	push	r29
  uint8_t           x;             /* bitmap x byte counter */
  uint8_t           y = 1;         /* bitmap y byte counter */

  /* get font index number from lookup table */
  Table = (uint8_t *)&FontTable;        /* start address */
  Table += Char;                        /* add offset for character */
    613e:	e8 2f       	mov	r30, r24
    6140:	f0 e0       	ldi	r31, 0x00	; 0
    6142:	e8 5c       	subi	r30, 0xC8	; 200
    6144:	fb 4f       	sbci	r31, 0xFB	; 251
  Index = pgm_read_byte(Table);         /* get index number */
    6146:	c4 91       	lpm	r28, Z
  if (Index == 0xff) return;            /* no character bitmap available */
    6148:	cf 3f       	cpi	r28, 0xFF	; 255
    614a:	c9 f0       	breq	.+50     	; 0x617e <LCD_Char+0x48>

  /* calculate start address of character bitmap */
  Table = (uint8_t *)&FontData;        /* start address of font data */
  Offset = FONT_BYTES_N * Index;       /* offset for character */
    614c:	d0 e0       	ldi	r29, 0x00	; 0
    614e:	cc 0f       	add	r28, r28
    6150:	dd 1f       	adc	r29, r29
    6152:	cc 0f       	add	r28, r28
    6154:	dd 1f       	adc	r29, r29
    6156:	cc 0f       	add	r28, r28
    6158:	dd 1f       	adc	r29, r29
  Table += Offset;                     /* address of character data */
    615a:	c8 5c       	subi	r28, 0xC8	; 200
    615c:	da 4f       	sbci	r29, 0xFA	; 250
    615e:	8e 01       	movw	r16, r28
    6160:	08 5f       	subi	r16, 0xF8	; 248
    6162:	1f 4f       	sbci	r17, 0xFF	; 255

    /* read and send all column bytes for this row */
    x = 1;
    while (x <= FONT_BYTES_X)
    {
      Index = pgm_read_byte(Table);     /* read byte */
    6164:	fe 01       	movw	r30, r28
    6166:	84 91       	lpm	r24, Z
      LCD_Data(Index);                  /* send byte */
    6168:	0e 94 04 30 	call	0x6008	; 0x6008 <LCD_Data>
      Table++;                          /* address for next byte */
    616c:	21 96       	adiw	r28, 0x01	; 1
      LCD_Cmd(CMD_PAGE | Page);              /* set new y pos (page) directly */
    }

    /* read and send all column bytes for this row */
    x = 1;
    while (x <= FONT_BYTES_X)
    616e:	c0 17       	cp	r28, r16
    6170:	d1 07       	cpc	r29, r17
    6172:	c1 f7       	brne	.-16     	; 0x6164 <LCD_Char+0x2e>

    Page++;                             /* next page */
    y++;                                /* next row */
  }

  UI.CharPos_X++;             /* update character position */
    6174:	e6 e2       	ldi	r30, 0x26	; 38
    6176:	f1 e0       	ldi	r31, 0x01	; 1
    6178:	82 81       	ldd	r24, Z+2	; 0x02
    617a:	8f 5f       	subi	r24, 0xFF	; 255
    617c:	82 83       	std	Z+2, r24	; 0x02
}
    617e:	df 91       	pop	r29
    6180:	cf 91       	pop	r28
    6182:	1f 91       	pop	r17
    6184:	0f 91       	pop	r16
    6186:	08 95       	ret

00006188 <LCD_Cursor>:
 *    0: cursor on
 *    1: cursor off
 */

void LCD_Cursor(uint8_t Mode)
{
    6188:	cf 93       	push	r28
    618a:	c8 2f       	mov	r28, r24
  LCD_Pos(LCD_CHAR_X, LCD_CHAR_Y);      /* move to bottom right */
    618c:	68 e0       	ldi	r22, 0x08	; 8
    618e:	80 e1       	ldi	r24, 0x10	; 16
    6190:	0e 94 08 30 	call	0x6010	; 0x6010 <LCD_Pos>

  if (Mode)              /* cursor on */
    6194:	cc 23       	and	r28, r28
    6196:	21 f0       	breq	.+8      	; 0x61a0 <LCD_Cursor+0x18>
  {
    LCD_Char('>');
    6198:	8e e3       	ldi	r24, 0x3E	; 62
    619a:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    619e:	03 c0       	rjmp	.+6      	; 0x61a6 <LCD_Cursor+0x1e>
  }
  else                   /* cursor off */
  {
    LCD_Char(' ');
    61a0:	80 e2       	ldi	r24, 0x20	; 32
    61a2:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
  }
}
    61a6:	cf 91       	pop	r28
    61a8:	08 95       	ret

000061aa <LCD_Symbol>:
 *  requires:
 *  - ID: symbol to display
 */

void LCD_Symbol(uint8_t ID)
{
    61aa:	cf 92       	push	r12
    61ac:	df 92       	push	r13
    61ae:	ef 92       	push	r14
    61b0:	ff 92       	push	r15
    61b2:	0f 93       	push	r16
    61b4:	1f 93       	push	r17
    61b6:	cf 93       	push	r28
    61b8:	df 93       	push	r29
  uint8_t           x;             /* bitmap x byte counter */
  uint8_t           y = 1;         /* bitmap y byte counter */

  /* calculate start address of character bitmap */
  Table = (uint8_t *)&SymbolData;       /* start address of symbol data */
  Offset = SYMBOL_BYTES_N * ID;         /* offset for symbol */
    61ba:	28 e4       	ldi	r18, 0x48	; 72
    61bc:	82 9f       	mul	r24, r18
    61be:	c0 01       	movw	r24, r0
    61c0:	11 24       	eor	r1, r1
  Table += Offset;                      /* address of symbol data */
    61c2:	ec 01       	movw	r28, r24
    61c4:	c8 52       	subi	r28, 0x28	; 40
    61c6:	df 4f       	sbci	r29, 0xFF	; 255

  /* calculate vertical start position */
  Page = CHAR_PAGES;                  /* pages/bytes per character */
  Page *= (UI.CharPos_Y - 1);         /* offset for character */
    61c8:	e0 90 29 01 	lds	r14, 0x0129
    61cc:	ea 94       	dec	r14
  uint8_t           *Table;        /* pointer to symbol table */
  uint8_t           Data;          /* symbol data */
  uint16_t          Offset;        /* address offset */
  uint8_t           Page;          /* page number */
  uint8_t           x;             /* bitmap x byte counter */
  uint8_t           y = 1;         /* bitmap y byte counter */
    61ce:	ff 24       	eor	r15, r15
    61d0:	f3 94       	inc	r15
  while (y <= SYMBOL_BYTES_Y)
  {
    if (y > 1)                /* multi-page bitmap */
    {
      /* set byte position */
      LCD_Pos(UI.CharPos_X, UI.CharPos_Y);   /* set x pos, keep y pos */
    61d2:	0f 2e       	mov	r0, r31
    61d4:	f6 e2       	ldi	r31, 0x26	; 38
    61d6:	cf 2e       	mov	r12, r31
    61d8:	f1 e0       	ldi	r31, 0x01	; 1
    61da:	df 2e       	mov	r13, r31
    61dc:	f0 2d       	mov	r31, r0
    61de:	1c c0       	rjmp	.+56     	; 0x6218 <LCD_Symbol+0x6e>
      LCD_Data(Data);                   /* send byte */
      Table++;                          /* address for next byte */
      x++;                              /* next byte */
    }

    Page++;                             /* next page */
    61e0:	e3 94       	inc	r14
  Page *= (UI.CharPos_Y - 1);         /* offset for character */

  /* read character bitmap and send it to display */
  while (y <= SYMBOL_BYTES_Y)
  {
    if (y > 1)                /* multi-page bitmap */
    61e2:	81 e0       	ldi	r24, 0x01	; 1
    61e4:	8f 15       	cp	r24, r15
    61e6:	b8 f4       	brcc	.+46     	; 0x6216 <LCD_Symbol+0x6c>
    {
      /* set byte position */
      LCD_Pos(UI.CharPos_X, UI.CharPos_Y);   /* set x pos, keep y pos */
    61e8:	f6 01       	movw	r30, r12
    61ea:	63 81       	ldd	r22, Z+3	; 0x03
    61ec:	82 81       	ldd	r24, Z+2	; 0x02
    61ee:	0e 94 08 30 	call	0x6010	; 0x6010 <LCD_Pos>
      LCD_Cmd(CMD_PAGE | Page);              /* set new y pos (page) directly */
    61f2:	8e 2d       	mov	r24, r14
    61f4:	80 6b       	ori	r24, 0xB0	; 176
    61f6:	0e 94 00 30 	call	0x6000	; 0x6000 <LCD_Cmd>
    61fa:	0d c0       	rjmp	.+26     	; 0x6216 <LCD_Symbol+0x6c>

    /* read and send all column bytes for this row */
    x = 1;
    while (x <= SYMBOL_BYTES_X)
    {
      Data = pgm_read_byte(Table);      /* read byte */
    61fc:	fe 01       	movw	r30, r28
    61fe:	84 91       	lpm	r24, Z
      LCD_Data(Data);                   /* send byte */
    6200:	0e 94 04 30 	call	0x6008	; 0x6008 <LCD_Data>
      Table++;                          /* address for next byte */
    6204:	21 96       	adiw	r28, 0x01	; 1
      LCD_Cmd(CMD_PAGE | Page);              /* set new y pos (page) directly */
    }

    /* read and send all column bytes for this row */
    x = 1;
    while (x <= SYMBOL_BYTES_X)
    6206:	c0 17       	cp	r28, r16
    6208:	d1 07       	cpc	r29, r17
    620a:	c1 f7       	brne	.-16     	; 0x61fc <LCD_Symbol+0x52>
      Table++;                          /* address for next byte */
      x++;                              /* next byte */
    }

    Page++;                             /* next page */
    y++;                                /* next row */
    620c:	f3 94       	inc	r15
  /* calculate vertical start position */
  Page = CHAR_PAGES;                  /* pages/bytes per character */
  Page *= (UI.CharPos_Y - 1);         /* offset for character */

  /* read character bitmap and send it to display */
  while (y <= SYMBOL_BYTES_Y)
    620e:	f4 e0       	ldi	r31, 0x04	; 4
    6210:	ff 12       	cpse	r15, r31
    6212:	e6 cf       	rjmp	.-52     	; 0x61e0 <LCD_Symbol+0x36>
    6214:	05 c0       	rjmp	.+10     	; 0x6220 <LCD_Symbol+0x76>
    6216:	e8 01       	movw	r28, r16
    6218:	8e 01       	movw	r16, r28
    621a:	08 5e       	subi	r16, 0xE8	; 232
    621c:	1f 4f       	sbci	r17, 0xFF	; 255
    621e:	ee cf       	rjmp	.-36     	; 0x61fc <LCD_Symbol+0x52>
    }

    Page++;                             /* next page */
    y++;                                /* next row */
  }
}
    6220:	df 91       	pop	r29
    6222:	cf 91       	pop	r28
    6224:	1f 91       	pop	r17
    6226:	0f 91       	pop	r16
    6228:	ff 90       	pop	r15
    622a:	ef 90       	pop	r14
    622c:	df 90       	pop	r13
    622e:	cf 90       	pop	r12
    6230:	08 95       	ret

00006232 <LCD_FancyProbeNumber>:
 *  - Probe: probe number
 *  - Table: pointer to pinout details
 */

void LCD_FancyProbeNumber(uint8_t Probe, uint8_t *Table)
{
    6232:	cf 93       	push	r28
  uint8_t           Data;          /* pinout data */
  uint8_t           x;             /* x position */
  uint8_t           y;             /* y position */

  Data = pgm_read_byte(Table);     /* read pinout details */
    6234:	fb 01       	movw	r30, r22
    6236:	24 91       	lpm	r18, Z

  if (Data != PIN_NONE)            /* show pin */
    6238:	22 23       	and	r18, r18
    623a:	89 f0       	breq	.+34     	; 0x625e <LCD_FancyProbeNumber+0x2c>
  {
    /* determine position based on pinout data */
    x = SymbolLeft;         /* set default positions */
    623c:	90 91 b3 01 	lds	r25, 0x01B3
    y = SymbolTop;
    6240:	60 91 b7 01 	lds	r22, 0x01B7
    if (Data & PIN_RIGHT) x = SymbolRight;
    6244:	21 fd       	sbrc	r18, 1
    6246:	90 91 b6 01 	lds	r25, 0x01B6
    if (Data & PIN_BOTTOM) y = SymbolBottom;
    624a:	22 fd       	sbrc	r18, 2
    624c:	60 91 b4 01 	lds	r22, 0x01B4
    6250:	c8 2f       	mov	r28, r24

    /* show probe number */
    LCD_Pos(x, y);               /* set position */
    6252:	89 2f       	mov	r24, r25
    6254:	0e 94 08 30 	call	0x6010	; 0x6010 <LCD_Pos>
    LCD_ProbeNumber(Probe);      /* display probe number */
    6258:	8c 2f       	mov	r24, r28
    625a:	0e 94 05 10 	call	0x200a	; 0x200a <LCD_ProbeNumber>
  }
}
    625e:	cf 91       	pop	r28
    6260:	08 95       	ret

00006262 <LCD_FancySemiPinout>:
 *  - display pin numbers left and right of symbol
 *  - symbol ID (0-) in Check.Symbol
 */

void LCD_FancySemiPinout(void)
{
    6262:	ef 92       	push	r14
    6264:	ff 92       	push	r15
    6266:	0f 93       	push	r16
    6268:	1f 93       	push	r17
    626a:	cf 93       	push	r28
    626c:	df 93       	push	r29
  uint8_t           Line;          /* line number */
  uint8_t           *Table;        /* pointer to pin table */
  uint16_t          Offset;        /* address offset */

  /* check if we got enough unused lines left on the display */
  Line = UI.CharPos_Y;        /* current text line */
    626e:	80 91 29 01 	lds	r24, 0x0129
  n = LCD_CHAR_Y;             /* number of text lines */
  n = n - Line;               /* free lines left */
    6272:	98 e0       	ldi	r25, 0x08	; 8
    6274:	98 1b       	sub	r25, r24
  if (n < LCD_SYMBOL_CHAR_Y) return;    /* too few lines */
    6276:	93 30       	cpi	r25, 0x03	; 3
    6278:	08 f4       	brcc	.+2      	; 0x627c <LCD_FancySemiPinout+0x1a>
    627a:	40 c0       	rjmp	.+128    	; 0x62fc <LCD_FancySemiPinout+0x9a>
  if (n > LCD_SYMBOL_CHAR_Y) Line++;    /* add a spacer line */
    627c:	94 30       	cpi	r25, 0x04	; 4
    627e:	08 f0       	brcs	.+2      	; 0x6282 <LCD_FancySemiPinout+0x20>
    6280:	8f 5f       	subi	r24, 0xFF	; 255

  /* determine positions */
  Line++;                               /* next line */
    6282:	91 e0       	ldi	r25, 0x01	; 1
    6284:	98 0f       	add	r25, r24
  SymbolTop = Line;
    6286:	90 93 b7 01 	sts	0x01B7, r25
  SymbolBottom = Line;
  SymbolBottom += (LCD_SYMBOL_CHAR_Y - 1);   /* add offset for symbol */
    628a:	8d 5f       	subi	r24, 0xFD	; 253
    628c:	80 93 b4 01 	sts	0x01B4, r24
  SymbolLeft = (LCD_CHAR_X - LCD_SYMBOL_CHAR_X) / 2;
    6290:	86 e0       	ldi	r24, 0x06	; 6
    6292:	80 93 b3 01 	sts	0x01B3, r24
  SymbolRight = SymbolLeft;
  SymbolRight += LCD_SYMBOL_CHAR_X + 1;      /* add offset for symbol */
    6296:	8a e0       	ldi	r24, 0x0A	; 10
    6298:	80 93 b6 01 	sts	0x01B6, r24

  /* calculate start address of pinout details */
  Table = (uint8_t *)&PinTable;         /* start address of pin table */
  Offset = Check.Symbol * 3;            /* offset for pin details */
    629c:	08 e0       	ldi	r16, 0x08	; 8
    629e:	11 e0       	ldi	r17, 0x01	; 1
    62a0:	f8 01       	movw	r30, r16
    62a2:	c0 85       	ldd	r28, Z+8	; 0x08
    62a4:	d0 e0       	ldi	r29, 0x00	; 0
    62a6:	be 01       	movw	r22, r28
    62a8:	66 0f       	add	r22, r22
    62aa:	77 1f       	adc	r23, r23
    62ac:	c6 0f       	add	r28, r22
    62ae:	d7 1f       	adc	r29, r23
  Table += Offset;                      /* address of pin details */
    62b0:	cc 54       	subi	r28, 0x4C	; 76
    62b2:	df 4f       	sbci	r29, 0xFF	; 255

  /* display pin numbers */
  LCD_FancyProbeNumber(Semi.A, Table);       /* A pin */
    62b4:	0f 2e       	mov	r0, r31
    62b6:	f1 e8       	ldi	r31, 0x81	; 129
    62b8:	ef 2e       	mov	r14, r31
    62ba:	f1 e0       	ldi	r31, 0x01	; 1
    62bc:	ff 2e       	mov	r15, r31
    62be:	f0 2d       	mov	r31, r0
    62c0:	be 01       	movw	r22, r28
    62c2:	f7 01       	movw	r30, r14
    62c4:	80 81       	ld	r24, Z
    62c6:	0e 94 19 31 	call	0x6232	; 0x6232 <LCD_FancyProbeNumber>
  Table++;                                   /* details for next pin */
    62ca:	be 01       	movw	r22, r28
    62cc:	6f 5f       	subi	r22, 0xFF	; 255
    62ce:	7f 4f       	sbci	r23, 0xFF	; 255
  LCD_FancyProbeNumber(Semi.B, Table);       /* B pin */
    62d0:	f7 01       	movw	r30, r14
    62d2:	81 81       	ldd	r24, Z+1	; 0x01
    62d4:	0e 94 19 31 	call	0x6232	; 0x6232 <LCD_FancyProbeNumber>
  Table++;                                   /* details for next pin */
    62d8:	be 01       	movw	r22, r28
    62da:	6e 5f       	subi	r22, 0xFE	; 254
    62dc:	7f 4f       	sbci	r23, 0xFF	; 255
  LCD_FancyProbeNumber(Semi.C, Table);       /* C pin */
    62de:	f7 01       	movw	r30, r14
    62e0:	82 81       	ldd	r24, Z+2	; 0x02
    62e2:	0e 94 19 31 	call	0x6232	; 0x6232 <LCD_FancyProbeNumber>

  /* display symbol */
  LCD_Pos(SymbolLeft + 1, SymbolTop);   /* set top left position  */
    62e6:	80 91 b3 01 	lds	r24, 0x01B3
    62ea:	60 91 b7 01 	lds	r22, 0x01B7
    62ee:	8f 5f       	subi	r24, 0xFF	; 255
    62f0:	0e 94 08 30 	call	0x6010	; 0x6010 <LCD_Pos>
  LCD_Symbol(Check.Symbol);             /* display symbol */
    62f4:	f8 01       	movw	r30, r16
    62f6:	80 85       	ldd	r24, Z+8	; 0x08
    62f8:	0e 94 d5 30 	call	0x61aa	; 0x61aa <LCD_Symbol>
}
    62fc:	df 91       	pop	r29
    62fe:	cf 91       	pop	r28
    6300:	1f 91       	pop	r17
    6302:	0f 91       	pop	r16
    6304:	ff 90       	pop	r15
    6306:	ef 90       	pop	r14
    6308:	08 95       	ret

0000630a <NumberOfDigits>:
/*
 *  get number of digits of a value
 */

uint8_t NumberOfDigits(uint32_t Value)
{
    630a:	cf 92       	push	r12
    630c:	df 92       	push	r13
    630e:	ef 92       	push	r14
    6310:	ff 92       	push	r15
    6312:	cf 93       	push	r28
  uint8_t           Counter = 1;   /* return value */

  while (Value >= 10)
    6314:	6a 30       	cpi	r22, 0x0A	; 10
    6316:	71 05       	cpc	r23, r1
    6318:	81 05       	cpc	r24, r1
    631a:	91 05       	cpc	r25, r1
    631c:	a8 f0       	brcs	.+42     	; 0x6348 <NumberOfDigits+0x3e>
    631e:	c1 e0       	ldi	r28, 0x01	; 1
  {
    Value /= 10;
    6320:	0f 2e       	mov	r0, r31
    6322:	fa e0       	ldi	r31, 0x0A	; 10
    6324:	cf 2e       	mov	r12, r31
    6326:	d1 2c       	mov	r13, r1
    6328:	e1 2c       	mov	r14, r1
    632a:	f1 2c       	mov	r15, r1
    632c:	f0 2d       	mov	r31, r0
    632e:	a7 01       	movw	r20, r14
    6330:	96 01       	movw	r18, r12
    6332:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    6336:	ca 01       	movw	r24, r20
    6338:	b9 01       	movw	r22, r18
    Counter++;
    633a:	cf 5f       	subi	r28, 0xFF	; 255

uint8_t NumberOfDigits(uint32_t Value)
{
  uint8_t           Counter = 1;   /* return value */

  while (Value >= 10)
    633c:	2a 30       	cpi	r18, 0x0A	; 10
    633e:	31 05       	cpc	r19, r1
    6340:	41 05       	cpc	r20, r1
    6342:	51 05       	cpc	r21, r1
    6344:	a0 f7       	brcc	.-24     	; 0x632e <NumberOfDigits+0x24>
    6346:	01 c0       	rjmp	.+2      	; 0x634a <NumberOfDigits+0x40>
 *  get number of digits of a value
 */

uint8_t NumberOfDigits(uint32_t Value)
{
  uint8_t           Counter = 1;   /* return value */
    6348:	c1 e0       	ldi	r28, 0x01	; 1
    Value /= 10;
    Counter++;
  }

  return Counter;
}
    634a:	8c 2f       	mov	r24, r28
    634c:	cf 91       	pop	r28
    634e:	ff 90       	pop	r15
    6350:	ef 90       	pop	r14
    6352:	df 90       	pop	r13
    6354:	cf 90       	pop	r12
    6356:	08 95       	ret

00006358 <CmpValue>:
 *  - 0 if equal
 *  - 1 if first value is larger than second one
 */

int8_t CmpValue(uint32_t Value1, int8_t Scale1, uint32_t Value2, int8_t Scale2)
{
    6358:	4f 92       	push	r4
    635a:	5f 92       	push	r5
    635c:	6f 92       	push	r6
    635e:	7f 92       	push	r7
    6360:	8f 92       	push	r8
    6362:	9f 92       	push	r9
    6364:	af 92       	push	r10
    6366:	bf 92       	push	r11
    6368:	ef 92       	push	r14
    636a:	0f 93       	push	r16
    636c:	1f 93       	push	r17
    636e:	cf 93       	push	r28
    6370:	df 93       	push	r29
    6372:	4b 01       	movw	r8, r22
    6374:	5c 01       	movw	r10, r24
    6376:	c4 2f       	mov	r28, r20
    6378:	28 01       	movw	r4, r16
    637a:	39 01       	movw	r6, r18
  int8_t            Flag;               /* return value */
  int8_t            Len1, Len2;         /* length */

  /* determine virtual length */
  Len1 = NumberOfDigits(Value1) + Scale1;
    637c:	0e 94 85 31 	call	0x630a	; 0x630a <NumberOfDigits>
    6380:	d8 2f       	mov	r29, r24
  Len2 = NumberOfDigits(Value2) + Scale2;
    6382:	c3 01       	movw	r24, r6
    6384:	b2 01       	movw	r22, r4
    6386:	0e 94 85 31 	call	0x630a	; 0x630a <NumberOfDigits>

  if ((Value1 == 0) || (Value2 == 0))    /* special case */
    638a:	81 14       	cp	r8, r1
    638c:	91 04       	cpc	r9, r1
    638e:	a1 04       	cpc	r10, r1
    6390:	b1 04       	cpc	r11, r1
    6392:	09 f4       	brne	.+2      	; 0x6396 <CmpValue+0x3e>
    6394:	3f c0       	rjmp	.+126    	; 0x6414 <CmpValue+0xbc>
    6396:	41 14       	cp	r4, r1
    6398:	51 04       	cpc	r5, r1
    639a:	61 04       	cpc	r6, r1
    639c:	71 04       	cpc	r7, r1
    639e:	09 f4       	brne	.+2      	; 0x63a2 <CmpValue+0x4a>
    63a0:	44 c0       	rjmp	.+136    	; 0x642a <CmpValue+0xd2>
{
  int8_t            Flag;               /* return value */
  int8_t            Len1, Len2;         /* length */

  /* determine virtual length */
  Len1 = NumberOfDigits(Value1) + Scale1;
    63a2:	cd 0f       	add	r28, r29
  Len2 = NumberOfDigits(Value2) + Scale2;
    63a4:	e8 0e       	add	r14, r24

  if ((Value1 == 0) || (Value2 == 0))    /* special case */
  {
    Flag = 10;                /* perform direct comparison */
  }
  else if (Len1 > Len2)       /* more digits -> larger */
    63a6:	ec 16       	cp	r14, r28
    63a8:	0c f4       	brge	.+2      	; 0x63ac <CmpValue+0x54>
    63aa:	45 c0       	rjmp	.+138    	; 0x6436 <CmpValue+0xde>
  {
    Flag = 1;
  }
  else if (Len1 == Len2)      /* same length */
    63ac:	ce 11       	cpse	r28, r14
    63ae:	45 c0       	rjmp	.+138    	; 0x643a <CmpValue+0xe2>
  {
    /* re-scale to longer value */
    Len1 -= Scale1;
    63b0:	2d 2f       	mov	r18, r29
    Len2 -= Scale2;
    63b2:	98 2f       	mov	r25, r24

    while (Len1 > Len2)       /* up-scale Value #2 */
    63b4:	8d 17       	cp	r24, r29
    63b6:	b4 f4       	brge	.+44     	; 0x63e4 <CmpValue+0x8c>
    {
      Value2 *= 10;
    63b8:	44 0c       	add	r4, r4
    63ba:	55 1c       	adc	r5, r5
    63bc:	66 1c       	adc	r6, r6
    63be:	77 1c       	adc	r7, r7
    63c0:	b3 01       	movw	r22, r6
    63c2:	a2 01       	movw	r20, r4
    63c4:	44 0f       	add	r20, r20
    63c6:	55 1f       	adc	r21, r21
    63c8:	66 1f       	adc	r22, r22
    63ca:	77 1f       	adc	r23, r23
    63cc:	44 0f       	add	r20, r20
    63ce:	55 1f       	adc	r21, r21
    63d0:	66 1f       	adc	r22, r22
    63d2:	77 1f       	adc	r23, r23
    63d4:	44 0e       	add	r4, r20
    63d6:	55 1e       	adc	r5, r21
    63d8:	66 1e       	adc	r6, r22
    63da:	77 1e       	adc	r7, r23
    63dc:	9f 5f       	subi	r25, 0xFF	; 255
  {
    /* re-scale to longer value */
    Len1 -= Scale1;
    Len2 -= Scale2;

    while (Len1 > Len2)       /* up-scale Value #2 */
    63de:	29 13       	cpse	r18, r25
    63e0:	eb cf       	rjmp	.-42     	; 0x63b8 <CmpValue+0x60>
    63e2:	9d 2f       	mov	r25, r29
      Value2 *= 10;
      Len2++;
      /* Scale2-- */
    }

    while (Len2 > Len1)       /* up-scale Value #1 */
    63e4:	29 17       	cp	r18, r25
    63e6:	0c f5       	brge	.+66     	; 0x642a <CmpValue+0xd2>
    {
      Value1 *= 10;
    63e8:	88 0c       	add	r8, r8
    63ea:	99 1c       	adc	r9, r9
    63ec:	aa 1c       	adc	r10, r10
    63ee:	bb 1c       	adc	r11, r11
    63f0:	b5 01       	movw	r22, r10
    63f2:	a4 01       	movw	r20, r8
    63f4:	44 0f       	add	r20, r20
    63f6:	55 1f       	adc	r21, r21
    63f8:	66 1f       	adc	r22, r22
    63fa:	77 1f       	adc	r23, r23
    63fc:	44 0f       	add	r20, r20
    63fe:	55 1f       	adc	r21, r21
    6400:	66 1f       	adc	r22, r22
    6402:	77 1f       	adc	r23, r23
    6404:	84 0e       	add	r8, r20
    6406:	95 1e       	adc	r9, r21
    6408:	a6 1e       	adc	r10, r22
    640a:	b7 1e       	adc	r11, r23
    640c:	2f 5f       	subi	r18, 0xFF	; 255
      Value2 *= 10;
      Len2++;
      /* Scale2-- */
    }

    while (Len2 > Len1)       /* up-scale Value #1 */
    640e:	29 13       	cpse	r18, r25
    6410:	eb cf       	rjmp	.-42     	; 0x63e8 <CmpValue+0x90>
    6412:	0b c0       	rjmp	.+22     	; 0x642a <CmpValue+0xd2>
  }

  if (Flag == 10)             /* perform direct comparison */
  {
    if (Value1 > Value2) Flag = 1;
    else if (Value1 < Value2) Flag = -1;
    6414:	81 e0       	ldi	r24, 0x01	; 1
    6416:	84 14       	cp	r8, r4
    6418:	95 04       	cpc	r9, r5
    641a:	a6 04       	cpc	r10, r6
    641c:	b7 04       	cpc	r11, r7
    641e:	08 f0       	brcs	.+2      	; 0x6422 <CmpValue+0xca>
    6420:	80 e0       	ldi	r24, 0x00	; 0
    6422:	81 95       	neg	r24
    6424:	0b c0       	rjmp	.+22     	; 0x643c <CmpValue+0xe4>
    Flag = -1;
  }

  if (Flag == 10)             /* perform direct comparison */
  {
    if (Value1 > Value2) Flag = 1;
    6426:	81 e0       	ldi	r24, 0x01	; 1
    6428:	09 c0       	rjmp	.+18     	; 0x643c <CmpValue+0xe4>
    642a:	48 14       	cp	r4, r8
    642c:	59 04       	cpc	r5, r9
    642e:	6a 04       	cpc	r6, r10
    6430:	7b 04       	cpc	r7, r11
    6432:	80 f7       	brcc	.-32     	; 0x6414 <CmpValue+0xbc>
    6434:	f8 cf       	rjmp	.-16     	; 0x6426 <CmpValue+0xce>
  {
    Flag = 10;                /* perform direct comparison */
  }
  else if (Len1 > Len2)       /* more digits -> larger */
  {
    Flag = 1;
    6436:	81 e0       	ldi	r24, 0x01	; 1
    6438:	01 c0       	rjmp	.+2      	; 0x643c <CmpValue+0xe4>

    Flag = 10;                /* perform direct comparison */
  }
  else                        /* less digits -> smaller */
  {
    Flag = -1;
    643a:	8f ef       	ldi	r24, 0xFF	; 255
    else if (Value1 < Value2) Flag = -1;
    else Flag = 0;
  }

  return Flag;
}
    643c:	df 91       	pop	r29
    643e:	cf 91       	pop	r28
    6440:	1f 91       	pop	r17
    6442:	0f 91       	pop	r16
    6444:	ef 90       	pop	r14
    6446:	bf 90       	pop	r11
    6448:	af 90       	pop	r10
    644a:	9f 90       	pop	r9
    644c:	8f 90       	pop	r8
    644e:	7f 90       	pop	r7
    6450:	6f 90       	pop	r6
    6452:	5f 90       	pop	r5
    6454:	4f 90       	pop	r4
    6456:	08 95       	ret

00006458 <RescaleValue>:
 *  - value and scale
 *  - new scale
 */

uint32_t RescaleValue(uint32_t Value, int8_t Scale, int8_t NewScale)
{
    6458:	cf 92       	push	r12
    645a:	df 92       	push	r13
    645c:	ef 92       	push	r14
    645e:	ff 92       	push	r15
    6460:	0f 93       	push	r16
    6462:	1f 93       	push	r17
    6464:	cf 93       	push	r28
    6466:	df 93       	push	r29
    6468:	c4 2f       	mov	r28, r20
    646a:	d2 2f       	mov	r29, r18
  uint32_t          NewValue;      /* return value */

  NewValue = Value;           /* take old value */

  while (Scale != NewScale)   /* processing loop */
    646c:	42 17       	cp	r20, r18
    646e:	51 f1       	breq	.+84     	; 0x64c4 <RescaleValue+0x6c>
  {
    if (NewScale > Scale)     /* upscale */
    {
      NewValue /= 10;
    6470:	0f 2e       	mov	r0, r31
    6472:	fa e0       	ldi	r31, 0x0A	; 10
    6474:	cf 2e       	mov	r12, r31
    6476:	d1 2c       	mov	r13, r1
    6478:	e1 2c       	mov	r14, r1
    647a:	f1 2c       	mov	r15, r1
    647c:	f0 2d       	mov	r31, r0

  NewValue = Value;           /* take old value */

  while (Scale != NewScale)   /* processing loop */
  {
    if (NewScale > Scale)     /* upscale */
    647e:	cd 17       	cp	r28, r29
    6480:	44 f4       	brge	.+16     	; 0x6492 <RescaleValue+0x3a>
    {
      NewValue /= 10;
    6482:	a7 01       	movw	r20, r14
    6484:	96 01       	movw	r18, r12
    6486:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    648a:	ca 01       	movw	r24, r20
    648c:	b9 01       	movw	r22, r18
      Scale++;
    648e:	cf 5f       	subi	r28, 0xFF	; 255
    6490:	17 c0       	rjmp	.+46     	; 0x64c0 <RescaleValue+0x68>
    }
    else                      /* downscale */
    {
      NewValue *= 10;
    6492:	dc 01       	movw	r26, r24
    6494:	cb 01       	movw	r24, r22
    6496:	88 0f       	add	r24, r24
    6498:	99 1f       	adc	r25, r25
    649a:	aa 1f       	adc	r26, r26
    649c:	bb 1f       	adc	r27, r27
    649e:	8c 01       	movw	r16, r24
    64a0:	9d 01       	movw	r18, r26
    64a2:	00 0f       	add	r16, r16
    64a4:	11 1f       	adc	r17, r17
    64a6:	22 1f       	adc	r18, r18
    64a8:	33 1f       	adc	r19, r19
    64aa:	00 0f       	add	r16, r16
    64ac:	11 1f       	adc	r17, r17
    64ae:	22 1f       	adc	r18, r18
    64b0:	33 1f       	adc	r19, r19
    64b2:	bc 01       	movw	r22, r24
    64b4:	cd 01       	movw	r24, r26
    64b6:	60 0f       	add	r22, r16
    64b8:	71 1f       	adc	r23, r17
    64ba:	82 1f       	adc	r24, r18
    64bc:	93 1f       	adc	r25, r19
      Scale--;
    64be:	c1 50       	subi	r28, 0x01	; 1
{
  uint32_t          NewValue;      /* return value */

  NewValue = Value;           /* take old value */

  while (Scale != NewScale)   /* processing loop */
    64c0:	dc 13       	cpse	r29, r28
    64c2:	dd cf       	rjmp	.-70     	; 0x647e <RescaleValue+0x26>
      Scale--;
    }
  }

  return NewValue;
}
    64c4:	df 91       	pop	r29
    64c6:	cf 91       	pop	r28
    64c8:	1f 91       	pop	r17
    64ca:	0f 91       	pop	r16
    64cc:	ff 90       	pop	r15
    64ce:	ef 90       	pop	r14
    64d0:	df 90       	pop	r13
    64d2:	cf 90       	pop	r12
    64d4:	08 95       	ret

000064d6 <DisplayValue>:
 *    e.g: p = 10^-12 -> -12
 *  - unit character (0 = none)
 */

void DisplayValue(uint32_t Value, int8_t Exponent, unsigned char Unit)
{
    64d6:	7f 92       	push	r7
    64d8:	8f 92       	push	r8
    64da:	9f 92       	push	r9
    64dc:	af 92       	push	r10
    64de:	bf 92       	push	r11
    64e0:	cf 92       	push	r12
    64e2:	df 92       	push	r13
    64e4:	ef 92       	push	r14
    64e6:	ff 92       	push	r15
    64e8:	0f 93       	push	r16
    64ea:	1f 93       	push	r17
    64ec:	cf 93       	push	r28
    64ee:	df 93       	push	r29
    64f0:	6b 01       	movw	r12, r22
    64f2:	7c 01       	movw	r14, r24
    64f4:	d4 2f       	mov	r29, r20
    64f6:	72 2e       	mov	r7, r18
  uint8_t           Offset = 0;         /* exponent offset to next 10^3 step */
  uint8_t           Index;              /* index ID */
  uint8_t           Length;             /* string length */

  /* scale value down to 4 digits */
  while (Value >= 10000)
    64f8:	80 e1       	ldi	r24, 0x10	; 16
    64fa:	c8 16       	cp	r12, r24
    64fc:	87 e2       	ldi	r24, 0x27	; 39
    64fe:	d8 06       	cpc	r13, r24
    6500:	e1 04       	cpc	r14, r1
    6502:	f1 04       	cpc	r15, r1
    6504:	c8 f0       	brcs	.+50     	; 0x6538 <DisplayValue+0x62>
  {
    Value += 5;                       /* for automagic rounding */
    Value = Value / 10;               /* scale down by 10^1 */
    6506:	0f 2e       	mov	r0, r31
    6508:	fa e0       	ldi	r31, 0x0A	; 10
    650a:	8f 2e       	mov	r8, r31
    650c:	91 2c       	mov	r9, r1
    650e:	a1 2c       	mov	r10, r1
    6510:	b1 2c       	mov	r11, r1
    6512:	f0 2d       	mov	r31, r0
  uint8_t           Length;             /* string length */

  /* scale value down to 4 digits */
  while (Value >= 10000)
  {
    Value += 5;                       /* for automagic rounding */
    6514:	c7 01       	movw	r24, r14
    6516:	b6 01       	movw	r22, r12
    6518:	6b 5f       	subi	r22, 0xFB	; 251
    651a:	7f 4f       	sbci	r23, 0xFF	; 255
    651c:	8f 4f       	sbci	r24, 0xFF	; 255
    651e:	9f 4f       	sbci	r25, 0xFF	; 255
    Value = Value / 10;               /* scale down by 10^1 */
    6520:	a5 01       	movw	r20, r10
    6522:	94 01       	movw	r18, r8
    6524:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    6528:	69 01       	movw	r12, r18
    652a:	7a 01       	movw	r14, r20
    652c:	df 5f       	subi	r29, 0xFF	; 255
  uint8_t           Offset = 0;         /* exponent offset to next 10^3 step */
  uint8_t           Index;              /* index ID */
  uint8_t           Length;             /* string length */

  /* scale value down to 4 digits */
  while (Value >= 10000)
    652e:	20 31       	cpi	r18, 0x10	; 16
    6530:	37 42       	sbci	r19, 0x27	; 39
    6532:	41 05       	cpc	r20, r1
    6534:	51 05       	cpc	r21, r1
    6536:	70 f7       	brcc	.-36     	; 0x6514 <DisplayValue+0x3e>

  /*
   *  determine prefix and offset (= number of digits right of dot)
   */

  if (Exponent >= -12)                  /* prevent index underflow */
    6538:	d4 3f       	cpi	r29, 0xF4	; 244
    653a:	0c f4       	brge	.+2      	; 0x653e <DisplayValue+0x68>
    653c:	66 c0       	rjmp	.+204    	; 0x660a <DisplayValue+0x134>
  {
    Exponent += 12;                     /* shift exponent to be >= 0 */ 
    653e:	d4 5f       	subi	r29, 0xF4	; 244
    Index = Exponent / 3;               /* number of 10^3 steps */
    6540:	86 e5       	ldi	r24, 0x56	; 86
    6542:	d8 02       	muls	r29, r24
    6544:	81 2d       	mov	r24, r1
    6546:	11 24       	eor	r1, r1
    6548:	d7 fd       	sbrc	r29, 7
    654a:	83 95       	inc	r24
    Offset = Exponent % 3;              /* offset to lower 10^3 step */
    654c:	98 2f       	mov	r25, r24
    654e:	99 0f       	add	r25, r25
    6550:	98 0f       	add	r25, r24
    6552:	bd 2e       	mov	r11, r29
    6554:	b9 1a       	sub	r11, r25

    if (Offset > 0)                     /* dot required */
    6556:	21 f0       	breq	.+8      	; 0x6560 <DisplayValue+0x8a>
    {
      Index++;                          /* upscale prefix */ 
    6558:	8f 5f       	subi	r24, 0xFF	; 255
      Offset = 3 - Offset;              /* reverse value (1 or 2) */
    655a:	93 e0       	ldi	r25, 0x03	; 3
    655c:	9b 19       	sub	r25, r11
    655e:	b9 2e       	mov	r11, r25
    }    

    /* look up prefix in table (also prevent array overflow) */
    if (Index <= 6) Prefix = eeprom_read_byte(&Prefix_table[Index]);
    6560:	87 30       	cpi	r24, 0x07	; 7
    6562:	38 f4       	brcc	.+14     	; 0x6572 <DisplayValue+0x9c>
    6564:	90 e0       	ldi	r25, 0x00	; 0
    6566:	8b 53       	subi	r24, 0x3B	; 59
    6568:	9f 4f       	sbci	r25, 0xFF	; 255
    656a:	0e 94 18 37 	call	0x6e30	; 0x6e30 <eeprom_read_byte>
    656e:	18 2f       	mov	r17, r24
    6570:	01 c0       	rjmp	.+2      	; 0x6574 <DisplayValue+0x9e>
 *  - unit character (0 = none)
 */

void DisplayValue(uint32_t Value, int8_t Exponent, unsigned char Unit)
{
  unsigned char     Prefix = 0;         /* prefix character */
    6572:	10 e0       	ldi	r17, 0x00	; 0
    } else if (__radix < 2 || __radix > 36) {
	*__s = 0;
	return __s;
    } else {
	extern char *__utoa_ncheck (unsigned int, char *, unsigned char);
	return __utoa_ncheck (__val, __s, __radix);
    6574:	4a e0       	ldi	r20, 0x0A	; 10
    6576:	6f e2       	ldi	r22, 0x2F	; 47
    6578:	71 e0       	ldi	r23, 0x01	; 1
    657a:	c6 01       	movw	r24, r12
    657c:	0e 94 ee 36 	call	0x6ddc	; 0x6ddc <__utoa_ncheck>
   *  display value
   */

  /* convert value into string */
  utoa((uint16_t)Value, OutBuffer, 10);
  Length = strlen(OutBuffer);
    6580:	ef e2       	ldi	r30, 0x2F	; 47
    6582:	f1 e0       	ldi	r31, 0x01	; 1
    6584:	01 90       	ld	r0, Z+
    6586:	00 20       	and	r0, r0
    6588:	e9 f7       	brne	.-6      	; 0x6584 <DisplayValue+0xae>
    658a:	31 97       	sbiw	r30, 0x01	; 1
    658c:	ef 52       	subi	r30, 0x2F	; 47
    658e:	f1 40       	sbci	r31, 0x01	; 1
    6590:	0e 2f       	mov	r16, r30

  /* we misuse Exponent for the dot position */
  Exponent = Length - Offset;           /* calculate position */
    6592:	de 2f       	mov	r29, r30
    6594:	db 19       	sub	r29, r11

  if (Exponent <= 0)                    /* we have to prepend "0." */
    6596:	1d 16       	cp	r1, r29
    6598:	74 f0       	brlt	.+28     	; 0x65b6 <DisplayValue+0xe0>
  {
    /* 0: factor 10 / -1: factor 100 */
    LCD_Char('0');
    659a:	80 e3       	ldi	r24, 0x30	; 48
    659c:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    LCD_Char('.');
    65a0:	8e e2       	ldi	r24, 0x2E	; 46
    65a2:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    if (Exponent < 0) LCD_Char('0');    /* extra 0 for factor 100 */
    65a6:	dd 23       	and	r29, r29
    65a8:	34 f4       	brge	.+12     	; 0x65b6 <DisplayValue+0xe0>
    65aa:	02 c0       	rjmp	.+4      	; 0x65b0 <DisplayValue+0xda>
 */

void DisplayValue(uint32_t Value, int8_t Exponent, unsigned char Unit)
{
  unsigned char     Prefix = 0;         /* prefix character */
  uint8_t           Offset = 0;         /* exponent offset to next 10^3 step */
    65ac:	b1 2c       	mov	r11, r1
 *  - unit character (0 = none)
 */

void DisplayValue(uint32_t Value, int8_t Exponent, unsigned char Unit)
{
  unsigned char     Prefix = 0;         /* prefix character */
    65ae:	10 e0       	ldi	r17, 0x00	; 0
  if (Exponent <= 0)                    /* we have to prepend "0." */
  {
    /* 0: factor 10 / -1: factor 100 */
    LCD_Char('0');
    LCD_Char('.');
    if (Exponent < 0) LCD_Char('0');    /* extra 0 for factor 100 */
    65b0:	80 e3       	ldi	r24, 0x30	; 48
    65b2:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
  }

  if (Offset == 0) Exponent = -1;       /* disable dot if not needed */
    65b6:	b1 10       	cpse	r11, r1
    65b8:	01 c0       	rjmp	.+2      	; 0x65bc <DisplayValue+0xe6>
    65ba:	df ef       	ldi	r29, 0xFF	; 255

  /* adjust position to match array or disable dot if set to 0 */ 
  Exponent--;
    65bc:	ef ef       	ldi	r30, 0xFF	; 255
    65be:	ed 0f       	add	r30, r29

  /* display value and add dot if requested */
  Index = 0;
  while (Index < Length)                /* loop through string */
    65c0:	01 11       	cpse	r16, r1
    65c2:	03 c0       	rjmp	.+6      	; 0x65ca <DisplayValue+0xf4>
    65c4:	17 c0       	rjmp	.+46     	; 0x65f4 <DisplayValue+0x11e>
 *  - unit character (0 = none)
 */

void DisplayValue(uint32_t Value, int8_t Exponent, unsigned char Unit)
{
  unsigned char     Prefix = 0;         /* prefix character */
    65c6:	10 e0       	ldi	r17, 0x00	; 0
  }

  if (Offset == 0) Exponent = -1;       /* disable dot if not needed */

  /* adjust position to match array or disable dot if set to 0 */ 
  Exponent--;
    65c8:	ee ef       	ldi	r30, 0xFE	; 254
    65ca:	cf e2       	ldi	r28, 0x2F	; 47
    65cc:	d1 e0       	ldi	r29, 0x01	; 1
    65ce:	e1 2c       	mov	r14, r1
    65d0:	f1 2c       	mov	r15, r1
  /* display value and add dot if requested */
  Index = 0;
  while (Index < Length)                /* loop through string */
  {
    LCD_Char(OutBuffer[Index]);              /* display char */
    if (Index == Exponent) LCD_Char('.');    /* display dot */
    65d2:	ce 2e       	mov	r12, r30
    65d4:	ee 0f       	add	r30, r30
    65d6:	dd 08       	sbc	r13, r13

  /* display value and add dot if requested */
  Index = 0;
  while (Index < Length)                /* loop through string */
  {
    LCD_Char(OutBuffer[Index]);              /* display char */
    65d8:	89 91       	ld	r24, Y+
    65da:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    if (Index == Exponent) LCD_Char('.');    /* display dot */
    65de:	ec 14       	cp	r14, r12
    65e0:	fd 04       	cpc	r15, r13
    65e2:	19 f4       	brne	.+6      	; 0x65ea <DisplayValue+0x114>
    65e4:	8e e2       	ldi	r24, 0x2E	; 46
    65e6:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    65ea:	8f ef       	ldi	r24, 0xFF	; 255
    65ec:	e8 1a       	sub	r14, r24
    65ee:	f8 0a       	sbc	r15, r24
  /* adjust position to match array or disable dot if set to 0 */ 
  Exponent--;

  /* display value and add dot if requested */
  Index = 0;
  while (Index < Length)                /* loop through string */
    65f0:	e0 16       	cp	r14, r16
    65f2:	90 f3       	brcs	.-28     	; 0x65d8 <DisplayValue+0x102>
    if (Index == Exponent) LCD_Char('.');    /* display dot */
    Index++;                                 /* next one */
  }

  /* display prefix and unit */
  if (Prefix) LCD_Char(Prefix);
    65f4:	11 23       	and	r17, r17
    65f6:	19 f0       	breq	.+6      	; 0x65fe <DisplayValue+0x128>
    65f8:	81 2f       	mov	r24, r17
    65fa:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
  if (Unit) LCD_Char(Unit);
    65fe:	77 20       	and	r7, r7
    6600:	29 f1       	breq	.+74     	; 0x664c <DisplayValue+0x176>
    6602:	87 2d       	mov	r24, r7
    6604:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    6608:	21 c0       	rjmp	.+66     	; 0x664c <DisplayValue+0x176>
    660a:	4a e0       	ldi	r20, 0x0A	; 10
    660c:	6f e2       	ldi	r22, 0x2F	; 47
    660e:	71 e0       	ldi	r23, 0x01	; 1
    6610:	c6 01       	movw	r24, r12
    6612:	0e 94 ee 36 	call	0x6ddc	; 0x6ddc <__utoa_ncheck>
   *  display value
   */

  /* convert value into string */
  utoa((uint16_t)Value, OutBuffer, 10);
  Length = strlen(OutBuffer);
    6616:	ef e2       	ldi	r30, 0x2F	; 47
    6618:	f1 e0       	ldi	r31, 0x01	; 1
    661a:	01 90       	ld	r0, Z+
    661c:	00 20       	and	r0, r0
    661e:	e9 f7       	brne	.-6      	; 0x661a <DisplayValue+0x144>
    6620:	31 97       	sbiw	r30, 0x01	; 1
    6622:	ef 52       	subi	r30, 0x2F	; 47
    6624:	f1 40       	sbci	r31, 0x01	; 1
    6626:	0e 2f       	mov	r16, r30

  /* we misuse Exponent for the dot position */
  Exponent = Length - Offset;           /* calculate position */
    6628:	de 2f       	mov	r29, r30

  if (Exponent <= 0)                    /* we have to prepend "0." */
    662a:	1e 16       	cp	r1, r30
    662c:	64 f0       	brlt	.+24     	; 0x6646 <DisplayValue+0x170>
  {
    /* 0: factor 10 / -1: factor 100 */
    LCD_Char('0');
    662e:	80 e3       	ldi	r24, 0x30	; 48
    6630:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    LCD_Char('.');
    6634:	8e e2       	ldi	r24, 0x2E	; 46
    6636:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    if (Exponent < 0) LCD_Char('0');    /* extra 0 for factor 100 */
    663a:	00 23       	and	r16, r16
    663c:	0c f4       	brge	.+2      	; 0x6640 <DisplayValue+0x16a>
    663e:	b6 cf       	rjmp	.-148    	; 0x65ac <DisplayValue+0xd6>
 *  - unit character (0 = none)
 */

void DisplayValue(uint32_t Value, int8_t Exponent, unsigned char Unit)
{
  unsigned char     Prefix = 0;         /* prefix character */
    6640:	10 e0       	ldi	r17, 0x00	; 0
    LCD_Char('0');
    LCD_Char('.');
    if (Exponent < 0) LCD_Char('0');    /* extra 0 for factor 100 */
  }

  if (Offset == 0) Exponent = -1;       /* disable dot if not needed */
    6642:	df ef       	ldi	r29, 0xFF	; 255
    6644:	bb cf       	rjmp	.-138    	; 0x65bc <DisplayValue+0xe6>
  /* adjust position to match array or disable dot if set to 0 */ 
  Exponent--;

  /* display value and add dot if requested */
  Index = 0;
  while (Index < Length)                /* loop through string */
    6646:	e1 11       	cpse	r30, r1
    6648:	be cf       	rjmp	.-132    	; 0x65c6 <DisplayValue+0xf0>
    664a:	d9 cf       	rjmp	.-78     	; 0x65fe <DisplayValue+0x128>
  }

  /* display prefix and unit */
  if (Prefix) LCD_Char(Prefix);
  if (Unit) LCD_Char(Unit);
}
    664c:	df 91       	pop	r29
    664e:	cf 91       	pop	r28
    6650:	1f 91       	pop	r17
    6652:	0f 91       	pop	r16
    6654:	ff 90       	pop	r15
    6656:	ef 90       	pop	r14
    6658:	df 90       	pop	r13
    665a:	cf 90       	pop	r12
    665c:	bf 90       	pop	r11
    665e:	af 90       	pop	r10
    6660:	9f 90       	pop	r9
    6662:	8f 90       	pop	r8
    6664:	7f 90       	pop	r7
    6666:	08 95       	ret

00006668 <DisplaySignedValue>:
 *    e.g: p = 10^-12 -> -12
 *  - unit character (0 = none)
 */

void DisplaySignedValue(int32_t Value, int8_t Exponent, unsigned char Unit)
{
    6668:	cf 92       	push	r12
    666a:	df 92       	push	r13
    666c:	ef 92       	push	r14
    666e:	ff 92       	push	r15
    6670:	cf 93       	push	r28
    6672:	df 93       	push	r29
    6674:	6b 01       	movw	r12, r22
    6676:	7c 01       	movw	r14, r24
    6678:	c4 2f       	mov	r28, r20
    667a:	d2 2f       	mov	r29, r18
  /* take care about sign */
  if (Value < 0)              /* negative value */
    667c:	99 23       	and	r25, r25
    667e:	5c f4       	brge	.+22     	; 0x6696 <DisplaySignedValue+0x2e>
  {
    LCD_Char('-');            /* display: "-" */
    6680:	8d e2       	ldi	r24, 0x2D	; 45
    6682:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    Value = -Value;           /* make value positive */
    6686:	f0 94       	com	r15
    6688:	e0 94       	com	r14
    668a:	d0 94       	com	r13
    668c:	c0 94       	com	r12
    668e:	c1 1c       	adc	r12, r1
    6690:	d1 1c       	adc	r13, r1
    6692:	e1 1c       	adc	r14, r1
    6694:	f1 1c       	adc	r15, r1
  }

  /* and display unsigned value */
  DisplayValue((int32_t)Value, Exponent, Unit);
    6696:	2d 2f       	mov	r18, r29
    6698:	4c 2f       	mov	r20, r28
    669a:	c7 01       	movw	r24, r14
    669c:	b6 01       	movw	r22, r12
    669e:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
}
    66a2:	df 91       	pop	r29
    66a4:	cf 91       	pop	r28
    66a6:	ff 90       	pop	r15
    66a8:	ef 90       	pop	r14
    66aa:	df 90       	pop	r13
    66ac:	cf 90       	pop	r12
    66ae:	08 95       	ret

000066b0 <TestKey>:
 *  - 4 if rotary encoder was turned left
 *  The turning velocity is returned by Enc.Velocity.
 */

uint8_t TestKey(uint16_t Timeout, uint8_t Mode)
{
    66b0:	df 92       	push	r13
    66b2:	ef 92       	push	r14
    66b4:	ff 92       	push	r15
    66b6:	0f 93       	push	r16
    66b8:	1f 93       	push	r17
    66ba:	cf 93       	push	r28
    66bc:	df 93       	push	r29
    66be:	8c 01       	movw	r16, r24
    66c0:	f6 2e       	mov	r15, r22
  Enc.Dir = DIR_RIGHT | DIR_LEFT;
  Enc.Pulses = 0;
  Enc.Velocity = 1;
  #endif

  if (Mode > 10)              /* consider operation mode */
    66c2:	8a e0       	ldi	r24, 0x0A	; 10
    66c4:	86 17       	cp	r24, r22
    66c6:	40 f4       	brcc	.+16     	; 0x66d8 <TestKey+0x28>
  {
    if (UI.TesterMode == MODE_AUTOHOLD)      /* auto hold mode */
    66c8:	80 91 26 01 	lds	r24, 0x0126
    66cc:	81 30       	cpi	r24, 0x01	; 1
    66ce:	51 f4       	brne	.+20     	; 0x66e4 <TestKey+0x34>
    {
      Timeout = 0;                 /* disable timeout */
      Mode -= 10;                  /* set cursor mode */
    66d0:	86 ef       	ldi	r24, 0xF6	; 246
    66d2:	f8 0e       	add	r15, r24

  if (Mode > 10)              /* consider operation mode */
  {
    if (UI.TesterMode == MODE_AUTOHOLD)      /* auto hold mode */
    {
      Timeout = 0;                 /* disable timeout */
    66d4:	00 e0       	ldi	r16, 0x00	; 0
    66d6:	10 e0       	ldi	r17, 0x00	; 0
    {
      Mode = 0;                    /* disable cursor */
    }
  }

  if (Mode > 0)               /* cursor enabled */
    66d8:	ff 20       	and	r15, r15
    66da:	29 f0       	breq	.+10     	; 0x66e6 <TestKey+0x36>
  {
    LCD_Cursor(1);            /* enable cursor */
    66dc:	81 e0       	ldi	r24, 0x01	; 1
    66de:	0e 94 c4 30 	call	0x6188	; 0x6188 <LCD_Cursor>
    66e2:	01 c0       	rjmp	.+2      	; 0x66e6 <TestKey+0x36>
      Timeout = 0;                 /* disable timeout */
      Mode -= 10;                  /* set cursor mode */
    }
    else                                     /* continous mode */
    {
      Mode = 0;                    /* disable cursor */
    66e4:	f1 2c       	mov	r15, r1
    66e6:	e1 2c       	mov	r14, r1
    66e8:	d1 e0       	ldi	r29, 0x01	; 1
  {
    /* take care about timeout */
    if (Timeout > 0)                    /* timeout enabled */
    {
      if (Timeout > 5) Timeout -= 5;    /* decrease timeout by 5ms */
      else Run = 0;                     /* end loop on timeout */
    66ea:	c0 e0       	ldi	r28, 0x00	; 0

          /* we misuse Run as toggle switch */
          if (Run == 1)                   /* turn off */
          {
            LCD_Cursor(0);                /* disable cursor */
            Run = 2;                      /* toggle flag */
    66ec:	68 94       	set
    66ee:	dd 24       	eor	r13, r13
    66f0:	d1 f8       	bld	r13, 1
   */
 
  while (Run)
  {
    /* take care about timeout */
    if (Timeout > 0)                    /* timeout enabled */
    66f2:	01 15       	cp	r16, r1
    66f4:	11 05       	cpc	r17, r1
    66f6:	39 f0       	breq	.+14     	; 0x6706 <TestKey+0x56>
    {
      if (Timeout > 5) Timeout -= 5;    /* decrease timeout by 5ms */
    66f8:	06 30       	cpi	r16, 0x06	; 6
    66fa:	11 05       	cpc	r17, r1
    66fc:	18 f0       	brcs	.+6      	; 0x6704 <TestKey+0x54>
    66fe:	05 50       	subi	r16, 0x05	; 5
    6700:	11 09       	sbc	r17, r1
    6702:	01 c0       	rjmp	.+2      	; 0x6706 <TestKey+0x56>
      else Run = 0;                     /* end loop on timeout */
    6704:	dc 2f       	mov	r29, r28
    }

    /* check for key press */
    /* push button is low active */
    if (!(CONTROL_PIN & (1 << TEST_BUTTON)))      /* if key is pressed */
    6706:	4f 99       	sbic	0x09, 7	; 9
    6708:	18 c0       	rjmp	.+48     	; 0x673a <TestKey+0x8a>
    {
      Counter = 0;            /* reset counter */
      MilliSleep(30);         /* time to debounce */
    670a:	8e e1       	ldi	r24, 0x1E	; 30
    670c:	90 e0       	ldi	r25, 0x00	; 0
    670e:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>

    /* check for key press */
    /* push button is low active */
    if (!(CONTROL_PIN & (1 << TEST_BUTTON)))      /* if key is pressed */
    {
      Counter = 0;            /* reset counter */
    6712:	c0 e0       	ldi	r28, 0x00	; 0
      while (Run)             /* detect how long key is pressed */
      {
        if (!(CONTROL_PIN & (1 << TEST_BUTTON)))  /* key still pressed */
        {
          Counter++;                        /* increase counter */
          if (Counter > 26) Run = 0;        /* end loop if 300ms are reached */
    6714:	10 e0       	ldi	r17, 0x00	; 0
    if (!(CONTROL_PIN & (1 << TEST_BUTTON)))      /* if key is pressed */
    {
      Counter = 0;            /* reset counter */
      MilliSleep(30);         /* time to debounce */

      while (Run)             /* detect how long key is pressed */
    6716:	09 c0       	rjmp	.+18     	; 0x672a <TestKey+0x7a>
      {
        if (!(CONTROL_PIN & (1 << TEST_BUTTON)))  /* key still pressed */
        {
          Counter++;                        /* increase counter */
    6718:	cf 5f       	subi	r28, 0xFF	; 255
          if (Counter > 26) Run = 0;        /* end loop if 300ms are reached */
    671a:	cb 31       	cpi	r28, 0x1B	; 27
    671c:	28 f4       	brcc	.+10     	; 0x6728 <TestKey+0x78>
          else MilliSleep(10);              /* otherwise wait 10ms */
    671e:	8a e0       	ldi	r24, 0x0A	; 10
    6720:	90 e0       	ldi	r25, 0x00	; 0
    6722:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>
    6726:	01 c0       	rjmp	.+2      	; 0x672a <TestKey+0x7a>
      while (Run)             /* detect how long key is pressed */
      {
        if (!(CONTROL_PIN & (1 << TEST_BUTTON)))  /* key still pressed */
        {
          Counter++;                        /* increase counter */
          if (Counter > 26) Run = 0;        /* end loop if 300ms are reached */
    6728:	d1 2f       	mov	r29, r17
    if (!(CONTROL_PIN & (1 << TEST_BUTTON)))      /* if key is pressed */
    {
      Counter = 0;            /* reset counter */
      MilliSleep(30);         /* time to debounce */

      while (Run)             /* detect how long key is pressed */
    672a:	dd 23       	and	r29, r29
    672c:	11 f0       	breq	.+4      	; 0x6732 <TestKey+0x82>
      {
        if (!(CONTROL_PIN & (1 << TEST_BUTTON)))  /* key still pressed */
    672e:	4f 9b       	sbis	0x09, 7	; 9
    6730:	f3 cf       	rjmp	.-26     	; 0x6718 <TestKey+0x68>
          Run = 0;                          /* end loop */
        }
      }

      /* determine key press type */
      if (Counter > 26) Flag = 2;       /* long (>= 300ms) */
    6732:	cb 31       	cpi	r28, 0x1B	; 27
    6734:	20 f5       	brcc	.+72     	; 0x677e <TestKey+0xce>
      else Flag = 1;                    /* short (< 300ms) */
    6736:	c1 e0       	ldi	r28, 0x01	; 1
    6738:	1a c0       	rjmp	.+52     	; 0x676e <TestKey+0xbe>
        Flag += 2;                 /* adjust feedback */
        break;                     /* leave loop */
      }
      #endif

      MilliSleep(5);               /* wait a little bit more (5ms) */
    673a:	85 e0       	ldi	r24, 0x05	; 5
    673c:	90 e0       	ldi	r25, 0x00	; 0
    673e:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>

      /* blinking cursor */
      /* HD44780's built-in blinking cursor is ugly anyway :) */
      
      if (Mode == 2)                    /* blinking cursor */
    6742:	82 e0       	ldi	r24, 0x02	; 2
    6744:	f8 12       	cpse	r15, r24
    6746:	10 c0       	rjmp	.+32     	; 0x6768 <TestKey+0xb8>
      {
        Counter++;                        /* increase counter */
    6748:	e3 94       	inc	r14

        if (Counter == 100)               /* every 500ms (1Hz) */
    674a:	84 e6       	ldi	r24, 0x64	; 100
    674c:	e8 12       	cpse	r14, r24
    674e:	0c c0       	rjmp	.+24     	; 0x6768 <TestKey+0xb8>
        {
          Counter = 0;                    /* reset counter */

          /* we misuse Run as toggle switch */
          if (Run == 1)                   /* turn off */
    6750:	d1 30       	cpi	r29, 0x01	; 1
    6752:	29 f4       	brne	.+10     	; 0x675e <TestKey+0xae>
          {
            LCD_Cursor(0);                /* disable cursor */
    6754:	8c 2f       	mov	r24, r28
    6756:	0e 94 c4 30 	call	0x6188	; 0x6188 <LCD_Cursor>
            Run = 2;                      /* toggle flag */
    675a:	dd 2d       	mov	r29, r13
    675c:	0e c0       	rjmp	.+28     	; 0x677a <TestKey+0xca>
          }
          else                            /* turn on */
          {
            LCD_Cursor(1);                /* enable cursor */
    675e:	81 e0       	ldi	r24, 0x01	; 1
    6760:	0e 94 c4 30 	call	0x6188	; 0x6188 <LCD_Cursor>
            Run = 1;                      /* toggle flag */
    6764:	d1 e0       	ldi	r29, 0x01	; 1
    6766:	09 c0       	rjmp	.+18     	; 0x677a <TestKey+0xca>

  /*
   *  wait for key press or timeout
   */
 
  while (Run)
    6768:	d1 11       	cpse	r29, r1
    676a:	c3 cf       	rjmp	.-122    	; 0x66f2 <TestKey+0x42>
    676c:	c0 e0       	ldi	r28, 0x00	; 0

  /*
   *  clean up
   */

  if (Mode > 0)               /* cursor enabled */
    676e:	ff 20       	and	r15, r15
    6770:	41 f0       	breq	.+16     	; 0x6782 <TestKey+0xd2>
  {
    LCD_Cursor(0);            /* disable cursor */
    6772:	80 e0       	ldi	r24, 0x00	; 0
    6774:	0e 94 c4 30 	call	0x6188	; 0x6188 <LCD_Cursor>
    6778:	04 c0       	rjmp	.+8      	; 0x6782 <TestKey+0xd2>
      Timeout = 0;                 /* disable timeout */
      Mode -= 10;                  /* set cursor mode */
    }
    else                                     /* continous mode */
    {
      Mode = 0;                    /* disable cursor */
    677a:	ec 2e       	mov	r14, r28
    677c:	ba cf       	rjmp	.-140    	; 0x66f2 <TestKey+0x42>
          Run = 0;                          /* end loop */
        }
      }

      /* determine key press type */
      if (Counter > 26) Flag = 2;       /* long (>= 300ms) */
    677e:	c2 e0       	ldi	r28, 0x02	; 2
    6780:	f6 cf       	rjmp	.-20     	; 0x676e <TestKey+0xbe>
  {
    LCD_Cursor(0);            /* disable cursor */
  }

  return Flag;
}
    6782:	8c 2f       	mov	r24, r28
    6784:	df 91       	pop	r29
    6786:	cf 91       	pop	r28
    6788:	1f 91       	pop	r17
    678a:	0f 91       	pop	r16
    678c:	ff 90       	pop	r15
    678e:	ef 90       	pop	r14
    6790:	df 90       	pop	r13
    6792:	08 95       	ret

00006794 <WaitKey>:
 */

void WaitKey(void)
{
  /* wait for key press or 3000ms timeout */
  TestKey(3000, 11);
    6794:	6b e0       	ldi	r22, 0x0B	; 11
    6796:	88 eb       	ldi	r24, 0xB8	; 184
    6798:	9b e0       	ldi	r25, 0x0B	; 11
    679a:	0e 94 58 33 	call	0x66b0	; 0x66b0 <TestKey>
    679e:	08 95       	ret

000067a0 <ShortCircuit>:
 *  - 0 on any problem
 *  - 1 on success
 */

uint8_t ShortCircuit(uint8_t Mode)
{
    67a0:	0f 93       	push	r16
    67a2:	1f 93       	push	r17
    67a4:	cf 93       	push	r28
    67a6:	df 93       	push	r29
    67a8:	d8 2f       	mov	r29, r24
  uint8_t           Test;               /* test feedback */
  uint8_t           Comp;               /* expected result */
  unsigned char     *String;            /* display string pointer */

  /* init */
  if (Mode == 0)         /* remove short */
    67aa:	88 23       	and	r24, r24
    67ac:	21 f0       	breq	.+8      	; 0x67b6 <ShortCircuit+0x16>
    String = (unsigned char *)Remove_str;
    Comp = 0;
  }
  else                   /* create short */
  {
    String = (unsigned char *)Create_str;
    67ae:	00 e6       	ldi	r16, 0x60	; 96
    67b0:	12 e0       	ldi	r17, 0x02	; 2
    Comp = 3;
    67b2:	c3 e0       	ldi	r28, 0x03	; 3
    67b4:	03 c0       	rjmp	.+6      	; 0x67bc <ShortCircuit+0x1c>
  unsigned char     *String;            /* display string pointer */

  /* init */
  if (Mode == 0)         /* remove short */
  {
    String = (unsigned char *)Remove_str;
    67b6:	07 e6       	ldi	r16, 0x67	; 103
    67b8:	12 e0       	ldi	r17, 0x02	; 2
    Comp = 0;
    67ba:	c0 e0       	ldi	r28, 0x00	; 0
    String = (unsigned char *)Create_str;
    Comp = 3;
  } 

  /* check if already done */
  Test = AllProbesShorted();            /* get current status */
    67bc:	0e 94 91 23 	call	0x4722	; 0x4722 <AllProbesShorted>
  if (Test == Comp) Flag = 1;           /* skip loop if job already done */
    67c0:	8c 13       	cpse	r24, r28
    67c2:	17 c0       	rjmp	.+46     	; 0x67f2 <ShortCircuit+0x52>
    67c4:	14 c0       	rjmp	.+40     	; 0x67ee <ShortCircuit+0x4e>
  }  

  /* wait until all probes are dis/connected */
  while (Flag == 2)
  {
    Test = AllProbesShorted();     /* check for short circuits */
    67c6:	0e 94 91 23 	call	0x4722	; 0x4722 <AllProbesShorted>

    if (Test == Comp)         /* job done */
    67ca:	8c 13       	cpse	r24, r28
    67cc:	06 c0       	rjmp	.+12     	; 0x67da <ShortCircuit+0x3a>
    {
       Flag = 1;              /* end loop */
       MilliSleep(200);       /* time to debounce */
    67ce:	88 ec       	ldi	r24, 0xC8	; 200
    67d0:	90 e0       	ldi	r25, 0x00	; 0
    67d2:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>
  {
    Test = AllProbesShorted();     /* check for short circuits */

    if (Test == Comp)         /* job done */
    {
       Flag = 1;              /* end loop */
    67d6:	81 e0       	ldi	r24, 0x01	; 1
    67d8:	19 c0       	rjmp	.+50     	; 0x680c <ShortCircuit+0x6c>
       MilliSleep(200);       /* time to debounce */
    }
    else                      /* job not done yet */
    {
      Test = TestKey(100, 0);      /* wait 100ms or detect key press */
    67da:	60 e0       	ldi	r22, 0x00	; 0
    67dc:	84 e6       	ldi	r24, 0x64	; 100
    67de:	90 e0       	ldi	r25, 0x00	; 0
    67e0:	0e 94 58 33 	call	0x66b0	; 0x66b0 <TestKey>
      if (Mode == 0) Test = 0;     /* ignore key for un-short mode */
    67e4:	dd 23       	and	r29, r29
    67e6:	79 f3       	breq	.-34     	; 0x67c6 <ShortCircuit+0x26>
      if (Test > 0) Flag = 0;      /* abort on key press */
    67e8:	81 11       	cpse	r24, r1
    67ea:	0f c0       	rjmp	.+30     	; 0x680a <ShortCircuit+0x6a>
    67ec:	ec cf       	rjmp	.-40     	; 0x67c6 <ShortCircuit+0x26>
    Comp = 3;
  } 

  /* check if already done */
  Test = AllProbesShorted();            /* get current status */
  if (Test == Comp) Flag = 1;           /* skip loop if job already done */
    67ee:	81 e0       	ldi	r24, 0x01	; 1
    67f0:	0d c0       	rjmp	.+26     	; 0x680c <ShortCircuit+0x6c>

  /* if necessary tell user what to do */
  if (Flag == 2)
  {
    LCD_Clear();
    67f2:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
    LCD_EEString(String);               /* display: Remove/Create */
    67f6:	c8 01       	movw	r24, r16
    67f8:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
    LCD_NextLine();
    67fc:	0e 94 d1 0f 	call	0x1fa2	; 0x1fa2 <LCD_NextLine>
    LCD_EEString(ShortCircuit_str);     /* display: short circuit! */
    6800:	81 e5       	ldi	r24, 0x51	; 81
    6802:	92 e0       	ldi	r25, 0x02	; 2
    6804:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
    6808:	de cf       	rjmp	.-68     	; 0x67c6 <ShortCircuit+0x26>
    }
    else                      /* job not done yet */
    {
      Test = TestKey(100, 0);      /* wait 100ms or detect key press */
      if (Mode == 0) Test = 0;     /* ignore key for un-short mode */
      if (Test > 0) Flag = 0;      /* abort on key press */
    680a:	80 e0       	ldi	r24, 0x00	; 0
    }
  }

  return Flag;
}
    680c:	df 91       	pop	r29
    680e:	cf 91       	pop	r28
    6810:	1f 91       	pop	r17
    6812:	0f 91       	pop	r16
    6814:	08 95       	ret

00006816 <ChangeContrast>:
 *  change LCD contrast
 *  - takes maximum value into account
 */

void ChangeContrast(void)
{
    6816:	1f 93       	push	r17
    6818:	cf 93       	push	r28
    681a:	df 93       	push	r29
   *  increase: short key press / right turn 
   *  decrease: long key press / left turn
   *  done:     two brief key presses          
   */

  LCD_Clear();
    681c:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
  LCD_EEString_Space(Contrast_str);     /* display: Contrast */
    6820:	85 e0       	ldi	r24, 0x05	; 5
    6822:	92 e0       	ldi	r25, 0x02	; 2
    6824:	0e 94 15 10 	call	0x202a	; 0x202a <LCD_EEString_Space>

  Contrast = NV.Contrast;          /* get current value */
    6828:	c0 91 a4 01 	lds	r28, 0x01A4
  Max = UI.MaxContrast;
    682c:	10 91 2c 01 	lds	r17, 0x012C

  while (Flag)
  {
    LCD_ClearLine2();
    6830:	0e 94 09 10 	call	0x2012	; 0x2012 <LCD_ClearLine2>
    DisplayValue(Contrast, 0, 0);
    6834:	8c 2f       	mov	r24, r28
    6836:	90 e0       	ldi	r25, 0x00	; 0
    6838:	a0 e0       	ldi	r26, 0x00	; 0
    683a:	b0 e0       	ldi	r27, 0x00	; 0
    683c:	20 e0       	ldi	r18, 0x00	; 0
    683e:	40 e0       	ldi	r20, 0x00	; 0
    6840:	bc 01       	movw	r22, r24
    6842:	cd 01       	movw	r24, r26
    6844:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>

    #ifdef HW_ENCODER
    if (Flag < 3)                       /* just for test button usage */
    #endif
    MilliSleep(300);                    /* smooth UI */
    6848:	8c e2       	ldi	r24, 0x2C	; 44
    684a:	91 e0       	ldi	r25, 0x01	; 1
    684c:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>

    Flag = TestKey(0, 0);               /* wait for user feedback */
    6850:	60 e0       	ldi	r22, 0x00	; 0
    6852:	80 e0       	ldi	r24, 0x00	; 0
    6854:	90 e0       	ldi	r25, 0x00	; 0
    6856:	0e 94 58 33 	call	0x66b0	; 0x66b0 <TestKey>
    685a:	d8 2f       	mov	r29, r24
    if (Flag == 1)                      /* short key press */
    685c:	81 30       	cpi	r24, 0x01	; 1
    685e:	79 f4       	brne	.+30     	; 0x687e <ChangeContrast+0x68>
    {
      MilliSleep(50);                   /* debounce button a little bit longer */
    6860:	82 e3       	ldi	r24, 0x32	; 50
    6862:	90 e0       	ldi	r25, 0x00	; 0
    6864:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>
      Test = TestKey(200, 0);           /* check for second key press */
    6868:	60 e0       	ldi	r22, 0x00	; 0
    686a:	88 ec       	ldi	r24, 0xC8	; 200
    686c:	90 e0       	ldi	r25, 0x00	; 0
    686e:	0e 94 58 33 	call	0x66b0	; 0x66b0 <TestKey>
      if (Test > 0)                     /* second key press */
    6872:	81 11       	cpse	r24, r1
    6874:	10 c0       	rjmp	.+32     	; 0x6896 <ChangeContrast+0x80>
      {
        Flag = 0;                         /* end loop */
      }
      else                              /* single key press */
      {
        if (Contrast < Max) Contrast++;   /* increase value */
    6876:	c1 17       	cp	r28, r17
    6878:	50 f4       	brcc	.+20     	; 0x688e <ChangeContrast+0x78>
    687a:	cf 5f       	subi	r28, 0xFF	; 255
    687c:	08 c0       	rjmp	.+16     	; 0x688e <ChangeContrast+0x78>
      if (Contrast < Max) Contrast++;   /* increase value */
    }
    #endif
    else                                /* long key press / left turn */
    {
      if (Contrast > 0) Contrast--;       /* decrease */
    687e:	c1 11       	cpse	r28, r1
    6880:	c1 50       	subi	r28, 0x01	; 1
    }

    LCD_Contrast(Contrast);        /* change contrast */
    6882:	8c 2f       	mov	r24, r28
    6884:	0e 94 54 30 	call	0x60a8	; 0x60a8 <LCD_Contrast>
  LCD_EEString_Space(Contrast_str);     /* display: Contrast */

  Contrast = NV.Contrast;          /* get current value */
  Max = UI.MaxContrast;

  while (Flag)
    6888:	d1 11       	cpse	r29, r1
    688a:	d2 cf       	rjmp	.-92     	; 0x6830 <ChangeContrast+0x1a>
    688c:	07 c0       	rjmp	.+14     	; 0x689c <ChangeContrast+0x86>
    else                                /* long key press / left turn */
    {
      if (Contrast > 0) Contrast--;       /* decrease */
    }

    LCD_Contrast(Contrast);        /* change contrast */
    688e:	8c 2f       	mov	r24, r28
    6890:	0e 94 54 30 	call	0x60a8	; 0x60a8 <LCD_Contrast>
    6894:	cd cf       	rjmp	.-102    	; 0x6830 <ChangeContrast+0x1a>
    6896:	8c 2f       	mov	r24, r28
    6898:	0e 94 54 30 	call	0x60a8	; 0x60a8 <LCD_Contrast>
  }
}
    689c:	df 91       	pop	r29
    689e:	cf 91       	pop	r28
    68a0:	1f 91       	pop	r17
    68a2:	08 95       	ret

000068a4 <MenuTool>:
 *  returns:
 *  - ID of selected item
 */

uint8_t MenuTool(uint8_t Items, uint8_t Type, void *Menu[], unsigned char *Unit)
{
    68a4:	2f 92       	push	r2
    68a6:	3f 92       	push	r3
    68a8:	4f 92       	push	r4
    68aa:	5f 92       	push	r5
    68ac:	6f 92       	push	r6
    68ae:	7f 92       	push	r7
    68b0:	8f 92       	push	r8
    68b2:	9f 92       	push	r9
    68b4:	af 92       	push	r10
    68b6:	bf 92       	push	r11
    68b8:	cf 92       	push	r12
    68ba:	df 92       	push	r13
    68bc:	ef 92       	push	r14
    68be:	ff 92       	push	r15
    68c0:	0f 93       	push	r16
    68c2:	1f 93       	push	r17
    68c4:	cf 93       	push	r28
    68c6:	df 93       	push	r29
    68c8:	00 d0       	rcall	.+0      	; 0x68ca <MenuTool+0x26>
    68ca:	00 d0       	rcall	.+0      	; 0x68cc <MenuTool+0x28>
    68cc:	1f 92       	push	r1
    68ce:	cd b7       	in	r28, 0x3d	; 61
    68d0:	de b7       	in	r29, 0x3e	; 62
    68d2:	66 2e       	mov	r6, r22
    68d4:	5a 83       	std	Y+2, r21	; 0x02
    68d6:	49 83       	std	Y+1, r20	; 0x01
    68d8:	69 01       	movw	r12, r18
  uint8_t           Lines;              /* line number */
  uint8_t           n;                  /* temp value */
  void              *Address;           /* address of menu element */
  uint16_t          Value;              /* temp. value */

  Items--;                    /* to match array counter */
    68da:	55 24       	eor	r5, r5
    68dc:	5a 94       	dec	r5
    68de:	58 0e       	add	r5, r24
  Lines = UI.CharMax_Y;       /* max. number of lines */
    68e0:	10 91 2b 01 	lds	r17, 0x012B
  Lines--;                    /* adjust to match item counter */
    68e4:	77 24       	eor	r7, r7
    68e6:	7a 94       	dec	r7
    68e8:	71 0e       	add	r7, r17
  LCD_Char(':');              /* whatever: */
    68ea:	8a e3       	ldi	r24, 0x3A	; 58
    68ec:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>

uint8_t MenuTool(uint8_t Items, uint8_t Type, void *Menu[], unsigned char *Unit)
{
  uint8_t           Selected = 0;       /* return value / ID of selected item */
  uint8_t           First = 0;          /* first item listed */
  uint8_t           Run = 2;            /* loop control flag */
    68f0:	02 e0       	ldi	r16, 0x02	; 2
 */

uint8_t MenuTool(uint8_t Items, uint8_t Type, void *Menu[], unsigned char *Unit)
{
  uint8_t           Selected = 0;       /* return value / ID of selected item */
  uint8_t           First = 0;          /* first item listed */
    68f2:	21 2c       	mov	r2, r1
 *  - ID of selected item
 */

uint8_t MenuTool(uint8_t Items, uint8_t Type, void *Menu[], unsigned char *Unit)
{
  uint8_t           Selected = 0;       /* return value / ID of selected item */
    68f4:	31 2c       	mov	r3, r1

    /*
     *  display item(s)
     */

    Address = &Menu[First];        /* get address of first item */
    68f6:	41 2c       	mov	r4, r1
    68f8:	12 50       	subi	r17, 0x02	; 2
    68fa:	1b 83       	std	Y+3, r17	; 0x03
        if (Selected == n)         /* item would be the last one listed */
        {
          if (Items > Selected)    /* more items follow in list */
          {
            First++;               /* scroll one item up */
            Run++;                 /* set flag for changed list */
    68fc:	80 2e       	mov	r8, r16
  LCD_Char(':');              /* whatever: */


  while (Run)
  {
    if (Lines == 1)           /* 2 line display */
    68fe:	81 e0       	ldi	r24, 0x01	; 1
    6900:	78 12       	cpse	r7, r24
    6902:	0e c0       	rjmp	.+28     	; 0x6920 <MenuTool+0x7c>
    {
      First = Selected;       /* just one line for items */
      Run++;                  /* set flag for changed list */
    6904:	83 94       	inc	r8

    /*
     *  display item(s)
     */

    Address = &Menu[First];        /* get address of first item */
    6906:	83 2d       	mov	r24, r3
    6908:	90 e0       	ldi	r25, 0x00	; 0
    690a:	9c 01       	movw	r18, r24
    690c:	22 0f       	add	r18, r18
    690e:	33 1f       	adc	r19, r19
    6910:	e9 81       	ldd	r30, Y+1	; 0x01
    6912:	fa 81       	ldd	r31, Y+2	; 0x02
    6914:	e2 0f       	add	r30, r18
    6916:	f3 1f       	adc	r31, r19
    6918:	fd 83       	std	Y+5, r31	; 0x05
    691a:	ec 83       	std	Y+4, r30	; 0x04
    691c:	23 2c       	mov	r2, r3
    691e:	0e c0       	rjmp	.+28     	; 0x693c <MenuTool+0x98>
    6920:	82 2d       	mov	r24, r2
    6922:	90 e0       	ldi	r25, 0x00	; 0
    6924:	9c 01       	movw	r18, r24
    6926:	22 0f       	add	r18, r18
    6928:	33 1f       	adc	r19, r19
    692a:	89 81       	ldd	r24, Y+1	; 0x01
    692c:	9a 81       	ldd	r25, Y+2	; 0x02
    692e:	82 0f       	add	r24, r18
    6930:	93 1f       	adc	r25, r19
    6932:	9d 83       	std	Y+5, r25	; 0x05
    6934:	8c 83       	std	Y+4, r24	; 0x04
    n = 0;

    while (n < Lines)
    6936:	77 20       	and	r7, r7
    6938:	09 f4       	brne	.+2      	; 0x693c <MenuTool+0x98>
    693a:	58 c0       	rjmp	.+176    	; 0x69ec <MenuTool+0x148>

    /*
     *  display item(s)
     */

    Address = &Menu[First];        /* get address of first item */
    693c:	00 e0       	ldi	r16, 0x00	; 0
    693e:	14 2d       	mov	r17, r4
    6940:	91 2c       	mov	r9, r1
      LCD_Pos(1, n + 2);           /* move to start of line */

      /* display indicator for multiline displays */
      if (Lines > 1)
      {
        if (Selected == (First + n))    /* selected item */
    6942:	a3 2c       	mov	r10, r3
    6944:	b1 2c       	mov	r11, r1
    6946:	e2 2c       	mov	r14, r2
    6948:	f1 2c       	mov	r15, r1
    694a:	62 e0       	ldi	r22, 0x02	; 2
    694c:	69 0d       	add	r22, r9
    Address = &Menu[First];        /* get address of first item */
    n = 0;

    while (n < Lines)
    {
      LCD_Pos(1, n + 2);           /* move to start of line */
    694e:	81 e0       	ldi	r24, 0x01	; 1
    6950:	0e 94 08 30 	call	0x6010	; 0x6010 <LCD_Pos>

      /* display indicator for multiline displays */
      if (Lines > 1)
    6954:	f1 e0       	ldi	r31, 0x01	; 1
    6956:	f7 15       	cp	r31, r7
    6958:	60 f4       	brcc	.+24     	; 0x6972 <MenuTool+0xce>
    695a:	c8 01       	movw	r24, r16
    695c:	8e 0d       	add	r24, r14
    695e:	9f 1d       	adc	r25, r15
      {
        if (Selected == (First + n))    /* selected item */
    6960:	a8 16       	cp	r10, r24
    6962:	b9 06       	cpc	r11, r25
    6964:	21 f4       	brne	.+8      	; 0x696e <MenuTool+0xca>
        {
          LCD_Char('*');
    6966:	8a e2       	ldi	r24, 0x2A	; 42
    6968:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    696c:	02 c0       	rjmp	.+4      	; 0x6972 <MenuTool+0xce>
        }
        else                            /* not selected */
        {
          LCD_Space();
    696e:	0e 94 11 10 	call	0x2022	; 0x2022 <LCD_Space>
        }
      }

      if (Run > 1)            /* list changed */
    6972:	81 e0       	ldi	r24, 0x01	; 1
    6974:	88 15       	cp	r24, r8
    6976:	e8 f4       	brcc	.+58     	; 0x69b2 <MenuTool+0x10e>
      {
        /* display item or value */
        if (Type == 1)                  /* fixed string */
    6978:	68 12       	cpse	r6, r24
    697a:	07 c0       	rjmp	.+14     	; 0x698a <MenuTool+0xe6>
        {
          LCD_EEString(*(unsigned char **)Address);
    697c:	ec 81       	ldd	r30, Y+4	; 0x04
    697e:	fd 81       	ldd	r31, Y+5	; 0x05
    6980:	80 81       	ld	r24, Z
    6982:	91 81       	ldd	r25, Z+1	; 0x01
    6984:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
    6988:	0b c0       	rjmp	.+22     	; 0x69a0 <MenuTool+0xfc>
        }
        else                            /* uint16_t in EEPROM */
        {
          Value = eeprom_read_word(Address); /* read value at eeprom address */
    698a:	8c 81       	ldd	r24, Y+4	; 0x04
    698c:	9d 81       	ldd	r25, Y+5	; 0x05
    698e:	0e 94 20 37 	call	0x6e40	; 0x6e40 <eeprom_read_word>
          DisplayValue(Value, 0, 0);
    6992:	bc 01       	movw	r22, r24
    6994:	80 e0       	ldi	r24, 0x00	; 0
    6996:	90 e0       	ldi	r25, 0x00	; 0
    6998:	20 e0       	ldi	r18, 0x00	; 0
    699a:	40 e0       	ldi	r20, 0x00	; 0
    699c:	0e 94 6b 32 	call	0x64d6	; 0x64d6 <DisplayValue>
        }     

        /* display optional fixed string */
        if (Unit)
    69a0:	c1 14       	cp	r12, r1
    69a2:	d1 04       	cpc	r13, r1
    69a4:	19 f0       	breq	.+6      	; 0x69ac <MenuTool+0x108>
        {
          LCD_EEString(Unit);
    69a6:	c6 01       	movw	r24, r12
    69a8:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
        }  

        LCD_ClearLine(0);     /* clear rest of this line */
    69ac:	80 e0       	ldi	r24, 0x00	; 0
    69ae:	0e 94 25 30 	call	0x604a	; 0x604a <LCD_ClearLine>
      }

      Address += 2;                /* next address (2 byte steps) */
    69b2:	8c 81       	ldd	r24, Y+4	; 0x04
    69b4:	9d 81       	ldd	r25, Y+5	; 0x05
    69b6:	02 96       	adiw	r24, 0x02	; 2
    69b8:	9d 83       	std	Y+5, r25	; 0x05
    69ba:	8c 83       	std	Y+4, r24	; 0x04
      n++;                         /* next item */
    69bc:	93 94       	inc	r9

      if (n > Items) n = Lines;    /* end loop for a short list */
    69be:	59 14       	cp	r5, r9
    69c0:	28 f0       	brcs	.+10     	; 0x69cc <MenuTool+0x128>
    69c2:	0f 5f       	subi	r16, 0xFF	; 255
    69c4:	1f 4f       	sbci	r17, 0xFF	; 255
     */

    Address = &Menu[First];        /* get address of first item */
    n = 0;

    while (n < Lines)
    69c6:	97 14       	cp	r9, r7
    69c8:	08 f4       	brcc	.+2      	; 0x69cc <MenuTool+0x128>
    69ca:	bf cf       	rjmp	.-130    	; 0x694a <MenuTool+0xa6>
    }

    Run = 1;             /* reset loop flag (changed list) */

    /* show navigation help for 2 line displays */
    if (Lines == 1)
    69cc:	91 e0       	ldi	r25, 0x01	; 1
    69ce:	79 12       	cpse	r7, r25
    69d0:	0d c0       	rjmp	.+26     	; 0x69ec <MenuTool+0x148>
    {
      LCD_Pos(UI.CharMax_X, UI.CharMax_Y);     /* set position to bottom right */
    69d2:	60 91 2b 01 	lds	r22, 0x012B
    69d6:	80 91 2a 01 	lds	r24, 0x012A
    69da:	0e 94 08 30 	call	0x6010	; 0x6010 <LCD_Pos>
      if (Selected < Items) n = '>';      /* another item follows */
    69de:	35 14       	cp	r3, r5
    69e0:	10 f0       	brcs	.+4      	; 0x69e6 <MenuTool+0x142>
      else n = '<';                       /* last item */
    69e2:	8c e3       	ldi	r24, 0x3C	; 60
    69e4:	01 c0       	rjmp	.+2      	; 0x69e8 <MenuTool+0x144>

    /* show navigation help for 2 line displays */
    if (Lines == 1)
    {
      LCD_Pos(UI.CharMax_X, UI.CharMax_Y);     /* set position to bottom right */
      if (Selected < Items) n = '>';      /* another item follows */
    69e6:	8e e3       	ldi	r24, 0x3E	; 62
      else n = '<';                       /* last item */
      LCD_Char(n);
    69e8:	0e 94 9b 30 	call	0x6136	; 0x6136 <LCD_Char>
    }

    #ifndef HW_ENCODER
      MilliSleep(100);        /* smooth UI */
    69ec:	84 e6       	ldi	r24, 0x64	; 100
    69ee:	90 e0       	ldi	r25, 0x00	; 0
    69f0:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>

    /*
     *  process user feedback
     */
 
    n = TestKey(0, 0);             /* wait for testkey */
    69f4:	60 e0       	ldi	r22, 0x00	; 0
    69f6:	80 e0       	ldi	r24, 0x00	; 0
    69f8:	94 2d       	mov	r25, r4
    69fa:	0e 94 58 33 	call	0x66b0	; 0x66b0 <TestKey>
      }
    }
    #endif

    /* processing for testkey */
    if (n == 1)                    /* short key press: move to next item */
    69fe:	81 30       	cpi	r24, 0x01	; 1
    6a00:	b1 f4       	brne	.+44     	; 0x6a2e <MenuTool+0x18a>
    {
      if (Selected == Items)       /* last item */
    6a02:	35 10       	cpse	r3, r5
    6a04:	08 c0       	rjmp	.+16     	; 0x6a16 <MenuTool+0x172>
      {
        Selected = 0;              /* roll over to first one */
        First = 0;                 /* also reset first item listed */

        if (Items >= Lines)        /* large list */
    6a06:	57 14       	cp	r5, r7
    6a08:	d0 f0       	brcs	.+52     	; 0x6a3e <MenuTool+0x19a>
        {
          Run++;                   /* set flag for changed list */
    6a0a:	68 94       	set
    6a0c:	88 24       	eor	r8, r8
    6a0e:	81 f8       	bld	r8, 1
    if (n == 1)                    /* short key press: move to next item */
    {
      if (Selected == Items)       /* last item */
      {
        Selected = 0;              /* roll over to first one */
        First = 0;                 /* also reset first item listed */
    6a10:	21 2c       	mov	r2, r1
    /* processing for testkey */
    if (n == 1)                    /* short key press: move to next item */
    {
      if (Selected == Items)       /* last item */
      {
        Selected = 0;              /* roll over to first one */
    6a12:	31 2c       	mov	r3, r1
    6a14:	74 cf       	rjmp	.-280    	; 0x68fe <MenuTool+0x5a>
          Run++;                   /* set flag for changed list */
        }
      }
      else                         /* more items follow */
      {
        Selected++;                /* move to next item */        
    6a16:	33 94       	inc	r3

        n = First + Lines - 1;     /* last item on screen */
    6a18:	8b 81       	ldd	r24, Y+3	; 0x03
    6a1a:	82 0d       	add	r24, r2
        if (Selected == n)         /* item would be the last one listed */
    6a1c:	38 12       	cpse	r3, r24
    6a1e:	14 c0       	rjmp	.+40     	; 0x6a48 <MenuTool+0x1a4>
        {
          if (Items > Selected)    /* more items follow in list */
    6a20:	35 14       	cp	r3, r5
    6a22:	a8 f4       	brcc	.+42     	; 0x6a4e <MenuTool+0x1aa>
          {
            First++;               /* scroll one item up */
    6a24:	23 94       	inc	r2
            Run++;                 /* set flag for changed list */
    6a26:	68 94       	set
    6a28:	88 24       	eor	r8, r8
    6a2a:	81 f8       	bld	r8, 1
    6a2c:	68 cf       	rjmp	.-304    	; 0x68fe <MenuTool+0x5a>
          }
        }
      }
    }
    else if (n == 2)               /* long key press: select current item */
    6a2e:	88 24       	eor	r8, r8
    6a30:	83 94       	inc	r8
    6a32:	82 30       	cpi	r24, 0x02	; 2
    6a34:	09 f4       	brne	.+2      	; 0x6a38 <MenuTool+0x194>
    6a36:	81 2c       	mov	r8, r1
  Lines = UI.CharMax_Y;       /* max. number of lines */
  Lines--;                    /* adjust to match item counter */
  LCD_Char(':');              /* whatever: */


  while (Run)
    6a38:	81 10       	cpse	r8, r1
    6a3a:	61 cf       	rjmp	.-318    	; 0x68fe <MenuTool+0x5a>
    6a3c:	0b c0       	rjmp	.+22     	; 0x6a54 <MenuTool+0x1b0>
      n++;                         /* next item */

      if (n > Items) n = Lines;    /* end loop for a short list */
    }

    Run = 1;             /* reset loop flag (changed list) */
    6a3e:	88 24       	eor	r8, r8
    6a40:	83 94       	inc	r8
    if (n == 1)                    /* short key press: move to next item */
    {
      if (Selected == Items)       /* last item */
      {
        Selected = 0;              /* roll over to first one */
        First = 0;                 /* also reset first item listed */
    6a42:	21 2c       	mov	r2, r1
    /* processing for testkey */
    if (n == 1)                    /* short key press: move to next item */
    {
      if (Selected == Items)       /* last item */
      {
        Selected = 0;              /* roll over to first one */
    6a44:	31 2c       	mov	r3, r1
    6a46:	5b cf       	rjmp	.-330    	; 0x68fe <MenuTool+0x5a>
      n++;                         /* next item */

      if (n > Items) n = Lines;    /* end loop for a short list */
    }

    Run = 1;             /* reset loop flag (changed list) */
    6a48:	88 24       	eor	r8, r8
    6a4a:	83 94       	inc	r8
    6a4c:	58 cf       	rjmp	.-336    	; 0x68fe <MenuTool+0x5a>
    6a4e:	88 24       	eor	r8, r8
    6a50:	83 94       	inc	r8
    6a52:	55 cf       	rjmp	.-342    	; 0x68fe <MenuTool+0x5a>
    {
      Run = 0;                     /* end loop */
    }
  }

  LCD_Clear();                /* feedback for user */
    6a54:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
  MilliSleep(500);            /* smooth UI */
    6a58:	84 ef       	ldi	r24, 0xF4	; 244
    6a5a:	91 e0       	ldi	r25, 0x01	; 1
    6a5c:	0e 94 86 22 	call	0x450c	; 0x450c <MilliSleep>

  return Selected;
}
    6a60:	83 2d       	mov	r24, r3
    6a62:	0f 90       	pop	r0
    6a64:	0f 90       	pop	r0
    6a66:	0f 90       	pop	r0
    6a68:	0f 90       	pop	r0
    6a6a:	0f 90       	pop	r0
    6a6c:	df 91       	pop	r29
    6a6e:	cf 91       	pop	r28
    6a70:	1f 91       	pop	r17
    6a72:	0f 91       	pop	r16
    6a74:	ff 90       	pop	r15
    6a76:	ef 90       	pop	r14
    6a78:	df 90       	pop	r13
    6a7a:	cf 90       	pop	r12
    6a7c:	bf 90       	pop	r11
    6a7e:	af 90       	pop	r10
    6a80:	9f 90       	pop	r9
    6a82:	8f 90       	pop	r8
    6a84:	7f 90       	pop	r7
    6a86:	6f 90       	pop	r6
    6a88:	5f 90       	pop	r5
    6a8a:	4f 90       	pop	r4
    6a8c:	3f 90       	pop	r3
    6a8e:	2f 90       	pop	r2
    6a90:	08 95       	ret

00006a92 <AdjustmentMenu>:
/*
 *  adjustment menu
 */

void AdjustmentMenu(uint8_t Mode)
{
    6a92:	1f 93       	push	r17
    6a94:	cf 93       	push	r28
    6a96:	df 93       	push	r29
    6a98:	cd b7       	in	r28, 0x3d	; 61
    6a9a:	de b7       	in	r29, 0x3e	; 62
    6a9c:	29 97       	sbiw	r28, 0x09	; 9
    6a9e:	0f b6       	in	r0, 0x3f	; 63
    6aa0:	f8 94       	cli
    6aa2:	de bf       	out	0x3e, r29	; 62
    6aa4:	0f be       	out	0x3f, r0	; 63
    6aa6:	cd bf       	out	0x3d, r28	; 61
    6aa8:	18 2f       	mov	r17, r24
  void              *MenuItem[MENU_ITEMS];   /* menu item strings */
  uint8_t           MenuID[MENU_ITEMS];      /* menu item IDs */
  uint8_t           ID;            /* profile ID */

  /* setup menu */
  MenuItem[Item] = (void *)Profile1_str;     /* profile #1 */
    6aaa:	84 e4       	ldi	r24, 0x44	; 68
    6aac:	91 e0       	ldi	r25, 0x01	; 1
    6aae:	9a 83       	std	Y+2, r25	; 0x02
    6ab0:	89 83       	std	Y+1, r24	; 0x01
  MenuID[Item] = 1;
    6ab2:	81 e0       	ldi	r24, 0x01	; 1
    6ab4:	8f 83       	std	Y+7, r24	; 0x07
  Item++;  
  MenuItem[Item] = (void *)Profile2_str;     /* profile #2 */
    6ab6:	81 e4       	ldi	r24, 0x41	; 65
    6ab8:	91 e0       	ldi	r25, 0x01	; 1
    6aba:	9c 83       	std	Y+4, r25	; 0x04
    6abc:	8b 83       	std	Y+3, r24	; 0x03
  MenuID[Item] = 2;
    6abe:	82 e0       	ldi	r24, 0x02	; 2
    6ac0:	88 87       	std	Y+8, r24	; 0x08
  Item++;
  MenuItem[Item] = (void *)Exit_str;         /* exit menu */
    6ac2:	8c e3       	ldi	r24, 0x3C	; 60
    6ac4:	92 e0       	ldi	r25, 0x02	; 2
    6ac6:	9e 83       	std	Y+6, r25	; 0x06
    6ac8:	8d 83       	std	Y+5, r24	; 0x05
  MenuID[Item] = 0;
    6aca:	19 86       	std	Y+9, r1	; 0x09
  Item++;                                    /* add 1 for item #0 */

  /* display mode */
  LCD_Clear();
    6acc:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
  if (Mode == MODE_SAVE)           /* write mode */
    6ad0:	12 30       	cpi	r17, 0x02	; 2
    6ad2:	29 f4       	brne	.+10     	; 0x6ade <AdjustmentMenu+0x4c>
  {
    LCD_EEString(Save_str);
    6ad4:	8f e7       	ldi	r24, 0x7F	; 127
    6ad6:	92 e0       	ldi	r25, 0x02	; 2
    6ad8:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
    6adc:	04 c0       	rjmp	.+8      	; 0x6ae6 <AdjustmentMenu+0x54>
  }
  else                             /* read mode */
  {
    LCD_EEString(Load_str);
    6ade:	8a e7       	ldi	r24, 0x7A	; 122
    6ae0:	92 e0       	ldi	r25, 0x02	; 2
    6ae2:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
  }

  /* run menu */
  ID = MenuTool(Item, 1, MenuItem, NULL);    /* menu dialog */
    6ae6:	20 e0       	ldi	r18, 0x00	; 0
    6ae8:	30 e0       	ldi	r19, 0x00	; 0
    6aea:	ae 01       	movw	r20, r28
    6aec:	4f 5f       	subi	r20, 0xFF	; 255
    6aee:	5f 4f       	sbci	r21, 0xFF	; 255
    6af0:	61 e0       	ldi	r22, 0x01	; 1
    6af2:	83 e0       	ldi	r24, 0x03	; 3
    6af4:	0e 94 52 34 	call	0x68a4	; 0x68a4 <MenuTool>
  ID = MenuID[ID];                           /* get item ID */
    6af8:	fe 01       	movw	r30, r28
    6afa:	e8 0f       	add	r30, r24
    6afc:	f1 1d       	adc	r31, r1
    6afe:	67 81       	ldd	r22, Z+7	; 0x07

  if (ID > 0)                 /* valid profile ID */
    6b00:	66 23       	and	r22, r22
    6b02:	19 f0       	breq	.+6      	; 0x6b0a <AdjustmentMenu+0x78>
  {
    ManageAdjust(Mode, ID);
    6b04:	81 2f       	mov	r24, r17
    6b06:	0e 94 38 05 	call	0xa70	; 0xa70 <ManageAdjust>
  }

  #undef MENU_ITEMS
}
    6b0a:	29 96       	adiw	r28, 0x09	; 9
    6b0c:	0f b6       	in	r0, 0x3f	; 63
    6b0e:	f8 94       	cli
    6b10:	de bf       	out	0x3e, r29	; 62
    6b12:	0f be       	out	0x3f, r0	; 63
    6b14:	cd bf       	out	0x3d, r28	; 61
    6b16:	df 91       	pop	r29
    6b18:	cf 91       	pop	r28
    6b1a:	1f 91       	pop	r17
    6b1c:	08 95       	ret

00006b1e <PresentMainMenu>:
/*
 *  create main menu and return ID of selected item  
 */

uint8_t PresentMainMenu(void)
{
    6b1e:	cf 93       	push	r28
    6b20:	df 93       	push	r29
    6b22:	cd b7       	in	r28, 0x3d	; 61
    6b24:	de b7       	in	r29, 0x3e	; 62
    6b26:	aa 97       	sbiw	r28, 0x2a	; 42
    6b28:	0f b6       	in	r0, 0x3f	; 63
    6b2a:	f8 94       	cli
    6b2c:	de bf       	out	0x3e, r29	; 62
    6b2e:	0f be       	out	0x3f, r0	; 63
    6b30:	cd bf       	out	0x3d, r28	; 61
   *  setup menu
   */

  /* extra items */
  #ifdef SW_PWM
  MenuItem[Item] = (void *)PWM_str;          /* PWM tool */
    6b32:	80 e3       	ldi	r24, 0x30	; 48
    6b34:	91 e0       	ldi	r25, 0x01	; 1
    6b36:	9a 83       	std	Y+2, r25	; 0x02
    6b38:	89 83       	std	Y+1, r24	; 0x01
  MenuID[Item] = 6;
    6b3a:	86 e0       	ldi	r24, 0x06	; 6
    6b3c:	8d 8f       	std	Y+29, r24	; 0x1d
  MenuItem[Item] = (void *)Zener_str;        /* Zener tool */
  MenuID[Item] = 8;  
  Item++;
  #endif
  #ifdef SW_ESR
  MenuItem[Item] = (void *)ESR_str;          /* in-circuit ESR */
    6b3e:	88 e3       	ldi	r24, 0x38	; 56
    6b40:	91 e0       	ldi	r25, 0x01	; 1
    6b42:	9c 83       	std	Y+4, r25	; 0x04
    6b44:	8b 83       	std	Y+3, r24	; 0x03
  MenuID[Item] = 9;
    6b46:	89 e0       	ldi	r24, 0x09	; 9
    6b48:	8e 8f       	std	Y+30, r24	; 0x1e
  MenuItem[Item] = (void *)FreqCounter_str;  /* frequency counter */
  MenuID[Item] = 10;
  Item++;
  #endif
  #ifdef SW_ENCODER
  MenuItem[Item] = (void *)Encoder_str;      /* rotary encoder check */
    6b4a:	8a e1       	ldi	r24, 0x1A	; 26
    6b4c:	92 e0       	ldi	r25, 0x02	; 2
    6b4e:	9e 83       	std	Y+6, r25	; 0x06
    6b50:	8d 83       	std	Y+5, r24	; 0x05
  MenuID[Item] = 11;
    6b52:	8b e0       	ldi	r24, 0x0B	; 11
    6b54:	8f 8f       	std	Y+31, r24	; 0x1f
  Item++;
  #endif
  #ifdef SW_CONTRAST
  MenuItem[Item] = (void *)Contrast_str;     /* change LCD contrast */
    6b56:	85 e0       	ldi	r24, 0x05	; 5
    6b58:	92 e0       	ldi	r25, 0x02	; 2
    6b5a:	98 87       	std	Y+8, r25	; 0x08
    6b5c:	8f 83       	std	Y+7, r24	; 0x07
  MenuID[Item] = 12;
    6b5e:	8c e0       	ldi	r24, 0x0C	; 12
    6b60:	88 a3       	std	Y+32, r24	; 0x20
  Item++;
  #endif
  #ifdef SW_IR_RECEIVER
  MenuItem[Item] = (void *)IR_Detector_str;  /* IR RC detection */
    6b62:	89 ef       	ldi	r24, 0xF9	; 249
    6b64:	91 e0       	ldi	r25, 0x01	; 1
    6b66:	9a 87       	std	Y+10, r25	; 0x0a
    6b68:	89 87       	std	Y+9, r24	; 0x09
  MenuID[Item] = 13;
    6b6a:	8d e0       	ldi	r24, 0x0D	; 13
    6b6c:	89 a3       	std	Y+33, r24	; 0x21
  Item++;
  #endif

  /* standard items */
  MenuItem[Item] = (void *)Selftest_str;    /* selftest */
    6b6e:	8f e8       	ldi	r24, 0x8F	; 143
    6b70:	92 e0       	ldi	r25, 0x02	; 2
    6b72:	9c 87       	std	Y+12, r25	; 0x0c
    6b74:	8b 87       	std	Y+11, r24	; 0x0b
  MenuID[Item] = 1;
    6b76:	81 e0       	ldi	r24, 0x01	; 1
    6b78:	8a a3       	std	Y+34, r24	; 0x22
  Item++;
  MenuItem[Item] = (void *)Adjustment_str;  /* self-adjustment */
    6b7a:	84 e8       	ldi	r24, 0x84	; 132
    6b7c:	92 e0       	ldi	r25, 0x02	; 2
    6b7e:	9e 87       	std	Y+14, r25	; 0x0e
    6b80:	8d 87       	std	Y+13, r24	; 0x0d
  MenuID[Item] = 2;
    6b82:	82 e0       	ldi	r24, 0x02	; 2
    6b84:	8b a3       	std	Y+35, r24	; 0x23
  Item++;  
  MenuItem[Item] = (void *)Save_str;        /* store self-adjustment values */
    6b86:	8f e7       	ldi	r24, 0x7F	; 127
    6b88:	92 e0       	ldi	r25, 0x02	; 2
    6b8a:	98 8b       	std	Y+16, r25	; 0x10
    6b8c:	8f 87       	std	Y+15, r24	; 0x0f
  MenuID[Item] = 3;
    6b8e:	83 e0       	ldi	r24, 0x03	; 3
    6b90:	8c a3       	std	Y+36, r24	; 0x24
  Item++;
  MenuItem[Item] = (void *)Load_str;        /* load self-adjustment values */
    6b92:	8a e7       	ldi	r24, 0x7A	; 122
    6b94:	92 e0       	ldi	r25, 0x02	; 2
    6b96:	9a 8b       	std	Y+18, r25	; 0x12
    6b98:	89 8b       	std	Y+17, r24	; 0x11
  MenuID[Item] = 4;
    6b9a:	84 e0       	ldi	r24, 0x04	; 4
    6b9c:	8d a3       	std	Y+37, r24	; 0x25
  Item++;
  MenuItem[Item] = (void *)Show_str;        /* show self-adjustment values */
    6b9e:	8e e6       	ldi	r24, 0x6E	; 110
    6ba0:	92 e0       	ldi	r25, 0x02	; 2
    6ba2:	9c 8b       	std	Y+20, r25	; 0x14
    6ba4:	8b 8b       	std	Y+19, r24	; 0x13
  MenuID[Item] = 5;
    6ba6:	85 e0       	ldi	r24, 0x05	; 5
    6ba8:	8e a3       	std	Y+38, r24	; 0x26
  Item++;
  MenuItem[Item] = (void *)Exit_str;        /* exit menu */
    6baa:	8c e3       	ldi	r24, 0x3C	; 60
    6bac:	92 e0       	ldi	r25, 0x02	; 2
    6bae:	9e 8b       	std	Y+22, r25	; 0x16
    6bb0:	8d 8b       	std	Y+21, r24	; 0x15
  MenuID[Item] = 0;
    6bb2:	1f a2       	std	Y+39, r1	; 0x27

  /*
   *  run menu
   */

  LCD_Clear();
    6bb4:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
  LCD_EEString(Select_str);                  /* display "Select" */
    6bb8:	88 e9       	ldi	r24, 0x98	; 152
    6bba:	92 e0       	ldi	r25, 0x02	; 2
    6bbc:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
  Item++;                                    /* add 1 for item #0 */
  ID = MenuTool(Item, 1, MenuItem, NULL);    /* menu dialog */
    6bc0:	20 e0       	ldi	r18, 0x00	; 0
    6bc2:	30 e0       	ldi	r19, 0x00	; 0
    6bc4:	ae 01       	movw	r20, r28
    6bc6:	4f 5f       	subi	r20, 0xFF	; 255
    6bc8:	5f 4f       	sbci	r21, 0xFF	; 255
    6bca:	61 e0       	ldi	r22, 0x01	; 1
    6bcc:	8b e0       	ldi	r24, 0x0B	; 11
    6bce:	0e 94 52 34 	call	0x68a4	; 0x68a4 <MenuTool>
  ID = MenuID[ID];                           /* get item ID */
    6bd2:	fe 01       	movw	r30, r28
    6bd4:	e8 0f       	add	r30, r24
    6bd6:	f1 1d       	adc	r31, r1

  return(ID);                 /* return item ID */

  #undef MENU_ITEMS
}
    6bd8:	85 8d       	ldd	r24, Z+29	; 0x1d
    6bda:	aa 96       	adiw	r28, 0x2a	; 42
    6bdc:	0f b6       	in	r0, 0x3f	; 63
    6bde:	f8 94       	cli
    6be0:	de bf       	out	0x3e, r29	; 62
    6be2:	0f be       	out	0x3f, r0	; 63
    6be4:	cd bf       	out	0x3d, r28	; 61
    6be6:	df 91       	pop	r29
    6be8:	cf 91       	pop	r28
    6bea:	08 95       	ret

00006bec <MainMenu>:
/*
 *  main menu
 */

void MainMenu(void)
{
    6bec:	cf 93       	push	r28
  uint8_t           Flag = 1;           /* control flag */
  #ifdef SW_PWM
  uint16_t          Frequency;          /* PWM frequency */  
  #endif

  ID = PresentMainMenu();     /* create menu and get user feedback */
    6bee:	0e 94 8f 35 	call	0x6b1e	; 0x6b1e <PresentMainMenu>

  /* run selected item */
  switch (ID)
    6bf2:	90 e0       	ldi	r25, 0x00	; 0
    6bf4:	fc 01       	movw	r30, r24
    6bf6:	31 97       	sbiw	r30, 0x01	; 1
    6bf8:	ed 30       	cpi	r30, 0x0D	; 13
    6bfa:	f1 05       	cpc	r31, r1
    6bfc:	d8 f5       	brcc	.+118    	; 0x6c74 <MainMenu+0x88>
    6bfe:	e3 5b       	subi	r30, 0xB3	; 179
    6c00:	ff 4f       	sbci	r31, 0xFF	; 255
    6c02:	0c 94 c7 36 	jmp	0x6d8e	; 0x6d8e <__tablejump2__>
  {
    /* case 0:              exit menu */

    case 1:              /* self-test */
      Flag = SelfTest();
    6c06:	0e 94 73 08 	call	0x10e6	; 0x10e6 <SelfTest>
    6c0a:	c8 2f       	mov	r28, r24
      break;
    6c0c:	34 c0       	rjmp	.+104    	; 0x6c76 <MainMenu+0x8a>

    case 2:              /* self-adjustment */
      Flag = SelfAdjust();
    6c0e:	0e 94 eb 05 	call	0xbd6	; 0xbd6 <SelfAdjust>
    6c12:	c8 2f       	mov	r28, r24
      break;
    6c14:	30 c0       	rjmp	.+96     	; 0x6c76 <MainMenu+0x8a>

    case 3:              /* save self-adjustment values */
      AdjustmentMenu(MODE_SAVE);
    6c16:	82 e0       	ldi	r24, 0x02	; 2
    6c18:	0e 94 49 35 	call	0x6a92	; 0x6a92 <AdjustmentMenu>
      break;
    6c1c:	3a c0       	rjmp	.+116    	; 0x6c92 <MainMenu+0xa6>

    case 4:              /* load self-adjustment values */
      AdjustmentMenu(MODE_LOAD);
    6c1e:	81 e0       	ldi	r24, 0x01	; 1
    6c20:	0e 94 49 35 	call	0x6a92	; 0x6a92 <AdjustmentMenu>
      break;
    6c24:	36 c0       	rjmp	.+108    	; 0x6c92 <MainMenu+0xa6>

    case 5:              /* show self-adjustment values */
      ShowAdjust();
    6c26:	0e 94 7f 05 	call	0xafe	; 0xafe <ShowAdjust>
      break;
    6c2a:	33 c0       	rjmp	.+102    	; 0x6c92 <MainMenu+0xa6>

    #ifdef SW_PWM
    case 6:              /* PWM tool */
      /* run PWM menu */
      LCD_Clear();
    6c2c:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
      LCD_EEString(PWM_str);
    6c30:	80 e3       	ldi	r24, 0x30	; 48
    6c32:	91 e0       	ldi	r25, 0x01	; 1
    6c34:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
      ID = MenuTool(8, 2, (void *)PWM_Freq_table, (unsigned char *)Hertz_str);
    6c38:	2d e2       	ldi	r18, 0x2D	; 45
    6c3a:	31 e0       	ldi	r19, 0x01	; 1
    6c3c:	49 e4       	ldi	r20, 0x49	; 73
    6c3e:	50 e0       	ldi	r21, 0x00	; 0
    6c40:	62 e0       	ldi	r22, 0x02	; 2
    6c42:	88 e0       	ldi	r24, 0x08	; 8
    6c44:	0e 94 52 34 	call	0x68a4	; 0x68a4 <MenuTool>
      Frequency = eeprom_read_word(&PWM_Freq_table[ID]);    /* get selected frequency */
    6c48:	90 e0       	ldi	r25, 0x00	; 0
    6c4a:	88 0f       	add	r24, r24
    6c4c:	99 1f       	adc	r25, r25
    6c4e:	87 5b       	subi	r24, 0xB7	; 183
    6c50:	9f 4f       	sbci	r25, 0xFF	; 255
    6c52:	0e 94 20 37 	call	0x6e40	; 0x6e40 <eeprom_read_word>
      PWM_Tool(Frequency);                                  /* and run PWM tool */
    6c56:	0e 94 61 10 	call	0x20c2	; 0x20c2 <PWM_Tool>
      break;
    6c5a:	1b c0       	rjmp	.+54     	; 0x6c92 <MainMenu+0xa6>
      break;
    #endif

    #ifdef SW_ESR
    case 9:              /* ESR tool */
      ESR_Tool();
    6c5c:	0e 94 62 11 	call	0x22c4	; 0x22c4 <ESR_Tool>
      break;
    6c60:	18 c0       	rjmp	.+48     	; 0x6c92 <MainMenu+0xa6>
      break;
    #endif

    #ifdef SW_ENCODER
    case 11:             /* rotary encoder check */
      Encoder_Tool();
    6c62:	0e 94 4a 12 	call	0x2494	; 0x2494 <Encoder_Tool>
      break;
    6c66:	15 c0       	rjmp	.+42     	; 0x6c92 <MainMenu+0xa6>
    #endif

    #ifdef SW_CONTRAST
    case 12:             /* change contrast */
      ChangeContrast();
    6c68:	0e 94 0b 34 	call	0x6816	; 0x6816 <ChangeContrast>
      break;
    6c6c:	12 c0       	rjmp	.+36     	; 0x6c92 <MainMenu+0xa6>
    #endif

    #ifdef SW_IR_RECEIVER
    case 13:             /* IR RC detection */
      IR_Detector();
    6c6e:	0e 94 5b 1a 	call	0x34b6	; 0x34b6 <IR_Detector>
      break;
    6c72:	0f c0       	rjmp	.+30     	; 0x6c92 <MainMenu+0xa6>
 */

void MainMenu(void)
{
  uint8_t           ID;                 /* ID of selected item */
  uint8_t           Flag = 1;           /* control flag */
    6c74:	c1 e0       	ldi	r28, 0x01	; 1
      break;
    #endif
  }

  /* display result */
  LCD_Clear();
    6c76:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
  if (Flag == 0)
    6c7a:	c1 11       	cpse	r28, r1
    6c7c:	05 c0       	rjmp	.+10     	; 0x6c88 <MainMenu+0x9c>
    LCD_EEString(Error_str);       /* display: error! */
    6c7e:	81 e4       	ldi	r24, 0x41	; 65
    6c80:	92 e0       	ldi	r25, 0x02	; 2
    6c82:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
    6c86:	08 c0       	rjmp	.+16     	; 0x6c98 <MainMenu+0xac>
  else
    LCD_EEString(Done_str);        /* display: done! */
    6c88:	8f e9       	ldi	r24, 0x9F	; 159
    6c8a:	92 e0       	ldi	r25, 0x02	; 2
    6c8c:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <LCD_EEString>
    6c90:	03 c0       	rjmp	.+6      	; 0x6c98 <MainMenu+0xac>
      break;
    #endif
  }

  /* display result */
  LCD_Clear();
    6c92:	0e 94 46 30 	call	0x608c	; 0x608c <LCD_Clear>
    6c96:	f8 cf       	rjmp	.-16     	; 0x6c88 <MainMenu+0x9c>
  if (Flag == 0)
    LCD_EEString(Error_str);       /* display: error! */
  else
    LCD_EEString(Done_str);        /* display: done! */
}
    6c98:	cf 91       	pop	r28
    6c9a:	08 95       	ret

00006c9c <__mulsi3>:
    6c9c:	db 01       	movw	r26, r22
    6c9e:	8f 93       	push	r24
    6ca0:	9f 93       	push	r25
    6ca2:	0e 94 e3 36 	call	0x6dc6	; 0x6dc6 <__muluhisi3>
    6ca6:	bf 91       	pop	r27
    6ca8:	af 91       	pop	r26
    6caa:	a2 9f       	mul	r26, r18
    6cac:	80 0d       	add	r24, r0
    6cae:	91 1d       	adc	r25, r1
    6cb0:	a3 9f       	mul	r26, r19
    6cb2:	90 0d       	add	r25, r0
    6cb4:	b2 9f       	mul	r27, r18
    6cb6:	90 0d       	add	r25, r0
    6cb8:	11 24       	eor	r1, r1
    6cba:	08 95       	ret

00006cbc <__udivmodhi4>:
    6cbc:	aa 1b       	sub	r26, r26
    6cbe:	bb 1b       	sub	r27, r27
    6cc0:	51 e1       	ldi	r21, 0x11	; 17
    6cc2:	07 c0       	rjmp	.+14     	; 0x6cd2 <__udivmodhi4_ep>

00006cc4 <__udivmodhi4_loop>:
    6cc4:	aa 1f       	adc	r26, r26
    6cc6:	bb 1f       	adc	r27, r27
    6cc8:	a6 17       	cp	r26, r22
    6cca:	b7 07       	cpc	r27, r23
    6ccc:	10 f0       	brcs	.+4      	; 0x6cd2 <__udivmodhi4_ep>
    6cce:	a6 1b       	sub	r26, r22
    6cd0:	b7 0b       	sbc	r27, r23

00006cd2 <__udivmodhi4_ep>:
    6cd2:	88 1f       	adc	r24, r24
    6cd4:	99 1f       	adc	r25, r25
    6cd6:	5a 95       	dec	r21
    6cd8:	a9 f7       	brne	.-22     	; 0x6cc4 <__udivmodhi4_loop>
    6cda:	80 95       	com	r24
    6cdc:	90 95       	com	r25
    6cde:	bc 01       	movw	r22, r24
    6ce0:	cd 01       	movw	r24, r26
    6ce2:	08 95       	ret

00006ce4 <__divmodhi4>:
    6ce4:	97 fb       	bst	r25, 7
    6ce6:	07 2e       	mov	r0, r23
    6ce8:	16 f4       	brtc	.+4      	; 0x6cee <__divmodhi4+0xa>
    6cea:	00 94       	com	r0
    6cec:	07 d0       	rcall	.+14     	; 0x6cfc <__divmodhi4_neg1>
    6cee:	77 fd       	sbrc	r23, 7
    6cf0:	09 d0       	rcall	.+18     	; 0x6d04 <__divmodhi4_neg2>
    6cf2:	0e 94 5e 36 	call	0x6cbc	; 0x6cbc <__udivmodhi4>
    6cf6:	07 fc       	sbrc	r0, 7
    6cf8:	05 d0       	rcall	.+10     	; 0x6d04 <__divmodhi4_neg2>
    6cfa:	3e f4       	brtc	.+14     	; 0x6d0a <__divmodhi4_exit>

00006cfc <__divmodhi4_neg1>:
    6cfc:	90 95       	com	r25
    6cfe:	81 95       	neg	r24
    6d00:	9f 4f       	sbci	r25, 0xFF	; 255
    6d02:	08 95       	ret

00006d04 <__divmodhi4_neg2>:
    6d04:	70 95       	com	r23
    6d06:	61 95       	neg	r22
    6d08:	7f 4f       	sbci	r23, 0xFF	; 255

00006d0a <__divmodhi4_exit>:
    6d0a:	08 95       	ret

00006d0c <__udivmodsi4>:
    6d0c:	a1 e2       	ldi	r26, 0x21	; 33
    6d0e:	1a 2e       	mov	r1, r26
    6d10:	aa 1b       	sub	r26, r26
    6d12:	bb 1b       	sub	r27, r27
    6d14:	fd 01       	movw	r30, r26
    6d16:	0d c0       	rjmp	.+26     	; 0x6d32 <__udivmodsi4_ep>

00006d18 <__udivmodsi4_loop>:
    6d18:	aa 1f       	adc	r26, r26
    6d1a:	bb 1f       	adc	r27, r27
    6d1c:	ee 1f       	adc	r30, r30
    6d1e:	ff 1f       	adc	r31, r31
    6d20:	a2 17       	cp	r26, r18
    6d22:	b3 07       	cpc	r27, r19
    6d24:	e4 07       	cpc	r30, r20
    6d26:	f5 07       	cpc	r31, r21
    6d28:	20 f0       	brcs	.+8      	; 0x6d32 <__udivmodsi4_ep>
    6d2a:	a2 1b       	sub	r26, r18
    6d2c:	b3 0b       	sbc	r27, r19
    6d2e:	e4 0b       	sbc	r30, r20
    6d30:	f5 0b       	sbc	r31, r21

00006d32 <__udivmodsi4_ep>:
    6d32:	66 1f       	adc	r22, r22
    6d34:	77 1f       	adc	r23, r23
    6d36:	88 1f       	adc	r24, r24
    6d38:	99 1f       	adc	r25, r25
    6d3a:	1a 94       	dec	r1
    6d3c:	69 f7       	brne	.-38     	; 0x6d18 <__udivmodsi4_loop>
    6d3e:	60 95       	com	r22
    6d40:	70 95       	com	r23
    6d42:	80 95       	com	r24
    6d44:	90 95       	com	r25
    6d46:	9b 01       	movw	r18, r22
    6d48:	ac 01       	movw	r20, r24
    6d4a:	bd 01       	movw	r22, r26
    6d4c:	cf 01       	movw	r24, r30
    6d4e:	08 95       	ret

00006d50 <__divmodsi4>:
    6d50:	05 2e       	mov	r0, r21
    6d52:	97 fb       	bst	r25, 7
    6d54:	1e f4       	brtc	.+6      	; 0x6d5c <__divmodsi4+0xc>
    6d56:	00 94       	com	r0
    6d58:	0e 94 bf 36 	call	0x6d7e	; 0x6d7e <__negsi2>
    6d5c:	57 fd       	sbrc	r21, 7
    6d5e:	07 d0       	rcall	.+14     	; 0x6d6e <__divmodsi4_neg2>
    6d60:	0e 94 86 36 	call	0x6d0c	; 0x6d0c <__udivmodsi4>
    6d64:	07 fc       	sbrc	r0, 7
    6d66:	03 d0       	rcall	.+6      	; 0x6d6e <__divmodsi4_neg2>
    6d68:	4e f4       	brtc	.+18     	; 0x6d7c <__divmodsi4_exit>
    6d6a:	0c 94 bf 36 	jmp	0x6d7e	; 0x6d7e <__negsi2>

00006d6e <__divmodsi4_neg2>:
    6d6e:	50 95       	com	r21
    6d70:	40 95       	com	r20
    6d72:	30 95       	com	r19
    6d74:	21 95       	neg	r18
    6d76:	3f 4f       	sbci	r19, 0xFF	; 255
    6d78:	4f 4f       	sbci	r20, 0xFF	; 255
    6d7a:	5f 4f       	sbci	r21, 0xFF	; 255

00006d7c <__divmodsi4_exit>:
    6d7c:	08 95       	ret

00006d7e <__negsi2>:
    6d7e:	90 95       	com	r25
    6d80:	80 95       	com	r24
    6d82:	70 95       	com	r23
    6d84:	61 95       	neg	r22
    6d86:	7f 4f       	sbci	r23, 0xFF	; 255
    6d88:	8f 4f       	sbci	r24, 0xFF	; 255
    6d8a:	9f 4f       	sbci	r25, 0xFF	; 255
    6d8c:	08 95       	ret

00006d8e <__tablejump2__>:
    6d8e:	ee 0f       	add	r30, r30
    6d90:	ff 1f       	adc	r31, r31
    6d92:	05 90       	lpm	r0, Z+
    6d94:	f4 91       	lpm	r31, Z
    6d96:	e0 2d       	mov	r30, r0
    6d98:	09 94       	ijmp

00006d9a <__umulhisi3>:
    6d9a:	a2 9f       	mul	r26, r18
    6d9c:	b0 01       	movw	r22, r0
    6d9e:	b3 9f       	mul	r27, r19
    6da0:	c0 01       	movw	r24, r0
    6da2:	a3 9f       	mul	r26, r19
    6da4:	70 0d       	add	r23, r0
    6da6:	81 1d       	adc	r24, r1
    6da8:	11 24       	eor	r1, r1
    6daa:	91 1d       	adc	r25, r1
    6dac:	b2 9f       	mul	r27, r18
    6dae:	70 0d       	add	r23, r0
    6db0:	81 1d       	adc	r24, r1
    6db2:	11 24       	eor	r1, r1
    6db4:	91 1d       	adc	r25, r1
    6db6:	08 95       	ret

00006db8 <__usmulhisi3>:
    6db8:	0e 94 cd 36 	call	0x6d9a	; 0x6d9a <__umulhisi3>

00006dbc <__usmulhisi3_tail>:
    6dbc:	b7 ff       	sbrs	r27, 7
    6dbe:	08 95       	ret
    6dc0:	82 1b       	sub	r24, r18
    6dc2:	93 0b       	sbc	r25, r19
    6dc4:	08 95       	ret

00006dc6 <__muluhisi3>:
    6dc6:	0e 94 cd 36 	call	0x6d9a	; 0x6d9a <__umulhisi3>
    6dca:	a5 9f       	mul	r26, r21
    6dcc:	90 0d       	add	r25, r0
    6dce:	b4 9f       	mul	r27, r20
    6dd0:	90 0d       	add	r25, r0
    6dd2:	a4 9f       	mul	r26, r20
    6dd4:	80 0d       	add	r24, r0
    6dd6:	91 1d       	adc	r25, r1
    6dd8:	11 24       	eor	r1, r1
    6dda:	08 95       	ret

00006ddc <__utoa_ncheck>:
    6ddc:	bb 27       	eor	r27, r27

00006dde <__utoa_common>:
    6dde:	fb 01       	movw	r30, r22
    6de0:	55 27       	eor	r21, r21
    6de2:	aa 27       	eor	r26, r26
    6de4:	88 0f       	add	r24, r24
    6de6:	99 1f       	adc	r25, r25
    6de8:	aa 1f       	adc	r26, r26
    6dea:	a4 17       	cp	r26, r20
    6dec:	10 f0       	brcs	.+4      	; 0x6df2 <__utoa_common+0x14>
    6dee:	a4 1b       	sub	r26, r20
    6df0:	83 95       	inc	r24
    6df2:	50 51       	subi	r21, 0x10	; 16
    6df4:	b9 f7       	brne	.-18     	; 0x6de4 <__utoa_common+0x6>
    6df6:	a0 5d       	subi	r26, 0xD0	; 208
    6df8:	aa 33       	cpi	r26, 0x3A	; 58
    6dfa:	08 f0       	brcs	.+2      	; 0x6dfe <__utoa_common+0x20>
    6dfc:	a9 5d       	subi	r26, 0xD9	; 217
    6dfe:	a1 93       	st	Z+, r26
    6e00:	00 97       	sbiw	r24, 0x00	; 0
    6e02:	79 f7       	brne	.-34     	; 0x6de2 <__utoa_common+0x4>
    6e04:	b1 11       	cpse	r27, r1
    6e06:	b1 93       	st	Z+, r27
    6e08:	11 92       	st	Z+, r1
    6e0a:	cb 01       	movw	r24, r22
    6e0c:	0c 94 08 37 	jmp	0x6e10	; 0x6e10 <strrev>

00006e10 <strrev>:
    6e10:	dc 01       	movw	r26, r24
    6e12:	fc 01       	movw	r30, r24
    6e14:	67 2f       	mov	r22, r23
    6e16:	71 91       	ld	r23, Z+
    6e18:	77 23       	and	r23, r23
    6e1a:	e1 f7       	brne	.-8      	; 0x6e14 <strrev+0x4>
    6e1c:	32 97       	sbiw	r30, 0x02	; 2
    6e1e:	04 c0       	rjmp	.+8      	; 0x6e28 <strrev+0x18>
    6e20:	7c 91       	ld	r23, X
    6e22:	6d 93       	st	X+, r22
    6e24:	70 83       	st	Z, r23
    6e26:	62 91       	ld	r22, -Z
    6e28:	ae 17       	cp	r26, r30
    6e2a:	bf 07       	cpc	r27, r31
    6e2c:	c8 f3       	brcs	.-14     	; 0x6e20 <strrev+0x10>
    6e2e:	08 95       	ret

00006e30 <eeprom_read_byte>:
    6e30:	f9 99       	sbic	0x1f, 1	; 31
    6e32:	fe cf       	rjmp	.-4      	; 0x6e30 <eeprom_read_byte>
    6e34:	92 bd       	out	0x22, r25	; 34
    6e36:	81 bd       	out	0x21, r24	; 33
    6e38:	f8 9a       	sbi	0x1f, 0	; 31
    6e3a:	99 27       	eor	r25, r25
    6e3c:	80 b5       	in	r24, 0x20	; 32
    6e3e:	08 95       	ret

00006e40 <eeprom_read_word>:
    6e40:	a8 e1       	ldi	r26, 0x18	; 24
    6e42:	b0 e0       	ldi	r27, 0x00	; 0
    6e44:	42 e0       	ldi	r20, 0x02	; 2
    6e46:	50 e0       	ldi	r21, 0x00	; 0
    6e48:	0c 94 36 37 	jmp	0x6e6c	; 0x6e6c <eeprom_read_blraw>

00006e4c <eeprom_write_byte>:
    6e4c:	26 2f       	mov	r18, r22

00006e4e <eeprom_write_r18>:
    6e4e:	f9 99       	sbic	0x1f, 1	; 31
    6e50:	fe cf       	rjmp	.-4      	; 0x6e4e <eeprom_write_r18>
    6e52:	1f ba       	out	0x1f, r1	; 31
    6e54:	92 bd       	out	0x22, r25	; 34
    6e56:	81 bd       	out	0x21, r24	; 33
    6e58:	20 bd       	out	0x20, r18	; 32
    6e5a:	0f b6       	in	r0, 0x3f	; 63
    6e5c:	f8 94       	cli
    6e5e:	fa 9a       	sbi	0x1f, 2	; 31
    6e60:	f9 9a       	sbi	0x1f, 1	; 31
    6e62:	0f be       	out	0x3f, r0	; 63
    6e64:	01 96       	adiw	r24, 0x01	; 1
    6e66:	08 95       	ret

00006e68 <eeprom_read_block>:
    6e68:	dc 01       	movw	r26, r24
    6e6a:	cb 01       	movw	r24, r22

00006e6c <eeprom_read_blraw>:
    6e6c:	fc 01       	movw	r30, r24
    6e6e:	f9 99       	sbic	0x1f, 1	; 31
    6e70:	fe cf       	rjmp	.-4      	; 0x6e6e <eeprom_read_blraw+0x2>
    6e72:	06 c0       	rjmp	.+12     	; 0x6e80 <eeprom_read_blraw+0x14>
    6e74:	f2 bd       	out	0x22, r31	; 34
    6e76:	e1 bd       	out	0x21, r30	; 33
    6e78:	f8 9a       	sbi	0x1f, 0	; 31
    6e7a:	31 96       	adiw	r30, 0x01	; 1
    6e7c:	00 b4       	in	r0, 0x20	; 32
    6e7e:	0d 92       	st	X+, r0
    6e80:	41 50       	subi	r20, 0x01	; 1
    6e82:	50 40       	sbci	r21, 0x00	; 0
    6e84:	b8 f7       	brcc	.-18     	; 0x6e74 <eeprom_read_blraw+0x8>
    6e86:	08 95       	ret

00006e88 <_exit>:
    6e88:	f8 94       	cli

00006e8a <__stop_program>:
    6e8a:	ff cf       	rjmp	.-2      	; 0x6e8a <__stop_program>
